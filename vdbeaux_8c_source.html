<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: vdbeaux.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>vdbeaux.c</h1><a href="vdbeaux_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">** 2003 September 6</span>
<a name="l00003"></a>00003 <span class="comment">**</span>
<a name="l00004"></a>00004 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00005"></a>00005 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00006"></a>00006 <span class="comment">**</span>
<a name="l00007"></a>00007 <span class="comment">**    May you do good and not evil.</span>
<a name="l00008"></a>00008 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00009"></a>00009 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">*************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment">** This file contains code used for creating, destroying, and populating</span>
<a name="l00013"></a>00013 <span class="comment">** a VDBE (or an &quot;sqlite3_stmt&quot; as it is known to the outside world.)  Prior</span>
<a name="l00014"></a>00014 <span class="comment">** to version 2.8.7, all this code was combined into the vdbe.c source file.</span>
<a name="l00015"></a>00015 <span class="comment">** But that file was getting too big so this subroutines were split out.</span>
<a name="l00016"></a>00016 <span class="comment">**</span>
<a name="l00017"></a>00017 <span class="comment">** $Id: vdbeaux.c,v 1.418 2008/11/05 17:41:19 drh Exp $</span>
<a name="l00018"></a>00018 <span class="comment">*/</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="sqliteInt_8h.html">sqliteInt.h</a>&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="vdbeInt_8h.html">vdbeInt.h</a>&quot;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">/*</span>
<a name="l00026"></a>00026 <span class="comment">** When debugging the code generator in a symbolic debugger, one can</span>
<a name="l00027"></a>00027 <span class="comment">** set the sqlite3VdbeAddopTrace to 1 and all opcodes will be printed</span>
<a name="l00028"></a>00028 <span class="comment">** as they are added to the instruction stream.</span>
<a name="l00029"></a>00029 <span class="comment">*/</span>
<a name="l00030"></a>00030 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="keywordtype">int</span> sqlite3VdbeAddopTrace = 0;
<a name="l00032"></a>00032 <span class="preprocessor">#endif</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">/*</span>
<a name="l00036"></a>00036 <span class="comment">** Create a new virtual database engine.</span>
<a name="l00037"></a>00037 <span class="comment">*/</span>
<a name="l00038"></a><a class="code" href="vdbeaux_8c.html#a5dc7d82dc2d1b80e5bbb356dc53f97c2">00038</a> <a class="code" href="structVdbe.html">Vdbe</a> *<a class="code" href="vdbe_8h.html#a19fd8bfb709ddb7bc11030ebbf5ff301">sqlite3VdbeCreate</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>){
<a name="l00039"></a>00039   <a class="code" href="structVdbe.html">Vdbe</a> *p;
<a name="l00040"></a>00040   p = <a class="code" href="malloc_8c.html#a9cdef45d3f06c28e71d728e8b15ebc0f">sqlite3DbMallocZero</a>(db, <span class="keyword">sizeof</span>(<a class="code" href="structVdbe.html">Vdbe</a>) );
<a name="l00041"></a>00041   <span class="keywordflow">if</span>( p==0 ) <span class="keywordflow">return</span> 0;
<a name="l00042"></a>00042   p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a> = db;
<a name="l00043"></a>00043   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a596f0301f43c5e25575c2a1403f8b571">pVdbe</a> ){
<a name="l00044"></a>00044     db-&gt;<a class="code" href="structsqlite3.html#a596f0301f43c5e25575c2a1403f8b571">pVdbe</a>-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a> = p;
<a name="l00045"></a>00045   }
<a name="l00046"></a>00046   p-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a> = db-&gt;<a class="code" href="structsqlite3.html#a596f0301f43c5e25575c2a1403f8b571">pVdbe</a>;
<a name="l00047"></a>00047   p-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a> = 0;
<a name="l00048"></a>00048   db-&gt;<a class="code" href="structsqlite3.html#a596f0301f43c5e25575c2a1403f8b571">pVdbe</a> = p;
<a name="l00049"></a>00049   p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a> = <a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a>;
<a name="l00050"></a>00050   <span class="keywordflow">return</span> p;
<a name="l00051"></a>00051 }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="comment">/*</span>
<a name="l00054"></a>00054 <span class="comment">** Remember the SQL string for a prepared statement.</span>
<a name="l00055"></a>00055 <span class="comment">*/</span>
<a name="l00056"></a><a class="code" href="vdbeaux_8c.html#a4f415c8a651aca1b2ede7117fadaf6d6">00056</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#a91ef9ee10a88caaa650cd178958c8dcf">sqlite3VdbeSetSql</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *z, <span class="keywordtype">int</span> n){
<a name="l00057"></a>00057   <span class="keywordflow">if</span>( p==0 ) <span class="keywordflow">return</span>;
<a name="l00058"></a>00058   assert( p-&gt;<a class="code" href="structVdbe.html#a5a61fd8f84ae0399ef73327e48048ae9">zSql</a>==0 );
<a name="l00059"></a>00059   p-&gt;<a class="code" href="structVdbe.html#a5a61fd8f84ae0399ef73327e48048ae9">zSql</a> = <a class="code" href="malloc_8c.html#a17fab011bf22c10e5f74813f08404f63">sqlite3DbStrNDup</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, z, n);
<a name="l00060"></a>00060 }
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">/*</span>
<a name="l00063"></a>00063 <span class="comment">** Return the SQL associated with a prepared statement</span>
<a name="l00064"></a>00064 <span class="comment">*/</span>
<a name="l00065"></a><a class="code" href="vdbeaux_8c.html#a08e26e378f63456743e0a39d13eb193e">00065</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="sqlite3_8h.html#a08e26e378f63456743e0a39d13eb193e">sqlite3_sql</a>(<a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *pStmt){
<a name="l00066"></a>00066   <span class="keywordflow">return</span> ((<a class="code" href="structVdbe.html">Vdbe</a> *)pStmt)-&gt;zSql;
<a name="l00067"></a>00067 }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/*</span>
<a name="l00070"></a>00070 <span class="comment">** Swap all content between two VDBE structures.</span>
<a name="l00071"></a>00071 <span class="comment">*/</span>
<a name="l00072"></a><a class="code" href="vdbeaux_8c.html#aceb6aa5df9714860ed6dec4e44557291">00072</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#ae5dc11f3d31e8c0b9b0e793185bff637">sqlite3VdbeSwap</a>(<a class="code" href="structVdbe.html">Vdbe</a> *pA, <a class="code" href="structVdbe.html">Vdbe</a> *pB){
<a name="l00073"></a>00073   <a class="code" href="structVdbe.html">Vdbe</a> tmp, *pTmp;
<a name="l00074"></a>00074   <span class="keywordtype">char</span> *zTmp;
<a name="l00075"></a>00075   <span class="keywordtype">int</span> nTmp;
<a name="l00076"></a>00076   tmp = *pA;
<a name="l00077"></a>00077   *pA = *pB;
<a name="l00078"></a>00078   *pB = tmp;
<a name="l00079"></a>00079   pTmp = pA-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a>;
<a name="l00080"></a>00080   pA-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a> = pB-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a>;
<a name="l00081"></a>00081   pB-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a> = pTmp;
<a name="l00082"></a>00082   pTmp = pA-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a>;
<a name="l00083"></a>00083   pA-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a> = pB-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a>;
<a name="l00084"></a>00084   pB-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a> = pTmp;
<a name="l00085"></a>00085   zTmp = pA-&gt;<a class="code" href="structVdbe.html#a5a61fd8f84ae0399ef73327e48048ae9">zSql</a>;
<a name="l00086"></a>00086   pA-&gt;<a class="code" href="structVdbe.html#a5a61fd8f84ae0399ef73327e48048ae9">zSql</a> = pB-&gt;<a class="code" href="structVdbe.html#a5a61fd8f84ae0399ef73327e48048ae9">zSql</a>;
<a name="l00087"></a>00087   pB-&gt;<a class="code" href="structVdbe.html#a5a61fd8f84ae0399ef73327e48048ae9">zSql</a> = zTmp;
<a name="l00088"></a>00088   nTmp = pA-&gt;<a class="code" href="structVdbe.html#ab64904abea204d2cb0040f4fdd2a55c9">nSql</a>;
<a name="l00089"></a>00089   pA-&gt;<a class="code" href="structVdbe.html#ab64904abea204d2cb0040f4fdd2a55c9">nSql</a> = pB-&gt;<a class="code" href="structVdbe.html#ab64904abea204d2cb0040f4fdd2a55c9">nSql</a>;
<a name="l00090"></a>00090   pB-&gt;<a class="code" href="structVdbe.html#ab64904abea204d2cb0040f4fdd2a55c9">nSql</a> = nTmp;
<a name="l00091"></a>00091 }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00095"></a>00095 <span class="comment">** Turn tracing on or off</span>
<a name="l00096"></a>00096 <span class="comment">*/</span>
<a name="l00097"></a>00097 <span class="keywordtype">void</span> sqlite3VdbeTrace(<a class="code" href="structVdbe.html">Vdbe</a> *p, FILE *trace){
<a name="l00098"></a>00098   p-&gt;trace = trace;
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 <span class="preprocessor">#endif</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>
<a name="l00102"></a>00102 <span class="comment">/*</span>
<a name="l00103"></a>00103 <span class="comment">** Resize the Vdbe.aOp array so that it contains at least N</span>
<a name="l00104"></a>00104 <span class="comment">** elements.</span>
<a name="l00105"></a>00105 <span class="comment">**</span>
<a name="l00106"></a>00106 <span class="comment">** If an out-of-memory error occurs while resizing the array,</span>
<a name="l00107"></a>00107 <span class="comment">** Vdbe.aOp and Vdbe.nOpAlloc remain unchanged (this is so that</span>
<a name="l00108"></a>00108 <span class="comment">** any opcodes already allocated can be correctly deallocated</span>
<a name="l00109"></a>00109 <span class="comment">** along with the rest of the Vdbe).</span>
<a name="l00110"></a>00110 <span class="comment">*/</span>
<a name="l00111"></a><a class="code" href="vdbeaux_8c.html#ad40889e863480532f1aea19343878e3e">00111</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#ad40889e863480532f1aea19343878e3e">resizeOpArray</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> N){
<a name="l00112"></a>00112   <a class="code" href="structVdbeOp.html">VdbeOp</a> *pNew;
<a name="l00113"></a>00113   pNew = <a class="code" href="malloc_8c.html#a5fd070055efafc36faa4e6092329d224">sqlite3DbRealloc</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>, N*<span class="keyword">sizeof</span>(<a class="code" href="structVdbeOp.html">Op</a>));
<a name="l00114"></a>00114   <span class="keywordflow">if</span>( pNew ){
<a name="l00115"></a>00115     p-&gt;<a class="code" href="structVdbe.html#aa52020050ea42e10ad8be8ebdf470850">nOpAlloc</a> = N;
<a name="l00116"></a>00116     p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a> = pNew;
<a name="l00117"></a>00117   }
<a name="l00118"></a>00118 }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">/*</span>
<a name="l00121"></a>00121 <span class="comment">** Add a new instruction to the list of instructions current in the</span>
<a name="l00122"></a>00122 <span class="comment">** VDBE.  Return the address of the new instruction.</span>
<a name="l00123"></a>00123 <span class="comment">**</span>
<a name="l00124"></a>00124 <span class="comment">** Parameters:</span>
<a name="l00125"></a>00125 <span class="comment">**</span>
<a name="l00126"></a>00126 <span class="comment">**    p               Pointer to the VDBE</span>
<a name="l00127"></a>00127 <span class="comment">**</span>
<a name="l00128"></a>00128 <span class="comment">**    op              The opcode for this instruction</span>
<a name="l00129"></a>00129 <span class="comment">**</span>
<a name="l00130"></a>00130 <span class="comment">**    p1, p2, p3      Operands</span>
<a name="l00131"></a>00131 <span class="comment">**</span>
<a name="l00132"></a>00132 <span class="comment">** Use the sqlite3VdbeResolveLabel() function to fix an address and</span>
<a name="l00133"></a>00133 <span class="comment">** the sqlite3VdbeChangeP4() function to change the value of the P4</span>
<a name="l00134"></a>00134 <span class="comment">** operand.</span>
<a name="l00135"></a>00135 <span class="comment">*/</span>
<a name="l00136"></a><a class="code" href="vdbeaux_8c.html#add1ad7c384ff80e4d8375051b866c575">00136</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> op, <span class="keywordtype">int</span> p1, <span class="keywordtype">int</span> p2, <span class="keywordtype">int</span> p3){
<a name="l00137"></a>00137   <span class="keywordtype">int</span> i;
<a name="l00138"></a>00138   <a class="code" href="structVdbeOp.html">VdbeOp</a> *pOp;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   i = p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>;
<a name="l00141"></a>00141   assert( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00142"></a>00142   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#aa52020050ea42e10ad8be8ebdf470850">nOpAlloc</a>&lt;=i ){
<a name="l00143"></a>00143     <a class="code" href="vdbeaux_8c.html#ad40889e863480532f1aea19343878e3e">resizeOpArray</a>(p, p-&gt;<a class="code" href="structVdbe.html#aa52020050ea42e10ad8be8ebdf470850">nOpAlloc</a> ? p-&gt;<a class="code" href="structVdbe.html#aa52020050ea42e10ad8be8ebdf470850">nOpAlloc</a>*2 : 1024/<span class="keyword">sizeof</span>(<a class="code" href="structVdbeOp.html">Op</a>));
<a name="l00144"></a>00144     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00145"></a>00145       <span class="keywordflow">return</span> 0;
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147   }
<a name="l00148"></a>00148   p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>++;
<a name="l00149"></a>00149   pOp = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i];
<a name="l00150"></a>00150   pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> = op;
<a name="l00151"></a>00151   pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> = 0;
<a name="l00152"></a>00152   pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> = p1;
<a name="l00153"></a>00153   pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> = p2;
<a name="l00154"></a>00154   pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a> = p3;
<a name="l00155"></a>00155   pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a> = 0;
<a name="l00156"></a>00156   pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = <a class="code" href="vdbe_8h.html#a627448337c6537dadef6d5bb387b05c9">P4_NOTUSED</a>;
<a name="l00157"></a>00157   p-&gt;<a class="code" href="structVdbe.html#ab281d7519a1e6f60163eab9b15048eda">expired</a> = 0;
<a name="l00158"></a>00158 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>  pOp-&gt;zComment = 0;
<a name="l00160"></a>00160   <span class="keywordflow">if</span>( sqlite3VdbeAddopTrace ) sqlite3VdbePrintOp(0, i, &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i]);
<a name="l00161"></a>00161 <span class="preprocessor">#endif</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span><span class="preprocessor">#ifdef VDBE_PROFILE</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span>  pOp-&gt;cycles = 0;
<a name="l00164"></a>00164   pOp-&gt;cnt = 0;
<a name="l00165"></a>00165 <span class="preprocessor">#endif</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span>  <span class="keywordflow">return</span> i;
<a name="l00167"></a>00167 }
<a name="l00168"></a><a class="code" href="vdbeaux_8c.html#aab8394de14922c35053a426521605618">00168</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#acf19aa381e21c080b6b731fa7408c724">sqlite3VdbeAddOp0</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> op){
<a name="l00169"></a>00169   <span class="keywordflow">return</span> <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(p, op, 0, 0, 0);
<a name="l00170"></a>00170 }
<a name="l00171"></a><a class="code" href="vdbeaux_8c.html#af234bbac7c0f28bd99c2ceaaa9471a74">00171</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> op, <span class="keywordtype">int</span> p1){
<a name="l00172"></a>00172   <span class="keywordflow">return</span> <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(p, op, p1, 0, 0);
<a name="l00173"></a>00173 }
<a name="l00174"></a><a class="code" href="vdbeaux_8c.html#ab1bdc9d4c8972ec0d6d0d3185fef8a8b">00174</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> op, <span class="keywordtype">int</span> p1, <span class="keywordtype">int</span> p2){
<a name="l00175"></a>00175   <span class="keywordflow">return</span> <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(p, op, p1, p2, 0);
<a name="l00176"></a>00176 }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="comment">/*</span>
<a name="l00180"></a>00180 <span class="comment">** Add an opcode that includes the p4 value as a pointer.</span>
<a name="l00181"></a>00181 <span class="comment">*/</span>
<a name="l00182"></a><a class="code" href="vdbeaux_8c.html#a35aa640bbc7c7335fffdd76ebad9c1b5">00182</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(
<a name="l00183"></a>00183   <a class="code" href="structVdbe.html">Vdbe</a> *p,            <span class="comment">/* Add the opcode to this VM */</span>
<a name="l00184"></a>00184   <span class="keywordtype">int</span> op,             <span class="comment">/* The new opcode */</span>
<a name="l00185"></a>00185   <span class="keywordtype">int</span> p1,             <span class="comment">/* The P1 operand */</span>
<a name="l00186"></a>00186   <span class="keywordtype">int</span> p2,             <span class="comment">/* The P2 operand */</span>
<a name="l00187"></a>00187   <span class="keywordtype">int</span> p3,             <span class="comment">/* The P3 operand */</span>
<a name="l00188"></a>00188   <span class="keyword">const</span> <span class="keywordtype">char</span> *zP4,    <span class="comment">/* The P4 operand */</span>
<a name="l00189"></a>00189   <span class="keywordtype">int</span> p4type          <span class="comment">/* P4 operand type */</span>
<a name="l00190"></a>00190 ){
<a name="l00191"></a>00191   <span class="keywordtype">int</span> addr = <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(p, op, p1, p2, p3);
<a name="l00192"></a>00192   <a class="code" href="vdbe_8h.html#a0417c7b01c7f0c8d93910a5dc00965ce">sqlite3VdbeChangeP4</a>(p, addr, zP4, p4type);
<a name="l00193"></a>00193   <span class="keywordflow">return</span> addr;
<a name="l00194"></a>00194 }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="comment">/*</span>
<a name="l00197"></a>00197 <span class="comment">** Create a new symbolic label for an instruction that has yet to be</span>
<a name="l00198"></a>00198 <span class="comment">** coded.  The symbolic label is really just a negative number.  The</span>
<a name="l00199"></a>00199 <span class="comment">** label can be used as the P2 value of an operation.  Later, when</span>
<a name="l00200"></a>00200 <span class="comment">** the label is resolved to a specific address, the VDBE will scan</span>
<a name="l00201"></a>00201 <span class="comment">** through its operation list and change all values of P2 which match</span>
<a name="l00202"></a>00202 <span class="comment">** the label into the resolved address.</span>
<a name="l00203"></a>00203 <span class="comment">**</span>
<a name="l00204"></a>00204 <span class="comment">** The VDBE knows that a P2 value is a label because labels are</span>
<a name="l00205"></a>00205 <span class="comment">** always negative and P2 values are suppose to be non-negative.</span>
<a name="l00206"></a>00206 <span class="comment">** Hence, a negative P2 value is a label that has yet to be resolved.</span>
<a name="l00207"></a>00207 <span class="comment">**</span>
<a name="l00208"></a>00208 <span class="comment">** Zero is returned if a malloc() fails.</span>
<a name="l00209"></a>00209 <span class="comment">*/</span>
<a name="l00210"></a><a class="code" href="vdbeaux_8c.html#a51ba2fc93f166984af88fa7750d0221c">00210</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#a5279e16a2acad1e72ba58ae938d385bd">sqlite3VdbeMakeLabel</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l00211"></a>00211   <span class="keywordtype">int</span> i;
<a name="l00212"></a>00212   i = p-&gt;<a class="code" href="structVdbe.html#ae74cf1db577889e4f7ee669d613939a9">nLabel</a>++;
<a name="l00213"></a>00213   assert( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00214"></a>00214   <span class="keywordflow">if</span>( i&gt;=p-&gt;<a class="code" href="structVdbe.html#a9368c53f69ebfdcb9d06f787597b4236">nLabelAlloc</a> ){
<a name="l00215"></a>00215     p-&gt;<a class="code" href="structVdbe.html#a9368c53f69ebfdcb9d06f787597b4236">nLabelAlloc</a> = p-&gt;<a class="code" href="structVdbe.html#a9368c53f69ebfdcb9d06f787597b4236">nLabelAlloc</a>*2 + 10;
<a name="l00216"></a>00216     p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a> = <a class="code" href="malloc_8c.html#ae141b4f66af57a6828c083c6926fa5c0">sqlite3DbReallocOrFree</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a>,
<a name="l00217"></a>00217                                     p-&gt;<a class="code" href="structVdbe.html#a9368c53f69ebfdcb9d06f787597b4236">nLabelAlloc</a>*<span class="keyword">sizeof</span>(p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a>[0]));
<a name="l00218"></a>00218   }
<a name="l00219"></a>00219   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a> ){
<a name="l00220"></a>00220     p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a>[i] = -1;
<a name="l00221"></a>00221   }
<a name="l00222"></a>00222   <span class="keywordflow">return</span> -1-i;
<a name="l00223"></a>00223 }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="comment">/*</span>
<a name="l00226"></a>00226 <span class="comment">** Resolve label &quot;x&quot; to be the address of the next instruction to</span>
<a name="l00227"></a>00227 <span class="comment">** be inserted.  The parameter &quot;x&quot; must have been obtained from</span>
<a name="l00228"></a>00228 <span class="comment">** a prior call to sqlite3VdbeMakeLabel().</span>
<a name="l00229"></a>00229 <span class="comment">*/</span>
<a name="l00230"></a><a class="code" href="vdbeaux_8c.html#a953b2d52ca6522ba65b4db90f3f3a09d">00230</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#aea27581f782aaa7e14ae22a3c061f483">sqlite3VdbeResolveLabel</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> x){
<a name="l00231"></a>00231   <span class="keywordtype">int</span> j = -1-x;
<a name="l00232"></a>00232   assert( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00233"></a>00233   assert( j&gt;=0 &amp;&amp; j&lt;p-&gt;nLabel );
<a name="l00234"></a>00234   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a> ){
<a name="l00235"></a>00235     p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a>[j] = p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>;
<a name="l00236"></a>00236   }
<a name="l00237"></a>00237 }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="comment">/*</span>
<a name="l00240"></a>00240 <span class="comment">** Loop through the program looking for P2 values that are negative</span>
<a name="l00241"></a>00241 <span class="comment">** on jump instructions.  Each such value is a label.  Resolve the</span>
<a name="l00242"></a>00242 <span class="comment">** label by setting the P2 value to its correct non-zero value.</span>
<a name="l00243"></a>00243 <span class="comment">**</span>
<a name="l00244"></a>00244 <span class="comment">** This routine is called once after all opcodes have been inserted.</span>
<a name="l00245"></a>00245 <span class="comment">**</span>
<a name="l00246"></a>00246 <span class="comment">** Variable *pMaxFuncArgs is set to the maximum value of any P2 argument </span>
<a name="l00247"></a>00247 <span class="comment">** to an OP_Function, OP_AggStep or OP_VFilter opcode. This is used by </span>
<a name="l00248"></a>00248 <span class="comment">** sqlite3VdbeMakeReady() to size the Vdbe.apArg[] array.</span>
<a name="l00249"></a>00249 <span class="comment">**</span>
<a name="l00250"></a>00250 <span class="comment">** This routine also does the following optimization:  It scans for</span>
<a name="l00251"></a>00251 <span class="comment">** instructions that might cause a statement rollback.  Such instructions</span>
<a name="l00252"></a>00252 <span class="comment">** are:</span>
<a name="l00253"></a>00253 <span class="comment">**</span>
<a name="l00254"></a>00254 <span class="comment">**   *  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.</span>
<a name="l00255"></a>00255 <span class="comment">**   *  OP_Destroy</span>
<a name="l00256"></a>00256 <span class="comment">**   *  OP_VUpdate</span>
<a name="l00257"></a>00257 <span class="comment">**   *  OP_VRename</span>
<a name="l00258"></a>00258 <span class="comment">**</span>
<a name="l00259"></a>00259 <span class="comment">** If no such instruction is found, then every Statement instruction </span>
<a name="l00260"></a>00260 <span class="comment">** is changed to a Noop.  In this way, we avoid creating the statement </span>
<a name="l00261"></a>00261 <span class="comment">** journal file unnecessarily.</span>
<a name="l00262"></a>00262 <span class="comment">*/</span>
<a name="l00263"></a><a class="code" href="vdbeaux_8c.html#a9aa9c7da468f7325e427e599812b92ab">00263</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#a9aa9c7da468f7325e427e599812b92ab">resolveP2Values</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> *pMaxFuncArgs){
<a name="l00264"></a>00264   <span class="keywordtype">int</span> i;
<a name="l00265"></a>00265   <span class="keywordtype">int</span> nMaxArgs = 0;
<a name="l00266"></a>00266   <a class="code" href="structVdbeOp.html">Op</a> *pOp;
<a name="l00267"></a>00267   <span class="keywordtype">int</span> *aLabel = p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a>;
<a name="l00268"></a>00268   <span class="keywordtype">int</span> doesStatementRollback = 0;
<a name="l00269"></a>00269   <span class="keywordtype">int</span> hasStatementBegin = 0;
<a name="l00270"></a>00270   p-&gt;<a class="code" href="structVdbe.html#a723ca4a68712aed8d37b3d682c336e84">readOnly</a> = 1;
<a name="l00271"></a>00271   p-&gt;<a class="code" href="structVdbe.html#aaac5176003bc8760200364c7752786a4">usesStmtJournal</a> = 0;
<a name="l00272"></a>00272   <span class="keywordflow">for</span>(pOp=p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>, i=p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>-1; i&gt;=0; i--, pOp++){
<a name="l00273"></a>00273     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> opcode = pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     <span class="keywordflow">if</span>( opcode==<a class="code" href="opcodes_8h.html#a4b273a1a59a2d7e22996e32c3ab632c9">OP_Function</a> || opcode==<a class="code" href="opcodes_8h.html#a02bdc453117200f5aa03b46e9243be71">OP_AggStep</a> ){
<a name="l00276"></a>00276       <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>&gt;nMaxArgs ) nMaxArgs = pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>;
<a name="l00277"></a>00277 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span>    }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( opcode==<a class="code" href="opcodes_8h.html#aca34cb921c1d7e1998a2a3c78b29c831">OP_VUpdate</a> ){
<a name="l00279"></a>00279       <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;nMaxArgs ) nMaxArgs = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l00280"></a>00280 <span class="preprocessor">#endif</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span>    }
<a name="l00282"></a>00282     <span class="keywordflow">if</span>( opcode==<a class="code" href="opcodes_8h.html#af1020441d30e76aa4d065ac2ec56c23d">OP_Halt</a> ){
<a name="l00283"></a>00283       <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>==<a class="code" href="sqlite3_8h.html#a60b2b65ad97f771203e26733f870af57">SQLITE_CONSTRAINT</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>==<a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a> ){
<a name="l00284"></a>00284         doesStatementRollback = 1;
<a name="l00285"></a>00285       }
<a name="l00286"></a>00286     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( opcode==<a class="code" href="opcodes_8h.html#a718776e9ac8775b4c0047118fd9e7aa1">OP_Statement</a> ){
<a name="l00287"></a>00287       hasStatementBegin = 1;
<a name="l00288"></a>00288       p-&gt;<a class="code" href="structVdbe.html#aaac5176003bc8760200364c7752786a4">usesStmtJournal</a> = 1;
<a name="l00289"></a>00289     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( opcode==<a class="code" href="opcodes_8h.html#abf530c50cef0171dc29ae47b684e44b1">OP_Destroy</a> ){
<a name="l00290"></a>00290       doesStatementRollback = 1;
<a name="l00291"></a>00291     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( opcode==<a class="code" href="opcodes_8h.html#a4b94e42b258f79e67949e9af065cbcc0">OP_Transaction</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>!=0 ){
<a name="l00292"></a>00292       p-&gt;<a class="code" href="structVdbe.html#a723ca4a68712aed8d37b3d682c336e84">readOnly</a> = 0;
<a name="l00293"></a>00293 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span>    }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( opcode==<a class="code" href="opcodes_8h.html#aca34cb921c1d7e1998a2a3c78b29c831">OP_VUpdate</a> || opcode==<a class="code" href="opcodes_8h.html#a1ecd8fe88dc779c985afc94e5810945b">OP_VRename</a> ){
<a name="l00295"></a>00295       doesStatementRollback = 1;
<a name="l00296"></a>00296     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( opcode==<a class="code" href="opcodes_8h.html#a8ee396bf68f267316ea560fa54587ed2">OP_VFilter</a> ){
<a name="l00297"></a>00297       <span class="keywordtype">int</span> n;
<a name="l00298"></a>00298       assert( p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a> - i &gt;= 3 );
<a name="l00299"></a>00299       assert( pOp[-1].opcode==<a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a> );
<a name="l00300"></a>00300       n = pOp[-1].<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l00301"></a>00301       <span class="keywordflow">if</span>( n&gt;nMaxArgs ) nMaxArgs = n;
<a name="l00302"></a>00302 <span class="preprocessor">#endif</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span>    }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     <span class="keywordflow">if</span>( <a class="code" href="vdbe_8c.html#a87b4d0450221c137df3f4952a2162865">sqlite3VdbeOpcodeHasProperty</a>(opcode, <a class="code" href="opcodes_8h.html#a83a96f385cb7af3843a6b321b2ac2842">OPFLG_JUMP</a>) &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;0 ){
<a name="l00306"></a>00306       assert( -1-pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;p-&gt;<a class="code" href="structVdbe.html#ae74cf1db577889e4f7ee669d613939a9">nLabel</a> );
<a name="l00307"></a>00307       pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> = aLabel[-1-pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309   }
<a name="l00310"></a>00310   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a>);
<a name="l00311"></a>00311   p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a> = 0;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   *pMaxFuncArgs = nMaxArgs;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315   <span class="comment">/* If we never rollback a statement transaction, then statement</span>
<a name="l00316"></a>00316 <span class="comment">  ** transactions are not needed.  So change every OP_Statement</span>
<a name="l00317"></a>00317 <span class="comment">  ** opcode into an OP_Noop.  This avoid a call to sqlite3OsOpenExclusive()</span>
<a name="l00318"></a>00318 <span class="comment">  ** which can be expensive on some platforms.</span>
<a name="l00319"></a>00319 <span class="comment">  */</span>
<a name="l00320"></a>00320   <span class="keywordflow">if</span>( hasStatementBegin &amp;&amp; !doesStatementRollback ){
<a name="l00321"></a>00321     p-&gt;<a class="code" href="structVdbe.html#aaac5176003bc8760200364c7752786a4">usesStmtJournal</a> = 0;
<a name="l00322"></a>00322     <span class="keywordflow">for</span>(pOp=p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>, i=p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>-1; i&gt;=0; i--, pOp++){
<a name="l00323"></a>00323       <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a718776e9ac8775b4c0047118fd9e7aa1">OP_Statement</a> ){
<a name="l00324"></a>00324         pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> = <a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a>;
<a name="l00325"></a>00325       }
<a name="l00326"></a>00326     }
<a name="l00327"></a>00327   }
<a name="l00328"></a>00328 }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="comment">/*</span>
<a name="l00331"></a>00331 <span class="comment">** Return the address of the next instruction to be inserted.</span>
<a name="l00332"></a>00332 <span class="comment">*/</span>
<a name="l00333"></a><a class="code" href="vdbeaux_8c.html#a603c32814e7280ca6e7516e6f6e12cfd">00333</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l00334"></a>00334   assert( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00335"></a>00335   <span class="keywordflow">return</span> p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>;
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="comment">/*</span>
<a name="l00339"></a>00339 <span class="comment">** Add a whole list of operations to the operation stack.  Return the</span>
<a name="l00340"></a>00340 <span class="comment">** address of the first operation added.</span>
<a name="l00341"></a>00341 <span class="comment">*/</span>
<a name="l00342"></a><a class="code" href="vdbeaux_8c.html#a951024c65d5e2619165ee6511793fb70">00342</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#a4105d7944fb904f78d6da14f8933bdd2">sqlite3VdbeAddOpList</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> nOp, <a class="code" href="structVdbeOpList.html">VdbeOpList</a> <span class="keyword">const</span> *aOp){
<a name="l00343"></a>00343   <span class="keywordtype">int</span> addr;
<a name="l00344"></a>00344   assert( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00345"></a>00345   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a> + nOp &gt; p-&gt;<a class="code" href="structVdbe.html#aa52020050ea42e10ad8be8ebdf470850">nOpAlloc</a> ){
<a name="l00346"></a>00346     <a class="code" href="vdbeaux_8c.html#ad40889e863480532f1aea19343878e3e">resizeOpArray</a>(p, p-&gt;<a class="code" href="structVdbe.html#aa52020050ea42e10ad8be8ebdf470850">nOpAlloc</a> ? p-&gt;<a class="code" href="structVdbe.html#aa52020050ea42e10ad8be8ebdf470850">nOpAlloc</a>*2 : 1024/<span class="keyword">sizeof</span>(<a class="code" href="structVdbeOp.html">Op</a>));
<a name="l00347"></a>00347     assert( p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>+nOp&lt;=p-&gt;nOpAlloc || p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> );
<a name="l00348"></a>00348   }
<a name="l00349"></a>00349   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00350"></a>00350     <span class="keywordflow">return</span> 0;
<a name="l00351"></a>00351   }
<a name="l00352"></a>00352   addr = p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>;
<a name="l00353"></a>00353   <span class="keywordflow">if</span>( nOp&gt;0 ){
<a name="l00354"></a>00354     <span class="keywordtype">int</span> i;
<a name="l00355"></a>00355     <a class="code" href="structVdbeOpList.html">VdbeOpList</a> <span class="keyword">const</span> *pIn = aOp;
<a name="l00356"></a>00356     <span class="keywordflow">for</span>(i=0; i&lt;nOp; i++, pIn++){
<a name="l00357"></a>00357       <span class="keywordtype">int</span> p2 = pIn-&gt;<a class="code" href="structVdbeOpList.html#a8493431402f7f91cea81c00e311dc4e1">p2</a>;
<a name="l00358"></a>00358       <a class="code" href="structVdbeOp.html">VdbeOp</a> *pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i+addr];
<a name="l00359"></a>00359       pOut-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> = pIn-&gt;<a class="code" href="structVdbeOpList.html#a9c839a619aed99f91cb5e226487be7be">opcode</a>;
<a name="l00360"></a>00360       pOut-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> = pIn-&gt;<a class="code" href="structVdbeOpList.html#a68641ef4313dfdfafe45b75203c49d5a">p1</a>;
<a name="l00361"></a>00361       <span class="keywordflow">if</span>( p2&lt;0 &amp;&amp; <a class="code" href="vdbe_8c.html#a87b4d0450221c137df3f4952a2162865">sqlite3VdbeOpcodeHasProperty</a>(pOut-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>, <a class="code" href="opcodes_8h.html#a83a96f385cb7af3843a6b321b2ac2842">OPFLG_JUMP</a>) ){
<a name="l00362"></a>00362         pOut-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> = addr + <a class="code" href="vdbe_8h.html#a5ce4347ce4f7fb635d839077f4633194">ADDR</a>(p2);
<a name="l00363"></a>00363       }<span class="keywordflow">else</span>{
<a name="l00364"></a>00364         pOut-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> = p2;
<a name="l00365"></a>00365       }
<a name="l00366"></a>00366       pOut-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a> = pIn-&gt;<a class="code" href="structVdbeOpList.html#a584cdaa02042fd5d1bc8cffbdfd9441d">p3</a>;
<a name="l00367"></a>00367       pOut-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = <a class="code" href="vdbe_8h.html#a627448337c6537dadef6d5bb387b05c9">P4_NOTUSED</a>;
<a name="l00368"></a>00368       pOut-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a> = 0;
<a name="l00369"></a>00369       pOut-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> = 0;
<a name="l00370"></a>00370 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span>      pOut-&gt;zComment = 0;
<a name="l00372"></a>00372       <span class="keywordflow">if</span>( sqlite3VdbeAddopTrace ){
<a name="l00373"></a>00373         sqlite3VdbePrintOp(0, i+addr, &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i+addr]);
<a name="l00374"></a>00374       }
<a name="l00375"></a>00375 <span class="preprocessor">#endif</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span>    }
<a name="l00377"></a>00377     p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a> += nOp;
<a name="l00378"></a>00378   }
<a name="l00379"></a>00379   <span class="keywordflow">return</span> addr;
<a name="l00380"></a>00380 }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="comment">/*</span>
<a name="l00383"></a>00383 <span class="comment">** Change the value of the P1 operand for a specific instruction.</span>
<a name="l00384"></a>00384 <span class="comment">** This routine is useful when a large program is loaded from a</span>
<a name="l00385"></a>00385 <span class="comment">** static array using sqlite3VdbeAddOpList but we want to make a</span>
<a name="l00386"></a>00386 <span class="comment">** few minor changes to the program.</span>
<a name="l00387"></a>00387 <span class="comment">*/</span>
<a name="l00388"></a><a class="code" href="vdbeaux_8c.html#a30a3615ded1c41ad9949ff596a712eaf">00388</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#a5b024078b85f7acc25e746fa9fc9136c">sqlite3VdbeChangeP1</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> addr, <span class="keywordtype">int</span> val){
<a name="l00389"></a>00389   assert( p==0 || p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00390"></a>00390   <span class="keywordflow">if</span>( p &amp;&amp; addr&gt;=0 &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>&gt;addr &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a> ){
<a name="l00391"></a>00391     p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[addr].<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> = val;
<a name="l00392"></a>00392   }
<a name="l00393"></a>00393 }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="comment">/*</span>
<a name="l00396"></a>00396 <span class="comment">** Change the value of the P2 operand for a specific instruction.</span>
<a name="l00397"></a>00397 <span class="comment">** This routine is useful for setting a jump destination.</span>
<a name="l00398"></a>00398 <span class="comment">*/</span>
<a name="l00399"></a><a class="code" href="vdbeaux_8c.html#a644796f274344762e4098aa8c49085ec">00399</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#ad80ae0e25107f1e56fad9d6eee8f010d">sqlite3VdbeChangeP2</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> addr, <span class="keywordtype">int</span> val){
<a name="l00400"></a>00400   assert( p==0 || p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00401"></a>00401   <span class="keywordflow">if</span>( p &amp;&amp; addr&gt;=0 &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>&gt;addr &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a> ){
<a name="l00402"></a>00402     p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[addr].<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> = val;
<a name="l00403"></a>00403   }
<a name="l00404"></a>00404 }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="comment">/*</span>
<a name="l00407"></a>00407 <span class="comment">** Change the value of the P3 operand for a specific instruction.</span>
<a name="l00408"></a>00408 <span class="comment">*/</span>
<a name="l00409"></a><a class="code" href="vdbeaux_8c.html#a23ffb6f7a45512892ee3e787b1de6a7c">00409</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#ac7aa977bac471cb643aff9c6c51079be">sqlite3VdbeChangeP3</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> addr, <span class="keywordtype">int</span> val){
<a name="l00410"></a>00410   assert( p==0 || p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00411"></a>00411   <span class="keywordflow">if</span>( p &amp;&amp; addr&gt;=0 &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>&gt;addr &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a> ){
<a name="l00412"></a>00412     p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[addr].<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a> = val;
<a name="l00413"></a>00413   }
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="comment">/*</span>
<a name="l00417"></a>00417 <span class="comment">** Change the value of the P5 operand for the most recently</span>
<a name="l00418"></a>00418 <span class="comment">** added operation.</span>
<a name="l00419"></a>00419 <span class="comment">*/</span>
<a name="l00420"></a><a class="code" href="vdbeaux_8c.html#af041a2e6bf4f15bafcfb4c581389ba7a">00420</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#adb56646cb8d4e3ef524755e857b0f702">sqlite3VdbeChangeP5</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> val){
<a name="l00421"></a>00421   assert( p==0 || p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00422"></a>00422   <span class="keywordflow">if</span>( p &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a> ){
<a name="l00423"></a>00423     assert( p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>&gt;0 );
<a name="l00424"></a>00424     p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>-1].<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> = val;
<a name="l00425"></a>00425   }
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 <span class="comment">/*</span>
<a name="l00429"></a>00429 <span class="comment">** Change the P2 operand of instruction addr so that it points to</span>
<a name="l00430"></a>00430 <span class="comment">** the address of the next instruction to be coded.</span>
<a name="l00431"></a>00431 <span class="comment">*/</span>
<a name="l00432"></a><a class="code" href="vdbeaux_8c.html#a2a98b02b6668229da02691a0523a2c3c">00432</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> addr){
<a name="l00433"></a>00433   <a class="code" href="vdbe_8h.html#ad80ae0e25107f1e56fad9d6eee8f010d">sqlite3VdbeChangeP2</a>(p, addr, p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>);
<a name="l00434"></a>00434 }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="comment">/*</span>
<a name="l00438"></a>00438 <span class="comment">** If the input FuncDef structure is ephemeral, then free it.  If</span>
<a name="l00439"></a>00439 <span class="comment">** the FuncDef is not ephermal, then do nothing.</span>
<a name="l00440"></a>00440 <span class="comment">*/</span>
<a name="l00441"></a><a class="code" href="vdbeaux_8c.html#ace0a45aad803937290f5495906773bc4">00441</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#ace0a45aad803937290f5495906773bc4">freeEphemeralFunction</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <a class="code" href="structFuncDef.html">FuncDef</a> *pDef){
<a name="l00442"></a>00442   <span class="keywordflow">if</span>( pDef &amp;&amp; (pDef-&gt;<a class="code" href="structFuncDef.html#aed4dc88e58b7582668bcaf425c4d053f">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a57775215b5162121f33826ac2f38ef43">SQLITE_FUNC_EPHEM</a>)!=0 ){
<a name="l00443"></a>00443     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pDef);
<a name="l00444"></a>00444   }
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="comment">/*</span>
<a name="l00448"></a>00448 <span class="comment">** Delete a P4 value if necessary.</span>
<a name="l00449"></a>00449 <span class="comment">*/</span>
<a name="l00450"></a><a class="code" href="vdbeaux_8c.html#aa1ec8debef2a9be5fe36a3082fd3e0f9">00450</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#aa1ec8debef2a9be5fe36a3082fd3e0f9">freeP4</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <span class="keywordtype">int</span> p4type, <span class="keywordtype">void</span> *p4){
<a name="l00451"></a>00451   <span class="keywordflow">if</span>( p4 ){
<a name="l00452"></a>00452     <span class="keywordflow">switch</span>( p4type ){
<a name="l00453"></a>00453       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a35e19eb3d788cc392377fa786c53023f">P4_REAL</a>:
<a name="l00454"></a>00454       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a212d17b0057bde2ae22873cf61b24bd9">P4_INT64</a>:
<a name="l00455"></a>00455       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a92364abf7e21288a31956e5fe2dec7f2">P4_MPRINTF</a>:
<a name="l00456"></a>00456       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#ae0cac143cf868ae8ec55be2ea9b13e7c">P4_DYNAMIC</a>:
<a name="l00457"></a>00457       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a>:
<a name="l00458"></a>00458       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a6049b6360b78fd6f690f090640e9544b">P4_INTARRAY</a>:
<a name="l00459"></a>00459       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a5a10f433c58f3ce20eb100fa29025e8d">P4_KEYINFO_HANDOFF</a>: {
<a name="l00460"></a>00460         <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p4);
<a name="l00461"></a>00461         <span class="keywordflow">break</span>;
<a name="l00462"></a>00462       }
<a name="l00463"></a>00463       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a711e7b05e9760d62cdb148164846fcbc">P4_VDBEFUNC</a>: {
<a name="l00464"></a>00464         <a class="code" href="structVdbeFunc.html">VdbeFunc</a> *pVdbeFunc = (<a class="code" href="structVdbeFunc.html">VdbeFunc</a> *)p4;
<a name="l00465"></a>00465         <a class="code" href="vdbeaux_8c.html#ace0a45aad803937290f5495906773bc4">freeEphemeralFunction</a>(db, pVdbeFunc-&gt;<a class="code" href="structVdbeFunc.html#a73cbc96029bec2f37c7e2a79052a2f65">pFunc</a>);
<a name="l00466"></a>00466         <a class="code" href="vdbeaux_8c.html#a39bd3906d852580ad020e9261f9d6eba">sqlite3VdbeDeleteAuxData</a>(pVdbeFunc, 0);
<a name="l00467"></a>00467         <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pVdbeFunc);
<a name="l00468"></a>00468         <span class="keywordflow">break</span>;
<a name="l00469"></a>00469       }
<a name="l00470"></a>00470       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a57b87da56c7edb102ed8d0525f9ab54e">P4_FUNCDEF</a>: {
<a name="l00471"></a>00471         <a class="code" href="vdbeaux_8c.html#ace0a45aad803937290f5495906773bc4">freeEphemeralFunction</a>(db, (<a class="code" href="structFuncDef.html">FuncDef</a>*)p4);
<a name="l00472"></a>00472         <span class="keywordflow">break</span>;
<a name="l00473"></a>00473       }
<a name="l00474"></a>00474       <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#af6c6e3475005335f2646434d48af6ffa">P4_MEM</a>: {
<a name="l00475"></a>00475         <a class="code" href="sqliteInt_8h.html#a7f826016b54aaa9036d865d284e77baf">sqlite3ValueFree</a>((<a class="code" href="structMem.html">sqlite3_value</a>*)p4);
<a name="l00476"></a>00476         <span class="keywordflow">break</span>;
<a name="l00477"></a>00477       }
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479   }
<a name="l00480"></a>00480 }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="comment">/*</span>
<a name="l00484"></a>00484 <span class="comment">** Change N opcodes starting at addr to No-ops.</span>
<a name="l00485"></a>00485 <span class="comment">*/</span>
<a name="l00486"></a><a class="code" href="vdbeaux_8c.html#a901bfe16b00a89446584fe08844c1abb">00486</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#ac38d185582ae5f72f6d8b39424eef847">sqlite3VdbeChangeToNoop</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> addr, <span class="keywordtype">int</span> N){
<a name="l00487"></a>00487   <span class="keywordflow">if</span>( p &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a> ){
<a name="l00488"></a>00488     <a class="code" href="structVdbeOp.html">VdbeOp</a> *pOp = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[addr];
<a name="l00489"></a>00489     <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l00490"></a>00490     <span class="keywordflow">while</span>( N-- ){
<a name="l00491"></a>00491       <a class="code" href="vdbeaux_8c.html#aa1ec8debef2a9be5fe36a3082fd3e0f9">freeP4</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a>);
<a name="l00492"></a>00492       memset(pOp, 0, <span class="keyword">sizeof</span>(pOp[0]));
<a name="l00493"></a>00493       pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> = <a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a>;
<a name="l00494"></a>00494       pOp++;
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496   }
<a name="l00497"></a>00497 }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="comment">/*</span>
<a name="l00500"></a>00500 <span class="comment">** Change the value of the P4 operand for a specific instruction.</span>
<a name="l00501"></a>00501 <span class="comment">** This routine is useful when a large program is loaded from a</span>
<a name="l00502"></a>00502 <span class="comment">** static array using sqlite3VdbeAddOpList but we want to make a</span>
<a name="l00503"></a>00503 <span class="comment">** few minor changes to the program.</span>
<a name="l00504"></a>00504 <span class="comment">**</span>
<a name="l00505"></a>00505 <span class="comment">** If n&gt;=0 then the P4 operand is dynamic, meaning that a copy of</span>
<a name="l00506"></a>00506 <span class="comment">** the string is made into memory obtained from sqlite3_malloc().</span>
<a name="l00507"></a>00507 <span class="comment">** A value of n==0 means copy bytes of zP4 up to and including the</span>
<a name="l00508"></a>00508 <span class="comment">** first null byte.  If n&gt;0 then copy n+1 bytes of zP4.</span>
<a name="l00509"></a>00509 <span class="comment">**</span>
<a name="l00510"></a>00510 <span class="comment">** If n==P4_KEYINFO it means that zP4 is a pointer to a KeyInfo structure.</span>
<a name="l00511"></a>00511 <span class="comment">** A copy is made of the KeyInfo structure into memory obtained from</span>
<a name="l00512"></a>00512 <span class="comment">** sqlite3_malloc, to be freed when the Vdbe is finalized.</span>
<a name="l00513"></a>00513 <span class="comment">** n==P4_KEYINFO_HANDOFF indicates that zP4 points to a KeyInfo structure</span>
<a name="l00514"></a>00514 <span class="comment">** stored in memory that the caller has obtained from sqlite3_malloc. The </span>
<a name="l00515"></a>00515 <span class="comment">** caller should not free the allocation, it will be freed when the Vdbe is</span>
<a name="l00516"></a>00516 <span class="comment">** finalized.</span>
<a name="l00517"></a>00517 <span class="comment">** </span>
<a name="l00518"></a>00518 <span class="comment">** Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points</span>
<a name="l00519"></a>00519 <span class="comment">** to a string or structure that is guaranteed to exist for the lifetime of</span>
<a name="l00520"></a>00520 <span class="comment">** the Vdbe. In these cases we can just copy the pointer.</span>
<a name="l00521"></a>00521 <span class="comment">**</span>
<a name="l00522"></a>00522 <span class="comment">** If addr&lt;0 then change P4 on the most recently inserted instruction.</span>
<a name="l00523"></a>00523 <span class="comment">*/</span>
<a name="l00524"></a><a class="code" href="vdbeaux_8c.html#a04e4f23bc421b06823226b4c809f936d">00524</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#a0417c7b01c7f0c8d93910a5dc00965ce">sqlite3VdbeChangeP4</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *zP4, <span class="keywordtype">int</span> n){
<a name="l00525"></a>00525   <a class="code" href="structVdbeOp.html">Op</a> *pOp;
<a name="l00526"></a>00526   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>;
<a name="l00527"></a>00527   assert( p!=0 );
<a name="l00528"></a>00528   db = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l00529"></a>00529   assert( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00530"></a>00530   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>==0 || db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00531"></a>00531     <span class="keywordflow">if</span> (n != <a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a>) {
<a name="l00532"></a>00532       <a class="code" href="vdbeaux_8c.html#aa1ec8debef2a9be5fe36a3082fd3e0f9">freeP4</a>(db, n, (<span class="keywordtype">void</span>*)*(<span class="keywordtype">char</span>**)&amp;zP4);
<a name="l00533"></a>00533     }
<a name="l00534"></a>00534     <span class="keywordflow">return</span>;
<a name="l00535"></a>00535   }
<a name="l00536"></a>00536   assert( addr&lt;p-&gt;nOp );
<a name="l00537"></a>00537   <span class="keywordflow">if</span>( addr&lt;0 ){
<a name="l00538"></a>00538     addr = p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a> - 1;
<a name="l00539"></a>00539     <span class="keywordflow">if</span>( addr&lt;0 ) <span class="keywordflow">return</span>;
<a name="l00540"></a>00540   }
<a name="l00541"></a>00541   pOp = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[addr];
<a name="l00542"></a>00542   <a class="code" href="vdbeaux_8c.html#aa1ec8debef2a9be5fe36a3082fd3e0f9">freeP4</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a>);
<a name="l00543"></a>00543   pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a> = 0;
<a name="l00544"></a>00544   <span class="keywordflow">if</span>( n==<a class="code" href="vdbe_8h.html#a985d1d22c0d0a5ceb7546b09e60d31ef">P4_INT32</a> ){
<a name="l00545"></a>00545     <span class="comment">/* Note: this cast is safe, because the origin data point was an int</span>
<a name="l00546"></a>00546 <span class="comment">    ** that was cast to a (const char *). */</span>
<a name="l00547"></a>00547     pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a69efeafb8cb87ea2a6feed61e877869a">i</a> = <a class="code" href="sqliteInt_8h.html#a1138dada988085d42630ce3b332bf550">SQLITE_PTR_TO_INT</a>(zP4);
<a name="l00548"></a>00548     pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = n;
<a name="l00549"></a>00549   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( zP4==0 ){
<a name="l00550"></a>00550     pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a> = 0;
<a name="l00551"></a>00551     pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = <a class="code" href="vdbe_8h.html#a627448337c6537dadef6d5bb387b05c9">P4_NOTUSED</a>;
<a name="l00552"></a>00552   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( n==<a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a> ){
<a name="l00553"></a>00553     <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKeyInfo;
<a name="l00554"></a>00554     <span class="keywordtype">int</span> nField, nByte;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     nField = ((<a class="code" href="structKeyInfo.html">KeyInfo</a>*)zP4)-&gt;nField;
<a name="l00557"></a>00557     nByte = <span class="keyword">sizeof</span>(*pKeyInfo) + (nField-1)*<span class="keyword">sizeof</span>(pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ad43aa024fca5a065e75d8e24b231adcb">aColl</a>[0]) + nField;
<a name="l00558"></a>00558     pKeyInfo = <a class="code" href="malloc_8c.html#a8c1a33577a57524c7c6eef3d9e64e742">sqlite3Malloc</a>( nByte );
<a name="l00559"></a>00559     pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a531b315fc943dd3990adb10e687ba737">pKeyInfo</a> = pKeyInfo;
<a name="l00560"></a>00560     <span class="keywordflow">if</span>( pKeyInfo ){
<a name="l00561"></a>00561       <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *aSortOrder;
<a name="l00562"></a>00562       memcpy(pKeyInfo, zP4, nByte);
<a name="l00563"></a>00563       aSortOrder = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ac5fe4bd0172a1f11f41f678528a7b21e">aSortOrder</a>;
<a name="l00564"></a>00564       <span class="keywordflow">if</span>( aSortOrder ){
<a name="l00565"></a>00565         pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ac5fe4bd0172a1f11f41f678528a7b21e">aSortOrder</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)&amp;pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ad43aa024fca5a065e75d8e24b231adcb">aColl</a>[nField];
<a name="l00566"></a>00566         memcpy(pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ac5fe4bd0172a1f11f41f678528a7b21e">aSortOrder</a>, aSortOrder, nField);
<a name="l00567"></a>00567       }
<a name="l00568"></a>00568       pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = <a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a>;
<a name="l00569"></a>00569     }<span class="keywordflow">else</span>{
<a name="l00570"></a>00570       p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l00571"></a>00571       pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = <a class="code" href="vdbe_8h.html#a627448337c6537dadef6d5bb387b05c9">P4_NOTUSED</a>;
<a name="l00572"></a>00572     }
<a name="l00573"></a>00573   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( n==<a class="code" href="vdbe_8h.html#a5a10f433c58f3ce20eb100fa29025e8d">P4_KEYINFO_HANDOFF</a> ){
<a name="l00574"></a>00574     pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a> = (<span class="keywordtype">void</span>*)zP4;
<a name="l00575"></a>00575     pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = <a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a>;
<a name="l00576"></a>00576   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( n&lt;0 ){
<a name="l00577"></a>00577     pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a> = (<span class="keywordtype">void</span>*)zP4;
<a name="l00578"></a>00578     pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = n;
<a name="l00579"></a>00579   }<span class="keywordflow">else</span>{
<a name="l00580"></a>00580     <span class="keywordflow">if</span>( n==0 ) n = strlen(zP4);
<a name="l00581"></a>00581     pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a> = <a class="code" href="malloc_8c.html#a17fab011bf22c10e5f74813f08404f63">sqlite3DbStrNDup</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, zP4, n);
<a name="l00582"></a>00582     pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = <a class="code" href="vdbe_8h.html#ae0cac143cf868ae8ec55be2ea9b13e7c">P4_DYNAMIC</a>;
<a name="l00583"></a>00583   }
<a name="l00584"></a>00584 }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00587"></a>00587 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00588"></a>00588 <span class="comment">** Change the comment on the the most recently coded instruction.  Or</span>
<a name="l00589"></a>00589 <span class="comment">** insert a No-op and add the comment to that new instruction.  This</span>
<a name="l00590"></a>00590 <span class="comment">** makes the code easier to read during debugging.  None of this happens</span>
<a name="l00591"></a>00591 <span class="comment">** in a production build.</span>
<a name="l00592"></a>00592 <span class="comment">*/</span>
<a name="l00593"></a>00593 <span class="keywordtype">void</span> sqlite3VdbeComment(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat, ...){
<a name="l00594"></a>00594   va_list ap;
<a name="l00595"></a>00595   assert( p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>&gt;0 || p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>==0 );
<a name="l00596"></a>00596   assert( p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>==0 || p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>-1].zComment==0 || p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> );
<a name="l00597"></a>00597   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a> ){
<a name="l00598"></a>00598     <span class="keywordtype">char</span> **pz = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>-1].zComment;
<a name="l00599"></a>00599     va_start(ap, zFormat);
<a name="l00600"></a>00600     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, *pz);
<a name="l00601"></a>00601     *pz = <a class="code" href="printf_8c.html#ac82afc5572767fef2638f3a680d9eaa1">sqlite3VMPrintf</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, zFormat, ap);
<a name="l00602"></a>00602     va_end(ap);
<a name="l00603"></a>00603   }
<a name="l00604"></a>00604 }
<a name="l00605"></a>00605 <span class="keywordtype">void</span> sqlite3VdbeNoopComment(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat, ...){
<a name="l00606"></a>00606   va_list ap;
<a name="l00607"></a>00607   <a class="code" href="vdbe_8h.html#acf19aa381e21c080b6b731fa7408c724">sqlite3VdbeAddOp0</a>(p, <a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a>);
<a name="l00608"></a>00608   assert( p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>&gt;0 || p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>==0 );
<a name="l00609"></a>00609   assert( p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>==0 || p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>-1].zComment==0 || p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> );
<a name="l00610"></a>00610   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a> ){
<a name="l00611"></a>00611     <span class="keywordtype">char</span> **pz = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>-1].zComment;
<a name="l00612"></a>00612     va_start(ap, zFormat);
<a name="l00613"></a>00613     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, *pz);
<a name="l00614"></a>00614     *pz = <a class="code" href="printf_8c.html#ac82afc5572767fef2638f3a680d9eaa1">sqlite3VMPrintf</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, zFormat, ap);
<a name="l00615"></a>00615     va_end(ap);
<a name="l00616"></a>00616   }
<a name="l00617"></a>00617 }
<a name="l00618"></a>00618 <span class="preprocessor">#endif  </span><span class="comment">/* NDEBUG */</span>
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <span class="comment">/*</span>
<a name="l00621"></a>00621 <span class="comment">** Return the opcode for a given address.</span>
<a name="l00622"></a>00622 <span class="comment">*/</span>
<a name="l00623"></a><a class="code" href="vdbeaux_8c.html#a14cbee81dc576a4f2410b2faefb5704f">00623</a> <a class="code" href="structVdbeOp.html">VdbeOp</a> *<a class="code" href="vdbe_8h.html#a1badd052381dc9cd17422bcc7e09db43">sqlite3VdbeGetOp</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> addr){
<a name="l00624"></a>00624   assert( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l00625"></a>00625   assert( (addr&gt;=0 &amp;&amp; addr&lt;p-&gt;nOp) || p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> );
<a name="l00626"></a>00626   <span class="keywordflow">return</span> ((addr&gt;=0 &amp;&amp; addr&lt;p-&gt;nOp)?(&amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[addr]):0);
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="preprocessor">#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) \</span>
<a name="l00630"></a>00630 <span class="preprocessor">     || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)</span>
<a name="l00631"></a>00631 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00632"></a>00632 <span class="comment">** Compute a string that describes the P4 parameter for an opcode.</span>
<a name="l00633"></a>00633 <span class="comment">** Use zTemp for any required temporary buffer space.</span>
<a name="l00634"></a>00634 <span class="comment">*/</span>
<a name="l00635"></a><a class="code" href="vdbeaux_8c.html#a213d2242690998ca991f734ee4d4dce9">00635</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="vdbeaux_8c.html#a213d2242690998ca991f734ee4d4dce9">displayP4</a>(<a class="code" href="structVdbeOp.html">Op</a> *pOp, <span class="keywordtype">char</span> *zTemp, <span class="keywordtype">int</span> nTemp){
<a name="l00636"></a>00636   <span class="keywordtype">char</span> *zP4 = zTemp;
<a name="l00637"></a>00637   assert( nTemp&gt;=20 );
<a name="l00638"></a>00638   <span class="keywordflow">switch</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> ){
<a name="l00639"></a>00639     <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#af34dc0e34fe248d9eded5a44f5b6cd55">P4_KEYINFO_STATIC</a>:
<a name="l00640"></a>00640     <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a>: {
<a name="l00641"></a>00641       <span class="keywordtype">int</span> i, j;
<a name="l00642"></a>00642       <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKeyInfo = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a531b315fc943dd3990adb10e687ba737">pKeyInfo</a>;
<a name="l00643"></a>00643       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;keyinfo(%d&quot;</span>, pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#af70436487a95e445d540bfc4ca1d3f0b">nField</a>);
<a name="l00644"></a>00644       i = strlen(zTemp);
<a name="l00645"></a>00645       <span class="keywordflow">for</span>(j=0; j&lt;pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#af70436487a95e445d540bfc4ca1d3f0b">nField</a>; j++){
<a name="l00646"></a>00646         <a class="code" href="structCollSeq.html">CollSeq</a> *pColl = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ad43aa024fca5a065e75d8e24b231adcb">aColl</a>[j];
<a name="l00647"></a>00647         <span class="keywordflow">if</span>( pColl ){
<a name="l00648"></a>00648           <span class="keywordtype">int</span> n = strlen(pColl-&gt;<a class="code" href="structCollSeq.html#a48d6d5f71d4f8a3ab122903464e8b4a1">zName</a>);
<a name="l00649"></a>00649           <span class="keywordflow">if</span>( i+n&gt;nTemp-6 ){
<a name="l00650"></a>00650             memcpy(&amp;zTemp[i],<span class="stringliteral">&quot;,...&quot;</span>,4);
<a name="l00651"></a>00651             <span class="keywordflow">break</span>;
<a name="l00652"></a>00652           }
<a name="l00653"></a>00653           zTemp[i++] = <span class="charliteral">&apos;,&apos;</span>;
<a name="l00654"></a>00654           <span class="keywordflow">if</span>( pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ac5fe4bd0172a1f11f41f678528a7b21e">aSortOrder</a> &amp;&amp; pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ac5fe4bd0172a1f11f41f678528a7b21e">aSortOrder</a>[j] ){
<a name="l00655"></a>00655             zTemp[i++] = <span class="charliteral">&apos;-&apos;</span>;
<a name="l00656"></a>00656           }
<a name="l00657"></a>00657           memcpy(&amp;zTemp[i], pColl-&gt;<a class="code" href="structCollSeq.html#a48d6d5f71d4f8a3ab122903464e8b4a1">zName</a>,n+1);
<a name="l00658"></a>00658           i += n;
<a name="l00659"></a>00659         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( i+4&lt;nTemp-6 ){
<a name="l00660"></a>00660           memcpy(&amp;zTemp[i],<span class="stringliteral">&quot;,nil&quot;</span>,4);
<a name="l00661"></a>00661           i += 4;
<a name="l00662"></a>00662         }
<a name="l00663"></a>00663       }
<a name="l00664"></a>00664       zTemp[i++] = <span class="charliteral">&apos;)&apos;</span>;
<a name="l00665"></a>00665       zTemp[i] = 0;
<a name="l00666"></a>00666       assert( i&lt;nTemp );
<a name="l00667"></a>00667       <span class="keywordflow">break</span>;
<a name="l00668"></a>00668     }
<a name="l00669"></a>00669     <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a75b33b0e5ede33c0da0a513e3ff9cdb8">P4_COLLSEQ</a>: {
<a name="l00670"></a>00670       <a class="code" href="structCollSeq.html">CollSeq</a> *pColl = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aaf1833fde93e43f42bac11511a0e9910">pColl</a>;
<a name="l00671"></a>00671       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;collseq(%.20s)&quot;</span>, pColl-&gt;<a class="code" href="structCollSeq.html#a48d6d5f71d4f8a3ab122903464e8b4a1">zName</a>);
<a name="l00672"></a>00672       <span class="keywordflow">break</span>;
<a name="l00673"></a>00673     }
<a name="l00674"></a>00674     <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a57b87da56c7edb102ed8d0525f9ab54e">P4_FUNCDEF</a>: {
<a name="l00675"></a>00675       <a class="code" href="structFuncDef.html">FuncDef</a> *pDef = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a041e9019dd14f775e7dc639e35127d39">pFunc</a>;
<a name="l00676"></a>00676       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;%s(%d)&quot;</span>, pDef-&gt;<a class="code" href="structFuncDef.html#a1135e622a3a505c7c463e975846ef926">zName</a>, pDef-&gt;<a class="code" href="structFuncDef.html#a4ad90c05868ec8ee60c211b6e20299df">nArg</a>);
<a name="l00677"></a>00677       <span class="keywordflow">break</span>;
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679     <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a212d17b0057bde2ae22873cf61b24bd9">P4_INT64</a>: {
<a name="l00680"></a>00680       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;%lld&quot;</span>, *pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aca64f9003a7490b02e08d790a7680fc3">pI64</a>);
<a name="l00681"></a>00681       <span class="keywordflow">break</span>;
<a name="l00682"></a>00682     }
<a name="l00683"></a>00683     <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a985d1d22c0d0a5ceb7546b09e60d31ef">P4_INT32</a>: {
<a name="l00684"></a>00684       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;%d&quot;</span>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a69efeafb8cb87ea2a6feed61e877869a">i</a>);
<a name="l00685"></a>00685       <span class="keywordflow">break</span>;
<a name="l00686"></a>00686     }
<a name="l00687"></a>00687     <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a35e19eb3d788cc392377fa786c53023f">P4_REAL</a>: {
<a name="l00688"></a>00688       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;%.16g&quot;</span>, *pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a627ba5846cb35734a01493acd010a9a0">pReal</a>);
<a name="l00689"></a>00689       <span class="keywordflow">break</span>;
<a name="l00690"></a>00690     }
<a name="l00691"></a>00691     <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#af6c6e3475005335f2646434d48af6ffa">P4_MEM</a>: {
<a name="l00692"></a>00692       <a class="code" href="structMem.html">Mem</a> *pMem = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#ae4fe6fe3da8afb8d946df3676d766bb7">pMem</a>;
<a name="l00693"></a>00693       assert( (pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>)==0 );
<a name="l00694"></a>00694       <span class="keywordflow">if</span>( pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a> ){
<a name="l00695"></a>00695         zP4 = pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>;
<a name="l00696"></a>00696       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> ){
<a name="l00697"></a>00697         <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;%lld&quot;</span>, pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>);
<a name="l00698"></a>00698       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a> ){
<a name="l00699"></a>00699         <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;%.16g&quot;</span>, pMem-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>);
<a name="l00700"></a>00700       }
<a name="l00701"></a>00701       <span class="keywordflow">break</span>;
<a name="l00702"></a>00702     }
<a name="l00703"></a>00703 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span>    <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a7a5cdd538a2cb9cf421f7e2f14b3947f">P4_VTAB</a>: {
<a name="l00705"></a>00705       <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a47739d78857f4d8fe62b4a5e0d721345">pVtab</a>;
<a name="l00706"></a>00706       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;vtab:%p:%p&quot;</span>, pVtab, pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>);
<a name="l00707"></a>00707       <span class="keywordflow">break</span>;
<a name="l00708"></a>00708     }
<a name="l00709"></a>00709 <span class="preprocessor">#endif</span>
<a name="l00710"></a>00710 <span class="preprocessor"></span>    <span class="keywordflow">case</span> <a class="code" href="vdbe_8h.html#a6049b6360b78fd6f690f090640e9544b">P4_INTARRAY</a>: {
<a name="l00711"></a>00711       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nTemp, zTemp, <span class="stringliteral">&quot;intarray&quot;</span>);
<a name="l00712"></a>00712       <span class="keywordflow">break</span>;
<a name="l00713"></a>00713     }
<a name="l00714"></a>00714     <span class="keywordflow">default</span>: {
<a name="l00715"></a>00715       zP4 = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>;
<a name="l00716"></a>00716       <span class="keywordflow">if</span>( zP4==0 ){
<a name="l00717"></a>00717         zP4 = zTemp;
<a name="l00718"></a>00718         zTemp[0] = 0;
<a name="l00719"></a>00719       }
<a name="l00720"></a>00720     }
<a name="l00721"></a>00721   }
<a name="l00722"></a>00722   assert( zP4!=0 );
<a name="l00723"></a>00723   <span class="keywordflow">return</span> zP4;
<a name="l00724"></a>00724 }
<a name="l00725"></a>00725 <span class="preprocessor">#endif</span>
<a name="l00726"></a>00726 <span class="preprocessor"></span>
<a name="l00727"></a>00727 <span class="comment">/*</span>
<a name="l00728"></a>00728 <span class="comment">** Declare to the Vdbe that the BTree object at db-&gt;aDb[i] is used.</span>
<a name="l00729"></a>00729 <span class="comment">**</span>
<a name="l00730"></a>00730 <span class="comment">*/</span>
<a name="l00731"></a><a class="code" href="vdbeaux_8c.html#a9e356eae8c884b344d42f1d5e2ca8760">00731</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#a44ca3a39c7bc260ba1358a4ad14f39d4">sqlite3VdbeUsesBtree</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> i){
<a name="l00732"></a>00732   <span class="keywordtype">int</span> mask;
<a name="l00733"></a>00733   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a> );
<a name="l00734"></a>00734   assert( i&lt;<span class="keyword">sizeof</span>(p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a>)*8 );
<a name="l00735"></a>00735   mask = 1&lt;&lt;i;
<a name="l00736"></a>00736   <span class="keywordflow">if</span>( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; mask)==0 ){
<a name="l00737"></a>00737     p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> |= mask;
<a name="l00738"></a>00738     <a class="code" href="btree_8h.html#a36ab9bd8eb947c4feccf2e79d2d6f93e">sqlite3BtreeMutexArrayInsert</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#aeeff59f076cad0b73997113e4e29bd76">aMutex</a>, p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>);
<a name="l00739"></a>00739   }
<a name="l00740"></a>00740 }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 <span class="preprocessor">#if defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)</span>
<a name="l00744"></a>00744 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00745"></a>00745 <span class="comment">** Print a single opcode.  This routine is used for debugging only.</span>
<a name="l00746"></a>00746 <span class="comment">*/</span>
<a name="l00747"></a>00747 <span class="keywordtype">void</span> sqlite3VdbePrintOp(FILE *pOut, <span class="keywordtype">int</span> pc, <a class="code" href="structVdbeOp.html">Op</a> *pOp){
<a name="l00748"></a>00748   <span class="keywordtype">char</span> *zP4;
<a name="l00749"></a>00749   <span class="keywordtype">char</span> zPtr[50];
<a name="l00750"></a>00750   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat1 = <span class="stringliteral">&quot;%4d %-13s %4d %4d %4d %-4s %.2X %s\n&quot;</span>;
<a name="l00751"></a>00751   <span class="keywordflow">if</span>( pOut==0 ) pOut = stdout;
<a name="l00752"></a>00752   zP4 = <a class="code" href="vdbeaux_8c.html#a213d2242690998ca991f734ee4d4dce9">displayP4</a>(pOp, zPtr, <span class="keyword">sizeof</span>(zPtr));
<a name="l00753"></a>00753   fprintf(pOut, zFormat1, pc, 
<a name="l00754"></a>00754       <a class="code" href="opcodes_8c.html#a584d6f606a225cf64848add409582776">sqlite3OpcodeName</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>), pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, zP4, pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>,
<a name="l00755"></a>00755 #ifdef SQLITE_DEBUG
<a name="l00756"></a>00756       pOp-&gt;zComment ? pOp-&gt;zComment : <span class="stringliteral">&quot;&quot;</span>
<a name="l00757"></a>00757 #<span class="keywordflow">else</span>
<a name="l00758"></a>00758       <span class="stringliteral">&quot;&quot;</span>
<a name="l00759"></a>00759 #endif
<a name="l00760"></a>00760   );
<a name="l00761"></a>00761   fflush(pOut);
<a name="l00762"></a>00762 }
<a name="l00763"></a>00763 <span class="preprocessor">#endif</span>
<a name="l00764"></a>00764 <span class="preprocessor"></span>
<a name="l00765"></a>00765 <span class="comment">/*</span>
<a name="l00766"></a>00766 <span class="comment">** Release an array of N Mem elements</span>
<a name="l00767"></a>00767 <span class="comment">*/</span>
<a name="l00768"></a><a class="code" href="vdbeaux_8c.html#a321ef1ead88ab0c4c636971ae5cc9778">00768</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#a321ef1ead88ab0c4c636971ae5cc9778">releaseMemArray</a>(<a class="code" href="structMem.html">Mem</a> *p, <span class="keywordtype">int</span> N){
<a name="l00769"></a>00769   <span class="keywordflow">if</span>( p &amp;&amp; N ){
<a name="l00770"></a>00770     <a class="code" href="structMem.html">Mem</a> *pEnd;
<a name="l00771"></a>00771     <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = p-&gt;<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a>;
<a name="l00772"></a>00772     <span class="keywordtype">int</span> malloc_failed = db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a>;
<a name="l00773"></a>00773     <span class="keywordflow">for</span>(pEnd=&amp;p[N]; p&lt;pEnd; p++){
<a name="l00774"></a>00774       assert( (&amp;p[1])==pEnd || p[0].db==p[1].db );
<a name="l00775"></a>00775 
<a name="l00776"></a>00776       <span class="comment">/* This block is really an inlined version of sqlite3VdbeMemRelease()</span>
<a name="l00777"></a>00777 <span class="comment">      ** that takes advantage of the fact that the memory cell value is </span>
<a name="l00778"></a>00778 <span class="comment">      ** being set to NULL after releasing any dynamic resources.</span>
<a name="l00779"></a>00779 <span class="comment">      **</span>
<a name="l00780"></a>00780 <span class="comment">      ** The justification for duplicating code is that according to </span>
<a name="l00781"></a>00781 <span class="comment">      ** callgrind, this causes a certain test case to hit the CPU 4.7 </span>
<a name="l00782"></a>00782 <span class="comment">      ** percent less (x86 linux, gcc version 4.1.2, -O6) than if </span>
<a name="l00783"></a>00783 <span class="comment">      ** sqlite3MemRelease() were called from here. With -O2, this jumps</span>
<a name="l00784"></a>00784 <span class="comment">      ** to 6.6 percent. The test case is inserting 1000 rows into a table </span>
<a name="l00785"></a>00785 <span class="comment">      ** with no indexes using a single prepared INSERT statement, bind() </span>
<a name="l00786"></a>00786 <span class="comment">      ** and reset(). Inserts are grouped into a transaction.</span>
<a name="l00787"></a>00787 <span class="comment">      */</span>
<a name="l00788"></a>00788       <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;(<a class="code" href="vdbeInt_8h.html#acabfe7d13c1ee8b1aa2631ff54ea75f3">MEM_Agg</a>|<a class="code" href="vdbeInt_8h.html#ae9774193fee66e1494092aa77697eb61">MEM_Dyn</a>) ){
<a name="l00789"></a>00789         <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(p);
<a name="l00790"></a>00790       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> ){
<a name="l00791"></a>00791         <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a>);
<a name="l00792"></a>00792         p-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l00793"></a>00793       }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795       p-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797     db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = malloc_failed;
<a name="l00798"></a>00798   }
<a name="l00799"></a>00799 }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 <span class="preprocessor">#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT</span>
<a name="l00802"></a>00802 <span class="preprocessor"></span><span class="keywordtype">int</span> sqlite3VdbeReleaseBuffers(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l00803"></a>00803   <span class="keywordtype">int</span> ii;
<a name="l00804"></a>00804   <span class="keywordtype">int</span> nFree = 0;
<a name="l00805"></a>00805   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l00806"></a>00806   <span class="keywordflow">for</span>(ii=1; ii&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a>; ii++){
<a name="l00807"></a>00807     <a class="code" href="structMem.html">Mem</a> *pMem = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[ii];
<a name="l00808"></a>00808     <span class="keywordflow">if</span>( pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> &amp;&amp; pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#ae9774193fee66e1494092aa77697eb61">MEM_Dyn</a> ){
<a name="l00809"></a>00809       assert( !pMem-&gt;<a class="code" href="structMem.html#a081ea2f86933d68a8940785b62f638ef">xDel</a> );
<a name="l00810"></a>00810       nFree += <a class="code" href="malloc_8c.html#a0059be2ea03856570fb97ffedddc2edf">sqlite3DbMallocSize</a>(pMem-&gt;<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a>, pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>);
<a name="l00811"></a>00811       <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(pMem);
<a name="l00812"></a>00812     }
<a name="l00813"></a>00813   }
<a name="l00814"></a>00814   <span class="keywordflow">return</span> nFree;
<a name="l00815"></a>00815 }
<a name="l00816"></a>00816 <span class="preprocessor">#endif</span>
<a name="l00817"></a>00817 <span class="preprocessor"></span>
<a name="l00818"></a>00818 <span class="preprocessor">#ifndef SQLITE_OMIT_EXPLAIN</span>
<a name="l00819"></a>00819 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00820"></a>00820 <span class="comment">** Give a listing of the program in the virtual machine.</span>
<a name="l00821"></a>00821 <span class="comment">**</span>
<a name="l00822"></a>00822 <span class="comment">** The interface is the same as sqlite3VdbeExec().  But instead of</span>
<a name="l00823"></a>00823 <span class="comment">** running the code, it invokes the callback once for each instruction.</span>
<a name="l00824"></a>00824 <span class="comment">** This feature is used to implement &quot;EXPLAIN&quot;.</span>
<a name="l00825"></a>00825 <span class="comment">**</span>
<a name="l00826"></a>00826 <span class="comment">** When p-&gt;explain==1, each instruction is listed.  When</span>
<a name="l00827"></a>00827 <span class="comment">** p-&gt;explain==2, only OP_Explain instructions are listed and these</span>
<a name="l00828"></a>00828 <span class="comment">** are shown in a different format.  p-&gt;explain==2 is used to implement</span>
<a name="l00829"></a>00829 <span class="comment">** EXPLAIN QUERY PLAN.</span>
<a name="l00830"></a>00830 <span class="comment">*/</span>
<a name="l00831"></a><a class="code" href="vdbeInt_8h.html#af2e518e0416c2687880545dd16efdb2f">00831</a> <span class="keywordtype">int</span> <a class="code" href="vdbeaux_8c.html#ad42fab71fd40f01ac18a5d5572e660e9">sqlite3VdbeList</a>(
<a name="l00832"></a>00832   <a class="code" href="structVdbe.html">Vdbe</a> *p                   <span class="comment">/* The VDBE */</span>
<a name="l00833"></a>00833 ){
<a name="l00834"></a>00834   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l00835"></a>00835   <span class="keywordtype">int</span> i;
<a name="l00836"></a>00836   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00837"></a>00837   <a class="code" href="structMem.html">Mem</a> *pMem = p-&gt;<a class="code" href="structVdbe.html#a0dec47b8d8c481df2b73d5bbf9cdde11">pResultSet</a> = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[1];
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   assert( p-&gt;<a class="code" href="structVdbe.html#aa1bbd3dcd803eb59dc73e681b6a585ed">explain</a> );
<a name="l00840"></a>00840   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>!=<a class="code" href="vdbeInt_8h.html#af3737d82d7edf97fffb59baf1592a528">VDBE_MAGIC_RUN</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a34f01e4ee909e6b68be040868f7503bc">SQLITE_MISUSE</a>;
<a name="l00841"></a>00841   assert( db-&gt;<a class="code" href="structsqlite3.html#a6d9069c555657020c5dd1532d8e9c3f9">magic</a>==<a class="code" href="sqliteInt_8h.html#ad024aa586d9bf98f26fccca95f21b265">SQLITE_MAGIC_BUSY</a> );
<a name="l00842"></a>00842   assert( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> || p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a> );
<a name="l00843"></a>00843 
<a name="l00844"></a>00844   <span class="comment">/* Even though this opcode does not use dynamic strings for</span>
<a name="l00845"></a>00845 <span class="comment">  ** the result, result columns may become dynamic if the user calls</span>
<a name="l00846"></a>00846 <span class="comment">  ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.</span>
<a name="l00847"></a>00847 <span class="comment">  */</span>
<a name="l00848"></a>00848   <a class="code" href="vdbeaux_8c.html#a321ef1ead88ab0c4c636971ae5cc9778">releaseMemArray</a>(pMem, p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a>);
<a name="l00849"></a>00849 
<a name="l00850"></a>00850   <span class="keywordflow">do</span>{
<a name="l00851"></a>00851     i = p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a>++;
<a name="l00852"></a>00852   }<span class="keywordflow">while</span>( i&lt;p-&gt;nOp &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#aa1bbd3dcd803eb59dc73e681b6a585ed">explain</a>==2 &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i].<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>!=<a class="code" href="opcodes_8h.html#a8b5bfbed11785aba4cf5d38d37e9ee5e">OP_Explain</a> );
<a name="l00853"></a>00853   <span class="keywordflow">if</span>( i&gt;=p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a> ){
<a name="l00854"></a>00854     p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00855"></a>00855     rc = <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>;
<a name="l00856"></a>00856   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#aa5db6567b0e7d5009c52e0307b1cf095">u1</a>.<a class="code" href="structsqlite3.html#a80b995fd97507bbf978d6960adde53f8">isInterrupted</a> ){
<a name="l00857"></a>00857     p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = <a class="code" href="sqlite3_8h.html#a03c9b25faf07d0e47ce7a1b1e46b2adc">SQLITE_INTERRUPT</a>;
<a name="l00858"></a>00858     rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l00859"></a>00859     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="main_8c.html#a02d1b390ceb669b8e689f27ea7134cad">sqlite3ErrStr</a>(p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>));
<a name="l00860"></a>00860   }<span class="keywordflow">else</span>{
<a name="l00861"></a>00861     <span class="keywordtype">char</span> *z;
<a name="l00862"></a>00862     <a class="code" href="structVdbeOp.html">Op</a> *pOp = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i];
<a name="l00863"></a>00863     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#aa1bbd3dcd803eb59dc73e681b6a585ed">explain</a>==1 ){
<a name="l00864"></a>00864       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l00865"></a>00865       pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#a7453d71905f10fa330940428f8abe21c">SQLITE_INTEGER</a>;
<a name="l00866"></a>00866       pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = i;                                <span class="comment">/* Program counter */</span>
<a name="l00867"></a>00867       pMem++;
<a name="l00868"></a>00868   
<a name="l00869"></a>00869       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a4f3ef3e28665fca360d6d0945ac4c02f">MEM_Static</a>|<a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a>|<a class="code" href="vdbeInt_8h.html#a07b1add4713bc55a88ecb0085c846ab7">MEM_Term</a>;
<a name="l00870"></a>00870       pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> = (<span class="keywordtype">char</span>*)<a class="code" href="opcodes_8c.html#a584d6f606a225cf64848add409582776">sqlite3OpcodeName</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>);  <span class="comment">/* Opcode */</span>
<a name="l00871"></a>00871       assert( pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>!=0 );
<a name="l00872"></a>00872       pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = strlen(pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>);
<a name="l00873"></a>00873       pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#accfdca5d473931c3959bbdf4fc5c2ead">SQLITE_TEXT</a>;
<a name="l00874"></a>00874       pMem-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>;
<a name="l00875"></a>00875       pMem++;
<a name="l00876"></a>00876     }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l00879"></a>00879     pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;                          <span class="comment">/* P1 */</span>
<a name="l00880"></a>00880     pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#a7453d71905f10fa330940428f8abe21c">SQLITE_INTEGER</a>;
<a name="l00881"></a>00881     pMem++;
<a name="l00882"></a>00882 
<a name="l00883"></a>00883     pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l00884"></a>00884     pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;                          <span class="comment">/* P2 */</span>
<a name="l00885"></a>00885     pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#a7453d71905f10fa330940428f8abe21c">SQLITE_INTEGER</a>;
<a name="l00886"></a>00886     pMem++;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#aa1bbd3dcd803eb59dc73e681b6a585ed">explain</a>==1 ){
<a name="l00889"></a>00889       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l00890"></a>00890       pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;                          <span class="comment">/* P3 */</span>
<a name="l00891"></a>00891       pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#a7453d71905f10fa330940428f8abe21c">SQLITE_INTEGER</a>;
<a name="l00892"></a>00892       pMem++;
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895     <span class="keywordflow">if</span>( <a class="code" href="vdbeInt_8h.html#ac934bc728baa7b73867a62722c30d311">sqlite3VdbeMemGrow</a>(pMem, 32, 0) ){            <span class="comment">/* P4 */</span>
<a name="l00896"></a>00896       p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l00897"></a>00897       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899     pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ae9774193fee66e1494092aa77697eb61">MEM_Dyn</a>|<a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a>|<a class="code" href="vdbeInt_8h.html#a07b1add4713bc55a88ecb0085c846ab7">MEM_Term</a>;
<a name="l00900"></a>00900     z = <a class="code" href="vdbeaux_8c.html#a213d2242690998ca991f734ee4d4dce9">displayP4</a>(pOp, pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, 32);
<a name="l00901"></a>00901     <span class="keywordflow">if</span>( z!=pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> ){
<a name="l00902"></a>00902       <a class="code" href="vdbeInt_8h.html#aba781c78989d5481ac168c09108c0ba8">sqlite3VdbeMemSetStr</a>(pMem, z, -1, <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>, 0);
<a name="l00903"></a>00903     }<span class="keywordflow">else</span>{
<a name="l00904"></a>00904       assert( pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>!=0 );
<a name="l00905"></a>00905       pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = strlen(pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>);
<a name="l00906"></a>00906       pMem-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>;
<a name="l00907"></a>00907     }
<a name="l00908"></a>00908     pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#accfdca5d473931c3959bbdf4fc5c2ead">SQLITE_TEXT</a>;
<a name="l00909"></a>00909     pMem++;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#aa1bbd3dcd803eb59dc73e681b6a585ed">explain</a>==1 ){
<a name="l00912"></a>00912       <span class="keywordflow">if</span>( <a class="code" href="vdbeInt_8h.html#ac934bc728baa7b73867a62722c30d311">sqlite3VdbeMemGrow</a>(pMem, 4, 0) ){
<a name="l00913"></a>00913         p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l00914"></a>00914         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l00915"></a>00915       }
<a name="l00916"></a>00916       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ae9774193fee66e1494092aa77697eb61">MEM_Dyn</a>|<a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a>|<a class="code" href="vdbeInt_8h.html#a07b1add4713bc55a88ecb0085c846ab7">MEM_Term</a>;
<a name="l00917"></a>00917       pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = 2;
<a name="l00918"></a>00918       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(3, pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, <span class="stringliteral">&quot;%.2x&quot;</span>, pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>);   <span class="comment">/* P5 */</span>
<a name="l00919"></a>00919       pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#accfdca5d473931c3959bbdf4fc5c2ead">SQLITE_TEXT</a>;
<a name="l00920"></a>00920       pMem-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>;
<a name="l00921"></a>00921       pMem++;
<a name="l00922"></a>00922   
<a name="l00923"></a>00923 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00924"></a>00924 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( pOp-&gt;zComment ){
<a name="l00925"></a>00925         pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a>|<a class="code" href="vdbeInt_8h.html#a07b1add4713bc55a88ecb0085c846ab7">MEM_Term</a>;
<a name="l00926"></a>00926         pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> = pOp-&gt;zComment;
<a name="l00927"></a>00927         pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = strlen(pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>);
<a name="l00928"></a>00928         pMem-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>;
<a name="l00929"></a>00929         pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#accfdca5d473931c3959bbdf4fc5c2ead">SQLITE_TEXT</a>;
<a name="l00930"></a>00930       }<span class="keywordflow">else</span>
<a name="l00931"></a>00931 <span class="preprocessor">#endif</span>
<a name="l00932"></a>00932 <span class="preprocessor"></span>      {
<a name="l00933"></a>00933         pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;                       <span class="comment">/* Comment */</span>
<a name="l00934"></a>00934         pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#afd180931f2d06d6c245791d187da5802">SQLITE_NULL</a>;
<a name="l00935"></a>00935       }
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938     p-&gt;<a class="code" href="structVdbe.html#ae4aebc61bfb17f7dc2099c4143900e83">nResColumn</a> = 8 - 5*(p-&gt;<a class="code" href="structVdbe.html#aa1bbd3dcd803eb59dc73e681b6a585ed">explain</a>-1);
<a name="l00939"></a>00939     p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00940"></a>00940     rc = <a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a>;
<a name="l00941"></a>00941   }
<a name="l00942"></a>00942   <span class="keywordflow">return</span> rc;
<a name="l00943"></a>00943 }
<a name="l00944"></a>00944 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_EXPLAIN */</span>
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00947"></a>00947 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00948"></a>00948 <span class="comment">** Print the SQL that was used to generate a VDBE program.</span>
<a name="l00949"></a>00949 <span class="comment">*/</span>
<a name="l00950"></a>00950 <span class="keywordtype">void</span> sqlite3VdbePrintSql(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l00951"></a>00951   <span class="keywordtype">int</span> nOp = p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>;
<a name="l00952"></a>00952   <a class="code" href="structVdbeOp.html">VdbeOp</a> *pOp;
<a name="l00953"></a>00953   <span class="keywordflow">if</span>( nOp&lt;1 ) <span class="keywordflow">return</span>;
<a name="l00954"></a>00954   pOp = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[0];
<a name="l00955"></a>00955   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a373f164d317ad0443c7e4ac692214c45">OP_Trace</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>!=0 ){
<a name="l00956"></a>00956     <span class="keyword">const</span> <span class="keywordtype">char</span> *z = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>;
<a name="l00957"></a>00957     <span class="keywordflow">while</span>( isspace(*(<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)z) ) z++;
<a name="l00958"></a>00958     printf(<span class="stringliteral">&quot;SQL: [%s]\n&quot;</span>, z);
<a name="l00959"></a>00959   }
<a name="l00960"></a>00960 }
<a name="l00961"></a>00961 <span class="preprocessor">#endif</span>
<a name="l00962"></a>00962 <span class="preprocessor"></span>
<a name="l00963"></a>00963 <span class="preprocessor">#if !defined(SQLITE_OMIT_TRACE) &amp;&amp; defined(SQLITE_ENABLE_IOTRACE)</span>
<a name="l00964"></a>00964 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00965"></a>00965 <span class="comment">** Print an IOTRACE message showing SQL content.</span>
<a name="l00966"></a>00966 <span class="comment">*/</span>
<a name="l00967"></a>00967 <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#abf1afd97609bace214ec9b39ed71e03c">sqlite3VdbeIOTraceSql</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l00968"></a>00968   <span class="keywordtype">int</span> nOp = p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>;
<a name="l00969"></a>00969   <a class="code" href="structVdbeOp.html">VdbeOp</a> *pOp;
<a name="l00970"></a>00970   <span class="keywordflow">if</span>( sqlite3IoTrace==0 ) <span class="keywordflow">return</span>;
<a name="l00971"></a>00971   <span class="keywordflow">if</span>( nOp&lt;1 ) <span class="keywordflow">return</span>;
<a name="l00972"></a>00972   pOp = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[0];
<a name="l00973"></a>00973   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a373f164d317ad0443c7e4ac692214c45">OP_Trace</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>!=0 ){
<a name="l00974"></a>00974     <span class="keywordtype">int</span> i, j;
<a name="l00975"></a>00975     <span class="keywordtype">char</span> z[1000];
<a name="l00976"></a>00976     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(z), z, <span class="stringliteral">&quot;%s&quot;</span>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l00977"></a>00977     <span class="keywordflow">for</span>(i=0; isspace((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)z[i]); i++){}
<a name="l00978"></a>00978     <span class="keywordflow">for</span>(j=0; z[i]; i++){
<a name="l00979"></a>00979       <span class="keywordflow">if</span>( isspace((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)z[i]) ){
<a name="l00980"></a>00980         <span class="keywordflow">if</span>( z[i-1]!=<span class="charliteral">&apos; &apos;</span> ){
<a name="l00981"></a>00981           z[j++] = <span class="charliteral">&apos; &apos;</span>;
<a name="l00982"></a>00982         }
<a name="l00983"></a>00983       }<span class="keywordflow">else</span>{
<a name="l00984"></a>00984         z[j++] = z[i];
<a name="l00985"></a>00985       }
<a name="l00986"></a>00986     }
<a name="l00987"></a>00987     z[j] = 0;
<a name="l00988"></a>00988     sqlite3IoTrace(<span class="stringliteral">&quot;SQL %s\n&quot;</span>, z);
<a name="l00989"></a>00989   }
<a name="l00990"></a>00990 }
<a name="l00991"></a>00991 <span class="preprocessor">#endif </span><span class="comment">/* !SQLITE_OMIT_TRACE &amp;&amp; SQLITE_ENABLE_IOTRACE */</span>
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 <span class="comment">/*</span>
<a name="l00995"></a>00995 <span class="comment">** Prepare a virtual machine for execution.  This involves things such</span>
<a name="l00996"></a>00996 <span class="comment">** as allocating stack space and initializing the program counter.</span>
<a name="l00997"></a>00997 <span class="comment">** After the VDBE has be prepped, it can be executed by one or more</span>
<a name="l00998"></a>00998 <span class="comment">** calls to sqlite3VdbeExec().  </span>
<a name="l00999"></a>00999 <span class="comment">**</span>
<a name="l01000"></a>01000 <span class="comment">** This is the only way to move a VDBE from VDBE_MAGIC_INIT to</span>
<a name="l01001"></a>01001 <span class="comment">** VDBE_MAGIC_RUN.</span>
<a name="l01002"></a>01002 <span class="comment">*/</span>
<a name="l01003"></a><a class="code" href="vdbeaux_8c.html#acc955b7f0e3eb99c475f4294b78c5c93">01003</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#ace51a1495db9070228c5fddb7a156ffe">sqlite3VdbeMakeReady</a>(
<a name="l01004"></a>01004   <a class="code" href="structVdbe.html">Vdbe</a> *p,                       <span class="comment">/* The VDBE */</span>
<a name="l01005"></a>01005   <span class="keywordtype">int</span> nVar,                      <span class="comment">/* Number of &apos;?&apos; see in the SQL statement */</span>
<a name="l01006"></a>01006   <span class="keywordtype">int</span> nMem,                      <span class="comment">/* Number of memory cells to allocate */</span>
<a name="l01007"></a>01007   <span class="keywordtype">int</span> nCursor,                   <span class="comment">/* Number of cursors to allocate */</span>
<a name="l01008"></a>01008   <span class="keywordtype">int</span> isExplain                  <span class="comment">/* True if the EXPLAIN keywords is present */</span>
<a name="l01009"></a>01009 ){
<a name="l01010"></a>01010   <span class="keywordtype">int</span> n;
<a name="l01011"></a>01011   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l01012"></a>01012 
<a name="l01013"></a>01013   assert( p!=0 );
<a name="l01014"></a>01014   assert( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> );
<a name="l01015"></a>01015 
<a name="l01016"></a>01016   <span class="comment">/* There should be at least one opcode.</span>
<a name="l01017"></a>01017 <span class="comment">  */</span>
<a name="l01018"></a>01018   assert( p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>&gt;0 );
<a name="l01019"></a>01019 
<a name="l01020"></a>01020   <span class="comment">/* Set the magic to VDBE_MAGIC_RUN sooner rather than later. This</span>
<a name="l01021"></a>01021 <span class="comment">   * is because the call to resizeOpArray() below may shrink the</span>
<a name="l01022"></a>01022 <span class="comment">   * p-&gt;aOp[] array to save memory if called when in VDBE_MAGIC_RUN </span>
<a name="l01023"></a>01023 <span class="comment">   * state.</span>
<a name="l01024"></a>01024 <span class="comment">   */</span>
<a name="l01025"></a>01025   p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a> = <a class="code" href="vdbeInt_8h.html#af3737d82d7edf97fffb59baf1592a528">VDBE_MAGIC_RUN</a>;
<a name="l01026"></a>01026 
<a name="l01027"></a>01027   <span class="comment">/* For each cursor required, also allocate a memory cell. Memory</span>
<a name="l01028"></a>01028 <span class="comment">  ** cells (nMem+1-nCursor)..nMem, inclusive, will never be used by</span>
<a name="l01029"></a>01029 <span class="comment">  ** the vdbe program. Instead they are used to allocate space for</span>
<a name="l01030"></a>01030 <span class="comment">  ** VdbeCursor/BtCursor structures. The blob of memory associated with </span>
<a name="l01031"></a>01031 <span class="comment">  ** cursor 0 is stored in memory cell nMem. Memory cell (nMem-1)</span>
<a name="l01032"></a>01032 <span class="comment">  ** stores the blob of memory associated with cursor 1, etc.</span>
<a name="l01033"></a>01033 <span class="comment">  **</span>
<a name="l01034"></a>01034 <span class="comment">  ** See also: allocateCursor().</span>
<a name="l01035"></a>01035 <span class="comment">  */</span>
<a name="l01036"></a>01036   nMem += nCursor;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038   <span class="comment">/*</span>
<a name="l01039"></a>01039 <span class="comment">  ** Allocation space for registers.</span>
<a name="l01040"></a>01040 <span class="comment">  */</span>
<a name="l01041"></a>01041   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>==0 ){
<a name="l01042"></a>01042     <span class="keywordtype">int</span> nArg;       <span class="comment">/* Maximum number of args passed to a user function. */</span>
<a name="l01043"></a>01043     <a class="code" href="vdbeaux_8c.html#a9aa9c7da468f7325e427e599812b92ab">resolveP2Values</a>(p, &amp;nArg);
<a name="l01044"></a>01044     <span class="comment">/*resizeOpArray(p, p-&gt;nOp);*/</span>
<a name="l01045"></a>01045     assert( nVar&gt;=0 );
<a name="l01046"></a>01046     <span class="keywordflow">if</span>( isExplain &amp;&amp; nMem&lt;10 ){
<a name="l01047"></a>01047       nMem = 10;
<a name="l01048"></a>01048     }
<a name="l01049"></a>01049     p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a> = <a class="code" href="malloc_8c.html#a9cdef45d3f06c28e71d728e8b15ebc0f">sqlite3DbMallocZero</a>(db,
<a name="l01050"></a>01050         nMem*<span class="keyword">sizeof</span>(<a class="code" href="structMem.html">Mem</a>)               <span class="comment">/* aMem */</span>
<a name="l01051"></a>01051       + nVar*<span class="keyword">sizeof</span>(<a class="code" href="structMem.html">Mem</a>)               <span class="comment">/* aVar */</span>
<a name="l01052"></a>01052       + nArg*<span class="keyword">sizeof</span>(<a class="code" href="structMem.html">Mem</a>*)              <span class="comment">/* apArg */</span>
<a name="l01053"></a>01053       + nVar*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*)             <span class="comment">/* azVar */</span>
<a name="l01054"></a>01054       + nCursor*<span class="keyword">sizeof</span>(<a class="code" href="structVdbeCursor.html">VdbeCursor</a>*)+1  <span class="comment">/* apCsr */</span>
<a name="l01055"></a>01055     );
<a name="l01056"></a>01056     <span class="keywordflow">if</span>( !db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l01057"></a>01057       p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>--;             <span class="comment">/* aMem[] goes from 1..nMem */</span>
<a name="l01058"></a>01058       p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> = nMem;        <span class="comment">/*       not from 0..nMem-1 */</span>
<a name="l01059"></a>01059       p-&gt;<a class="code" href="structVdbe.html#a8877b72591926e3597fa93e22f84b99c">aVar</a> = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[nMem+1];
<a name="l01060"></a>01060       p-&gt;<a class="code" href="structVdbe.html#a4423b7c92b9284791cf2660cefe07f91">nVar</a> = nVar;
<a name="l01061"></a>01061       p-&gt;<a class="code" href="structVdbe.html#abc9dc62695d85f64ab0badec04a46472">okVar</a> = 0;
<a name="l01062"></a>01062       p-&gt;<a class="code" href="structVdbe.html#a74fd4612c55ac2fde475096a4d2605b5">apArg</a> = (<a class="code" href="structMem.html">Mem</a>**)&amp;p-&gt;<a class="code" href="structVdbe.html#a8877b72591926e3597fa93e22f84b99c">aVar</a>[nVar];
<a name="l01063"></a>01063       p-&gt;<a class="code" href="structVdbe.html#af3c62ca5eee6b2549c97a6bb87fb2f54">azVar</a> = (<span class="keywordtype">char</span>**)&amp;p-&gt;<a class="code" href="structVdbe.html#a74fd4612c55ac2fde475096a4d2605b5">apArg</a>[nArg];
<a name="l01064"></a>01064       p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a> = (<a class="code" href="structVdbeCursor.html">VdbeCursor</a>**)&amp;p-&gt;<a class="code" href="structVdbe.html#af3c62ca5eee6b2549c97a6bb87fb2f54">azVar</a>[nVar];
<a name="l01065"></a>01065       p-&gt;<a class="code" href="structVdbe.html#aa12a6a1075311bd5d89bc69eaefc6351">nCursor</a> = nCursor;
<a name="l01066"></a>01066       <span class="keywordflow">for</span>(n=0; n&lt;nVar; n++){
<a name="l01067"></a>01067         p-&gt;<a class="code" href="structVdbe.html#a8877b72591926e3597fa93e22f84b99c">aVar</a>[n].<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;
<a name="l01068"></a>01068         p-&gt;<a class="code" href="structVdbe.html#a8877b72591926e3597fa93e22f84b99c">aVar</a>[n].<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = db;
<a name="l01069"></a>01069       }
<a name="l01070"></a>01070       <span class="keywordflow">for</span>(n=1; n&lt;=nMem; n++){
<a name="l01071"></a>01071         p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[n].<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;
<a name="l01072"></a>01072         p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[n].<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = db;
<a name="l01073"></a>01073       }
<a name="l01074"></a>01074     }
<a name="l01075"></a>01075   }
<a name="l01076"></a>01076 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l01077"></a>01077 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(n=1; n&lt;p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a>; n++){
<a name="l01078"></a>01078     assert( p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[n].<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a>==db );
<a name="l01079"></a>01079   }
<a name="l01080"></a>01080 <span class="preprocessor">#endif</span>
<a name="l01081"></a>01081 <span class="preprocessor"></span>
<a name="l01082"></a>01082   p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a> = -1;
<a name="l01083"></a>01083   p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01084"></a>01084   p-&gt;<a class="code" href="structVdbe.html#a6be9563c42757424a7c01d83234e0cc2">uniqueCnt</a> = 0;
<a name="l01085"></a>01085   p-&gt;<a class="code" href="structVdbe.html#accafc9e9bac961a2e34daa1190cc228a">errorAction</a> = <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l01086"></a>01086   p-&gt;<a class="code" href="structVdbe.html#aa1bbd3dcd803eb59dc73e681b6a585ed">explain</a> |= isExplain;
<a name="l01087"></a>01087   p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a> = <a class="code" href="vdbeInt_8h.html#af3737d82d7edf97fffb59baf1592a528">VDBE_MAGIC_RUN</a>;
<a name="l01088"></a>01088   p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a> = 0;
<a name="l01089"></a>01089   p-&gt;<a class="code" href="structVdbe.html#ad3eb9132373a6b791c69251f94949744">cacheCtr</a> = 1;
<a name="l01090"></a>01090   p-&gt;<a class="code" href="structVdbe.html#a679ac87f7b835982cd7c1990fbc3605b">minWriteFileFormat</a> = 255;
<a name="l01091"></a>01091   p-&gt;<a class="code" href="structVdbe.html#a9f18480295980eda04c84fe74c5a4061">openedStatement</a> = 0;
<a name="l01092"></a>01092 <span class="preprocessor">#ifdef VDBE_PROFILE</span>
<a name="l01093"></a>01093 <span class="preprocessor"></span>  {
<a name="l01094"></a>01094     <span class="keywordtype">int</span> i;
<a name="l01095"></a>01095     <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>; i++){
<a name="l01096"></a>01096       p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i].cnt = 0;
<a name="l01097"></a>01097       p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i].cycles = 0;
<a name="l01098"></a>01098     }
<a name="l01099"></a>01099   }
<a name="l01100"></a>01100 <span class="preprocessor">#endif</span>
<a name="l01101"></a>01101 <span class="preprocessor"></span>}
<a name="l01102"></a>01102 
<a name="l01103"></a>01103 <span class="comment">/*</span>
<a name="l01104"></a>01104 <span class="comment">** Close a VDBE cursor and release all the resources that cursor </span>
<a name="l01105"></a>01105 <span class="comment">** happens to hold.</span>
<a name="l01106"></a>01106 <span class="comment">*/</span>
<a name="l01107"></a><a class="code" href="vdbeInt_8h.html#ae81469ffff3a49f3d6a8befaa96ee6eb">01107</a> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#a6db711e5d25afe0e6b41bb62b5d45ee6">sqlite3VdbeFreeCursor</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCx){
<a name="l01108"></a>01108   <span class="keywordflow">if</span>( pCx==0 ){
<a name="l01109"></a>01109     <span class="keywordflow">return</span>;
<a name="l01110"></a>01110   }
<a name="l01111"></a>01111   <span class="keywordflow">if</span>( pCx-&gt;<a class="code" href="structVdbeCursor.html#a287db3fe6d84102fad3d69494b565e9b">pBt</a> ){
<a name="l01112"></a>01112     <a class="code" href="btree_8c.html#aa017e368e670ab1b08097a8d4f6307d3">sqlite3BtreeClose</a>(pCx-&gt;<a class="code" href="structVdbeCursor.html#a287db3fe6d84102fad3d69494b565e9b">pBt</a>);
<a name="l01113"></a>01113     <span class="comment">/* The pCx-&gt;pCursor will be close automatically, if it exists, by</span>
<a name="l01114"></a>01114 <span class="comment">    ** the call above. */</span>
<a name="l01115"></a>01115   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pCx-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a> ){
<a name="l01116"></a>01116     <a class="code" href="btree_8c.html#aceb051a90ea80c52fc1513ed5de5087d">sqlite3BtreeCloseCursor</a>(pCx-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>);
<a name="l01117"></a>01117   }
<a name="l01118"></a>01118 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l01119"></a>01119 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pCx-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a> ){
<a name="l01120"></a>01120     <a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pVtabCursor = pCx-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>;
<a name="l01121"></a>01121     <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule = pCx-&gt;<a class="code" href="structVdbeCursor.html#ab385a7fa060ff00bbe9e6861bb599505">pModule</a>;
<a name="l01122"></a>01122     p-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a> = 1;
<a name="l01123"></a>01123     (void)<a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>);
<a name="l01124"></a>01124     pModule-&gt;<a class="code" href="structsqlite3__module.html#a514c66634a5297ca9879947fa6f8f10f">xClose</a>(pVtabCursor);
<a name="l01125"></a>01125     (void)<a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>);
<a name="l01126"></a>01126     p-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a> = 0;
<a name="l01127"></a>01127   }
<a name="l01128"></a>01128 <span class="preprocessor">#endif</span>
<a name="l01129"></a>01129 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( !pCx-&gt;<a class="code" href="structVdbeCursor.html#a70576a23035c6f2aced72f2309e6f024">ephemPseudoTable</a> ){
<a name="l01130"></a>01130     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>, pCx-&gt;<a class="code" href="structVdbeCursor.html#a24a939339569b64ed386652955df6be7">pData</a>);
<a name="l01131"></a>01131   }
<a name="l01132"></a>01132 }
<a name="l01133"></a>01133 
<a name="l01134"></a>01134 <span class="comment">/*</span>
<a name="l01135"></a>01135 <span class="comment">** Close all cursors except for VTab cursors that are currently</span>
<a name="l01136"></a>01136 <span class="comment">** in use.</span>
<a name="l01137"></a>01137 <span class="comment">*/</span>
<a name="l01138"></a><a class="code" href="vdbeaux_8c.html#ae3b3368c9fbc2719b28a01cc94fa5219">01138</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#ae3b3368c9fbc2719b28a01cc94fa5219">closeAllCursorsExceptActiveVtabs</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l01139"></a>01139   <span class="keywordtype">int</span> i;
<a name="l01140"></a>01140   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>==0 ) <span class="keywordflow">return</span>;
<a name="l01141"></a>01141   <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structVdbe.html#aa12a6a1075311bd5d89bc69eaefc6351">nCursor</a>; i++){
<a name="l01142"></a>01142     <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l01143"></a>01143     <span class="keywordflow">if</span>( pC &amp;&amp; (!p-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a> || !pC-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>) ){
<a name="l01144"></a>01144       <a class="code" href="vdbeaux_8c.html#a6db711e5d25afe0e6b41bb62b5d45ee6">sqlite3VdbeFreeCursor</a>(p, pC);
<a name="l01145"></a>01145       p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i] = 0;
<a name="l01146"></a>01146     }
<a name="l01147"></a>01147   }
<a name="l01148"></a>01148 }
<a name="l01149"></a>01149 
<a name="l01150"></a>01150 <span class="comment">/*</span>
<a name="l01151"></a>01151 <span class="comment">** Clean up the VM after execution.</span>
<a name="l01152"></a>01152 <span class="comment">**</span>
<a name="l01153"></a>01153 <span class="comment">** This routine will automatically close any cursors, lists, and/or</span>
<a name="l01154"></a>01154 <span class="comment">** sorters that were left open.  It also deletes the values of</span>
<a name="l01155"></a>01155 <span class="comment">** variables in the aVar[] array.</span>
<a name="l01156"></a>01156 <span class="comment">*/</span>
<a name="l01157"></a><a class="code" href="vdbeaux_8c.html#ae3e0dbf7ac3255e91d16cd24fd2c2b1d">01157</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#ae3e0dbf7ac3255e91d16cd24fd2c2b1d">Cleanup</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l01158"></a>01158   <span class="keywordtype">int</span> i;
<a name="l01159"></a>01159   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l01160"></a>01160   <a class="code" href="vdbeaux_8c.html#ae3b3368c9fbc2719b28a01cc94fa5219">closeAllCursorsExceptActiveVtabs</a>(p);
<a name="l01161"></a>01161   <span class="keywordflow">for</span>(i=1; i&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a>; i++){
<a name="l01162"></a>01162     <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[i], <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>);
<a name="l01163"></a>01163   }
<a name="l01164"></a>01164   <a class="code" href="vdbeaux_8c.html#a321ef1ead88ab0c4c636971ae5cc9778">releaseMemArray</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[1], p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a>);
<a name="l01165"></a>01165   <a class="code" href="vdbefifo_8c.html#af910addcbc65dfbaf85415e99524f158">sqlite3VdbeFifoClear</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#ab9222d0ba3c069da606602bc772cb05d">sFifo</a>);
<a name="l01166"></a>01166   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a994114f03c89cdc3f011c48be8eb4bd4">contextStack</a> ){
<a name="l01167"></a>01167     <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structVdbe.html#a93d6a431e8a27b85754243e341ab6c31">contextStackTop</a>; i++){
<a name="l01168"></a>01168       <a class="code" href="vdbefifo_8c.html#af910addcbc65dfbaf85415e99524f158">sqlite3VdbeFifoClear</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#a994114f03c89cdc3f011c48be8eb4bd4">contextStack</a>[i].<a class="code" href="structContext.html#ab80b78ed84a5d01f2f7fafc88bf339e5">sFifo</a>);
<a name="l01169"></a>01169     }
<a name="l01170"></a>01170     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#a994114f03c89cdc3f011c48be8eb4bd4">contextStack</a>);
<a name="l01171"></a>01171   }
<a name="l01172"></a>01172   p-&gt;<a class="code" href="structVdbe.html#a994114f03c89cdc3f011c48be8eb4bd4">contextStack</a> = 0;
<a name="l01173"></a>01173   p-&gt;<a class="code" href="structVdbe.html#a7a1b3e41da59c4aff65c250809c14ce5">contextStackDepth</a> = 0;
<a name="l01174"></a>01174   p-&gt;<a class="code" href="structVdbe.html#a93d6a431e8a27b85754243e341ab6c31">contextStackTop</a> = 0;
<a name="l01175"></a>01175   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l01176"></a>01176   p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = 0;
<a name="l01177"></a>01177   p-&gt;<a class="code" href="structVdbe.html#a0dec47b8d8c481df2b73d5bbf9cdde11">pResultSet</a> = 0;
<a name="l01178"></a>01178 }
<a name="l01179"></a>01179 
<a name="l01180"></a>01180 <span class="comment">/*</span>
<a name="l01181"></a>01181 <span class="comment">** Set the number of result columns that will be returned by this SQL</span>
<a name="l01182"></a>01182 <span class="comment">** statement. This is now set at compile time, rather than during</span>
<a name="l01183"></a>01183 <span class="comment">** execution of the vdbe program so that sqlite3_column_count() can</span>
<a name="l01184"></a>01184 <span class="comment">** be called on an SQL statement before sqlite3_step().</span>
<a name="l01185"></a>01185 <span class="comment">*/</span>
<a name="l01186"></a><a class="code" href="vdbeaux_8c.html#a6a82670eb8329a6d3428787ef38874e8">01186</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#adbf4be46f9152eb8e9be03ad52453b3e">sqlite3VdbeSetNumCols</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p, <span class="keywordtype">int</span> nResColumn){
<a name="l01187"></a>01187   <a class="code" href="structMem.html">Mem</a> *pColName;
<a name="l01188"></a>01188   <span class="keywordtype">int</span> n;
<a name="l01189"></a>01189   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191   <a class="code" href="vdbeaux_8c.html#a321ef1ead88ab0c4c636971ae5cc9778">releaseMemArray</a>(p-&gt;<a class="code" href="structVdbe.html#a900f557143e7d2ab8c560f7ada66d0f7">aColName</a>, p-&gt;<a class="code" href="structVdbe.html#ae4aebc61bfb17f7dc2099c4143900e83">nResColumn</a>*<a class="code" href="vdbe_8h.html#aca828d8d49b011a44db5870cf5bab5b7">COLNAME_N</a>);
<a name="l01192"></a>01192   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#a900f557143e7d2ab8c560f7ada66d0f7">aColName</a>);
<a name="l01193"></a>01193   n = nResColumn*<a class="code" href="vdbe_8h.html#aca828d8d49b011a44db5870cf5bab5b7">COLNAME_N</a>;
<a name="l01194"></a>01194   p-&gt;<a class="code" href="structVdbe.html#ae4aebc61bfb17f7dc2099c4143900e83">nResColumn</a> = nResColumn;
<a name="l01195"></a>01195   p-&gt;<a class="code" href="structVdbe.html#a900f557143e7d2ab8c560f7ada66d0f7">aColName</a> = pColName = (<a class="code" href="structMem.html">Mem</a>*)<a class="code" href="malloc_8c.html#a9cdef45d3f06c28e71d728e8b15ebc0f">sqlite3DbMallocZero</a>(db, <span class="keyword">sizeof</span>(<a class="code" href="structMem.html">Mem</a>)*n );
<a name="l01196"></a>01196   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a900f557143e7d2ab8c560f7ada66d0f7">aColName</a>==0 ) <span class="keywordflow">return</span>;
<a name="l01197"></a>01197   <span class="keywordflow">while</span>( n-- &gt; 0 ){
<a name="l01198"></a>01198     pColName-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;
<a name="l01199"></a>01199     pColName-&gt;<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l01200"></a>01200     pColName++;
<a name="l01201"></a>01201   }
<a name="l01202"></a>01202 }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 <span class="comment">/*</span>
<a name="l01205"></a>01205 <span class="comment">** Set the name of the idx&apos;th column to be returned by the SQL statement.</span>
<a name="l01206"></a>01206 <span class="comment">** zName must be a pointer to a nul terminated string.</span>
<a name="l01207"></a>01207 <span class="comment">**</span>
<a name="l01208"></a>01208 <span class="comment">** This call must be made after a call to sqlite3VdbeSetNumCols().</span>
<a name="l01209"></a>01209 <span class="comment">**</span>
<a name="l01210"></a>01210 <span class="comment">** The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC</span>
<a name="l01211"></a>01211 <span class="comment">** or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed</span>
<a name="l01212"></a>01212 <span class="comment">** to by zName will be freed by sqlite3DbFree() when the vdbe is destroyed.</span>
<a name="l01213"></a>01213 <span class="comment">*/</span>
<a name="l01214"></a><a class="code" href="vdbeaux_8c.html#a63108dc23c74c52c264302cbb01240f4">01214</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#a3501a072f6a015567c0ce5ed683bf31f">sqlite3VdbeSetColName</a>(
<a name="l01215"></a>01215   <a class="code" href="structVdbe.html">Vdbe</a> *p,                         <span class="comment">/* Vdbe being configured */</span>
<a name="l01216"></a>01216   <span class="keywordtype">int</span> idx,                         <span class="comment">/* Index of column zName applies to */</span>
<a name="l01217"></a>01217   <span class="keywordtype">int</span> var,                         <span class="comment">/* One of the COLNAME_* constants */</span>
<a name="l01218"></a>01218   <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,               <span class="comment">/* Pointer to buffer containing name */</span>
<a name="l01219"></a>01219   <span class="keywordtype">void</span> (*xDel)(<span class="keywordtype">void</span>*)              <span class="comment">/* Memory management strategy for zName */</span>
<a name="l01220"></a>01220 ){
<a name="l01221"></a>01221   <span class="keywordtype">int</span> rc;
<a name="l01222"></a>01222   <a class="code" href="structMem.html">Mem</a> *pColName;
<a name="l01223"></a>01223   assert( idx&lt;p-&gt;nResColumn );
<a name="l01224"></a>01224   assert( var&lt;<a class="code" href="vdbe_8h.html#aca828d8d49b011a44db5870cf5bab5b7">COLNAME_N</a> );
<a name="l01225"></a>01225   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l01226"></a>01226     assert( !zName || xDel!=<a class="code" href="sqliteInt_8h.html#a1c44dfe35a125f6778580d200c11c416">SQLITE_DYNAMIC</a> );
<a name="l01227"></a>01227     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01228"></a>01228   }
<a name="l01229"></a>01229   assert( p-&gt;<a class="code" href="structVdbe.html#a900f557143e7d2ab8c560f7ada66d0f7">aColName</a>!=0 );
<a name="l01230"></a>01230   pColName = &amp;(p-&gt;<a class="code" href="structVdbe.html#a900f557143e7d2ab8c560f7ada66d0f7">aColName</a>[idx+var*p-&gt;<a class="code" href="structVdbe.html#ae4aebc61bfb17f7dc2099c4143900e83">nResColumn</a>]);
<a name="l01231"></a>01231   rc = <a class="code" href="vdbeInt_8h.html#aba781c78989d5481ac168c09108c0ba8">sqlite3VdbeMemSetStr</a>(pColName, zName, -1, <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>, xDel);
<a name="l01232"></a>01232   assert( rc!=0 || !zName || (pColName-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#a07b1add4713bc55a88ecb0085c846ab7">MEM_Term</a>)!=0 );
<a name="l01233"></a>01233   <span class="keywordflow">return</span> rc;
<a name="l01234"></a>01234 }
<a name="l01235"></a>01235 
<a name="l01236"></a>01236 <span class="comment">/*</span>
<a name="l01237"></a>01237 <span class="comment">** A read or write transaction may or may not be active on database handle</span>
<a name="l01238"></a>01238 <span class="comment">** db. If a transaction is active, commit it. If there is a</span>
<a name="l01239"></a>01239 <span class="comment">** write-transaction spanning more than one database file, this routine</span>
<a name="l01240"></a>01240 <span class="comment">** takes care of the master journal trickery.</span>
<a name="l01241"></a>01241 <span class="comment">*/</span>
<a name="l01242"></a><a class="code" href="vdbeaux_8c.html#a5d7f1e0625451b987728f600cfe1b92d">01242</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="vdbeaux_8c.html#a5d7f1e0625451b987728f600cfe1b92d">vdbeCommit</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l01243"></a>01243   <span class="keywordtype">int</span> i;
<a name="l01244"></a>01244   <span class="keywordtype">int</span> nTrans = 0;  <span class="comment">/* Number of databases with an active write-transaction */</span>
<a name="l01245"></a>01245   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01246"></a>01246   <span class="keywordtype">int</span> needXcommit = 0;
<a name="l01247"></a>01247 
<a name="l01248"></a>01248   <span class="comment">/* Before doing anything else, call the xSync() callback for any</span>
<a name="l01249"></a>01249 <span class="comment">  ** virtual module tables written in this transaction. This has to</span>
<a name="l01250"></a>01250 <span class="comment">  ** be done before determining whether a master journal file is </span>
<a name="l01251"></a>01251 <span class="comment">  ** required, as an xSync() callback may add an attached database</span>
<a name="l01252"></a>01252 <span class="comment">  ** to the transaction.</span>
<a name="l01253"></a>01253 <span class="comment">  */</span>
<a name="l01254"></a>01254   rc = <a class="code" href="sqliteInt_8h.html#a3133bbaa56e583e887c38a1d143ffb08">sqlite3VtabSync</a>(db, &amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l01255"></a>01255   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01256"></a>01256     <span class="keywordflow">return</span> rc;
<a name="l01257"></a>01257   }
<a name="l01258"></a>01258 
<a name="l01259"></a>01259   <span class="comment">/* This loop determines (a) if the commit hook should be invoked and</span>
<a name="l01260"></a>01260 <span class="comment">  ** (b) how many database files have open write transactions, not </span>
<a name="l01261"></a>01261 <span class="comment">  ** including the temp database. (b) is important because if more than </span>
<a name="l01262"></a>01262 <span class="comment">  ** one database file has an open write transaction, a master journal</span>
<a name="l01263"></a>01263 <span class="comment">  ** file is required for an atomic commit.</span>
<a name="l01264"></a>01264 <span class="comment">  */</span> 
<a name="l01265"></a>01265   <span class="keywordflow">for</span>(i=0; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a>; i++){ 
<a name="l01266"></a>01266     <a class="code" href="structBtree.html">Btree</a> *pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l01267"></a>01267     <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#aeff539aa1765b2b7a18313c3cc26d0ba">sqlite3BtreeIsInTrans</a>(pBt) ){
<a name="l01268"></a>01268       needXcommit = 1;
<a name="l01269"></a>01269       <span class="keywordflow">if</span>( i!=1 ) nTrans++;
<a name="l01270"></a>01270     }
<a name="l01271"></a>01271   }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273   <span class="comment">/* If there are any write-transactions at all, invoke the commit hook */</span>
<a name="l01274"></a>01274   <span class="keywordflow">if</span>( needXcommit &amp;&amp; db-&gt;<a class="code" href="structsqlite3.html#a1b12d797fb7f9c526ffb6665a7f42203">xCommitCallback</a> ){
<a name="l01275"></a>01275     (void)<a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db);
<a name="l01276"></a>01276     rc = db-&gt;<a class="code" href="structsqlite3.html#a1b12d797fb7f9c526ffb6665a7f42203">xCommitCallback</a>(db-&gt;<a class="code" href="structsqlite3.html#a355237725d3a535d702815b6ef8be75e">pCommitArg</a>);
<a name="l01277"></a>01277     (void)<a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db);
<a name="l01278"></a>01278     <span class="keywordflow">if</span>( rc ){
<a name="l01279"></a>01279       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a60b2b65ad97f771203e26733f870af57">SQLITE_CONSTRAINT</a>;
<a name="l01280"></a>01280     }
<a name="l01281"></a>01281   }
<a name="l01282"></a>01282 
<a name="l01283"></a>01283   <span class="comment">/* The simple case - no more than one database file (not counting the</span>
<a name="l01284"></a>01284 <span class="comment">  ** TEMP database) has a transaction active.   There is no need for the</span>
<a name="l01285"></a>01285 <span class="comment">  ** master-journal.</span>
<a name="l01286"></a>01286 <span class="comment">  **</span>
<a name="l01287"></a>01287 <span class="comment">  ** If the return value of sqlite3BtreeGetFilename() is a zero length</span>
<a name="l01288"></a>01288 <span class="comment">  ** string, it means the main database is :memory: or a temp file.  In </span>
<a name="l01289"></a>01289 <span class="comment">  ** that case we do not support atomic multi-file commits, so use the </span>
<a name="l01290"></a>01290 <span class="comment">  ** simple case then too.</span>
<a name="l01291"></a>01291 <span class="comment">  */</span>
<a name="l01292"></a>01292   <span class="keywordflow">if</span>( 0==strlen(<a class="code" href="btree_8c.html#ae559bdc5deaabdec6e91bf5477cbaa47">sqlite3BtreeGetFilename</a>(db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[0].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>)) || nTrans&lt;=1 ){
<a name="l01293"></a>01293     <span class="keywordflow">for</span>(i=0; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a>; i++){ 
<a name="l01294"></a>01294       <a class="code" href="structBtree.html">Btree</a> *pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l01295"></a>01295       <span class="keywordflow">if</span>( pBt ){
<a name="l01296"></a>01296         rc = <a class="code" href="btree_8c.html#aaa86a820748624295c214bf418a2cbd9">sqlite3BtreeCommitPhaseOne</a>(pBt, 0);
<a name="l01297"></a>01297       }
<a name="l01298"></a>01298     }
<a name="l01299"></a>01299 
<a name="l01300"></a>01300     <span class="comment">/* Do the commit only if all databases successfully complete phase 1. </span>
<a name="l01301"></a>01301 <span class="comment">    ** If one of the BtreeCommitPhaseOne() calls fails, this indicates an</span>
<a name="l01302"></a>01302 <span class="comment">    ** IO error while deleting or truncating a journal file. It is unlikely,</span>
<a name="l01303"></a>01303 <span class="comment">    ** but could happen. In this case abandon processing and return the error.</span>
<a name="l01304"></a>01304 <span class="comment">    */</span>
<a name="l01305"></a>01305     <span class="keywordflow">for</span>(i=0; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a>; i++){
<a name="l01306"></a>01306       <a class="code" href="structBtree.html">Btree</a> *pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l01307"></a>01307       <span class="keywordflow">if</span>( pBt ){
<a name="l01308"></a>01308         rc = <a class="code" href="btree_8c.html#abd2fba5cda8e4602f74dbcb7b949d417">sqlite3BtreeCommitPhaseTwo</a>(pBt);
<a name="l01309"></a>01309       }
<a name="l01310"></a>01310     }
<a name="l01311"></a>01311     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01312"></a>01312       <a class="code" href="sqliteInt_8h.html#a31f47781e4e0664baa4688da7aea6b2b">sqlite3VtabCommit</a>(db);
<a name="l01313"></a>01313     }
<a name="l01314"></a>01314   }
<a name="l01315"></a>01315 
<a name="l01316"></a>01316   <span class="comment">/* The complex case - There is a multi-file write-transaction active.</span>
<a name="l01317"></a>01317 <span class="comment">  ** This requires a master journal file to ensure the transaction is</span>
<a name="l01318"></a>01318 <span class="comment">  ** committed atomicly.</span>
<a name="l01319"></a>01319 <span class="comment">  */</span>
<a name="l01320"></a>01320 <span class="preprocessor">#ifndef SQLITE_OMIT_DISKIO</span>
<a name="l01321"></a>01321 <span class="preprocessor"></span>  <span class="keywordflow">else</span>{
<a name="l01322"></a>01322     <a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs = db-&gt;<a class="code" href="structsqlite3.html#a8ad0bcb473e4cb492165739acff918cd">pVfs</a>;
<a name="l01323"></a>01323     <span class="keywordtype">int</span> needSync = 0;
<a name="l01324"></a>01324     <span class="keywordtype">char</span> *zMaster = 0;   <span class="comment">/* File-name for the master journal */</span>
<a name="l01325"></a>01325     <span class="keywordtype">char</span> <span class="keyword">const</span> *zMainFile = <a class="code" href="btree_8c.html#ae559bdc5deaabdec6e91bf5477cbaa47">sqlite3BtreeGetFilename</a>(db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[0].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>);
<a name="l01326"></a>01326     <a class="code" href="structsqlite3__file.html">sqlite3_file</a> *pMaster = 0;
<a name="l01327"></a>01327     <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> offset = 0;
<a name="l01328"></a>01328     <span class="keywordtype">int</span> res;
<a name="l01329"></a>01329 
<a name="l01330"></a>01330     <span class="comment">/* Select a master journal file name */</span>
<a name="l01331"></a>01331     <span class="keywordflow">do</span> {
<a name="l01332"></a>01332       <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> random;
<a name="l01333"></a>01333       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zMaster);
<a name="l01334"></a>01334       <a class="code" href="random_8c.html#a1431cd360c32f40da9dec267d29eb998">sqlite3_randomness</a>(<span class="keyword">sizeof</span>(random), &amp;random);
<a name="l01335"></a>01335       zMaster = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db, <span class="stringliteral">&quot;%s-mj%08X&quot;</span>, zMainFile, random&amp;0x7fffffff);
<a name="l01336"></a>01336       <span class="keywordflow">if</span>( !zMaster ){
<a name="l01337"></a>01337         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01338"></a>01338       }
<a name="l01339"></a>01339       rc = <a class="code" href="os_8c.html#a0cae4a47231c187a56c7b1aa98708b6a">sqlite3OsAccess</a>(pVfs, zMaster, <a class="code" href="sqlite3_8h.html#a8451f266ab642f03f344209484dc3b61">SQLITE_ACCESS_EXISTS</a>, &amp;res);
<a name="l01340"></a>01340     }<span class="keywordflow">while</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; res );
<a name="l01341"></a>01341     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01342"></a>01342       <span class="comment">/* Open the master journal. */</span>
<a name="l01343"></a>01343       rc = <a class="code" href="os_8c.html#abc39a77b7f8cb5b745e409fcdae89e84">sqlite3OsOpenMalloc</a>(pVfs, zMaster, &amp;pMaster, 
<a name="l01344"></a>01344           <a class="code" href="sqlite3_8h.html#a3eb39cf04a78fae3b553b96d65f93419">SQLITE_OPEN_READWRITE</a>|<a class="code" href="sqlite3_8h.html#a06cff06321a46ca610a29c8f125f9c08">SQLITE_OPEN_CREATE</a>|
<a name="l01345"></a>01345           <a class="code" href="sqlite3_8h.html#a3eace21577bcc4790a72a096c21ba645">SQLITE_OPEN_EXCLUSIVE</a>|<a class="code" href="sqlite3_8h.html#abd5b137f274db77586b40939b1390e07">SQLITE_OPEN_MASTER_JOURNAL</a>, 0
<a name="l01346"></a>01346       );
<a name="l01347"></a>01347     }
<a name="l01348"></a>01348     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01349"></a>01349       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zMaster);
<a name="l01350"></a>01350       <span class="keywordflow">return</span> rc;
<a name="l01351"></a>01351     }
<a name="l01352"></a>01352  
<a name="l01353"></a>01353     <span class="comment">/* Write the name of each database file in the transaction into the new</span>
<a name="l01354"></a>01354 <span class="comment">    ** master journal file. If an error occurs at this point close</span>
<a name="l01355"></a>01355 <span class="comment">    ** and delete the master journal file. All the individual journal files</span>
<a name="l01356"></a>01356 <span class="comment">    ** still have &apos;null&apos; as the master journal pointer, so they will roll</span>
<a name="l01357"></a>01357 <span class="comment">    ** back independently if a failure occurs.</span>
<a name="l01358"></a>01358 <span class="comment">    */</span>
<a name="l01359"></a>01359     <span class="keywordflow">for</span>(i=0; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a>; i++){
<a name="l01360"></a>01360       <a class="code" href="structBtree.html">Btree</a> *pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l01361"></a>01361       <span class="keywordflow">if</span>( i==1 ) <span class="keywordflow">continue</span>;   <span class="comment">/* Ignore the TEMP database */</span>
<a name="l01362"></a>01362       <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#aeff539aa1765b2b7a18313c3cc26d0ba">sqlite3BtreeIsInTrans</a>(pBt) ){
<a name="l01363"></a>01363         <span class="keywordtype">char</span> <span class="keyword">const</span> *zFile = <a class="code" href="btree_8c.html#aeb149d6e7384787932d54485512cd97d">sqlite3BtreeGetJournalname</a>(pBt);
<a name="l01364"></a>01364         <span class="keywordflow">if</span>( zFile[0]==0 ) <span class="keywordflow">continue</span>;  <span class="comment">/* Ignore :memory: databases */</span>
<a name="l01365"></a>01365         <span class="keywordflow">if</span>( !needSync &amp;&amp; !<a class="code" href="btree_8c.html#a4b57ba6fa84109fa8bb257bd5f56b37c">sqlite3BtreeSyncDisabled</a>(pBt) ){
<a name="l01366"></a>01366           needSync = 1;
<a name="l01367"></a>01367         }
<a name="l01368"></a>01368         rc = <a class="code" href="os_8c.html#ab2aa7b80aa192c498f721ad60860315e">sqlite3OsWrite</a>(pMaster, zFile, strlen(zFile)+1, offset);
<a name="l01369"></a>01369         offset += strlen(zFile)+1;
<a name="l01370"></a>01370         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01371"></a>01371           <a class="code" href="os_8c.html#a454eb770db26fff1e88f4f82ed3e3195">sqlite3OsCloseFree</a>(pMaster);
<a name="l01372"></a>01372           <a class="code" href="os_8c.html#aefc174f728d138188ac764088382e342">sqlite3OsDelete</a>(pVfs, zMaster, 0);
<a name="l01373"></a>01373           <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zMaster);
<a name="l01374"></a>01374           <span class="keywordflow">return</span> rc;
<a name="l01375"></a>01375         }
<a name="l01376"></a>01376       }
<a name="l01377"></a>01377     }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379     <span class="comment">/* Sync the master journal file. If the IOCAP_SEQUENTIAL device</span>
<a name="l01380"></a>01380 <span class="comment">    ** flag is set this is not required.</span>
<a name="l01381"></a>01381 <span class="comment">    */</span>
<a name="l01382"></a>01382     zMainFile = <a class="code" href="btree_8c.html#ac25feffedc6fcd95915b0cf30f7965b3">sqlite3BtreeGetDirname</a>(db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[0].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>);
<a name="l01383"></a>01383     <span class="keywordflow">if</span>( (needSync 
<a name="l01384"></a>01384      &amp;&amp; (0==(<a class="code" href="os_8c.html#a58cdb6aae4a35782cfcd2298ee239a99">sqlite3OsDeviceCharacteristics</a>(pMaster)&amp;<a class="code" href="sqlite3_8h.html#ad199518ff2b4f7700705310356a1db69">SQLITE_IOCAP_SEQUENTIAL</a>))
<a name="l01385"></a>01385      &amp;&amp; (rc=<a class="code" href="os_8c.html#a08a9a7080eb78647a7906e05ccd8c7d9">sqlite3OsSync</a>(pMaster, <a class="code" href="sqlite3_8h.html#a2cea9e1af38eddd7730c51c98692f2cd">SQLITE_SYNC_NORMAL</a>))!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>) ){
<a name="l01386"></a>01386       <a class="code" href="os_8c.html#a454eb770db26fff1e88f4f82ed3e3195">sqlite3OsCloseFree</a>(pMaster);
<a name="l01387"></a>01387       <a class="code" href="os_8c.html#aefc174f728d138188ac764088382e342">sqlite3OsDelete</a>(pVfs, zMaster, 0);
<a name="l01388"></a>01388       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zMaster);
<a name="l01389"></a>01389       <span class="keywordflow">return</span> rc;
<a name="l01390"></a>01390     }
<a name="l01391"></a>01391 
<a name="l01392"></a>01392     <span class="comment">/* Sync all the db files involved in the transaction. The same call</span>
<a name="l01393"></a>01393 <span class="comment">    ** sets the master journal pointer in each individual journal. If</span>
<a name="l01394"></a>01394 <span class="comment">    ** an error occurs here, do not delete the master journal file.</span>
<a name="l01395"></a>01395 <span class="comment">    **</span>
<a name="l01396"></a>01396 <span class="comment">    ** If the error occurs during the first call to</span>
<a name="l01397"></a>01397 <span class="comment">    ** sqlite3BtreeCommitPhaseOne(), then there is a chance that the</span>
<a name="l01398"></a>01398 <span class="comment">    ** master journal file will be orphaned. But we cannot delete it,</span>
<a name="l01399"></a>01399 <span class="comment">    ** in case the master journal file name was written into the journal</span>
<a name="l01400"></a>01400 <span class="comment">    ** file before the failure occured.</span>
<a name="l01401"></a>01401 <span class="comment">    */</span>
<a name="l01402"></a>01402     <span class="keywordflow">for</span>(i=0; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a>; i++){ 
<a name="l01403"></a>01403       <a class="code" href="structBtree.html">Btree</a> *pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l01404"></a>01404       <span class="keywordflow">if</span>( pBt ){
<a name="l01405"></a>01405         rc = <a class="code" href="btree_8c.html#aaa86a820748624295c214bf418a2cbd9">sqlite3BtreeCommitPhaseOne</a>(pBt, zMaster);
<a name="l01406"></a>01406       }
<a name="l01407"></a>01407     }
<a name="l01408"></a>01408     <a class="code" href="os_8c.html#a454eb770db26fff1e88f4f82ed3e3195">sqlite3OsCloseFree</a>(pMaster);
<a name="l01409"></a>01409     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01410"></a>01410       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zMaster);
<a name="l01411"></a>01411       <span class="keywordflow">return</span> rc;
<a name="l01412"></a>01412     }
<a name="l01413"></a>01413 
<a name="l01414"></a>01414     <span class="comment">/* Delete the master journal file. This commits the transaction. After</span>
<a name="l01415"></a>01415 <span class="comment">    ** doing this the directory is synced again before any individual</span>
<a name="l01416"></a>01416 <span class="comment">    ** transaction files are deleted.</span>
<a name="l01417"></a>01417 <span class="comment">    */</span>
<a name="l01418"></a>01418     rc = <a class="code" href="os_8c.html#aefc174f728d138188ac764088382e342">sqlite3OsDelete</a>(pVfs, zMaster, 1);
<a name="l01419"></a>01419     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zMaster);
<a name="l01420"></a>01420     zMaster = 0;
<a name="l01421"></a>01421     <span class="keywordflow">if</span>( rc ){
<a name="l01422"></a>01422       <span class="keywordflow">return</span> rc;
<a name="l01423"></a>01423     }
<a name="l01424"></a>01424 
<a name="l01425"></a>01425     <span class="comment">/* All files and directories have already been synced, so the following</span>
<a name="l01426"></a>01426 <span class="comment">    ** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and</span>
<a name="l01427"></a>01427 <span class="comment">    ** deleting or truncating journals. If something goes wrong while</span>
<a name="l01428"></a>01428 <span class="comment">    ** this is happening we don&apos;t really care. The integrity of the</span>
<a name="l01429"></a>01429 <span class="comment">    ** transaction is already guaranteed, but some stray &apos;cold&apos; journals</span>
<a name="l01430"></a>01430 <span class="comment">    ** may be lying around. Returning an error code won&apos;t help matters.</span>
<a name="l01431"></a>01431 <span class="comment">    */</span>
<a name="l01432"></a>01432     <a class="code" href="pager_8c.html#afec41e74bcf69822a217b8a12a67943d">disable_simulated_io_errors</a>();
<a name="l01433"></a>01433     <a class="code" href="fault_8c.html#abd9e16e72d950da81603ebdf72ed4d5c">sqlite3BeginBenignMalloc</a>();
<a name="l01434"></a>01434     <span class="keywordflow">for</span>(i=0; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a>; i++){ 
<a name="l01435"></a>01435       <a class="code" href="structBtree.html">Btree</a> *pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l01436"></a>01436       <span class="keywordflow">if</span>( pBt ){
<a name="l01437"></a>01437         <a class="code" href="btree_8c.html#abd2fba5cda8e4602f74dbcb7b949d417">sqlite3BtreeCommitPhaseTwo</a>(pBt);
<a name="l01438"></a>01438       }
<a name="l01439"></a>01439     }
<a name="l01440"></a>01440     <a class="code" href="fault_8c.html#ab9784f82977599f15fc02ea3ce1a770a">sqlite3EndBenignMalloc</a>();
<a name="l01441"></a>01441     <a class="code" href="pager_8c.html#a5e72f503ac96109e9231f75e69e6f714">enable_simulated_io_errors</a>();
<a name="l01442"></a>01442 
<a name="l01443"></a>01443     <a class="code" href="sqliteInt_8h.html#a31f47781e4e0664baa4688da7aea6b2b">sqlite3VtabCommit</a>(db);
<a name="l01444"></a>01444   }
<a name="l01445"></a>01445 <span class="preprocessor">#endif</span>
<a name="l01446"></a>01446 <span class="preprocessor"></span>
<a name="l01447"></a>01447   <span class="keywordflow">return</span> rc;
<a name="l01448"></a>01448 }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 <span class="comment">/* </span>
<a name="l01451"></a>01451 <span class="comment">** This routine checks that the sqlite3.activeVdbeCnt count variable</span>
<a name="l01452"></a>01452 <span class="comment">** matches the number of vdbe&apos;s in the list sqlite3.pVdbe that are</span>
<a name="l01453"></a>01453 <span class="comment">** currently active. An assertion fails if the two counts do not match.</span>
<a name="l01454"></a>01454 <span class="comment">** This is an internal self-check only - it is not an essential processing</span>
<a name="l01455"></a>01455 <span class="comment">** step.</span>
<a name="l01456"></a>01456 <span class="comment">**</span>
<a name="l01457"></a>01457 <span class="comment">** This is a no-op if NDEBUG is defined.</span>
<a name="l01458"></a>01458 <span class="comment">*/</span>
<a name="l01459"></a>01459 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01460"></a>01460 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#a62198942915c8bba41484677d9a3148a">checkActiveVdbeCnt</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>){
<a name="l01461"></a>01461   <a class="code" href="structVdbe.html">Vdbe</a> *p;
<a name="l01462"></a>01462   <span class="keywordtype">int</span> cnt = 0;
<a name="l01463"></a>01463   <span class="keywordtype">int</span> nWrite = 0;
<a name="l01464"></a>01464   p = db-&gt;<a class="code" href="structsqlite3.html#a596f0301f43c5e25575c2a1403f8b571">pVdbe</a>;
<a name="l01465"></a>01465   <span class="keywordflow">while</span>( p ){
<a name="l01466"></a>01466     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#af3737d82d7edf97fffb59baf1592a528">VDBE_MAGIC_RUN</a> &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a>&gt;=0 ){
<a name="l01467"></a>01467       cnt++;
<a name="l01468"></a>01468       <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a723ca4a68712aed8d37b3d682c336e84">readOnly</a>==0 ) nWrite++;
<a name="l01469"></a>01469     }
<a name="l01470"></a>01470     p = p-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a>;
<a name="l01471"></a>01471   }
<a name="l01472"></a>01472   assert( cnt==db-&gt;<a class="code" href="structsqlite3.html#ada07202e7fd80f275e2e5063d96b5cb0">activeVdbeCnt</a> );
<a name="l01473"></a>01473   assert( nWrite==db-&gt;<a class="code" href="structsqlite3.html#a632e51f8d35c1e8802639661e2fcd567">writeVdbeCnt</a> );
<a name="l01474"></a>01474 }
<a name="l01475"></a>01475 <span class="preprocessor">#else</span>
<a name="l01476"></a><a class="code" href="vdbeaux_8c.html#a62198942915c8bba41484677d9a3148a">01476</a> <span class="preprocessor"></span><span class="preprocessor">#define checkActiveVdbeCnt(x)</span>
<a name="l01477"></a>01477 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01478"></a>01478 <span class="preprocessor"></span>
<a name="l01479"></a>01479 <span class="comment">/*</span>
<a name="l01480"></a>01480 <span class="comment">** For every Btree that in database connection db which </span>
<a name="l01481"></a>01481 <span class="comment">** has been modified, &quot;trip&quot; or invalidate each cursor in</span>
<a name="l01482"></a>01482 <span class="comment">** that Btree might have been modified so that the cursor</span>
<a name="l01483"></a>01483 <span class="comment">** can never be used again.  This happens when a rollback</span>
<a name="l01484"></a>01484 <span class="comment">*** occurs.  We have to trip all the other cursors, even</span>
<a name="l01485"></a>01485 <span class="comment">** cursor from other VMs in different database connections,</span>
<a name="l01486"></a>01486 <span class="comment">** so that none of them try to use the data at which they</span>
<a name="l01487"></a>01487 <span class="comment">** were pointing and which now may have been changed due</span>
<a name="l01488"></a>01488 <span class="comment">** to the rollback.</span>
<a name="l01489"></a>01489 <span class="comment">**</span>
<a name="l01490"></a>01490 <span class="comment">** Remember that a rollback can delete tables complete and</span>
<a name="l01491"></a>01491 <span class="comment">** reorder rootpages.  So it is not sufficient just to save</span>
<a name="l01492"></a>01492 <span class="comment">** the state of the cursor.  We have to invalidate the cursor</span>
<a name="l01493"></a>01493 <span class="comment">** so that it is never used again.</span>
<a name="l01494"></a>01494 <span class="comment">*/</span>
<a name="l01495"></a><a class="code" href="vdbeaux_8c.html#ae4ed6d6cc1a15bb2321cd7fc4433c9b9">01495</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#ae4ed6d6cc1a15bb2321cd7fc4433c9b9">invalidateCursorsOnModifiedBtrees</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db){
<a name="l01496"></a>01496   <span class="keywordtype">int</span> i;
<a name="l01497"></a>01497   <span class="keywordflow">for</span>(i=0; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a>; i++){
<a name="l01498"></a>01498     <a class="code" href="structBtree.html">Btree</a> *p = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l01499"></a>01499     <span class="keywordflow">if</span>( p &amp;&amp; <a class="code" href="btree_8c.html#aeff539aa1765b2b7a18313c3cc26d0ba">sqlite3BtreeIsInTrans</a>(p) ){
<a name="l01500"></a>01500       <a class="code" href="btree_8c.html#a16024e460e480bab5c8748ad12113c80">sqlite3BtreeTripAllCursors</a>(p, <a class="code" href="sqlite3_8h.html#ab0c18279e950b695575a4667c7bb38b7">SQLITE_ABORT</a>);
<a name="l01501"></a>01501     }
<a name="l01502"></a>01502   }
<a name="l01503"></a>01503 }
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 <span class="comment">/*</span>
<a name="l01506"></a>01506 <span class="comment">** This routine is called the when a VDBE tries to halt.  If the VDBE</span>
<a name="l01507"></a>01507 <span class="comment">** has made changes and is in autocommit mode, then commit those</span>
<a name="l01508"></a>01508 <span class="comment">** changes.  If a rollback is needed, then do the rollback.</span>
<a name="l01509"></a>01509 <span class="comment">**</span>
<a name="l01510"></a>01510 <span class="comment">** This routine is the only way to move the state of a VM from</span>
<a name="l01511"></a>01511 <span class="comment">** SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to</span>
<a name="l01512"></a>01512 <span class="comment">** call this on a VM that is in the SQLITE_MAGIC_HALT state.</span>
<a name="l01513"></a>01513 <span class="comment">**</span>
<a name="l01514"></a>01514 <span class="comment">** Return an error code.  If the commit could not complete because of</span>
<a name="l01515"></a>01515 <span class="comment">** lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it</span>
<a name="l01516"></a>01516 <span class="comment">** means the close did not happen and needs to be repeated.</span>
<a name="l01517"></a>01517 <span class="comment">*/</span>
<a name="l01518"></a><a class="code" href="vdbeInt_8h.html#ad3d4febc3bcdaae1f9300d2f822fefd0">01518</a> <span class="keywordtype">int</span> <a class="code" href="vdbeaux_8c.html#af186927cd7de8e0c35b3d3fdb584c3ab">sqlite3VdbeHalt</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l01519"></a>01519   <a class="code" href="structsqlite3.html">sqlite3</a> *db = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l01520"></a>01520   <span class="keywordtype">int</span> i;
<a name="l01521"></a>01521   int (*xFunc)(<a class="code" href="structBtree.html">Btree</a> *pBt) = 0;  <span class="comment">/* Function to call on each btree backend */</span>
<a name="l01522"></a>01522   <span class="keywordtype">int</span> isSpecialError;            <span class="comment">/* Set to true if SQLITE_NOMEM or IOERR */</span>
<a name="l01523"></a>01523 
<a name="l01524"></a>01524   <span class="comment">/* This function contains the logic that determines if a statement or</span>
<a name="l01525"></a>01525 <span class="comment">  ** transaction will be committed or rolled back as a result of the</span>
<a name="l01526"></a>01526 <span class="comment">  ** execution of this virtual machine. </span>
<a name="l01527"></a>01527 <span class="comment">  **</span>
<a name="l01528"></a>01528 <span class="comment">  ** If any of the following errors occur:</span>
<a name="l01529"></a>01529 <span class="comment">  **</span>
<a name="l01530"></a>01530 <span class="comment">  **     SQLITE_NOMEM</span>
<a name="l01531"></a>01531 <span class="comment">  **     SQLITE_IOERR</span>
<a name="l01532"></a>01532 <span class="comment">  **     SQLITE_FULL</span>
<a name="l01533"></a>01533 <span class="comment">  **     SQLITE_INTERRUPT</span>
<a name="l01534"></a>01534 <span class="comment">  **</span>
<a name="l01535"></a>01535 <span class="comment">  ** Then the internal cache might have been left in an inconsistent</span>
<a name="l01536"></a>01536 <span class="comment">  ** state.  We need to rollback the statement transaction, if there is</span>
<a name="l01537"></a>01537 <span class="comment">  ** one, or the complete transaction if there is no statement transaction.</span>
<a name="l01538"></a>01538 <span class="comment">  */</span>
<a name="l01539"></a>01539 
<a name="l01540"></a>01540   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l01541"></a>01541     p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01542"></a>01542   }
<a name="l01543"></a>01543   <a class="code" href="vdbeaux_8c.html#ae3b3368c9fbc2719b28a01cc94fa5219">closeAllCursorsExceptActiveVtabs</a>(p);
<a name="l01544"></a>01544   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>!=<a class="code" href="vdbeInt_8h.html#af3737d82d7edf97fffb59baf1592a528">VDBE_MAGIC_RUN</a> ){
<a name="l01545"></a>01545     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01546"></a>01546   }
<a name="l01547"></a>01547   <a class="code" href="vdbeaux_8c.html#a62198942915c8bba41484677d9a3148a">checkActiveVdbeCnt</a>(db);
<a name="l01548"></a>01548 
<a name="l01549"></a>01549   <span class="comment">/* No commit or rollback needed if the program never started */</span>
<a name="l01550"></a>01550   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a>&gt;=0 ){
<a name="l01551"></a>01551     <span class="keywordtype">int</span> mrc;   <span class="comment">/* Primary error code from p-&gt;rc */</span>
<a name="l01552"></a>01552 
<a name="l01553"></a>01553     <span class="comment">/* Lock all btrees used by the statement */</span>
<a name="l01554"></a>01554     <a class="code" href="btree_8h.html#abf94f61173691e5a98c08e89bb905d3a">sqlite3BtreeMutexArrayEnter</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#aeeff59f076cad0b73997113e4e29bd76">aMutex</a>);
<a name="l01555"></a>01555 
<a name="l01556"></a>01556     <span class="comment">/* Check for one of the special errors */</span>
<a name="l01557"></a>01557     mrc = p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> &amp; 0xff;
<a name="l01558"></a>01558     isSpecialError = mrc==<a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a> || mrc==<a class="code" href="sqlite3_8h.html#a45a4718698f155ae3b45d37d3b94d9a2">SQLITE_IOERR</a>
<a name="l01559"></a>01559                      || mrc==<a class="code" href="sqlite3_8h.html#a03c9b25faf07d0e47ce7a1b1e46b2adc">SQLITE_INTERRUPT</a> || mrc==<a class="code" href="sqlite3_8h.html#a0e968a73ba9e13561c5dbf38f6ac7402">SQLITE_FULL</a>;
<a name="l01560"></a>01560     <span class="keywordflow">if</span>( isSpecialError ){
<a name="l01561"></a>01561       <span class="comment">/* If the query was read-only, we need do no rollback at all. Otherwise,</span>
<a name="l01562"></a>01562 <span class="comment">      ** proceed with the special handling.</span>
<a name="l01563"></a>01563 <span class="comment">      */</span>
<a name="l01564"></a>01564       <span class="keywordflow">if</span>( !p-&gt;<a class="code" href="structVdbe.html#a723ca4a68712aed8d37b3d682c336e84">readOnly</a> || mrc!=<a class="code" href="sqlite3_8h.html#a03c9b25faf07d0e47ce7a1b1e46b2adc">SQLITE_INTERRUPT</a> ){
<a name="l01565"></a>01565         <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a7bccb0ab5af74f1d05c0c0356083d820">SQLITE_IOERR_BLOCKED</a> &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#aaac5176003bc8760200364c7752786a4">usesStmtJournal</a> ){
<a name="l01566"></a>01566           xFunc = <a class="code" href="btree_8c.html#a18ab0ec8e821396eef5dbbd238a5dba3">sqlite3BtreeRollbackStmt</a>;
<a name="l01567"></a>01567           p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l01568"></a>01568         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( (mrc==<a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a> || mrc==<a class="code" href="sqlite3_8h.html#a0e968a73ba9e13561c5dbf38f6ac7402">SQLITE_FULL</a>)
<a name="l01569"></a>01569                    &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#aaac5176003bc8760200364c7752786a4">usesStmtJournal</a> ){
<a name="l01570"></a>01570           xFunc = <a class="code" href="btree_8c.html#a18ab0ec8e821396eef5dbbd238a5dba3">sqlite3BtreeRollbackStmt</a>;
<a name="l01571"></a>01571         }<span class="keywordflow">else</span>{
<a name="l01572"></a>01572           <span class="comment">/* We are forced to roll back the active transaction. Before doing</span>
<a name="l01573"></a>01573 <span class="comment">          ** so, abort any other statements this handle currently has active.</span>
<a name="l01574"></a>01574 <span class="comment">          */</span>
<a name="l01575"></a>01575           <a class="code" href="vdbeaux_8c.html#ae4ed6d6cc1a15bb2321cd7fc4433c9b9">invalidateCursorsOnModifiedBtrees</a>(db);
<a name="l01576"></a>01576           <a class="code" href="main_8c.html#ad0f384ff433a7d7b300edd34a01faac2">sqlite3RollbackAll</a>(db);
<a name="l01577"></a>01577           db-&gt;<a class="code" href="structsqlite3.html#a11baf5e051b2e4ea03c5d03c09bb624e">autoCommit</a> = 1;
<a name="l01578"></a>01578         }
<a name="l01579"></a>01579       }
<a name="l01580"></a>01580     }
<a name="l01581"></a>01581   
<a name="l01582"></a>01582     <span class="comment">/* If the auto-commit flag is set and this is the only active vdbe, then</span>
<a name="l01583"></a>01583 <span class="comment">    ** we do either a commit or rollback of the current transaction. </span>
<a name="l01584"></a>01584 <span class="comment">    **</span>
<a name="l01585"></a>01585 <span class="comment">    ** Note: This block also runs if one of the special errors handled </span>
<a name="l01586"></a>01586 <span class="comment">    ** above has occurred. </span>
<a name="l01587"></a>01587 <span class="comment">    */</span>
<a name="l01588"></a>01588     <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a11baf5e051b2e4ea03c5d03c09bb624e">autoCommit</a> &amp;&amp; db-&gt;<a class="code" href="structsqlite3.html#a632e51f8d35c1e8802639661e2fcd567">writeVdbeCnt</a>==(p-&gt;<a class="code" href="structVdbe.html#a723ca4a68712aed8d37b3d682c336e84">readOnly</a>==0) ){
<a name="l01589"></a>01589       <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> || (p-&gt;<a class="code" href="structVdbe.html#accafc9e9bac961a2e34daa1190cc228a">errorAction</a>==<a class="code" href="sqliteInt_8h.html#ac892e798ddea994b1d2ea1fdb4100c69">OE_Fail</a> &amp;&amp; !isSpecialError) ){
<a name="l01590"></a>01590         <span class="comment">/* The auto-commit flag is true, and the vdbe program was </span>
<a name="l01591"></a>01591 <span class="comment">        ** successful or hit an &apos;OR FAIL&apos; constraint. This means a commit </span>
<a name="l01592"></a>01592 <span class="comment">        ** is required.</span>
<a name="l01593"></a>01593 <span class="comment">        */</span>
<a name="l01594"></a>01594         <span class="keywordtype">int</span> rc = <a class="code" href="vdbeaux_8c.html#a5d7f1e0625451b987728f600cfe1b92d">vdbeCommit</a>(db, p);
<a name="l01595"></a>01595         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a> ){
<a name="l01596"></a>01596           <a class="code" href="btree_8h.html#a6505eb1c64d02f88a1f044f6c633fc90">sqlite3BtreeMutexArrayLeave</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#aeeff59f076cad0b73997113e4e29bd76">aMutex</a>);
<a name="l01597"></a>01597           <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l01598"></a>01598         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01599"></a>01599           p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = rc;
<a name="l01600"></a>01600           <a class="code" href="main_8c.html#ad0f384ff433a7d7b300edd34a01faac2">sqlite3RollbackAll</a>(db);
<a name="l01601"></a>01601         }<span class="keywordflow">else</span>{
<a name="l01602"></a>01602           <a class="code" href="build_8c.html#a062d37e1dd1b785e13695ad1900e4a60">sqlite3CommitInternalChanges</a>(db);
<a name="l01603"></a>01603         }
<a name="l01604"></a>01604       }<span class="keywordflow">else</span>{
<a name="l01605"></a>01605         <a class="code" href="main_8c.html#ad0f384ff433a7d7b300edd34a01faac2">sqlite3RollbackAll</a>(db);
<a name="l01606"></a>01606       }
<a name="l01607"></a>01607     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( !xFunc ){
<a name="l01608"></a>01608       <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> || p-&gt;<a class="code" href="structVdbe.html#accafc9e9bac961a2e34daa1190cc228a">errorAction</a>==<a class="code" href="sqliteInt_8h.html#ac892e798ddea994b1d2ea1fdb4100c69">OE_Fail</a> ){
<a name="l01609"></a>01609         <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a9f18480295980eda04c84fe74c5a4061">openedStatement</a> ){
<a name="l01610"></a>01610           xFunc = <a class="code" href="btree_8c.html#a08070c585cf98ef87dd60c2de12fb4b1">sqlite3BtreeCommitStmt</a>;
<a name="l01611"></a>01611         } 
<a name="l01612"></a>01612       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#accafc9e9bac961a2e34daa1190cc228a">errorAction</a>==<a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a> ){
<a name="l01613"></a>01613         xFunc = <a class="code" href="btree_8c.html#a18ab0ec8e821396eef5dbbd238a5dba3">sqlite3BtreeRollbackStmt</a>;
<a name="l01614"></a>01614       }<span class="keywordflow">else</span>{
<a name="l01615"></a>01615         <a class="code" href="vdbeaux_8c.html#ae4ed6d6cc1a15bb2321cd7fc4433c9b9">invalidateCursorsOnModifiedBtrees</a>(db);
<a name="l01616"></a>01616         <a class="code" href="main_8c.html#ad0f384ff433a7d7b300edd34a01faac2">sqlite3RollbackAll</a>(db);
<a name="l01617"></a>01617         db-&gt;<a class="code" href="structsqlite3.html#a11baf5e051b2e4ea03c5d03c09bb624e">autoCommit</a> = 1;
<a name="l01618"></a>01618       }
<a name="l01619"></a>01619     }
<a name="l01620"></a>01620   
<a name="l01621"></a>01621     <span class="comment">/* If xFunc is not NULL, then it is one of sqlite3BtreeRollbackStmt or</span>
<a name="l01622"></a>01622 <span class="comment">    ** sqlite3BtreeCommitStmt. Call it once on each backend. If an error occurs</span>
<a name="l01623"></a>01623 <span class="comment">    ** and the return code is still SQLITE_OK, set the return code to the new</span>
<a name="l01624"></a>01624 <span class="comment">    ** error value.</span>
<a name="l01625"></a>01625 <span class="comment">    */</span>
<a name="l01626"></a>01626     assert(!xFunc ||
<a name="l01627"></a>01627       xFunc==<a class="code" href="btree_8c.html#a08070c585cf98ef87dd60c2de12fb4b1">sqlite3BtreeCommitStmt</a> ||
<a name="l01628"></a>01628       xFunc==<a class="code" href="btree_8c.html#a18ab0ec8e821396eef5dbbd238a5dba3">sqlite3BtreeRollbackStmt</a>
<a name="l01629"></a>01629     );
<a name="l01630"></a>01630     <span class="keywordflow">for</span>(i=0; xFunc &amp;&amp; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a>; i++){ 
<a name="l01631"></a>01631       <span class="keywordtype">int</span> rc;
<a name="l01632"></a>01632       <a class="code" href="structBtree.html">Btree</a> *pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l01633"></a>01633       <span class="keywordflow">if</span>( pBt ){
<a name="l01634"></a>01634         rc = xFunc(pBt);
<a name="l01635"></a>01635         <span class="keywordflow">if</span>( rc &amp;&amp; (p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> || p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a60b2b65ad97f771203e26733f870af57">SQLITE_CONSTRAINT</a>) ){
<a name="l01636"></a>01636           p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = rc;
<a name="l01637"></a>01637           <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l01638"></a>01638           p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = 0;
<a name="l01639"></a>01639         }
<a name="l01640"></a>01640       }
<a name="l01641"></a>01641     }
<a name="l01642"></a>01642   
<a name="l01643"></a>01643     <span class="comment">/* If this was an INSERT, UPDATE or DELETE and the statement was committed, </span>
<a name="l01644"></a>01644 <span class="comment">    ** set the change counter. </span>
<a name="l01645"></a>01645 <span class="comment">    */</span>
<a name="l01646"></a>01646     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a448850e8bd320c590ca2d75588fe3a70">changeCntOn</a> &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a>&gt;=0 ){
<a name="l01647"></a>01647       <span class="keywordflow">if</span>( !xFunc || xFunc==<a class="code" href="btree_8c.html#a08070c585cf98ef87dd60c2de12fb4b1">sqlite3BtreeCommitStmt</a> ){
<a name="l01648"></a>01648         <a class="code" href="sqliteInt_8h.html#a20b9440f5f5fde83614215876ac0e13a">sqlite3VdbeSetChanges</a>(db, p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a>);
<a name="l01649"></a>01649       }<span class="keywordflow">else</span>{
<a name="l01650"></a>01650         <a class="code" href="sqliteInt_8h.html#a20b9440f5f5fde83614215876ac0e13a">sqlite3VdbeSetChanges</a>(db, 0);
<a name="l01651"></a>01651       }
<a name="l01652"></a>01652       p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a> = 0;
<a name="l01653"></a>01653     }
<a name="l01654"></a>01654   
<a name="l01655"></a>01655     <span class="comment">/* Rollback or commit any schema changes that occurred. */</span>
<a name="l01656"></a>01656     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a>&amp;<a class="code" href="sqliteInt_8h.html#ac4ee799ffccd81c7967fde25523c6c6a">SQLITE_InternChanges</a> ){
<a name="l01657"></a>01657       <a class="code" href="build_8c.html#a67e7c0c4f9880fb86514ef03643b1cd2">sqlite3ResetInternalSchema</a>(db, 0);
<a name="l01658"></a>01658       db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> = (db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> | <a class="code" href="sqliteInt_8h.html#ac4ee799ffccd81c7967fde25523c6c6a">SQLITE_InternChanges</a>);
<a name="l01659"></a>01659     }
<a name="l01660"></a>01660 
<a name="l01661"></a>01661     <span class="comment">/* Release the locks */</span>
<a name="l01662"></a>01662     <a class="code" href="btree_8h.html#a6505eb1c64d02f88a1f044f6c633fc90">sqlite3BtreeMutexArrayLeave</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#aeeff59f076cad0b73997113e4e29bd76">aMutex</a>);
<a name="l01663"></a>01663   }
<a name="l01664"></a>01664 
<a name="l01665"></a>01665   <span class="comment">/* We have successfully halted and closed the VM.  Record this fact. */</span>
<a name="l01666"></a>01666   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a>&gt;=0 ){
<a name="l01667"></a>01667     db-&gt;<a class="code" href="structsqlite3.html#ada07202e7fd80f275e2e5063d96b5cb0">activeVdbeCnt</a>--;
<a name="l01668"></a>01668     <span class="keywordflow">if</span>( !p-&gt;<a class="code" href="structVdbe.html#a723ca4a68712aed8d37b3d682c336e84">readOnly</a> ){
<a name="l01669"></a>01669       db-&gt;<a class="code" href="structsqlite3.html#a632e51f8d35c1e8802639661e2fcd567">writeVdbeCnt</a>--;
<a name="l01670"></a>01670     }
<a name="l01671"></a>01671     assert( db-&gt;<a class="code" href="structsqlite3.html#ada07202e7fd80f275e2e5063d96b5cb0">activeVdbeCnt</a>&gt;=db-&gt;<a class="code" href="structsqlite3.html#a632e51f8d35c1e8802639661e2fcd567">writeVdbeCnt</a> );
<a name="l01672"></a>01672   }
<a name="l01673"></a>01673   p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a> = <a class="code" href="vdbeInt_8h.html#a2e7e3b36e28cb03e85947839274d1222">VDBE_MAGIC_HALT</a>;
<a name="l01674"></a>01674   <a class="code" href="vdbeaux_8c.html#a62198942915c8bba41484677d9a3148a">checkActiveVdbeCnt</a>(db);
<a name="l01675"></a>01675   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l01676"></a>01676     p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01677"></a>01677   }
<a name="l01678"></a>01678 
<a name="l01679"></a>01679   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01680"></a>01680 }
<a name="l01681"></a>01681 
<a name="l01682"></a>01682 
<a name="l01683"></a>01683 <span class="comment">/*</span>
<a name="l01684"></a>01684 <span class="comment">** Each VDBE holds the result of the most recent sqlite3_step() call</span>
<a name="l01685"></a>01685 <span class="comment">** in p-&gt;rc.  This routine sets that result back to SQLITE_OK.</span>
<a name="l01686"></a>01686 <span class="comment">*/</span>
<a name="l01687"></a><a class="code" href="vdbeaux_8c.html#a9c157cac75ccb2661c38db2ce3383c63">01687</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#aebcf31493be1e7a7c4d88c67876ced9f">sqlite3VdbeResetStepResult</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l01688"></a>01688   p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01689"></a>01689 }
<a name="l01690"></a>01690 
<a name="l01691"></a>01691 <span class="comment">/*</span>
<a name="l01692"></a>01692 <span class="comment">** Clean up a VDBE after execution but do not delete the VDBE just yet.</span>
<a name="l01693"></a>01693 <span class="comment">** Write any error messages into *pzErrMsg.  Return the result code.</span>
<a name="l01694"></a>01694 <span class="comment">**</span>
<a name="l01695"></a>01695 <span class="comment">** After this routine is run, the VDBE should be ready to be executed</span>
<a name="l01696"></a>01696 <span class="comment">** again.</span>
<a name="l01697"></a>01697 <span class="comment">**</span>
<a name="l01698"></a>01698 <span class="comment">** To look at it another way, this routine resets the state of the</span>
<a name="l01699"></a>01699 <span class="comment">** virtual machine from VDBE_MAGIC_RUN or VDBE_MAGIC_HALT back to</span>
<a name="l01700"></a>01700 <span class="comment">** VDBE_MAGIC_INIT.</span>
<a name="l01701"></a>01701 <span class="comment">*/</span>
<a name="l01702"></a><a class="code" href="vdbeaux_8c.html#a118ef9a9a35b16692713ce222f20920e">01702</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#a1f8c32073f7a3dee445aeafec02accac">sqlite3VdbeReset</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l01703"></a>01703   <a class="code" href="structsqlite3.html">sqlite3</a> *db;
<a name="l01704"></a>01704   db = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l01705"></a>01705 
<a name="l01706"></a>01706   <span class="comment">/* If the VM did not run to completion or if it encountered an</span>
<a name="l01707"></a>01707 <span class="comment">  ** error, then it might not have been halted properly.  So halt</span>
<a name="l01708"></a>01708 <span class="comment">  ** it now.</span>
<a name="l01709"></a>01709 <span class="comment">  */</span>
<a name="l01710"></a>01710   (void)<a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db);
<a name="l01711"></a>01711   <a class="code" href="vdbeaux_8c.html#af186927cd7de8e0c35b3d3fdb584c3ab">sqlite3VdbeHalt</a>(p);
<a name="l01712"></a>01712   (void)<a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db);
<a name="l01713"></a>01713 
<a name="l01714"></a>01714   <span class="comment">/* If the VDBE has be run even partially, then transfer the error code</span>
<a name="l01715"></a>01715 <span class="comment">  ** and error message from the VDBE into the main database structure.  But</span>
<a name="l01716"></a>01716 <span class="comment">  ** if the VDBE has just been set to run but has not actually executed any</span>
<a name="l01717"></a>01717 <span class="comment">  ** instructions yet, leave the main database error information unchanged.</span>
<a name="l01718"></a>01718 <span class="comment">  */</span>
<a name="l01719"></a>01719   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a>&gt;=0 ){
<a name="l01720"></a>01720     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> ){
<a name="l01721"></a>01721       <a class="code" href="fault_8c.html#abd9e16e72d950da81603ebdf72ed4d5c">sqlite3BeginBenignMalloc</a>();
<a name="l01722"></a>01722       <a class="code" href="sqliteInt_8h.html#abfaa7933ed60fe6211fe0f32022d89ca">sqlite3ValueSetStr</a>(db-&gt;<a class="code" href="structsqlite3.html#a90941a0c05641f623c257a7a65b22809">pErr</a>,-1,p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>,<a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>,<a class="code" href="sqlite3_8h.html#adec3d88e3dff21d4c566daccbede9b3b">SQLITE_TRANSIENT</a>);
<a name="l01723"></a>01723       <a class="code" href="fault_8c.html#ab9784f82977599f15fc02ea3ce1a770a">sqlite3EndBenignMalloc</a>();
<a name="l01724"></a>01724       db-&gt;<a class="code" href="structsqlite3.html#a73adbb5395118bcbd9e4d705712966a2">errCode</a> = p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>;
<a name="l01725"></a>01725       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l01726"></a>01726       p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = 0;
<a name="l01727"></a>01727     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> ){
<a name="l01728"></a>01728       <a class="code" href="sqliteInt_8h.html#adf4434e94ac41a2abedd476047d49983">sqlite3Error</a>(db, p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>, 0);
<a name="l01729"></a>01729     }<span class="keywordflow">else</span>{
<a name="l01730"></a>01730       <a class="code" href="sqliteInt_8h.html#adf4434e94ac41a2abedd476047d49983">sqlite3Error</a>(db, <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>, 0);
<a name="l01731"></a>01731     }
<a name="l01732"></a>01732   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> &amp;&amp; p-&gt;<a class="code" href="structVdbe.html#ab281d7519a1e6f60163eab9b15048eda">expired</a> ){
<a name="l01733"></a>01733     <span class="comment">/* The expired flag was set on the VDBE before the first call</span>
<a name="l01734"></a>01734 <span class="comment">    ** to sqlite3_step(). For consistency (since sqlite3_step() was</span>
<a name="l01735"></a>01735 <span class="comment">    ** called), set the database error in this case as well.</span>
<a name="l01736"></a>01736 <span class="comment">    */</span>
<a name="l01737"></a>01737     <a class="code" href="sqliteInt_8h.html#adf4434e94ac41a2abedd476047d49983">sqlite3Error</a>(db, p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>, 0);
<a name="l01738"></a>01738     <a class="code" href="sqliteInt_8h.html#abfaa7933ed60fe6211fe0f32022d89ca">sqlite3ValueSetStr</a>(db-&gt;<a class="code" href="structsqlite3.html#a90941a0c05641f623c257a7a65b22809">pErr</a>, -1, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>, <a class="code" href="sqlite3_8h.html#adec3d88e3dff21d4c566daccbede9b3b">SQLITE_TRANSIENT</a>);
<a name="l01739"></a>01739     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l01740"></a>01740     p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = 0;
<a name="l01741"></a>01741   }
<a name="l01742"></a>01742 
<a name="l01743"></a>01743   <span class="comment">/* Reclaim all memory used by the VDBE</span>
<a name="l01744"></a>01744 <span class="comment">  */</span>
<a name="l01745"></a>01745   <a class="code" href="vdbeaux_8c.html#ae3e0dbf7ac3255e91d16cd24fd2c2b1d">Cleanup</a>(p);
<a name="l01746"></a>01746 
<a name="l01747"></a>01747   <span class="comment">/* Save profiling information from this VDBE run.</span>
<a name="l01748"></a>01748 <span class="comment">  */</span>
<a name="l01749"></a>01749 <span class="preprocessor">#ifdef VDBE_PROFILE</span>
<a name="l01750"></a>01750 <span class="preprocessor"></span>  {
<a name="l01751"></a>01751     FILE *out = fopen(<span class="stringliteral">&quot;vdbe_profile.out&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>);
<a name="l01752"></a>01752     <span class="keywordflow">if</span>( out ){
<a name="l01753"></a>01753       <span class="keywordtype">int</span> i;
<a name="l01754"></a>01754       fprintf(out, <span class="stringliteral">&quot;---- &quot;</span>);
<a name="l01755"></a>01755       <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>; i++){
<a name="l01756"></a>01756         fprintf(out, <span class="stringliteral">&quot;%02x&quot;</span>, p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i].<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>);
<a name="l01757"></a>01757       }
<a name="l01758"></a>01758       fprintf(out, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01759"></a>01759       <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>; i++){
<a name="l01760"></a>01760         fprintf(out, <span class="stringliteral">&quot;%6d %10lld %8lld &quot;</span>,
<a name="l01761"></a>01761            p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i].cnt,
<a name="l01762"></a>01762            p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i].cycles,
<a name="l01763"></a>01763            p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i].cnt&gt;0 ? p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i].cycles/p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i].cnt : 0
<a name="l01764"></a>01764         );
<a name="l01765"></a>01765         sqlite3VdbePrintOp(out, i, &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i]);
<a name="l01766"></a>01766       }
<a name="l01767"></a>01767       fclose(out);
<a name="l01768"></a>01768     }
<a name="l01769"></a>01769   }
<a name="l01770"></a>01770 <span class="preprocessor">#endif</span>
<a name="l01771"></a>01771 <span class="preprocessor"></span>  p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a> = <a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a>;
<a name="l01772"></a>01772   <span class="keywordflow">return</span> p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> &amp; db-&gt;<a class="code" href="structsqlite3.html#a12541dafcf60cfce52fb60f84e42f152">errMask</a>;
<a name="l01773"></a>01773 }
<a name="l01774"></a>01774  
<a name="l01775"></a>01775 <span class="comment">/*</span>
<a name="l01776"></a>01776 <span class="comment">** Clean up and delete a VDBE after execution.  Return an integer which is</span>
<a name="l01777"></a>01777 <span class="comment">** the result code.  Write any error message text into *pzErrMsg.</span>
<a name="l01778"></a>01778 <span class="comment">*/</span>
<a name="l01779"></a><a class="code" href="vdbeaux_8c.html#a6a975456b074617e42cae491eea89065">01779</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#a65395771ab2499f7e467c7edb809b670">sqlite3VdbeFinalize</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l01780"></a>01780   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01781"></a>01781   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#af3737d82d7edf97fffb59baf1592a528">VDBE_MAGIC_RUN</a> || p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#a2e7e3b36e28cb03e85947839274d1222">VDBE_MAGIC_HALT</a> ){
<a name="l01782"></a>01782     rc = <a class="code" href="vdbe_8h.html#a1f8c32073f7a3dee445aeafec02accac">sqlite3VdbeReset</a>(p);
<a name="l01783"></a>01783     assert( (rc &amp; p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a12541dafcf60cfce52fb60f84e42f152">errMask</a>)==rc );
<a name="l01784"></a>01784   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>!=<a class="code" href="vdbeInt_8h.html#a622df040a9de6bafb1d10227318459ce">VDBE_MAGIC_INIT</a> ){
<a name="l01785"></a>01785     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a34f01e4ee909e6b68be040868f7503bc">SQLITE_MISUSE</a>;
<a name="l01786"></a>01786   }
<a name="l01787"></a>01787   <a class="code" href="vdbe_8h.html#a7c6e6c7a7ebeb5a9d7e575a4715802e0">sqlite3VdbeDelete</a>(p);
<a name="l01788"></a>01788   <span class="keywordflow">return</span> rc;
<a name="l01789"></a>01789 }
<a name="l01790"></a>01790 
<a name="l01791"></a>01791 <span class="comment">/*</span>
<a name="l01792"></a>01792 <span class="comment">** Call the destructor for each auxdata entry in pVdbeFunc for which</span>
<a name="l01793"></a>01793 <span class="comment">** the corresponding bit in mask is clear.  Auxdata entries beyond 31</span>
<a name="l01794"></a>01794 <span class="comment">** are always destroyed.  To destroy all auxdata entries, call this</span>
<a name="l01795"></a>01795 <span class="comment">** routine with mask==0.</span>
<a name="l01796"></a>01796 <span class="comment">*/</span>
<a name="l01797"></a><a class="code" href="vdbeInt_8h.html#a1023c34dc82dc6a5c50938dd6cf6286d">01797</a> <span class="keywordtype">void</span> <a class="code" href="vdbeaux_8c.html#a39bd3906d852580ad020e9261f9d6eba">sqlite3VdbeDeleteAuxData</a>(<a class="code" href="structVdbeFunc.html">VdbeFunc</a> *pVdbeFunc, <span class="keywordtype">int</span> mask){
<a name="l01798"></a>01798   <span class="keywordtype">int</span> i;
<a name="l01799"></a>01799   <span class="keywordflow">for</span>(i=0; i&lt;pVdbeFunc-&gt;<a class="code" href="structVdbeFunc.html#ad78feda4c310ea0bc17b7bba53bccd3c">nAux</a>; i++){
<a name="l01800"></a>01800     <span class="keyword">struct </span>AuxData *pAux = &amp;pVdbeFunc-&gt;<a class="code" href="structVdbeFunc.html#abb466d61a0d36b913418460e5922166a">apAux</a>[i];
<a name="l01801"></a>01801     <span class="keywordflow">if</span>( (i&gt;31 || !(mask&amp;(1&lt;&lt;i))) &amp;&amp; pAux-&gt;pAux ){
<a name="l01802"></a>01802       <span class="keywordflow">if</span>( pAux-&gt;xDelete ){
<a name="l01803"></a>01803         pAux-&gt;<a class="code" href="structVdbeFunc_1_1AuxData.html#a6742f89d0634b5fc6684f245bac76fd5">xDelete</a>(pAux-&gt;pAux);
<a name="l01804"></a>01804       }
<a name="l01805"></a>01805       pAux-&gt;pAux = 0;
<a name="l01806"></a>01806     }
<a name="l01807"></a>01807   }
<a name="l01808"></a>01808 }
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 <span class="comment">/*</span>
<a name="l01811"></a>01811 <span class="comment">** Delete an entire VDBE.</span>
<a name="l01812"></a>01812 <span class="comment">*/</span>
<a name="l01813"></a><a class="code" href="vdbeaux_8c.html#ae264575fc410b02da05cab6889aa57ff">01813</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#a7c6e6c7a7ebeb5a9d7e575a4715802e0">sqlite3VdbeDelete</a>(<a class="code" href="structVdbe.html">Vdbe</a> *p){
<a name="l01814"></a>01814   <span class="keywordtype">int</span> i;
<a name="l01815"></a>01815   <a class="code" href="structsqlite3.html">sqlite3</a> *db;
<a name="l01816"></a>01816 
<a name="l01817"></a>01817   <span class="keywordflow">if</span>( p==0 ) <span class="keywordflow">return</span>;
<a name="l01818"></a>01818   db = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l01819"></a>01819   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a> ){
<a name="l01820"></a>01820     p-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a>-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a> = p-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a>;
<a name="l01821"></a>01821   }<span class="keywordflow">else</span>{
<a name="l01822"></a>01822     assert( db-&gt;<a class="code" href="structsqlite3.html#a596f0301f43c5e25575c2a1403f8b571">pVdbe</a>==p );
<a name="l01823"></a>01823     db-&gt;<a class="code" href="structsqlite3.html#a596f0301f43c5e25575c2a1403f8b571">pVdbe</a> = p-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a>;
<a name="l01824"></a>01824   }
<a name="l01825"></a>01825   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a> ){
<a name="l01826"></a>01826     p-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a>-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a> = p-&gt;<a class="code" href="structVdbe.html#a2afc3b6cd2f5b38d991148b809b3c53f">pPrev</a>;
<a name="l01827"></a>01827   }
<a name="l01828"></a>01828   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a> ){
<a name="l01829"></a>01829     <a class="code" href="structVdbeOp.html">Op</a> *pOp = p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>;
<a name="l01830"></a>01830     <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>; i++, pOp++){
<a name="l01831"></a>01831       <a class="code" href="vdbeaux_8c.html#aa1ec8debef2a9be5fe36a3082fd3e0f9">freeP4</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a>);
<a name="l01832"></a>01832 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l01833"></a>01833 <span class="preprocessor"></span>      <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pOp-&gt;zComment);
<a name="l01834"></a>01834 <span class="preprocessor">#endif     </span>
<a name="l01835"></a>01835 <span class="preprocessor"></span>    }
<a name="l01836"></a>01836     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>);
<a name="l01837"></a>01837   }
<a name="l01838"></a>01838   <a class="code" href="vdbeaux_8c.html#a321ef1ead88ab0c4c636971ae5cc9778">releaseMemArray</a>(p-&gt;<a class="code" href="structVdbe.html#a8877b72591926e3597fa93e22f84b99c">aVar</a>, p-&gt;<a class="code" href="structVdbe.html#a4423b7c92b9284791cf2660cefe07f91">nVar</a>);
<a name="l01839"></a>01839   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#a8d9c9a70f5a5ffd037cc29cd3d3815b2">aLabel</a>);
<a name="l01840"></a>01840   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a> ){
<a name="l01841"></a>01841     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[1]);
<a name="l01842"></a>01842   }
<a name="l01843"></a>01843   <a class="code" href="vdbeaux_8c.html#a321ef1ead88ab0c4c636971ae5cc9778">releaseMemArray</a>(p-&gt;<a class="code" href="structVdbe.html#a900f557143e7d2ab8c560f7ada66d0f7">aColName</a>, p-&gt;<a class="code" href="structVdbe.html#ae4aebc61bfb17f7dc2099c4143900e83">nResColumn</a>*<a class="code" href="vdbe_8h.html#aca828d8d49b011a44db5870cf5bab5b7">COLNAME_N</a>);
<a name="l01844"></a>01844   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#a900f557143e7d2ab8c560f7ada66d0f7">aColName</a>);
<a name="l01845"></a>01845   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#a5a61fd8f84ae0399ef73327e48048ae9">zSql</a>);
<a name="l01846"></a>01846   p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a> = <a class="code" href="vdbeInt_8h.html#ae713b0da4605ac2b907322430cf54333">VDBE_MAGIC_DEAD</a>;
<a name="l01847"></a>01847   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p);
<a name="l01848"></a>01848 }
<a name="l01849"></a>01849 
<a name="l01850"></a>01850 <span class="comment">/*</span>
<a name="l01851"></a>01851 <span class="comment">** If a MoveTo operation is pending on the given cursor, then do that</span>
<a name="l01852"></a>01852 <span class="comment">** MoveTo now.  Return an error code.  If no MoveTo is pending, this</span>
<a name="l01853"></a>01853 <span class="comment">** routine does nothing and returns SQLITE_OK.</span>
<a name="l01854"></a>01854 <span class="comment">*/</span>
<a name="l01855"></a><a class="code" href="vdbeInt_8h.html#a55715e2cd492172bb9cb03d5789efcdb">01855</a> <span class="keywordtype">int</span> <a class="code" href="vdbeaux_8c.html#a0e6c6ab44bba69b7b9d4e5b8c461dfe2">sqlite3VdbeCursorMoveto</a>(<a class="code" href="structVdbeCursor.html">VdbeCursor</a> *p){
<a name="l01856"></a>01856   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a> ){
<a name="l01857"></a>01857     <span class="keywordtype">int</span> res, rc;
<a name="l01858"></a>01858 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l01859"></a>01859 <span class="preprocessor"></span>    <span class="keyword">extern</span> <span class="keywordtype">int</span> sqlite3_search_count;
<a name="l01860"></a>01860 <span class="preprocessor">#endif</span>
<a name="l01861"></a>01861 <span class="preprocessor"></span>    assert( p-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> );
<a name="l01862"></a>01862     rc = <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(p-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, 0, p-&gt;<a class="code" href="structVdbeCursor.html#af3c157d480c0597ba50aca227eb8e3b8">movetoTarget</a>, 0, &amp;res);
<a name="l01863"></a>01863     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l01864"></a>01864     p-&gt;<a class="code" href="structVdbeCursor.html#af2ff971acc308c012c60b1e949c64411">lastRowid</a> = <a class="code" href="vdbeInt_8h.html#a0d7ab028a08884fcdd3a349d8d319e1b">keyToInt</a>(p-&gt;<a class="code" href="structVdbeCursor.html#af3c157d480c0597ba50aca227eb8e3b8">movetoTarget</a>);
<a name="l01865"></a>01865     p-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = res==0;
<a name="l01866"></a>01866     <span class="keywordflow">if</span>( res&lt;0 ){
<a name="l01867"></a>01867       rc = <a class="code" href="btree_8c.html#adf99ca89adc2e91557a41d6d11e97039">sqlite3BtreeNext</a>(p-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, &amp;res);
<a name="l01868"></a>01868       <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l01869"></a>01869     }
<a name="l01870"></a>01870 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l01871"></a>01871 <span class="preprocessor"></span>    sqlite3_search_count++;
<a name="l01872"></a>01872 <span class="preprocessor">#endif</span>
<a name="l01873"></a>01873 <span class="preprocessor"></span>    p-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a> = 0;
<a name="l01874"></a>01874     p-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l01875"></a>01875   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a> ){
<a name="l01876"></a>01876     <span class="keywordtype">int</span> hasMoved;
<a name="l01877"></a>01877     <span class="keywordtype">int</span> rc = <a class="code" href="btree_8c.html#a8175c379b606ff1986a8c51c88d979c8">sqlite3BtreeCursorHasMoved</a>(p-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, &amp;hasMoved);
<a name="l01878"></a>01878     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l01879"></a>01879     <span class="keywordflow">if</span>( hasMoved ){
<a name="l01880"></a>01880       p-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l01881"></a>01881       p-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = 1;
<a name="l01882"></a>01882     }
<a name="l01883"></a>01883   }
<a name="l01884"></a>01884   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01885"></a>01885 }
<a name="l01886"></a>01886 
<a name="l01887"></a>01887 <span class="comment">/*</span>
<a name="l01888"></a>01888 <span class="comment">** The following functions:</span>
<a name="l01889"></a>01889 <span class="comment">**</span>
<a name="l01890"></a>01890 <span class="comment">** sqlite3VdbeSerialType()</span>
<a name="l01891"></a>01891 <span class="comment">** sqlite3VdbeSerialTypeLen()</span>
<a name="l01892"></a>01892 <span class="comment">** sqlite3VdbeSerialLen()</span>
<a name="l01893"></a>01893 <span class="comment">** sqlite3VdbeSerialPut()</span>
<a name="l01894"></a>01894 <span class="comment">** sqlite3VdbeSerialGet()</span>
<a name="l01895"></a>01895 <span class="comment">**</span>
<a name="l01896"></a>01896 <span class="comment">** encapsulate the code that serializes values for storage in SQLite</span>
<a name="l01897"></a>01897 <span class="comment">** data and index records. Each serialized value consists of a</span>
<a name="l01898"></a>01898 <span class="comment">** &apos;serial-type&apos; and a blob of data. The serial type is an 8-byte unsigned</span>
<a name="l01899"></a>01899 <span class="comment">** integer, stored as a varint.</span>
<a name="l01900"></a>01900 <span class="comment">**</span>
<a name="l01901"></a>01901 <span class="comment">** In an SQLite index record, the serial type is stored directly before</span>
<a name="l01902"></a>01902 <span class="comment">** the blob of data that it corresponds to. In a table record, all serial</span>
<a name="l01903"></a>01903 <span class="comment">** types are stored at the start of the record, and the blobs of data at</span>
<a name="l01904"></a>01904 <span class="comment">** the end. Hence these functions allow the caller to handle the</span>
<a name="l01905"></a>01905 <span class="comment">** serial-type and data blob seperately.</span>
<a name="l01906"></a>01906 <span class="comment">**</span>
<a name="l01907"></a>01907 <span class="comment">** The following table describes the various storage classes for data:</span>
<a name="l01908"></a>01908 <span class="comment">**</span>
<a name="l01909"></a>01909 <span class="comment">**   serial type        bytes of data      type</span>
<a name="l01910"></a>01910 <span class="comment">**   --------------     ---------------    ---------------</span>
<a name="l01911"></a>01911 <span class="comment">**      0                     0            NULL</span>
<a name="l01912"></a>01912 <span class="comment">**      1                     1            signed integer</span>
<a name="l01913"></a>01913 <span class="comment">**      2                     2            signed integer</span>
<a name="l01914"></a>01914 <span class="comment">**      3                     3            signed integer</span>
<a name="l01915"></a>01915 <span class="comment">**      4                     4            signed integer</span>
<a name="l01916"></a>01916 <span class="comment">**      5                     6            signed integer</span>
<a name="l01917"></a>01917 <span class="comment">**      6                     8            signed integer</span>
<a name="l01918"></a>01918 <span class="comment">**      7                     8            IEEE float</span>
<a name="l01919"></a>01919 <span class="comment">**      8                     0            Integer constant 0</span>
<a name="l01920"></a>01920 <span class="comment">**      9                     0            Integer constant 1</span>
<a name="l01921"></a>01921 <span class="comment">**     10,11                               reserved for expansion</span>
<a name="l01922"></a>01922 <span class="comment">**    N&gt;=12 and even       (N-12)/2        BLOB</span>
<a name="l01923"></a>01923 <span class="comment">**    N&gt;=13 and odd        (N-13)/2        text</span>
<a name="l01924"></a>01924 <span class="comment">**</span>
<a name="l01925"></a>01925 <span class="comment">** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions</span>
<a name="l01926"></a>01926 <span class="comment">** of SQLite will not understand those serial types.</span>
<a name="l01927"></a>01927 <span class="comment">*/</span>
<a name="l01928"></a>01928 
<a name="l01929"></a>01929 <span class="comment">/*</span>
<a name="l01930"></a>01930 <span class="comment">** Return the serial-type for the value stored in pMem.</span>
<a name="l01931"></a>01931 <span class="comment">*/</span>
<a name="l01932"></a><a class="code" href="vdbeInt_8h.html#affea961bbe98250b8de15cd8a15a42e8">01932</a> <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> <a class="code" href="vdbeaux_8c.html#af0cba819e11277d6247f823d022f5f74">sqlite3VdbeSerialType</a>(<a class="code" href="structMem.html">Mem</a> *pMem, <span class="keywordtype">int</span> file_format){
<a name="l01933"></a>01933   <span class="keywordtype">int</span> flags = pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>;
<a name="l01934"></a>01934   <span class="keywordtype">int</span> n;
<a name="l01935"></a>01935 
<a name="l01936"></a>01936   <span class="keywordflow">if</span>( flags&amp;<a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l01937"></a>01937     <span class="keywordflow">return</span> 0;
<a name="l01938"></a>01938   }
<a name="l01939"></a>01939   <span class="keywordflow">if</span>( flags&amp;<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> ){
<a name="l01940"></a>01940     <span class="comment">/* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */</span>
<a name="l01941"></a>01941 <span class="preprocessor">#   define MAX_6BYTE ((((i64)0x00008000)&lt;&lt;32)-1)</span>
<a name="l01942"></a>01942 <span class="preprocessor"></span>    <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> i = pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l01943"></a>01943     <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> u;
<a name="l01944"></a>01944     <span class="keywordflow">if</span>( file_format&gt;=4 &amp;&amp; (i&amp;1)==i ){
<a name="l01945"></a>01945       <span class="keywordflow">return</span> 8+i;
<a name="l01946"></a>01946     }
<a name="l01947"></a>01947     u = i&lt;0 ? -i : i;
<a name="l01948"></a>01948     <span class="keywordflow">if</span>( u&lt;=127 ) <span class="keywordflow">return</span> 1;
<a name="l01949"></a>01949     <span class="keywordflow">if</span>( u&lt;=32767 ) <span class="keywordflow">return</span> 2;
<a name="l01950"></a>01950     <span class="keywordflow">if</span>( u&lt;=8388607 ) <span class="keywordflow">return</span> 3;
<a name="l01951"></a>01951     <span class="keywordflow">if</span>( u&lt;=2147483647 ) <span class="keywordflow">return</span> 4;
<a name="l01952"></a>01952     <span class="keywordflow">if</span>( u&lt;=<a class="code" href="vdbeaux_8c.html#a85dab21898423584bb6bea5e5a9899b7">MAX_6BYTE</a> ) <span class="keywordflow">return</span> 5;
<a name="l01953"></a>01953     <span class="keywordflow">return</span> 6;
<a name="l01954"></a>01954   }
<a name="l01955"></a>01955   <span class="keywordflow">if</span>( flags&amp;<a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a> ){
<a name="l01956"></a>01956     <span class="keywordflow">return</span> 7;
<a name="l01957"></a>01957   }
<a name="l01958"></a>01958   assert( pMem-&gt;<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> || flags&amp;(<a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a>|<a class="code" href="vdbeInt_8h.html#a4def40a3702fc50cd2f3a5820e1a4f68">MEM_Blob</a>) );
<a name="l01959"></a>01959   n = pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>;
<a name="l01960"></a>01960   <span class="keywordflow">if</span>( flags &amp; <a class="code" href="vdbeInt_8h.html#a9433e8fe887266736d2e795fe0b71fd3">MEM_Zero</a> ){
<a name="l01961"></a>01961     n += pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l01962"></a>01962   }
<a name="l01963"></a>01963   assert( n&gt;=0 );
<a name="l01964"></a>01964   <span class="keywordflow">return</span> ((n*2) + 12 + ((flags&amp;<a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a>)!=0));
<a name="l01965"></a>01965 }
<a name="l01966"></a>01966 
<a name="l01967"></a>01967 <span class="comment">/*</span>
<a name="l01968"></a>01968 <span class="comment">** Return the length of the data corresponding to the supplied serial-type.</span>
<a name="l01969"></a>01969 <span class="comment">*/</span>
<a name="l01970"></a><a class="code" href="vdbeInt_8h.html#ac66924309c0a006e270574c8551d561f">01970</a> <span class="keywordtype">int</span> <a class="code" href="vdbeaux_8c.html#a002b233ebea0d972e5bc2964f5fe5de6">sqlite3VdbeSerialTypeLen</a>(<a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> serial_type){
<a name="l01971"></a>01971   <span class="keywordflow">if</span>( serial_type&gt;=12 ){
<a name="l01972"></a>01972     <span class="keywordflow">return</span> (serial_type-12)/2;
<a name="l01973"></a>01973   }<span class="keywordflow">else</span>{
<a name="l01974"></a>01974     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> aSize[] = { 0, 1, 2, 3, 4, 6, 8, 8, 0, 0, 0, 0 };
<a name="l01975"></a>01975     <span class="keywordflow">return</span> aSize[serial_type];
<a name="l01976"></a>01976   }
<a name="l01977"></a>01977 }
<a name="l01978"></a>01978 
<a name="l01979"></a>01979 <span class="comment">/*</span>
<a name="l01980"></a>01980 <span class="comment">** If we are on an architecture with mixed-endian floating </span>
<a name="l01981"></a>01981 <span class="comment">** points (ex: ARM7) then swap the lower 4 bytes with the </span>
<a name="l01982"></a>01982 <span class="comment">** upper 4 bytes.  Return the result.</span>
<a name="l01983"></a>01983 <span class="comment">**</span>
<a name="l01984"></a>01984 <span class="comment">** For most architectures, this is a no-op.</span>
<a name="l01985"></a>01985 <span class="comment">**</span>
<a name="l01986"></a>01986 <span class="comment">** (later):  It is reported to me that the mixed-endian problem</span>
<a name="l01987"></a>01987 <span class="comment">** on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems</span>
<a name="l01988"></a>01988 <span class="comment">** that early versions of GCC stored the two words of a 64-bit</span>
<a name="l01989"></a>01989 <span class="comment">** float in the wrong order.  And that error has been propagated</span>
<a name="l01990"></a>01990 <span class="comment">** ever since.  The blame is not necessarily with GCC, though.</span>
<a name="l01991"></a>01991 <span class="comment">** GCC might have just copying the problem from a prior compiler.</span>
<a name="l01992"></a>01992 <span class="comment">** I am also told that newer versions of GCC that follow a different</span>
<a name="l01993"></a>01993 <span class="comment">** ABI get the byte order right.</span>
<a name="l01994"></a>01994 <span class="comment">**</span>
<a name="l01995"></a>01995 <span class="comment">** Developers using SQLite on an ARM7 should compile and run their</span>
<a name="l01996"></a>01996 <span class="comment">** application using -DSQLITE_DEBUG=1 at least once.  With DEBUG</span>
<a name="l01997"></a>01997 <span class="comment">** enabled, some asserts below will ensure that the byte order of</span>
<a name="l01998"></a>01998 <span class="comment">** floating point values is correct.</span>
<a name="l01999"></a>01999 <span class="comment">**</span>
<a name="l02000"></a>02000 <span class="comment">** (2007-08-30)  Frank van Vugt has studied this problem closely</span>
<a name="l02001"></a>02001 <span class="comment">** and has send his findings to the SQLite developers.  Frank</span>
<a name="l02002"></a>02002 <span class="comment">** writes that some Linux kernels offer floating point hardware</span>
<a name="l02003"></a>02003 <span class="comment">** emulation that uses only 32-bit mantissas instead of a full </span>
<a name="l02004"></a>02004 <span class="comment">** 48-bits as required by the IEEE standard.  (This is the</span>
<a name="l02005"></a>02005 <span class="comment">** CONFIG_FPE_FASTFPE option.)  On such systems, floating point</span>
<a name="l02006"></a>02006 <span class="comment">** byte swapping becomes very complicated.  To avoid problems,</span>
<a name="l02007"></a>02007 <span class="comment">** the necessary byte swapping is carried out using a 64-bit integer</span>
<a name="l02008"></a>02008 <span class="comment">** rather than a 64-bit float.  Frank assures us that the code here</span>
<a name="l02009"></a>02009 <span class="comment">** works for him.  We, the developers, have no way to independently</span>
<a name="l02010"></a>02010 <span class="comment">** verify this, but Frank seems to know what he is talking about</span>
<a name="l02011"></a>02011 <span class="comment">** so we trust him.</span>
<a name="l02012"></a>02012 <span class="comment">*/</span>
<a name="l02013"></a>02013 <span class="preprocessor">#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT</span>
<a name="l02014"></a>02014 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> floatSwap(<a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> in){
<a name="l02015"></a>02015   <span class="keyword">union </span>{
<a name="l02016"></a>02016     <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> r;
<a name="l02017"></a>02017     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> i[2];
<a name="l02018"></a>02018   } u;
<a name="l02019"></a>02019   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> t;
<a name="l02020"></a>02020 
<a name="l02021"></a>02021   u.r = in;
<a name="l02022"></a>02022   t = u.i[0];
<a name="l02023"></a>02023   u.i[0] = u.i[1];
<a name="l02024"></a>02024   u.i[1] = t;
<a name="l02025"></a>02025   <span class="keywordflow">return</span> u.r;
<a name="l02026"></a>02026 }
<a name="l02027"></a>02027 <span class="preprocessor"># define swapMixedEndianFloat(X)  X = floatSwap(X)</span>
<a name="l02028"></a>02028 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l02029"></a><a class="code" href="vdbeaux_8c.html#a4a933e8ee6cfece9fd82e1c6f6a9baac">02029</a> <span class="preprocessor"></span><span class="preprocessor"># define swapMixedEndianFloat(X)</span>
<a name="l02030"></a>02030 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02031"></a>02031 <span class="preprocessor"></span>
<a name="l02032"></a>02032 <span class="comment">/*</span>
<a name="l02033"></a>02033 <span class="comment">** Write the serialized data blob for the value stored in pMem into </span>
<a name="l02034"></a>02034 <span class="comment">** buf. It is assumed that the caller has allocated sufficient space.</span>
<a name="l02035"></a>02035 <span class="comment">** Return the number of bytes written.</span>
<a name="l02036"></a>02036 <span class="comment">**</span>
<a name="l02037"></a>02037 <span class="comment">** nBuf is the amount of space left in buf[].  nBuf must always be</span>
<a name="l02038"></a>02038 <span class="comment">** large enough to hold the entire field.  Except, if the field is</span>
<a name="l02039"></a>02039 <span class="comment">** a blob with a zero-filled tail, then buf[] might be just the right</span>
<a name="l02040"></a>02040 <span class="comment">** size to hold everything except for the zero-filled tail.  If buf[]</span>
<a name="l02041"></a>02041 <span class="comment">** is only big enough to hold the non-zero prefix, then only write that</span>
<a name="l02042"></a>02042 <span class="comment">** prefix into buf[].  But if buf[] is large enough to hold both the</span>
<a name="l02043"></a>02043 <span class="comment">** prefix and the tail then write the prefix and set the tail to all</span>
<a name="l02044"></a>02044 <span class="comment">** zeros.</span>
<a name="l02045"></a>02045 <span class="comment">**</span>
<a name="l02046"></a>02046 <span class="comment">** Return the number of bytes actually written into buf[].  The number</span>
<a name="l02047"></a>02047 <span class="comment">** of bytes in the zero-filled tail is included in the return value only</span>
<a name="l02048"></a>02048 <span class="comment">** if those bytes were zeroed in buf[].</span>
<a name="l02049"></a>02049 <span class="comment">*/</span> 
<a name="l02050"></a><a class="code" href="vdbeaux_8c.html#a7386a986968b44a9ab2ea83eca22bd90">02050</a> <span class="keywordtype">int</span> <a class="code" href="vdbeaux_8c.html#a7386a986968b44a9ab2ea83eca22bd90">sqlite3VdbeSerialPut</a>(<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *buf, <span class="keywordtype">int</span> nBuf, <a class="code" href="structMem.html">Mem</a> *pMem, <span class="keywordtype">int</span> file_format){
<a name="l02051"></a>02051   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> serial_type = <a class="code" href="vdbeaux_8c.html#af0cba819e11277d6247f823d022f5f74">sqlite3VdbeSerialType</a>(pMem, file_format);
<a name="l02052"></a>02052   <span class="keywordtype">int</span> len;
<a name="l02053"></a>02053 
<a name="l02054"></a>02054   <span class="comment">/* Integer and Real */</span>
<a name="l02055"></a>02055   <span class="keywordflow">if</span>( serial_type&lt;=7 &amp;&amp; serial_type&gt;0 ){
<a name="l02056"></a>02056     <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> v;
<a name="l02057"></a>02057     <span class="keywordtype">int</span> i;
<a name="l02058"></a>02058     <span class="keywordflow">if</span>( serial_type==7 ){
<a name="l02059"></a>02059       assert( <span class="keyword">sizeof</span>(v)==<span class="keyword">sizeof</span>(pMem-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>) );
<a name="l02060"></a>02060       memcpy(&amp;v, &amp;pMem-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>, <span class="keyword">sizeof</span>(v));
<a name="l02061"></a>02061       <a class="code" href="vdbeaux_8c.html#a4a933e8ee6cfece9fd82e1c6f6a9baac">swapMixedEndianFloat</a>(v);
<a name="l02062"></a>02062     }<span class="keywordflow">else</span>{
<a name="l02063"></a>02063       v = pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l02064"></a>02064     }
<a name="l02065"></a>02065     len = i = <a class="code" href="vdbeaux_8c.html#a002b233ebea0d972e5bc2964f5fe5de6">sqlite3VdbeSerialTypeLen</a>(serial_type);
<a name="l02066"></a>02066     assert( len&lt;=nBuf );
<a name="l02067"></a>02067     <span class="keywordflow">while</span>( i-- ){
<a name="l02068"></a>02068       buf[i] = (v&amp;0xFF);
<a name="l02069"></a>02069       v &gt;&gt;= 8;
<a name="l02070"></a>02070     }
<a name="l02071"></a>02071     <span class="keywordflow">return</span> len;
<a name="l02072"></a>02072   }
<a name="l02073"></a>02073 
<a name="l02074"></a>02074   <span class="comment">/* String or blob */</span>
<a name="l02075"></a>02075   <span class="keywordflow">if</span>( serial_type&gt;=12 ){
<a name="l02076"></a>02076     assert( pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> + ((pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a9433e8fe887266736d2e795fe0b71fd3">MEM_Zero</a>)?pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>:0)
<a name="l02077"></a>02077              == <a class="code" href="vdbeaux_8c.html#a002b233ebea0d972e5bc2964f5fe5de6">sqlite3VdbeSerialTypeLen</a>(serial_type) );
<a name="l02078"></a>02078     assert( pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>&lt;=nBuf );
<a name="l02079"></a>02079     len = pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>;
<a name="l02080"></a>02080     memcpy(buf, pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, len);
<a name="l02081"></a>02081     <span class="keywordflow">if</span>( pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a9433e8fe887266736d2e795fe0b71fd3">MEM_Zero</a> ){
<a name="l02082"></a>02082       len += pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l02083"></a>02083       <span class="keywordflow">if</span>( len&gt;nBuf ){
<a name="l02084"></a>02084         len = nBuf;
<a name="l02085"></a>02085       }
<a name="l02086"></a>02086       memset(&amp;buf[pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>], 0, len-pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>);
<a name="l02087"></a>02087     }
<a name="l02088"></a>02088     <span class="keywordflow">return</span> len;
<a name="l02089"></a>02089   }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091   <span class="comment">/* NULL or constants 0 or 1 */</span>
<a name="l02092"></a>02092   <span class="keywordflow">return</span> 0;
<a name="l02093"></a>02093 }
<a name="l02094"></a>02094 
<a name="l02095"></a>02095 <span class="comment">/*</span>
<a name="l02096"></a>02096 <span class="comment">** Deserialize the data blob pointed to by buf as serial type serial_type</span>
<a name="l02097"></a>02097 <span class="comment">** and store the result in pMem.  Return the number of bytes read.</span>
<a name="l02098"></a>02098 <span class="comment">*/</span> 
<a name="l02099"></a><a class="code" href="vdbeInt_8h.html#a2926a7207f4bdda331aee62e230ea1bc">02099</a> <span class="keywordtype">int</span> <a class="code" href="vdbeaux_8c.html#ac46e144d389f7ef81075005a4b5c41ef">sqlite3VdbeSerialGet</a>(
<a name="l02100"></a>02100   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf,     <span class="comment">/* Buffer to deserialize from */</span>
<a name="l02101"></a>02101   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> serial_type,              <span class="comment">/* Serial type to deserialize */</span>
<a name="l02102"></a>02102   <a class="code" href="structMem.html">Mem</a> *pMem                     <span class="comment">/* Memory cell to write value into */</span>
<a name="l02103"></a>02103 ){
<a name="l02104"></a>02104   <span class="keywordflow">switch</span>( serial_type ){
<a name="l02105"></a>02105     <span class="keywordflow">case</span> 10:   <span class="comment">/* Reserved for future use */</span>
<a name="l02106"></a>02106     <span class="keywordflow">case</span> 11:   <span class="comment">/* Reserved for future use */</span>
<a name="l02107"></a>02107     <span class="keywordflow">case</span> 0: {  <span class="comment">/* NULL */</span>
<a name="l02108"></a>02108       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;
<a name="l02109"></a>02109       <span class="keywordflow">break</span>;
<a name="l02110"></a>02110     }
<a name="l02111"></a>02111     <span class="keywordflow">case</span> 1: { <span class="comment">/* 1-byte signed integer */</span>
<a name="l02112"></a>02112       pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = (<span class="keywordtype">signed</span> char)buf[0];
<a name="l02113"></a>02113       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l02114"></a>02114       <span class="keywordflow">return</span> 1;
<a name="l02115"></a>02115     }
<a name="l02116"></a>02116     <span class="keywordflow">case</span> 2: { <span class="comment">/* 2-byte signed integer */</span>
<a name="l02117"></a>02117       pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = (((<span class="keywordtype">signed</span> char)buf[0])&lt;&lt;8) | buf[1];
<a name="l02118"></a>02118       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l02119"></a>02119       <span class="keywordflow">return</span> 2;
<a name="l02120"></a>02120     }
<a name="l02121"></a>02121     <span class="keywordflow">case</span> 3: { <span class="comment">/* 3-byte signed integer */</span>
<a name="l02122"></a>02122       pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = (((<span class="keywordtype">signed</span> char)buf[0])&lt;&lt;16) | (buf[1]&lt;&lt;8) | buf[2];
<a name="l02123"></a>02123       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l02124"></a>02124       <span class="keywordflow">return</span> 3;
<a name="l02125"></a>02125     }
<a name="l02126"></a>02126     <span class="keywordflow">case</span> 4: { <span class="comment">/* 4-byte signed integer */</span>
<a name="l02127"></a>02127       pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = (buf[0]&lt;&lt;24) | (buf[1]&lt;&lt;16) | (buf[2]&lt;&lt;8) | buf[3];
<a name="l02128"></a>02128       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l02129"></a>02129       <span class="keywordflow">return</span> 4;
<a name="l02130"></a>02130     }
<a name="l02131"></a>02131     <span class="keywordflow">case</span> 5: { <span class="comment">/* 6-byte signed integer */</span>
<a name="l02132"></a>02132       <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> x = (((<span class="keywordtype">signed</span> char)buf[0])&lt;&lt;8) | buf[1];
<a name="l02133"></a>02133       <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> y = (buf[2]&lt;&lt;24) | (buf[3]&lt;&lt;16) | (buf[4]&lt;&lt;8) | buf[5];
<a name="l02134"></a>02134       x = (x&lt;&lt;32) | y;
<a name="l02135"></a>02135       pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = *(<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>*)&amp;x;
<a name="l02136"></a>02136       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l02137"></a>02137       <span class="keywordflow">return</span> 6;
<a name="l02138"></a>02138     }
<a name="l02139"></a>02139     <span class="keywordflow">case</span> 6:   <span class="comment">/* 8-byte signed integer */</span>
<a name="l02140"></a>02140     <span class="keywordflow">case</span> 7: { <span class="comment">/* IEEE floating point */</span>
<a name="l02141"></a>02141       <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> x;
<a name="l02142"></a>02142       <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> y;
<a name="l02143"></a>02143 <span class="preprocessor">#if !defined(NDEBUG) &amp;&amp; !defined(SQLITE_OMIT_FLOATING_POINT)</span>
<a name="l02144"></a>02144 <span class="preprocessor"></span>      <span class="comment">/* Verify that integers and floating point values use the same</span>
<a name="l02145"></a>02145 <span class="comment">      ** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is</span>
<a name="l02146"></a>02146 <span class="comment">      ** defined that 64-bit floating point values really are mixed</span>
<a name="l02147"></a>02147 <span class="comment">      ** endian.</span>
<a name="l02148"></a>02148 <span class="comment">      */</span>
<a name="l02149"></a>02149       <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> t1 = ((<a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a>)0x3ff00000)&lt;&lt;32;
<a name="l02150"></a>02150       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> r1 = 1.0;
<a name="l02151"></a>02151       <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> t2 = t1;
<a name="l02152"></a>02152       <a class="code" href="vdbeaux_8c.html#a4a933e8ee6cfece9fd82e1c6f6a9baac">swapMixedEndianFloat</a>(t2);
<a name="l02153"></a>02153       assert( <span class="keyword">sizeof</span>(r1)==<span class="keyword">sizeof</span>(t2) &amp;&amp; memcmp(&amp;r1, &amp;t2, <span class="keyword">sizeof</span>(r1))==0 );
<a name="l02154"></a>02154 <span class="preprocessor">#endif</span>
<a name="l02155"></a>02155 <span class="preprocessor"></span>
<a name="l02156"></a>02156       x = (buf[0]&lt;&lt;24) | (buf[1]&lt;&lt;16) | (buf[2]&lt;&lt;8) | buf[3];
<a name="l02157"></a>02157       y = (buf[4]&lt;&lt;24) | (buf[5]&lt;&lt;16) | (buf[6]&lt;&lt;8) | buf[7];
<a name="l02158"></a>02158       x = (x&lt;&lt;32) | y;
<a name="l02159"></a>02159       <span class="keywordflow">if</span>( serial_type==6 ){
<a name="l02160"></a>02160         pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = *(<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>*)&amp;x;
<a name="l02161"></a>02161         pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l02162"></a>02162       }<span class="keywordflow">else</span>{
<a name="l02163"></a>02163         assert( <span class="keyword">sizeof</span>(x)==8 &amp;&amp; <span class="keyword">sizeof</span>(pMem-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>)==8 );
<a name="l02164"></a>02164         <a class="code" href="vdbeaux_8c.html#a4a933e8ee6cfece9fd82e1c6f6a9baac">swapMixedEndianFloat</a>(x);
<a name="l02165"></a>02165         memcpy(&amp;pMem-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>, &amp;x, <span class="keyword">sizeof</span>(x));
<a name="l02166"></a>02166         pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="sqliteInt_8h.html#a82c2a680007adffbdf6e95315b02477d">sqlite3IsNaN</a>(pMem-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>) ? <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> : <a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>;
<a name="l02167"></a>02167       }
<a name="l02168"></a>02168       <span class="keywordflow">return</span> 8;
<a name="l02169"></a>02169     }
<a name="l02170"></a>02170     <span class="keywordflow">case</span> 8:    <span class="comment">/* Integer 0 */</span>
<a name="l02171"></a>02171     <span class="keywordflow">case</span> 9: {  <span class="comment">/* Integer 1 */</span>
<a name="l02172"></a>02172       pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = serial_type-8;
<a name="l02173"></a>02173       pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l02174"></a>02174       <span class="keywordflow">return</span> 0;
<a name="l02175"></a>02175     }
<a name="l02176"></a>02176     <span class="keywordflow">default</span>: {
<a name="l02177"></a>02177       <span class="keywordtype">int</span> len = (serial_type-12)/2;
<a name="l02178"></a>02178       pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> = (<span class="keywordtype">char</span> *)buf;
<a name="l02179"></a>02179       pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = len;
<a name="l02180"></a>02180       pMem-&gt;<a class="code" href="structMem.html#a081ea2f86933d68a8940785b62f638ef">xDel</a> = 0;
<a name="l02181"></a>02181       <span class="keywordflow">if</span>( serial_type&amp;0x01 ){
<a name="l02182"></a>02182         pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a> | <a class="code" href="vdbeInt_8h.html#a38c45feb5b1c4fd9e789aaafcf7e47cd">MEM_Ephem</a>;
<a name="l02183"></a>02183       }<span class="keywordflow">else</span>{
<a name="l02184"></a>02184         pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a4def40a3702fc50cd2f3a5820e1a4f68">MEM_Blob</a> | <a class="code" href="vdbeInt_8h.html#a38c45feb5b1c4fd9e789aaafcf7e47cd">MEM_Ephem</a>;
<a name="l02185"></a>02185       }
<a name="l02186"></a>02186       <span class="keywordflow">return</span> len;
<a name="l02187"></a>02187     }
<a name="l02188"></a>02188   }
<a name="l02189"></a>02189   <span class="keywordflow">return</span> 0;
<a name="l02190"></a>02190 }
<a name="l02191"></a>02191 
<a name="l02192"></a>02192 
<a name="l02193"></a>02193 <span class="comment">/*</span>
<a name="l02194"></a>02194 <span class="comment">** Given the nKey-byte encoding of a record in pKey[], parse the</span>
<a name="l02195"></a>02195 <span class="comment">** record into a UnpackedRecord structure.  Return a pointer to</span>
<a name="l02196"></a>02196 <span class="comment">** that structure.</span>
<a name="l02197"></a>02197 <span class="comment">**</span>
<a name="l02198"></a>02198 <span class="comment">** The calling function might provide szSpace bytes of memory</span>
<a name="l02199"></a>02199 <span class="comment">** space at pSpace.  This space can be used to hold the returned</span>
<a name="l02200"></a>02200 <span class="comment">** VDbeParsedRecord structure if it is large enough.  If it is</span>
<a name="l02201"></a>02201 <span class="comment">** not big enough, space is obtained from sqlite3_malloc().</span>
<a name="l02202"></a>02202 <span class="comment">**</span>
<a name="l02203"></a>02203 <span class="comment">** The returned structure should be closed by a call to</span>
<a name="l02204"></a>02204 <span class="comment">** sqlite3VdbeDeleteUnpackedRecord().</span>
<a name="l02205"></a>02205 <span class="comment">*/</span> 
<a name="l02206"></a><a class="code" href="vdbeaux_8c.html#a378f2411289e03acb0af135fc2e35c12">02206</a> <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *<a class="code" href="vdbe_8h.html#a3b886b85d57a0b60bc5be0478f55e8d9">sqlite3VdbeRecordUnpack</a>(
<a name="l02207"></a>02207   <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKeyInfo,     <span class="comment">/* Information about the record format */</span>
<a name="l02208"></a>02208   <span class="keywordtype">int</span> nKey,              <span class="comment">/* Size of the binary record */</span>
<a name="l02209"></a>02209   <span class="keyword">const</span> <span class="keywordtype">void</span> *pKey,      <span class="comment">/* The binary record */</span>
<a name="l02210"></a>02210   <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *pSpace,<span class="comment">/* Space available to hold resulting object */</span>
<a name="l02211"></a>02211   <span class="keywordtype">int</span> szSpace            <span class="comment">/* Size of pSpace[] in bytes */</span>
<a name="l02212"></a>02212 ){
<a name="l02213"></a>02213   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *aKey = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)pKey;
<a name="l02214"></a>02214   <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *p;
<a name="l02215"></a>02215   <span class="keywordtype">int</span> nByte;
<a name="l02216"></a>02216   <span class="keywordtype">int</span> idx, <a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>;
<a name="l02217"></a>02217   <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> u;                 <span class="comment">/* Unsigned loop counter */</span>
<a name="l02218"></a>02218   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> szHdr;
<a name="l02219"></a>02219   <a class="code" href="structMem.html">Mem</a> *pMem;
<a name="l02220"></a>02220   
<a name="l02221"></a>02221   assert( <span class="keyword">sizeof</span>(<a class="code" href="structMem.html">Mem</a>)&gt;<span class="keyword">sizeof</span>(*p) );
<a name="l02222"></a>02222   nByte = <span class="keyword">sizeof</span>(<a class="code" href="structMem.html">Mem</a>)*(pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#af70436487a95e445d540bfc4ca1d3f0b">nField</a>+2);
<a name="l02223"></a>02223   <span class="keywordflow">if</span>( nByte&gt;szSpace ){
<a name="l02224"></a>02224     p = <a class="code" href="malloc_8c.html#a043f868d32456bd7cdca4a62837277c1">sqlite3DbMallocRaw</a>(pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#af2e7a3a411f5ca1ccf6de77d320b59db">db</a>, nByte);
<a name="l02225"></a>02225     <span class="keywordflow">if</span>( p==0 ) <span class="keywordflow">return</span> 0;
<a name="l02226"></a>02226     p-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> = <a class="code" href="sqliteInt_8h.html#a12b23e447ac92f1ef6df984ed9e80d81">UNPACKED_NEED_FREE</a> | <a class="code" href="sqliteInt_8h.html#a0397b1ab321885beb247701fbbd25da1">UNPACKED_NEED_DESTROY</a>;
<a name="l02227"></a>02227   }<span class="keywordflow">else</span>{
<a name="l02228"></a>02228     p = pSpace;
<a name="l02229"></a>02229     p-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> = <a class="code" href="sqliteInt_8h.html#a0397b1ab321885beb247701fbbd25da1">UNPACKED_NEED_DESTROY</a>;
<a name="l02230"></a>02230   }
<a name="l02231"></a>02231   p-&gt;<a class="code" href="structUnpackedRecord.html#aeb43e7a1e300857cab2cbe98eacd575b">pKeyInfo</a> = pKeyInfo;
<a name="l02232"></a>02232   p-&gt;<a class="code" href="structUnpackedRecord.html#a2c5062735cdbc5039679d255cc900668">nField</a> = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#af70436487a95e445d540bfc4ca1d3f0b">nField</a> + 1;
<a name="l02233"></a>02233   p-&gt;<a class="code" href="structUnpackedRecord.html#a3299c322ceb8b758dacc59701021ae9f">aMem</a> = pMem = &amp;((<a class="code" href="structMem.html">Mem</a>*)p)[1];
<a name="l02234"></a>02234   idx = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(aKey, szHdr);
<a name="l02235"></a>02235   d = szHdr;
<a name="l02236"></a>02236   u = 0;
<a name="l02237"></a>02237   <span class="keywordflow">while</span>( idx&lt;szHdr &amp;&amp; u&lt;p-&gt;nField ){
<a name="l02238"></a>02238     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> serial_type;
<a name="l02239"></a>02239 
<a name="l02240"></a>02240     idx += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>( aKey+idx, serial_type);
<a name="l02241"></a>02241     <span class="keywordflow">if</span>( d&gt;=nKey &amp;&amp; <a class="code" href="vdbeaux_8c.html#a002b233ebea0d972e5bc2964f5fe5de6">sqlite3VdbeSerialTypeLen</a>(serial_type)&gt;0 ) <span class="keywordflow">break</span>;
<a name="l02242"></a>02242     pMem-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#a37972825f9a148668e979be12465e832">enc</a>;
<a name="l02243"></a>02243     pMem-&gt;<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#af2e7a3a411f5ca1ccf6de77d320b59db">db</a>;
<a name="l02244"></a>02244     pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = 0;
<a name="l02245"></a>02245     pMem-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l02246"></a>02246     d += <a class="code" href="vdbeaux_8c.html#ac46e144d389f7ef81075005a4b5c41ef">sqlite3VdbeSerialGet</a>(&amp;aKey[d], serial_type, pMem);
<a name="l02247"></a>02247     pMem++;
<a name="l02248"></a>02248     u++;
<a name="l02249"></a>02249   }
<a name="l02250"></a>02250   assert( u&lt;=pKeyInfo-&gt;nField + 1 );
<a name="l02251"></a>02251   p-&gt;<a class="code" href="structUnpackedRecord.html#a2c5062735cdbc5039679d255cc900668">nField</a> = u;
<a name="l02252"></a>02252   <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)p;
<a name="l02253"></a>02253 }
<a name="l02254"></a>02254 
<a name="l02255"></a>02255 <span class="comment">/*</span>
<a name="l02256"></a>02256 <span class="comment">** This routine destroys a UnpackedRecord object</span>
<a name="l02257"></a>02257 <span class="comment">*/</span>
<a name="l02258"></a><a class="code" href="vdbeaux_8c.html#aa7d51d9ecd91c5dde87f55f26bebaabe">02258</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#a92e9ed579bf09eeeb3b4006f669753a0">sqlite3VdbeDeleteUnpackedRecord</a>(<a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *p){
<a name="l02259"></a>02259   <span class="keywordflow">if</span>( p ){
<a name="l02260"></a>02260     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a0397b1ab321885beb247701fbbd25da1">UNPACKED_NEED_DESTROY</a> ){
<a name="l02261"></a>02261       <span class="keywordtype">int</span> i;
<a name="l02262"></a>02262       <a class="code" href="structMem.html">Mem</a> *pMem;
<a name="l02263"></a>02263       <span class="keywordflow">for</span>(i=0, pMem=p-&gt;<a class="code" href="structUnpackedRecord.html#a3299c322ceb8b758dacc59701021ae9f">aMem</a>; i&lt;p-&gt;nField; i++, pMem++){
<a name="l02264"></a>02264         <span class="keywordflow">if</span>( pMem-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> ){
<a name="l02265"></a>02265           <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(pMem);
<a name="l02266"></a>02266         }
<a name="l02267"></a>02267       }
<a name="l02268"></a>02268     }
<a name="l02269"></a>02269     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a12b23e447ac92f1ef6df984ed9e80d81">UNPACKED_NEED_FREE</a> ){
<a name="l02270"></a>02270       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(p-&gt;<a class="code" href="structUnpackedRecord.html#aeb43e7a1e300857cab2cbe98eacd575b">pKeyInfo</a>-&gt;<a class="code" href="structKeyInfo.html#af2e7a3a411f5ca1ccf6de77d320b59db">db</a>, p);
<a name="l02271"></a>02271     }
<a name="l02272"></a>02272   }
<a name="l02273"></a>02273 }
<a name="l02274"></a>02274 
<a name="l02275"></a>02275 <span class="comment">/*</span>
<a name="l02276"></a>02276 <span class="comment">** This function compares the two table rows or index records</span>
<a name="l02277"></a>02277 <span class="comment">** specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero</span>
<a name="l02278"></a>02278 <span class="comment">** or positive integer if key1 is less than, equal to or </span>
<a name="l02279"></a>02279 <span class="comment">** greater than key2.  The {nKey1, pKey1} key must be a blob</span>
<a name="l02280"></a>02280 <span class="comment">** created by th OP_MakeRecord opcode of the VDBE.  The pPKey2</span>
<a name="l02281"></a>02281 <span class="comment">** key must be a parsed key such as obtained from</span>
<a name="l02282"></a>02282 <span class="comment">** sqlite3VdbeParseRecord.</span>
<a name="l02283"></a>02283 <span class="comment">**</span>
<a name="l02284"></a>02284 <span class="comment">** Key1 and Key2 do not have to contain the same number of fields.</span>
<a name="l02285"></a>02285 <span class="comment">** The key with fewer fields is usually compares less than the </span>
<a name="l02286"></a>02286 <span class="comment">** longer key.  However if the UNPACKED_INCRKEY flags in pPKey2 is set</span>
<a name="l02287"></a>02287 <span class="comment">** and the common prefixes are equal, then key1 is less than key2.</span>
<a name="l02288"></a>02288 <span class="comment">** Or if the UNPACKED_MATCH_PREFIX flag is set and the prefixes are</span>
<a name="l02289"></a>02289 <span class="comment">** equal, then the keys are considered to be equal and</span>
<a name="l02290"></a>02290 <span class="comment">** the parts beyond the common prefix are ignored.</span>
<a name="l02291"></a>02291 <span class="comment">**</span>
<a name="l02292"></a>02292 <span class="comment">** If the UNPACKED_IGNORE_ROWID flag is set, then the last byte of</span>
<a name="l02293"></a>02293 <span class="comment">** the header of pKey1 is ignored.  It is assumed that pKey1 is</span>
<a name="l02294"></a>02294 <span class="comment">** an index key, and thus ends with a rowid value.  The last byte</span>
<a name="l02295"></a>02295 <span class="comment">** of the header will therefore be the serial type of the rowid:</span>
<a name="l02296"></a>02296 <span class="comment">** one of 1, 2, 3, 4, 5, 6, 8, or 9 - the integer serial types.</span>
<a name="l02297"></a>02297 <span class="comment">** The serial type of the final rowid will always be a single byte.</span>
<a name="l02298"></a>02298 <span class="comment">** By ignoring this last byte of the header, we force the comparison</span>
<a name="l02299"></a>02299 <span class="comment">** to ignore the rowid at the end of key1.</span>
<a name="l02300"></a>02300 <span class="comment">*/</span>
<a name="l02301"></a><a class="code" href="vdbeaux_8c.html#a34faf8bcd999edda053db44d27156c0b">02301</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8h.html#ad4cc2261adcd9523c071abf47847dafa">sqlite3VdbeRecordCompare</a>(
<a name="l02302"></a>02302   <span class="keywordtype">int</span> nKey1, <span class="keyword">const</span> <span class="keywordtype">void</span> *pKey1, <span class="comment">/* Left key */</span>
<a name="l02303"></a>02303   <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *pPKey2        <span class="comment">/* Right key */</span>
<a name="l02304"></a>02304 ){
<a name="l02305"></a>02305   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> d1;            <span class="comment">/* Offset into aKey[] of next data element */</span>
<a name="l02306"></a>02306   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> idx1;          <span class="comment">/* Offset into aKey[] of next header element */</span>
<a name="l02307"></a>02307   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> szHdr1;        <span class="comment">/* Number of bytes in header */</span>
<a name="l02308"></a>02308   <span class="keywordtype">int</span> i = 0;
<a name="l02309"></a>02309   <span class="keywordtype">int</span> nField;
<a name="l02310"></a>02310   <span class="keywordtype">int</span> rc = 0;
<a name="l02311"></a>02311   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *aKey1 = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)pKey1;
<a name="l02312"></a>02312   <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKeyInfo;
<a name="l02313"></a>02313   <a class="code" href="structMem.html">Mem</a> mem1;
<a name="l02314"></a>02314 
<a name="l02315"></a>02315   pKeyInfo = pPKey2-&gt;<a class="code" href="structUnpackedRecord.html#aeb43e7a1e300857cab2cbe98eacd575b">pKeyInfo</a>;
<a name="l02316"></a>02316   mem1.<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#a37972825f9a148668e979be12465e832">enc</a>;
<a name="l02317"></a>02317   mem1.<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#af2e7a3a411f5ca1ccf6de77d320b59db">db</a>;
<a name="l02318"></a>02318   mem1.<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = 0;
<a name="l02319"></a>02319   mem1.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l02320"></a>02320   
<a name="l02321"></a>02321   idx1 = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(aKey1, szHdr1);
<a name="l02322"></a>02322   d1 = szHdr1;
<a name="l02323"></a>02323   <span class="keywordflow">if</span>( pPKey2-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a1650685ebf83cd7720588c3ef7449f41">UNPACKED_IGNORE_ROWID</a> ){
<a name="l02324"></a>02324     szHdr1--;
<a name="l02325"></a>02325   }
<a name="l02326"></a>02326   nField = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#af70436487a95e445d540bfc4ca1d3f0b">nField</a>;
<a name="l02327"></a>02327   <span class="keywordflow">while</span>( idx1&lt;szHdr1 &amp;&amp; i&lt;pPKey2-&gt;nField ){
<a name="l02328"></a>02328     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> serial_type1;
<a name="l02329"></a>02329 
<a name="l02330"></a>02330     <span class="comment">/* Read the serial types for the next element in each key. */</span>
<a name="l02331"></a>02331     idx1 += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>( aKey1+idx1, serial_type1 );
<a name="l02332"></a>02332     <span class="keywordflow">if</span>( d1&gt;=nKey1 &amp;&amp; <a class="code" href="vdbeaux_8c.html#a002b233ebea0d972e5bc2964f5fe5de6">sqlite3VdbeSerialTypeLen</a>(serial_type1)&gt;0 ) <span class="keywordflow">break</span>;
<a name="l02333"></a>02333 
<a name="l02334"></a>02334     <span class="comment">/* Extract the values to be compared.</span>
<a name="l02335"></a>02335 <span class="comment">    */</span>
<a name="l02336"></a>02336     d1 += <a class="code" href="vdbeaux_8c.html#ac46e144d389f7ef81075005a4b5c41ef">sqlite3VdbeSerialGet</a>(&amp;aKey1[d1], serial_type1, &amp;mem1);
<a name="l02337"></a>02337 
<a name="l02338"></a>02338     <span class="comment">/* Do the comparison</span>
<a name="l02339"></a>02339 <span class="comment">    */</span>
<a name="l02340"></a>02340     rc = <a class="code" href="vdbeInt_8h.html#aec697f0479b721b582dcab0baf2dd031">sqlite3MemCompare</a>(&amp;mem1, &amp;pPKey2-&gt;<a class="code" href="structUnpackedRecord.html#a3299c322ceb8b758dacc59701021ae9f">aMem</a>[i],
<a name="l02341"></a>02341                            i&lt;nField ? pKeyInfo-&gt;aColl[i] : 0);
<a name="l02342"></a>02342     <span class="keywordflow">if</span>( rc!=0 ){
<a name="l02343"></a>02343       <span class="keywordflow">break</span>;
<a name="l02344"></a>02344     }
<a name="l02345"></a>02345     i++;
<a name="l02346"></a>02346   }
<a name="l02347"></a>02347   <span class="keywordflow">if</span>( mem1.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> ) <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(&amp;mem1);
<a name="l02348"></a>02348 
<a name="l02349"></a>02349   <span class="keywordflow">if</span>( rc==0 ){
<a name="l02350"></a>02350     <span class="comment">/* rc==0 here means that one of the keys ran out of fields and</span>
<a name="l02351"></a>02351 <span class="comment">    ** all the fields up to that point were equal. If the UNPACKED_INCRKEY</span>
<a name="l02352"></a>02352 <span class="comment">    ** flag is set, then break the tie by treating key2 as larger.</span>
<a name="l02353"></a>02353 <span class="comment">    ** If the UPACKED_PREFIX_MATCH flag is set, then keys with common prefixes</span>
<a name="l02354"></a>02354 <span class="comment">    ** are considered to be equal.  Otherwise, the longer key is the </span>
<a name="l02355"></a>02355 <span class="comment">    ** larger.  As it happens, the pPKey2 will always be the longer</span>
<a name="l02356"></a>02356 <span class="comment">    ** if there is a difference.</span>
<a name="l02357"></a>02357 <span class="comment">    */</span>
<a name="l02358"></a>02358     <span class="keywordflow">if</span>( pPKey2-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a3908fc771b61da3bcd4c146de8e1515f">UNPACKED_INCRKEY</a> ){
<a name="l02359"></a>02359       rc = -1;
<a name="l02360"></a>02360     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pPKey2-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#ae23637243712af21268d993ba3c69d18">UNPACKED_PREFIX_MATCH</a> ){
<a name="l02361"></a>02361       <span class="comment">/* Leave rc==0 */</span>
<a name="l02362"></a>02362     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( idx1&lt;szHdr1 ){
<a name="l02363"></a>02363       rc = 1;
<a name="l02364"></a>02364     }
<a name="l02365"></a>02365   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ac5fe4bd0172a1f11f41f678528a7b21e">aSortOrder</a> &amp;&amp; i&lt;pKeyInfo-&gt;nField
<a name="l02366"></a>02366                &amp;&amp; pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ac5fe4bd0172a1f11f41f678528a7b21e">aSortOrder</a>[i] ){
<a name="l02367"></a>02367     rc = -rc;
<a name="l02368"></a>02368   }
<a name="l02369"></a>02369 
<a name="l02370"></a>02370   <span class="keywordflow">return</span> rc;
<a name="l02371"></a>02371 }
<a name="l02372"></a>02372  
<a name="l02373"></a>02373 
<a name="l02374"></a>02374 <span class="comment">/*</span>
<a name="l02375"></a>02375 <span class="comment">** pCur points at an index entry created using the OP_MakeRecord opcode.</span>
<a name="l02376"></a>02376 <span class="comment">** Read the rowid (the last field in the record) and store it in *rowid.</span>
<a name="l02377"></a>02377 <span class="comment">** Return SQLITE_OK if everything works, or an error code otherwise.</span>
<a name="l02378"></a>02378 <span class="comment">*/</span>
<a name="l02379"></a><a class="code" href="vdbeInt_8h.html#a0ace9511ec35d4505c420bcc7d19540b">02379</a> <span class="keywordtype">int</span> <a class="code" href="vdbeaux_8c.html#ad5f1e2b1c24e382e4c64868bd2c8f707">sqlite3VdbeIdxRowid</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> *rowid){
<a name="l02380"></a>02380   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> nCellKey = 0;
<a name="l02381"></a>02381   <span class="keywordtype">int</span> rc;
<a name="l02382"></a>02382   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> szHdr;        <span class="comment">/* Size of the header */</span>
<a name="l02383"></a>02383   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> typeRowid;    <span class="comment">/* Serial type of the rowid */</span>
<a name="l02384"></a>02384   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> lenRowid;     <span class="comment">/* Size of the rowid */</span>
<a name="l02385"></a>02385   <a class="code" href="structMem.html">Mem</a> m, v;
<a name="l02386"></a>02386 
<a name="l02387"></a>02387   <a class="code" href="btree_8c.html#a2d5023d925e7eade74a33a94fbbc45e0">sqlite3BtreeKeySize</a>(pCur, &amp;nCellKey);
<a name="l02388"></a>02388   <span class="keywordflow">if</span>( nCellKey&lt;=0 ){
<a name="l02389"></a>02389     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l02390"></a>02390   }
<a name="l02391"></a>02391   m.<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = 0;
<a name="l02392"></a>02392   m.<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = 0;
<a name="l02393"></a>02393   m.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l02394"></a>02394   rc = <a class="code" href="vdbeInt_8h.html#a923c9ff0b25fe7535097420b26712ee1">sqlite3VdbeMemFromBtree</a>(pCur, 0, nCellKey, 1, &amp;m);
<a name="l02395"></a>02395   <span class="keywordflow">if</span>( rc ){
<a name="l02396"></a>02396     <span class="keywordflow">return</span> rc;
<a name="l02397"></a>02397   }
<a name="l02398"></a>02398   (void)<a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>((<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)m.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, szHdr);
<a name="l02399"></a>02399   (void)<a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>((<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)&amp;m.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[szHdr-1], typeRowid);
<a name="l02400"></a>02400   lenRowid = <a class="code" href="vdbeaux_8c.html#a002b233ebea0d972e5bc2964f5fe5de6">sqlite3VdbeSerialTypeLen</a>(typeRowid);
<a name="l02401"></a>02401   <a class="code" href="vdbeaux_8c.html#ac46e144d389f7ef81075005a4b5c41ef">sqlite3VdbeSerialGet</a>((<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)&amp;m.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[m.<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>-lenRowid], typeRowid, &amp;v);
<a name="l02402"></a>02402   *rowid = v.<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l02403"></a>02403   <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(&amp;m);
<a name="l02404"></a>02404   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02405"></a>02405 }
<a name="l02406"></a>02406 
<a name="l02407"></a>02407 <span class="comment">/*</span>
<a name="l02408"></a>02408 <span class="comment">** Compare the key of the index entry that cursor pC is point to against</span>
<a name="l02409"></a>02409 <span class="comment">** the key string in pKey (of length nKey).  Write into *pRes a number</span>
<a name="l02410"></a>02410 <span class="comment">** that is negative, zero, or positive if pC is less than, equal to,</span>
<a name="l02411"></a>02411 <span class="comment">** or greater than pKey.  Return SQLITE_OK on success.</span>
<a name="l02412"></a>02412 <span class="comment">**</span>
<a name="l02413"></a>02413 <span class="comment">** pKey is either created without a rowid or is truncated so that it</span>
<a name="l02414"></a>02414 <span class="comment">** omits the rowid at the end.  The rowid at the end of the index entry</span>
<a name="l02415"></a>02415 <span class="comment">** is ignored as well.  Hence, this routine only compares the prefixes </span>
<a name="l02416"></a>02416 <span class="comment">** of the keys prior to the final rowid, not the entire key.</span>
<a name="l02417"></a>02417 <span class="comment">**</span>
<a name="l02418"></a>02418 <span class="comment">** pUnpacked may be an unpacked version of pKey,nKey.  If pUnpacked is</span>
<a name="l02419"></a>02419 <span class="comment">** supplied it is used in place of pKey,nKey.</span>
<a name="l02420"></a>02420 <span class="comment">*/</span>
<a name="l02421"></a><a class="code" href="vdbeInt_8h.html#a154c2f3a6141ca31e27189300b8316a7">02421</a> <span class="keywordtype">int</span> <a class="code" href="vdbeaux_8c.html#a1fadd000b100ed3f3b10f697e73f1bd6">sqlite3VdbeIdxKeyCompare</a>(
<a name="l02422"></a>02422   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC,             <span class="comment">/* The cursor to compare against */</span>
<a name="l02423"></a>02423   <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *pUnpacked,  <span class="comment">/* Unpacked version of pKey and nKey */</span>
<a name="l02424"></a>02424   <span class="keywordtype">int</span> *res                    <span class="comment">/* Write the comparison result here */</span>
<a name="l02425"></a>02425 ){
<a name="l02426"></a>02426   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> nCellKey = 0;
<a name="l02427"></a>02427   <span class="keywordtype">int</span> rc;
<a name="l02428"></a>02428   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur = pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>;
<a name="l02429"></a>02429   <a class="code" href="structMem.html">Mem</a> m;
<a name="l02430"></a>02430 
<a name="l02431"></a>02431   <a class="code" href="btree_8c.html#a2d5023d925e7eade74a33a94fbbc45e0">sqlite3BtreeKeySize</a>(pCur, &amp;nCellKey);
<a name="l02432"></a>02432   <span class="keywordflow">if</span>( nCellKey&lt;=0 ){
<a name="l02433"></a>02433     *res = 0;
<a name="l02434"></a>02434     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02435"></a>02435   }
<a name="l02436"></a>02436   m.<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = 0;
<a name="l02437"></a>02437   m.<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = 0;
<a name="l02438"></a>02438   m.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l02439"></a>02439   rc = <a class="code" href="vdbeInt_8h.html#a923c9ff0b25fe7535097420b26712ee1">sqlite3VdbeMemFromBtree</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, 0, nCellKey, 1, &amp;m);
<a name="l02440"></a>02440   <span class="keywordflow">if</span>( rc ){
<a name="l02441"></a>02441     <span class="keywordflow">return</span> rc;
<a name="l02442"></a>02442   }
<a name="l02443"></a>02443   assert( pUnpacked-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a1650685ebf83cd7720588c3ef7449f41">UNPACKED_IGNORE_ROWID</a> );
<a name="l02444"></a>02444   *res = <a class="code" href="vdbe_8h.html#ad4cc2261adcd9523c071abf47847dafa">sqlite3VdbeRecordCompare</a>(m.<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>, m.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, pUnpacked);
<a name="l02445"></a>02445   <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(&amp;m);
<a name="l02446"></a>02446   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02447"></a>02447 }
<a name="l02448"></a>02448 
<a name="l02449"></a>02449 <span class="comment">/*</span>
<a name="l02450"></a>02450 <span class="comment">** This routine sets the value to be returned by subsequent calls to</span>
<a name="l02451"></a>02451 <span class="comment">** sqlite3_changes() on the database handle &apos;db&apos;. </span>
<a name="l02452"></a>02452 <span class="comment">*/</span>
<a name="l02453"></a><a class="code" href="vdbeaux_8c.html#a2025da617eb29907c8edc7da80988e1d">02453</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#a20b9440f5f5fde83614215876ac0e13a">sqlite3VdbeSetChanges</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <span class="keywordtype">int</span> nChange){
<a name="l02454"></a>02454   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(db-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l02455"></a>02455   db-&gt;<a class="code" href="structsqlite3.html#aaafd4eaa11ae4ea51d84ed4564a8d372">nChange</a> = nChange;
<a name="l02456"></a>02456   db-&gt;<a class="code" href="structsqlite3.html#ade95b396eda5eb5929851abb581cff3f">nTotalChange</a> += nChange;
<a name="l02457"></a>02457 }
<a name="l02458"></a>02458 
<a name="l02459"></a>02459 <span class="comment">/*</span>
<a name="l02460"></a>02460 <span class="comment">** Set a flag in the vdbe to update the change counter when it is finalised</span>
<a name="l02461"></a>02461 <span class="comment">** or reset.</span>
<a name="l02462"></a>02462 <span class="comment">*/</span>
<a name="l02463"></a><a class="code" href="vdbeaux_8c.html#a9105e586bfc6c2a0155a4762b33daaac">02463</a> <span class="keywordtype">void</span> <a class="code" href="vdbe_8h.html#a22fff0ed8212f3d787e80d22571b04b6">sqlite3VdbeCountChanges</a>(<a class="code" href="structVdbe.html">Vdbe</a> *v){
<a name="l02464"></a>02464   v-&gt;<a class="code" href="structVdbe.html#a448850e8bd320c590ca2d75588fe3a70">changeCntOn</a> = 1;
<a name="l02465"></a>02465 }
<a name="l02466"></a>02466 
<a name="l02467"></a>02467 <span class="comment">/*</span>
<a name="l02468"></a>02468 <span class="comment">** Mark every prepared statement associated with a database connection</span>
<a name="l02469"></a>02469 <span class="comment">** as expired.</span>
<a name="l02470"></a>02470 <span class="comment">**</span>
<a name="l02471"></a>02471 <span class="comment">** An expired statement means that recompilation of the statement is</span>
<a name="l02472"></a>02472 <span class="comment">** recommend.  Statements expire when things happen that make their</span>
<a name="l02473"></a>02473 <span class="comment">** programs obsolete.  Removing user-defined functions or collating</span>
<a name="l02474"></a>02474 <span class="comment">** sequences, or changing an authorization function are the types of</span>
<a name="l02475"></a>02475 <span class="comment">** things that make prepared statements obsolete.</span>
<a name="l02476"></a>02476 <span class="comment">*/</span>
<a name="l02477"></a><a class="code" href="vdbeaux_8c.html#a13fac39172538f998172c5574847790a">02477</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#ac49dbebed4f062b16e866f024c262e95">sqlite3ExpirePreparedStatements</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db){
<a name="l02478"></a>02478   <a class="code" href="structVdbe.html">Vdbe</a> *p;
<a name="l02479"></a>02479   <span class="keywordflow">for</span>(p = db-&gt;<a class="code" href="structsqlite3.html#a596f0301f43c5e25575c2a1403f8b571">pVdbe</a>; p; p=p-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a>){
<a name="l02480"></a>02480     p-&gt;<a class="code" href="structVdbe.html#ab281d7519a1e6f60163eab9b15048eda">expired</a> = 1;
<a name="l02481"></a>02481   }
<a name="l02482"></a>02482 }
<a name="l02483"></a>02483 
<a name="l02484"></a>02484 <span class="comment">/*</span>
<a name="l02485"></a>02485 <span class="comment">** Return the database associated with the Vdbe.</span>
<a name="l02486"></a>02486 <span class="comment">*/</span>
<a name="l02487"></a><a class="code" href="vdbeaux_8c.html#ad560289204cd0e224c2a4830787f5ff8">02487</a> <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="vdbe_8h.html#af0e1e3c12dca9f250170460e88bccdad">sqlite3VdbeDb</a>(<a class="code" href="structVdbe.html">Vdbe</a> *v){
<a name="l02488"></a>02488   <span class="keywordflow">return</span> v-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;
<a name="l02489"></a>02489 }
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:57 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
