<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: fts1.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>fts1.c</h1><a href="fts1_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* fts1 has a design flaw which can lead to database corruption (see</span>
<a name="l00002"></a>00002 <span class="comment">** below).  It is recommended not to use it any longer, instead use</span>
<a name="l00003"></a>00003 <span class="comment">** fts3 (or higher).  If you believe that your use of fts1 is safe,</span>
<a name="l00004"></a>00004 <span class="comment">** add -DSQLITE_ENABLE_BROKEN_FTS1=1 to your CFLAGS.</span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 <span class="preprocessor">#if (!defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1)) \</span>
<a name="l00007"></a>00007 <span class="preprocessor">        &amp;&amp; !defined(SQLITE_ENABLE_BROKEN_FTS1)</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#error fts1 has a design flaw and has been deprecated.</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="comment">/* The flaw is that fts1 uses the content table&apos;s unaliased rowid as</span>
<a name="l00011"></a>00011 <span class="comment">** the unique docid.  fts1 embeds the rowid in the index it builds,</span>
<a name="l00012"></a>00012 <span class="comment">** and expects the rowid to not change.  The SQLite VACUUM operation</span>
<a name="l00013"></a>00013 <span class="comment">** will renumber such rowids, thereby breaking fts1.  If you are using</span>
<a name="l00014"></a>00014 <span class="comment">** fts1 in a system which has disabled VACUUM, then you can continue</span>
<a name="l00015"></a>00015 <span class="comment">** to use it safely.  Note that PRAGMA auto_vacuum does NOT disable</span>
<a name="l00016"></a>00016 <span class="comment">** VACUUM, though systems using auto_vacuum are unlikely to invoke</span>
<a name="l00017"></a>00017 <span class="comment">** VACUUM.</span>
<a name="l00018"></a>00018 <span class="comment">**</span>
<a name="l00019"></a>00019 <span class="comment">** fts1 should be safe even across VACUUM if you only insert documents</span>
<a name="l00020"></a>00020 <span class="comment">** and never delete.</span>
<a name="l00021"></a>00021 <span class="comment">*/</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/* The author disclaims copyright to this source code.</span>
<a name="l00024"></a>00024 <span class="comment"> *</span>
<a name="l00025"></a>00025 <span class="comment"> * This is an SQLite module implementing full-text search.</span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">/*</span>
<a name="l00029"></a>00029 <span class="comment">** The code in this file is only compiled if:</span>
<a name="l00030"></a>00030 <span class="comment">**</span>
<a name="l00031"></a>00031 <span class="comment">**     * The FTS1 module is being built as an extension</span>
<a name="l00032"></a>00032 <span class="comment">**       (in which case SQLITE_CORE is not defined), or</span>
<a name="l00033"></a>00033 <span class="comment">**</span>
<a name="l00034"></a>00034 <span class="comment">**     * The FTS1 module is being built into the core of</span>
<a name="l00035"></a>00035 <span class="comment">**       SQLite (in which case SQLITE_ENABLE_FTS1 is defined).</span>
<a name="l00036"></a>00036 <span class="comment">*/</span>
<a name="l00037"></a>00037 <span class="preprocessor">#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1)</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#if defined(SQLITE_ENABLE_FTS1) &amp;&amp; !defined(SQLITE_CORE)</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor"># define SQLITE_CORE 1</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="fts1_8h.html">fts1.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="fts1__hash_8h.html">fts1_hash.h</a>&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="fts1__tokenizer_8h.html">fts1_tokenizer.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="sqlite3_8h.html">sqlite3.h</a>&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="sqlite3ext_8h.html">sqlite3ext.h</a>&quot;</span>
<a name="l00054"></a>00054 <a class="code" href="sqlite3ext_8h.html#afff1053b875c905fa8695b458d836b42">SQLITE_EXTENSION_INIT1</a>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="preprocessor">#if 0</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor"># define TRACE(A)  printf A; fflush(stdout)</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00060"></a><a class="code" href="fts1_8c.html#aeaae6edb1c0c3f3eaf73c0199c25afb3">00060</a> <span class="preprocessor"></span><span class="preprocessor"># define TRACE(A)</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="comment">/* utility functions */</span>
<a name="l00064"></a>00064 
<a name="l00065"></a><a class="code" href="structStringBuffer.html">00065</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structStringBuffer.html">StringBuffer</a> {
<a name="l00066"></a><a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">00066</a>   <span class="keywordtype">int</span> <a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>;      <span class="comment">/* length, not including null terminator */</span>
<a name="l00067"></a><a class="code" href="structStringBuffer.html#a0a28822505e012c9a81e3dcce8aab658">00067</a>   <span class="keywordtype">int</span> <a class="code" href="structStringBuffer.html#a0a28822505e012c9a81e3dcce8aab658">alloced</a>;  <span class="comment">/* Space allocated for s[] */</span> 
<a name="l00068"></a><a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">00068</a>   <span class="keywordtype">char</span> *<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>;      <span class="comment">/* Content of the string */</span>
<a name="l00069"></a>00069 } <a class="code" href="structStringBuffer.html">StringBuffer</a>;
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="fts1_8c.html#af53d41e9c022beb0601be19642881765">00071</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb){
<a name="l00072"></a>00072   sb-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a> = 0;
<a name="l00073"></a>00073   sb-&gt;<a class="code" href="structStringBuffer.html#a0a28822505e012c9a81e3dcce8aab658">alloced</a> = 100;
<a name="l00074"></a>00074   sb-&gt;<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a> = malloc(100);
<a name="l00075"></a>00075   sb-&gt;<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>[0] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00076"></a>00076 }
<a name="l00077"></a>00077 
<a name="l00078"></a><a class="code" href="fts1_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">00078</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFrom, <span class="keywordtype">int</span> nFrom){
<a name="l00079"></a>00079   <span class="keywordflow">if</span>( sb-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a> + nFrom &gt;= sb-&gt;<a class="code" href="structStringBuffer.html#a0a28822505e012c9a81e3dcce8aab658">alloced</a> ){
<a name="l00080"></a>00080     sb-&gt;<a class="code" href="structStringBuffer.html#a0a28822505e012c9a81e3dcce8aab658">alloced</a> = sb-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a> + nFrom + 100;
<a name="l00081"></a>00081     sb-&gt;<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a> = realloc(sb-&gt;<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>, sb-&gt;<a class="code" href="structStringBuffer.html#a0a28822505e012c9a81e3dcce8aab658">alloced</a>+1);
<a name="l00082"></a>00082     <span class="keywordflow">if</span>( sb-&gt;<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>==0 ){
<a name="l00083"></a>00083       <a class="code" href="fts1_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(sb);
<a name="l00084"></a>00084       <span class="keywordflow">return</span>;
<a name="l00085"></a>00085     }
<a name="l00086"></a>00086   }
<a name="l00087"></a>00087   memcpy(sb-&gt;<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a> + sb-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>, zFrom, nFrom);
<a name="l00088"></a>00088   sb-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a> += nFrom;
<a name="l00089"></a>00089   sb-&gt;<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>[sb-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>] = 0;
<a name="l00090"></a>00090 }
<a name="l00091"></a><a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">00091</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFrom){
<a name="l00092"></a>00092   <a class="code" href="fts1_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(sb, zFrom, strlen(zFrom));
<a name="l00093"></a>00093 }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="comment">/* We encode variable-length integers in little-endian order using seven bits</span>
<a name="l00096"></a>00096 <span class="comment"> * per byte as follows:</span>
<a name="l00097"></a>00097 <span class="comment">**</span>
<a name="l00098"></a>00098 <span class="comment">** KEY:</span>
<a name="l00099"></a>00099 <span class="comment">**         A = 0xxxxxxx    7 bits of data and one flag bit</span>
<a name="l00100"></a>00100 <span class="comment">**         B = 1xxxxxxx    7 bits of data and one flag bit</span>
<a name="l00101"></a>00101 <span class="comment">**</span>
<a name="l00102"></a>00102 <span class="comment">**  7 bits - A</span>
<a name="l00103"></a>00103 <span class="comment">** 14 bits - BA</span>
<a name="l00104"></a>00104 <span class="comment">** 21 bits - BBA</span>
<a name="l00105"></a>00105 <span class="comment">** and so on.</span>
<a name="l00106"></a>00106 <span class="comment">*/</span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="comment">/* We may need up to VARINT_MAX bytes to store an encoded 64-bit integer. */</span>
<a name="l00109"></a><a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">00109</a> <span class="preprocessor">#define VARINT_MAX 10</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>
<a name="l00111"></a>00111 <span class="comment">/* Write a 64-bit variable-length integer to memory starting at p[0].</span>
<a name="l00112"></a>00112 <span class="comment"> * The length of data written will be between 1 and VARINT_MAX bytes.</span>
<a name="l00113"></a>00113 <span class="comment"> * The number of bytes written is returned. */</span>
<a name="l00114"></a><a class="code" href="fts1_8c.html#a67a954d4b47621a14ebae9c22d46a271">00114</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(<span class="keywordtype">char</span> *p, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> v){
<a name="l00115"></a>00115   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *q = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) p;
<a name="l00116"></a>00116   <a class="code" href="sqlite3_8h.html#a127a9c18f6d067a05b994f5d0111ee25">sqlite_uint64</a> vu = v;
<a name="l00117"></a>00117   <span class="keywordflow">do</span>{
<a name="l00118"></a>00118     *q++ = (<span class="keywordtype">unsigned</span> char) ((vu &amp; 0x7f) | 0x80);
<a name="l00119"></a>00119     vu &gt;&gt;= 7;
<a name="l00120"></a>00120   }<span class="keywordflow">while</span>( vu!=0 );
<a name="l00121"></a>00121   q[-1] &amp;= 0x7f;  <span class="comment">/* turn off high bit in final byte */</span>
<a name="l00122"></a>00122   assert( q - (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)p &lt;= <a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a> );
<a name="l00123"></a>00123   <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) (q - (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)p);
<a name="l00124"></a>00124 }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="comment">/* Read a 64-bit variable-length integer from memory starting at p[0].</span>
<a name="l00127"></a>00127 <span class="comment"> * Return the number of bytes read, or 0 on error.</span>
<a name="l00128"></a>00128 <span class="comment"> * The value is stored in *v. */</span>
<a name="l00129"></a><a class="code" href="fts1_8c.html#a2e94291c61716c6bbb22f0e44cfa2b79">00129</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *p, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *v){
<a name="l00130"></a>00130   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *q = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) p;
<a name="l00131"></a>00131   <a class="code" href="sqlite3_8h.html#a127a9c18f6d067a05b994f5d0111ee25">sqlite_uint64</a> x = 0, y = 1;
<a name="l00132"></a>00132   <span class="keywordflow">while</span>( (*q &amp; 0x80) == 0x80 ){
<a name="l00133"></a>00133     x += y * (*q++ &amp; 0x7f);
<a name="l00134"></a>00134     y &lt;&lt;= 7;
<a name="l00135"></a>00135     <span class="keywordflow">if</span>( q - (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)p &gt;= <a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a> ){  <span class="comment">/* bad data */</span>
<a name="l00136"></a>00136       assert( 0 );
<a name="l00137"></a>00137       <span class="keywordflow">return</span> 0;
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139   }
<a name="l00140"></a>00140   x += y * (*q++);
<a name="l00141"></a>00141   *v = (<a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a>) x;
<a name="l00142"></a>00142   <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) (q - (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)p);
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a><a class="code" href="fts1_8c.html#ae06c82772c657bafa9fd7af259034782">00145</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> *pi){
<a name="l00146"></a>00146  <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> i;
<a name="l00147"></a>00147  <span class="keywordtype">int</span> ret = <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(p, &amp;i);
<a name="l00148"></a>00148  *pi = (int) i;
<a name="l00149"></a>00149  assert( *pi==i );
<a name="l00150"></a>00150  <span class="keywordflow">return</span> ret;
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="comment">/*** Document lists ***</span>
<a name="l00154"></a>00154 <span class="comment"> *</span>
<a name="l00155"></a>00155 <span class="comment"> * A document list holds a sorted list of varint-encoded document IDs.</span>
<a name="l00156"></a>00156 <span class="comment"> *</span>
<a name="l00157"></a>00157 <span class="comment"> * A doclist with type DL_POSITIONS_OFFSETS is stored like this:</span>
<a name="l00158"></a>00158 <span class="comment"> *</span>
<a name="l00159"></a>00159 <span class="comment"> * array {</span>
<a name="l00160"></a>00160 <span class="comment"> *   varint docid;</span>
<a name="l00161"></a>00161 <span class="comment"> *   array {</span>
<a name="l00162"></a>00162 <span class="comment"> *     varint position;     (delta from previous position plus POS_BASE)</span>
<a name="l00163"></a>00163 <span class="comment"> *     varint startOffset;  (delta from previous startOffset)</span>
<a name="l00164"></a>00164 <span class="comment"> *     varint endOffset;    (delta from startOffset)</span>
<a name="l00165"></a>00165 <span class="comment"> *   }</span>
<a name="l00166"></a>00166 <span class="comment"> * }</span>
<a name="l00167"></a>00167 <span class="comment"> *</span>
<a name="l00168"></a>00168 <span class="comment"> * Here, array { X } means zero or more occurrences of X, adjacent in memory.</span>
<a name="l00169"></a>00169 <span class="comment"> *</span>
<a name="l00170"></a>00170 <span class="comment"> * A position list may hold positions for text in multiple columns.  A position</span>
<a name="l00171"></a>00171 <span class="comment"> * POS_COLUMN is followed by a varint containing the index of the column for</span>
<a name="l00172"></a>00172 <span class="comment"> * following positions in the list.  Any positions appearing before any</span>
<a name="l00173"></a>00173 <span class="comment"> * occurrences of POS_COLUMN are for column 0.</span>
<a name="l00174"></a>00174 <span class="comment"> *</span>
<a name="l00175"></a>00175 <span class="comment"> * A doclist with type DL_POSITIONS is like the above, but holds only docids</span>
<a name="l00176"></a>00176 <span class="comment"> * and positions without offset information.</span>
<a name="l00177"></a>00177 <span class="comment"> *</span>
<a name="l00178"></a>00178 <span class="comment"> * A doclist with type DL_DOCIDS is like the above, but holds only docids</span>
<a name="l00179"></a>00179 <span class="comment"> * without positions or offset information.</span>
<a name="l00180"></a>00180 <span class="comment"> *</span>
<a name="l00181"></a>00181 <span class="comment"> * On disk, every document list has positions and offsets, so we don&apos;t bother</span>
<a name="l00182"></a>00182 <span class="comment"> * to serialize a doclist&apos;s type.</span>
<a name="l00183"></a>00183 <span class="comment"> * </span>
<a name="l00184"></a>00184 <span class="comment"> * We don&apos;t yet delta-encode document IDs; doing so will probably be a</span>
<a name="l00185"></a>00185 <span class="comment"> * modest win.</span>
<a name="l00186"></a>00186 <span class="comment"> *</span>
<a name="l00187"></a>00187 <span class="comment"> * NOTE(shess) I&apos;ve thought of a slightly (1%) better offset encoding.</span>
<a name="l00188"></a>00188 <span class="comment"> * After the first offset, estimate the next offset by using the</span>
<a name="l00189"></a>00189 <span class="comment"> * current token position and the previous token position and offset,</span>
<a name="l00190"></a>00190 <span class="comment"> * offset to handle some variance.  So the estimate would be</span>
<a name="l00191"></a>00191 <span class="comment"> * (iPosition*w-&gt;iStartOffset/w-&gt;iPosition-64), which is delta-encoded</span>
<a name="l00192"></a>00192 <span class="comment"> * as normal.  Offsets more than 64 chars from the estimate are</span>
<a name="l00193"></a>00193 <span class="comment"> * encoded as the delta to the previous start offset + 128.  An</span>
<a name="l00194"></a>00194 <span class="comment"> * additional tiny increment can be gained by using the end offset of</span>
<a name="l00195"></a>00195 <span class="comment"> * the previous token to make the estimate a tiny bit more precise.</span>
<a name="l00196"></a>00196 <span class="comment">*/</span>
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="comment">/* It is not safe to call isspace(), tolower(), or isalnum() on</span>
<a name="l00199"></a>00199 <span class="comment">** hi-bit-set characters.  This is the same solution used in the</span>
<a name="l00200"></a>00200 <span class="comment">** tokenizer.</span>
<a name="l00201"></a>00201 <span class="comment">*/</span>
<a name="l00202"></a>00202 <span class="comment">/* TODO(shess) The snippet-generation code should be using the</span>
<a name="l00203"></a>00203 <span class="comment">** tokenizer-generated tokens rather than doing its own local</span>
<a name="l00204"></a>00204 <span class="comment">** tokenization.</span>
<a name="l00205"></a>00205 <span class="comment">*/</span>
<a name="l00206"></a>00206 <span class="comment">/* TODO(shess) Is __isascii() a portable version of (c&amp;0x80)==0? */</span>
<a name="l00207"></a><a class="code" href="fts1_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">00207</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(<span class="keywordtype">char</span> c){
<a name="l00208"></a>00208   <span class="keywordflow">return</span> (c&amp;0x80)==0 ? isspace(c) : 0;
<a name="l00209"></a>00209 }
<a name="l00210"></a><a class="code" href="fts1_8c.html#aa13290c27de028c6f1886f82656482fa">00210</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#aa13290c27de028c6f1886f82656482fa">safe_tolower</a>(<span class="keywordtype">char</span> c){
<a name="l00211"></a>00211   <span class="keywordflow">return</span> (c&amp;0x80)==0 ? tolower(c) : c;
<a name="l00212"></a>00212 }
<a name="l00213"></a><a class="code" href="fts1_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">00213</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">safe_isalnum</a>(<span class="keywordtype">char</span> c){
<a name="l00214"></a>00214   <span class="keywordflow">return</span> (c&amp;0x80)==0 ? isalnum(c) : 0;
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a><a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">00217</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> {
<a name="l00218"></a><a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">00218</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>,              <span class="comment">/* docids only */</span>
<a name="l00219"></a><a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">00219</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a>,           <span class="comment">/* docids + positions */</span>
<a name="l00220"></a><a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">00220</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a>    <span class="comment">/* docids + positions + offsets */</span>
<a name="l00221"></a>00221 } <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a>;
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 <span class="comment">/*</span>
<a name="l00224"></a>00224 <span class="comment">** By default, only positions and not offsets are stored in the doclists.</span>
<a name="l00225"></a>00225 <span class="comment">** To change this so that offsets are stored too, compile with</span>
<a name="l00226"></a>00226 <span class="comment">**</span>
<a name="l00227"></a>00227 <span class="comment">**          -DDL_DEFAULT=DL_POSITIONS_OFFSETS</span>
<a name="l00228"></a>00228 <span class="comment">**</span>
<a name="l00229"></a>00229 <span class="comment">*/</span>
<a name="l00230"></a>00230 <span class="preprocessor">#ifndef DL_DEFAULT</span>
<a name="l00231"></a><a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">00231</a> <span class="preprocessor"></span><span class="preprocessor"># define DL_DEFAULT DL_POSITIONS</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span>
<a name="l00234"></a><a class="code" href="structDocList.html">00234</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structDocList.html">DocList</a> {
<a name="l00235"></a><a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">00235</a>   <span class="keywordtype">char</span> *<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>;
<a name="l00236"></a><a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">00236</a>   <span class="keywordtype">int</span> <a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>;
<a name="l00237"></a><a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">00237</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> <a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>;
<a name="l00238"></a><a class="code" href="structDocList.html#a0e95565cd9e23cc20287cac4b9639dbe">00238</a>   <span class="keywordtype">int</span> <a class="code" href="structDocList.html#a0e95565cd9e23cc20287cac4b9639dbe">iLastColumn</a>;    <span class="comment">/* the last column written */</span>
<a name="l00239"></a><a class="code" href="structDocList.html#a19b48ee159add4fb8b3ff71493d009c2">00239</a>   <span class="keywordtype">int</span> <a class="code" href="structDocList.html#a19b48ee159add4fb8b3ff71493d009c2">iLastPos</a>;       <span class="comment">/* the last position written */</span>
<a name="l00240"></a><a class="code" href="structDocList.html#aa1b473eb1723078bc81982e3e35e1f5a">00240</a>   <span class="keywordtype">int</span> <a class="code" href="structDocList.html#aa1b473eb1723078bc81982e3e35e1f5a">iLastOffset</a>;    <span class="comment">/* the last start offset written */</span>
<a name="l00241"></a>00241 } <a class="code" href="structDocList.html">DocList</a>;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keyword">enum</span> {
<a name="l00244"></a><a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">00244</a>   <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a> = 0,        <span class="comment">/* end of this position list */</span>
<a name="l00245"></a><a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">00245</a>   <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">POS_COLUMN</a>,         <span class="comment">/* followed by new column number */</span>
<a name="l00246"></a><a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a97c7ac3d72e7a29547748b3c4f529945">00246</a>   <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a97c7ac3d72e7a29547748b3c4f529945">POS_BASE</a>
<a name="l00247"></a>00247 };
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="comment">/* Initialize a new DocList to hold the given data. */</span>
<a name="l00250"></a><a class="code" href="fts1_8c.html#ab9c4fadccc51f39560c880c3d031a27b">00250</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#ab9c4fadccc51f39560c880c3d031a27b">docListInit</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType,
<a name="l00251"></a>00251                         <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData){
<a name="l00252"></a>00252   d-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a> = nData;
<a name="l00253"></a>00253   <span class="keywordflow">if</span>( nData&gt;0 ){
<a name="l00254"></a>00254     d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a> = malloc(nData);
<a name="l00255"></a>00255     memcpy(d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>, pData, nData);
<a name="l00256"></a>00256   } <span class="keywordflow">else</span> {
<a name="l00257"></a>00257     d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a> = NULL;
<a name="l00258"></a>00258   }
<a name="l00259"></a>00259   d-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a> = iType;
<a name="l00260"></a>00260   d-&gt;<a class="code" href="structDocList.html#a0e95565cd9e23cc20287cac4b9639dbe">iLastColumn</a> = 0;
<a name="l00261"></a>00261   d-&gt;<a class="code" href="structDocList.html#a19b48ee159add4fb8b3ff71493d009c2">iLastPos</a> = d-&gt;<a class="code" href="structDocList.html#aa1b473eb1723078bc81982e3e35e1f5a">iLastOffset</a> = 0;
<a name="l00262"></a>00262 }
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="comment">/* Create a new dynamically-allocated DocList. */</span>
<a name="l00265"></a><a class="code" href="fts1_8c.html#a17dda48d7ada1bbe7a4cd214fcf00865">00265</a> <span class="keyword">static</span> <a class="code" href="structDocList.html">DocList</a> *<a class="code" href="fts1_8c.html#a17dda48d7ada1bbe7a4cd214fcf00865">docListNew</a>(<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType){
<a name="l00266"></a>00266   <a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a> = (<a class="code" href="structDocList.html">DocList</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structDocList.html">DocList</a>));
<a name="l00267"></a>00267   <a class="code" href="fts1_8c.html#ab9c4fadccc51f39560c880c3d031a27b">docListInit</a>(d, iType, 0, 0);
<a name="l00268"></a>00268   <span class="keywordflow">return</span> d;
<a name="l00269"></a>00269 }
<a name="l00270"></a>00270 
<a name="l00271"></a><a class="code" href="fts1_8c.html#afc9760991434278d35e17d8b0ab59001">00271</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#afc9760991434278d35e17d8b0ab59001">docListDestroy</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>){
<a name="l00272"></a>00272   free(d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>);
<a name="l00273"></a>00273 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00274"></a>00274 <span class="preprocessor"></span>  memset(d, 0x55, <span class="keyword">sizeof</span>(*d));
<a name="l00275"></a>00275 <span class="preprocessor">#endif</span>
<a name="l00276"></a>00276 <span class="preprocessor"></span>}
<a name="l00277"></a>00277 
<a name="l00278"></a><a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">00278</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>){
<a name="l00279"></a>00279   <a class="code" href="fts1_8c.html#afc9760991434278d35e17d8b0ab59001">docListDestroy</a>(d);
<a name="l00280"></a>00280   free(d);
<a name="l00281"></a>00281 }
<a name="l00282"></a>00282 
<a name="l00283"></a><a class="code" href="fts1_8c.html#a32c4b74e8bc1ccdfb04b8ef9e151775c">00283</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts1_8c.html#a32c4b74e8bc1ccdfb04b8ef9e151775c">docListEnd</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>){
<a name="l00284"></a>00284   <span class="keywordflow">return</span> d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a> + d-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>;
<a name="l00285"></a>00285 }
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="comment">/* Append a varint to a DocList&apos;s data. */</span>
<a name="l00288"></a><a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">00288</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> i){
<a name="l00289"></a>00289   <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l00290"></a>00290   <span class="keywordtype">int</span> n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, i);
<a name="l00291"></a>00291   d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a> = realloc(d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>, d-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a> + n);
<a name="l00292"></a>00292   memcpy(d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a> + d-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>, c, n);
<a name="l00293"></a>00293   d-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a> += n;
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00296"></a><a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">00296</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid){
<a name="l00297"></a>00297   <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(d, iDocid);
<a name="l00298"></a>00298   <span class="keywordflow">if</span>( d-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ){
<a name="l00299"></a>00299     <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(d, <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a>);  <span class="comment">/* initially empty position list */</span>
<a name="l00300"></a>00300     d-&gt;<a class="code" href="structDocList.html#a0e95565cd9e23cc20287cac4b9639dbe">iLastColumn</a> = 0;
<a name="l00301"></a>00301     d-&gt;<a class="code" href="structDocList.html#a19b48ee159add4fb8b3ff71493d009c2">iLastPos</a> = d-&gt;<a class="code" href="structDocList.html#aa1b473eb1723078bc81982e3e35e1f5a">iLastOffset</a> = 0;
<a name="l00302"></a>00302   }
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="comment">/* helper function for docListAddPos and docListAddPosOffset */</span>
<a name="l00306"></a><a class="code" href="fts1_8c.html#a30b42e828312fc51a28a551d5107bd69">00306</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a30b42e828312fc51a28a551d5107bd69">addPos</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>, <span class="keywordtype">int</span> iColumn, <span class="keywordtype">int</span> iPos){
<a name="l00307"></a>00307   assert( d-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>&gt;0 );
<a name="l00308"></a>00308   --d-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>;  <span class="comment">/* remove previous terminator */</span>
<a name="l00309"></a>00309   <span class="keywordflow">if</span>( iColumn!=d-&gt;<a class="code" href="structDocList.html#a0e95565cd9e23cc20287cac4b9639dbe">iLastColumn</a> ){
<a name="l00310"></a>00310     assert( iColumn&gt;d-&gt;<a class="code" href="structDocList.html#a0e95565cd9e23cc20287cac4b9639dbe">iLastColumn</a> );
<a name="l00311"></a>00311     <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(d, <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">POS_COLUMN</a>);
<a name="l00312"></a>00312     <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(d, iColumn);
<a name="l00313"></a>00313     d-&gt;<a class="code" href="structDocList.html#a0e95565cd9e23cc20287cac4b9639dbe">iLastColumn</a> = iColumn;
<a name="l00314"></a>00314     d-&gt;<a class="code" href="structDocList.html#a19b48ee159add4fb8b3ff71493d009c2">iLastPos</a> = d-&gt;<a class="code" href="structDocList.html#aa1b473eb1723078bc81982e3e35e1f5a">iLastOffset</a> = 0;
<a name="l00315"></a>00315   }
<a name="l00316"></a>00316   assert( iPos&gt;=d-&gt;<a class="code" href="structDocList.html#a19b48ee159add4fb8b3ff71493d009c2">iLastPos</a> );
<a name="l00317"></a>00317   <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(d, iPos-d-&gt;<a class="code" href="structDocList.html#a19b48ee159add4fb8b3ff71493d009c2">iLastPos</a>+<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a97c7ac3d72e7a29547748b3c4f529945">POS_BASE</a>);
<a name="l00318"></a>00318   d-&gt;<a class="code" href="structDocList.html#a19b48ee159add4fb8b3ff71493d009c2">iLastPos</a> = iPos;
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="comment">/* Add a position to the last position list in a doclist. */</span>
<a name="l00322"></a><a class="code" href="fts1_8c.html#a105f3796bdaec568d23860c752aaab38">00322</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a105f3796bdaec568d23860c752aaab38">docListAddPos</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>, <span class="keywordtype">int</span> iColumn, <span class="keywordtype">int</span> iPos){
<a name="l00323"></a>00323   assert( d-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> );
<a name="l00324"></a>00324   <a class="code" href="fts1_8c.html#a30b42e828312fc51a28a551d5107bd69">addPos</a>(d, iColumn, iPos);
<a name="l00325"></a>00325   <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(d, <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a>);  <span class="comment">/* add new terminator */</span>
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="comment">/*</span>
<a name="l00329"></a>00329 <span class="comment">** Add a position and starting and ending offsets to a doclist.</span>
<a name="l00330"></a>00330 <span class="comment">**</span>
<a name="l00331"></a>00331 <span class="comment">** If the doclist is setup to handle only positions, then insert</span>
<a name="l00332"></a>00332 <span class="comment">** the position only and ignore the offsets.</span>
<a name="l00333"></a>00333 <span class="comment">*/</span>
<a name="l00334"></a><a class="code" href="fts1_8c.html#ad8a22ce767c69c39f134e5127c1d7bb5">00334</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#ad8a22ce767c69c39f134e5127c1d7bb5">docListAddPosOffset</a>(
<a name="l00335"></a>00335   <a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>,             <span class="comment">/* Doclist under construction */</span>
<a name="l00336"></a>00336   <span class="keywordtype">int</span> iColumn,            <span class="comment">/* Column the inserted term is part of */</span>
<a name="l00337"></a>00337   <span class="keywordtype">int</span> iPos,               <span class="comment">/* Position of the inserted term */</span>
<a name="l00338"></a>00338   <span class="keywordtype">int</span> iStartOffset,       <span class="comment">/* Starting offset of inserted term */</span>
<a name="l00339"></a>00339   <span class="keywordtype">int</span> iEndOffset          <span class="comment">/* Ending offset of inserted term */</span>
<a name="l00340"></a>00340 ){
<a name="l00341"></a>00341   assert( d-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> );
<a name="l00342"></a>00342   <a class="code" href="fts1_8c.html#a30b42e828312fc51a28a551d5107bd69">addPos</a>(d, iColumn, iPos);
<a name="l00343"></a>00343   <span class="keywordflow">if</span>( d-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a> ){
<a name="l00344"></a>00344     assert( iStartOffset&gt;=d-&gt;<a class="code" href="structDocList.html#aa1b473eb1723078bc81982e3e35e1f5a">iLastOffset</a> );
<a name="l00345"></a>00345     <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(d, iStartOffset-d-&gt;<a class="code" href="structDocList.html#aa1b473eb1723078bc81982e3e35e1f5a">iLastOffset</a>);
<a name="l00346"></a>00346     d-&gt;<a class="code" href="structDocList.html#aa1b473eb1723078bc81982e3e35e1f5a">iLastOffset</a> = iStartOffset;
<a name="l00347"></a>00347     assert( iEndOffset&gt;=iStartOffset );
<a name="l00348"></a>00348     <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(d, iEndOffset-iStartOffset);
<a name="l00349"></a>00349   }
<a name="l00350"></a>00350   <a class="code" href="fts1_8c.html#a46ec83f7a686b9eba33e33f8f023565a">appendVarint</a>(d, <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a>);  <span class="comment">/* add new terminator */</span>
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="comment">/*</span>
<a name="l00354"></a>00354 <span class="comment">** A DocListReader object is a cursor into a doclist.  Initialize</span>
<a name="l00355"></a>00355 <span class="comment">** the cursor to the beginning of the doclist by calling readerInit().</span>
<a name="l00356"></a>00356 <span class="comment">** Then use routines</span>
<a name="l00357"></a>00357 <span class="comment">**</span>
<a name="l00358"></a>00358 <span class="comment">**      peekDocid()</span>
<a name="l00359"></a>00359 <span class="comment">**      readDocid()</span>
<a name="l00360"></a>00360 <span class="comment">**      readPosition()</span>
<a name="l00361"></a>00361 <span class="comment">**      skipPositionList()</span>
<a name="l00362"></a>00362 <span class="comment">**      and so forth...</span>
<a name="l00363"></a>00363 <span class="comment">**</span>
<a name="l00364"></a>00364 <span class="comment">** to read information out of the doclist.  When we reach the end</span>
<a name="l00365"></a>00365 <span class="comment">** of the doclist, atEnd() returns TRUE.</span>
<a name="l00366"></a>00366 <span class="comment">*/</span>
<a name="l00367"></a><a class="code" href="structDocListReader.html">00367</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structDocListReader.html">DocListReader</a> {
<a name="l00368"></a><a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">00368</a>   <a class="code" href="structDocList.html">DocList</a> *<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>;  <span class="comment">/* The document list we are stepping through */</span>
<a name="l00369"></a><a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">00369</a>   <span class="keywordtype">char</span> *<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>;            <span class="comment">/* Pointer to next unread byte in the doclist */</span>
<a name="l00370"></a><a class="code" href="structDocListReader.html#a79206df067246cfe59143a519f00f0ed">00370</a>   <span class="keywordtype">int</span> <a class="code" href="structDocListReader.html#a79206df067246cfe59143a519f00f0ed">iLastColumn</a>;
<a name="l00371"></a><a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">00371</a>   <span class="keywordtype">int</span> <a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a>;  <span class="comment">/* the last position read, or -1 when not in a position list */</span>
<a name="l00372"></a>00372 } <a class="code" href="structDocListReader.html">DocListReader</a>;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="comment">/*</span>
<a name="l00375"></a>00375 <span class="comment">** Initialize the DocListReader r to point to the beginning of pDoclist.</span>
<a name="l00376"></a>00376 <span class="comment">*/</span>
<a name="l00377"></a><a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">00377</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *r, <a class="code" href="structDocList.html">DocList</a> *pDoclist){
<a name="l00378"></a>00378   r-&gt;<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a> = pDoclist;
<a name="l00379"></a>00379   <span class="keywordflow">if</span>( pDoclist!=NULL ){
<a name="l00380"></a>00380     r-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a> = pDoclist-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>;
<a name="l00381"></a>00381   }
<a name="l00382"></a>00382   r-&gt;<a class="code" href="structDocListReader.html#a79206df067246cfe59143a519f00f0ed">iLastColumn</a> = -1;
<a name="l00383"></a>00383   r-&gt;<a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a> = -1;
<a name="l00384"></a>00384 }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 <span class="comment">/*</span>
<a name="l00387"></a>00387 <span class="comment">** Return TRUE if we have reached then end of pReader and there is</span>
<a name="l00388"></a>00388 <span class="comment">** nothing else left to read.</span>
<a name="l00389"></a>00389 <span class="comment">*/</span>
<a name="l00390"></a><a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">00390</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *pReader){
<a name="l00391"></a>00391   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>==0 || (pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a> &gt;= <a class="code" href="fts1_8c.html#a32c4b74e8bc1ccdfb04b8ef9e151775c">docListEnd</a>(pReader-&gt;<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>));
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 <span class="comment">/* Peek at the next docid without advancing the read pointer. </span>
<a name="l00395"></a>00395 <span class="comment">*/</span>
<a name="l00396"></a><a class="code" href="fts1_8c.html#a3397ec25e30e39028a83bf14ad576b2f">00396</a> <span class="keyword">static</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="fts1_8c.html#a3397ec25e30e39028a83bf14ad576b2f">peekDocid</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *pReader){
<a name="l00397"></a>00397   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> ret;
<a name="l00398"></a>00398   assert( !<a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(pReader) );
<a name="l00399"></a>00399   assert( pReader-&gt;<a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a>==-1 );
<a name="l00400"></a>00400   <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>, &amp;ret);
<a name="l00401"></a>00401   <span class="keywordflow">return</span> ret;
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="comment">/* Read the next docid.   See also nextDocid().</span>
<a name="l00405"></a>00405 <span class="comment">*/</span>
<a name="l00406"></a><a class="code" href="fts1_8c.html#a9fb0f7bec80b2dbc1bc2afdb7a13b51d">00406</a> <span class="keyword">static</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="fts1_8c.html#a9fb0f7bec80b2dbc1bc2afdb7a13b51d">readDocid</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *pReader){
<a name="l00407"></a>00407   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> ret;
<a name="l00408"></a>00408   assert( !<a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(pReader) );
<a name="l00409"></a>00409   assert( pReader-&gt;<a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a>==-1 );
<a name="l00410"></a>00410   pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a> += <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>, &amp;ret);
<a name="l00411"></a>00411   <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ){
<a name="l00412"></a>00412     pReader-&gt;<a class="code" href="structDocListReader.html#a79206df067246cfe59143a519f00f0ed">iLastColumn</a> = 0;
<a name="l00413"></a>00413     pReader-&gt;<a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a> = 0;
<a name="l00414"></a>00414   }
<a name="l00415"></a>00415   <span class="keywordflow">return</span> ret;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="comment">/* Read the next position and column index from a position list.</span>
<a name="l00419"></a>00419 <span class="comment"> * Returns the position, or -1 at the end of the list. */</span>
<a name="l00420"></a><a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">00420</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *pReader, <span class="keywordtype">int</span> *iColumn){
<a name="l00421"></a>00421   <span class="keywordtype">int</span> i;
<a name="l00422"></a>00422   <span class="keywordtype">int</span> iType = pReader-&gt;<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>;
<a name="l00423"></a>00423 
<a name="l00424"></a>00424   <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a>==-1 ){
<a name="l00425"></a>00425     <span class="keywordflow">return</span> -1;
<a name="l00426"></a>00426   }
<a name="l00427"></a>00427   assert( !<a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(pReader) );
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="keywordflow">if</span>( iType&lt;<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ){
<a name="l00430"></a>00430     <span class="keywordflow">return</span> -1;
<a name="l00431"></a>00431   }
<a name="l00432"></a>00432   pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a> += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>, &amp;i);
<a name="l00433"></a>00433   <span class="keywordflow">if</span>( i==<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a> ){
<a name="l00434"></a>00434     pReader-&gt;<a class="code" href="structDocListReader.html#a79206df067246cfe59143a519f00f0ed">iLastColumn</a> = pReader-&gt;<a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a> = -1;
<a name="l00435"></a>00435     *iColumn = -1;
<a name="l00436"></a>00436     <span class="keywordflow">return</span> -1;
<a name="l00437"></a>00437   }
<a name="l00438"></a>00438   <span class="keywordflow">if</span>( i==<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">POS_COLUMN</a> ){
<a name="l00439"></a>00439     pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a> += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>, &amp;pReader-&gt;<a class="code" href="structDocListReader.html#a79206df067246cfe59143a519f00f0ed">iLastColumn</a>);
<a name="l00440"></a>00440     pReader-&gt;<a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a> = 0;
<a name="l00441"></a>00441     pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a> += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>, &amp;i);
<a name="l00442"></a>00442     assert( i&gt;=<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a97c7ac3d72e7a29547748b3c4f529945">POS_BASE</a> );
<a name="l00443"></a>00443   }
<a name="l00444"></a>00444   pReader-&gt;<a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a> += ((int) i)-<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a97c7ac3d72e7a29547748b3c4f529945">POS_BASE</a>;
<a name="l00445"></a>00445   <span class="keywordflow">if</span>( iType&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a> ){
<a name="l00446"></a>00446     <span class="comment">/* Skip over offsets, ignoring them for now. */</span>
<a name="l00447"></a>00447     <span class="keywordtype">int</span> iStart, iEnd;
<a name="l00448"></a>00448     pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a> += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>, &amp;iStart);
<a name="l00449"></a>00449     pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a> += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>, &amp;iEnd);
<a name="l00450"></a>00450   }
<a name="l00451"></a>00451   *iColumn = pReader-&gt;<a class="code" href="structDocListReader.html#a79206df067246cfe59143a519f00f0ed">iLastColumn</a>;
<a name="l00452"></a>00452   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structDocListReader.html#ad5b6121c31173cd87c7f6fe717d0056f">iLastPos</a>;
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 <span class="comment">/* Skip past the end of a position list. */</span>
<a name="l00456"></a><a class="code" href="fts1_8c.html#a19e60ea05015383b586aaf71b9bb20db">00456</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a19e60ea05015383b586aaf71b9bb20db">skipPositionList</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *pReader){
<a name="l00457"></a>00457   <a class="code" href="structDocList.html">DocList</a> *p = pReader-&gt;<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>;
<a name="l00458"></a>00458   <span class="keywordflow">if</span>( p &amp;&amp; p-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ){
<a name="l00459"></a>00459     <span class="keywordtype">int</span> iColumn;
<a name="l00460"></a>00460     <span class="keywordflow">while</span>( <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(pReader, &amp;iColumn)!=-1 ){}
<a name="l00461"></a>00461   }
<a name="l00462"></a>00462 }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="comment">/* Skip over a docid, including its position list if the doclist has</span>
<a name="l00465"></a>00465 <span class="comment"> * positions. */</span>
<a name="l00466"></a><a class="code" href="fts1_8c.html#a4bfe356b1bf6d861bee8dfebd13a7cde">00466</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a4bfe356b1bf6d861bee8dfebd13a7cde">skipDocument</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *pReader){
<a name="l00467"></a>00467   <a class="code" href="fts1_8c.html#a9fb0f7bec80b2dbc1bc2afdb7a13b51d">readDocid</a>(pReader);
<a name="l00468"></a>00468   <a class="code" href="fts1_8c.html#a19e60ea05015383b586aaf71b9bb20db">skipPositionList</a>(pReader);
<a name="l00469"></a>00469 }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 <span class="comment">/* Skip past all docids which are less than [iDocid].  Returns 1 if a docid</span>
<a name="l00472"></a>00472 <span class="comment"> * matching [iDocid] was found.  */</span>
<a name="l00473"></a><a class="code" href="fts1_8c.html#a9773da327fecea3d6daf279d374808d8">00473</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a9773da327fecea3d6daf279d374808d8">skipToDocid</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *pReader, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid){
<a name="l00474"></a>00474   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a> = 0;
<a name="l00475"></a>00475   <span class="keywordflow">while</span>( !<a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(pReader) &amp;&amp; (d=<a class="code" href="fts1_8c.html#a3397ec25e30e39028a83bf14ad576b2f">peekDocid</a>(pReader))&lt;iDocid ){
<a name="l00476"></a>00476     <a class="code" href="fts1_8c.html#a4bfe356b1bf6d861bee8dfebd13a7cde">skipDocument</a>(pReader);
<a name="l00477"></a>00477   }
<a name="l00478"></a>00478   <span class="keywordflow">return</span> !<a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(pReader) &amp;&amp; d==iDocid;
<a name="l00479"></a>00479 }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="comment">/* Return the first document in a document list.</span>
<a name="l00482"></a>00482 <span class="comment">*/</span>
<a name="l00483"></a><a class="code" href="fts1_8c.html#a0c7e8e20502babc12c58345078bcec3b">00483</a> <span class="keyword">static</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="fts1_8c.html#a0c7e8e20502babc12c58345078bcec3b">firstDocid</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>){
<a name="l00484"></a>00484   <a class="code" href="structDocListReader.html">DocListReader</a> r;
<a name="l00485"></a>00485   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;r, d);
<a name="l00486"></a>00486   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#a9fb0f7bec80b2dbc1bc2afdb7a13b51d">readDocid</a>(&amp;r);
<a name="l00487"></a>00487 }
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00491"></a>00491 <span class="comment">** This routine is used for debugging purpose only.</span>
<a name="l00492"></a>00492 <span class="comment">**</span>
<a name="l00493"></a>00493 <span class="comment">** Write the content of a doclist to standard output.</span>
<a name="l00494"></a>00494 <span class="comment">*/</span>
<a name="l00495"></a>00495 <span class="keyword">static</span> <span class="keywordtype">void</span> printDoclist(<a class="code" href="structDocList.html">DocList</a> *p){
<a name="l00496"></a>00496   <a class="code" href="structDocListReader.html">DocListReader</a> r;
<a name="l00497"></a>00497   <span class="keyword">const</span> <span class="keywordtype">char</span> *zSep = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;r, p);
<a name="l00500"></a>00500   <span class="keywordflow">while</span>( !<a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(&amp;r) ){
<a name="l00501"></a>00501     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> docid = <a class="code" href="fts1_8c.html#a9fb0f7bec80b2dbc1bc2afdb7a13b51d">readDocid</a>(&amp;r);
<a name="l00502"></a>00502     <span class="keywordflow">if</span>( docid==0 ){
<a name="l00503"></a>00503       <a class="code" href="fts1_8c.html#a19e60ea05015383b586aaf71b9bb20db">skipPositionList</a>(&amp;r);
<a name="l00504"></a>00504       <span class="keywordflow">continue</span>;
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506     printf(<span class="stringliteral">&quot;%s%lld&quot;</span>, zSep, docid);
<a name="l00507"></a>00507     zSep =  <span class="stringliteral">&quot;,&quot;</span>;
<a name="l00508"></a>00508     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ){
<a name="l00509"></a>00509       <span class="keywordtype">int</span> iPos, iCol;
<a name="l00510"></a>00510       <span class="keyword">const</span> <span class="keywordtype">char</span> *zDiv = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00511"></a>00511       printf(<span class="stringliteral">&quot;(&quot;</span>);
<a name="l00512"></a>00512       <span class="keywordflow">while</span>( (iPos = <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(&amp;r, &amp;iCol))&gt;=0 ){
<a name="l00513"></a>00513         printf(<span class="stringliteral">&quot;%s%d:%d&quot;</span>, zDiv, iCol, iPos);
<a name="l00514"></a>00514         zDiv = <span class="stringliteral">&quot;:&quot;</span>;
<a name="l00515"></a>00515       }
<a name="l00516"></a>00516       printf(<span class="stringliteral">&quot;)&quot;</span>);
<a name="l00517"></a>00517     }
<a name="l00518"></a>00518   }
<a name="l00519"></a>00519   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00520"></a>00520   fflush(stdout);
<a name="l00521"></a>00521 }
<a name="l00522"></a>00522 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_DEBUG */</span>
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 <span class="comment">/* Trim the given doclist to contain only positions in column</span>
<a name="l00525"></a>00525 <span class="comment"> * [iRestrictColumn]. */</span>
<a name="l00526"></a><a class="code" href="fts1_8c.html#a259026659139162c0c753eb05ad14d4c">00526</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a259026659139162c0c753eb05ad14d4c">docListRestrictColumn</a>(<a class="code" href="structDocList.html">DocList</a> *in, <span class="keywordtype">int</span> iRestrictColumn){
<a name="l00527"></a>00527   <a class="code" href="structDocListReader.html">DocListReader</a> r;
<a name="l00528"></a>00528   <a class="code" href="structDocList.html">DocList</a> out;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530   assert( in-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> );
<a name="l00531"></a>00531   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;r, in);
<a name="l00532"></a>00532   <a class="code" href="fts1_8c.html#ab9c4fadccc51f39560c880c3d031a27b">docListInit</a>(&amp;out, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a>, NULL, 0);
<a name="l00533"></a>00533 
<a name="l00534"></a>00534   <span class="keywordflow">while</span>( !<a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(&amp;r) ){
<a name="l00535"></a>00535     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid = <a class="code" href="fts1_8c.html#a9fb0f7bec80b2dbc1bc2afdb7a13b51d">readDocid</a>(&amp;r);
<a name="l00536"></a>00536     <span class="keywordtype">int</span> iPos, iColumn;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538     <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(&amp;out, iDocid);
<a name="l00539"></a>00539     <span class="keywordflow">while</span>( (iPos = <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(&amp;r, &amp;iColumn)) != -1 ){
<a name="l00540"></a>00540       <span class="keywordflow">if</span>( iColumn==iRestrictColumn ){
<a name="l00541"></a>00541         <a class="code" href="fts1_8c.html#a105f3796bdaec568d23860c752aaab38">docListAddPos</a>(&amp;out, iColumn, iPos);
<a name="l00542"></a>00542       }
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544   }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   <a class="code" href="fts1_8c.html#afc9760991434278d35e17d8b0ab59001">docListDestroy</a>(in);
<a name="l00547"></a>00547   *in = out;
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="comment">/* Trim the given doclist by discarding any docids without any remaining</span>
<a name="l00551"></a>00551 <span class="comment"> * positions. */</span>
<a name="l00552"></a><a class="code" href="fts1_8c.html#a7cf5f4570dc1141fb188267caec8a6da">00552</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a7cf5f4570dc1141fb188267caec8a6da">docListDiscardEmpty</a>(<a class="code" href="structDocList.html">DocList</a> *in) {
<a name="l00553"></a>00553   <a class="code" href="structDocListReader.html">DocListReader</a> r;
<a name="l00554"></a>00554   <a class="code" href="structDocList.html">DocList</a> out;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556   <span class="comment">/* TODO: It would be nice to implement this operation in place; that</span>
<a name="l00557"></a>00557 <span class="comment">   * could save a significant amount of memory in queries with long doclists. */</span>
<a name="l00558"></a>00558   assert( in-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> );
<a name="l00559"></a>00559   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;r, in);
<a name="l00560"></a>00560   <a class="code" href="fts1_8c.html#ab9c4fadccc51f39560c880c3d031a27b">docListInit</a>(&amp;out, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a>, NULL, 0);
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   <span class="keywordflow">while</span>( !<a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(&amp;r) ){
<a name="l00563"></a>00563     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid = <a class="code" href="fts1_8c.html#a9fb0f7bec80b2dbc1bc2afdb7a13b51d">readDocid</a>(&amp;r);
<a name="l00564"></a>00564     <span class="keywordtype">int</span> <a class="code" href="lstrlib_8c.html#a52a45835b75e5d31ec66421456bbb728">match</a> = 0;
<a name="l00565"></a>00565     <span class="keywordtype">int</span> iPos, iColumn;
<a name="l00566"></a>00566     <span class="keywordflow">while</span>( (iPos = <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(&amp;r, &amp;iColumn)) != -1 ){
<a name="l00567"></a>00567       <span class="keywordflow">if</span>( !match ){
<a name="l00568"></a>00568         <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(&amp;out, iDocid);
<a name="l00569"></a>00569         match = 1;
<a name="l00570"></a>00570       }
<a name="l00571"></a>00571       <a class="code" href="fts1_8c.html#a105f3796bdaec568d23860c752aaab38">docListAddPos</a>(&amp;out, iColumn, iPos);
<a name="l00572"></a>00572     }
<a name="l00573"></a>00573   }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575   <a class="code" href="fts1_8c.html#afc9760991434278d35e17d8b0ab59001">docListDestroy</a>(in);
<a name="l00576"></a>00576   *in = out;
<a name="l00577"></a>00577 }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 <span class="comment">/* Helper function for docListUpdate() and docListAccumulate().</span>
<a name="l00580"></a>00580 <span class="comment">** Splices a doclist element into the doclist represented by r,</span>
<a name="l00581"></a>00581 <span class="comment">** leaving r pointing after the newly spliced element.</span>
<a name="l00582"></a>00582 <span class="comment">*/</span>
<a name="l00583"></a><a class="code" href="fts1_8c.html#ad19a2b404cf3d71b8950638d0ef534f0">00583</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#ad19a2b404cf3d71b8950638d0ef534f0">docListSpliceElement</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *r, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid,
<a name="l00584"></a>00584                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *pSource, <span class="keywordtype">int</span> nSource){
<a name="l00585"></a>00585   <a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a> = r-&gt;<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>;
<a name="l00586"></a>00586   <span class="keywordtype">char</span> *pTarget;
<a name="l00587"></a>00587   <span class="keywordtype">int</span> nTarget, found;
<a name="l00588"></a>00588 
<a name="l00589"></a>00589   found = <a class="code" href="fts1_8c.html#a9773da327fecea3d6daf279d374808d8">skipToDocid</a>(r, iDocid);
<a name="l00590"></a>00590 
<a name="l00591"></a>00591   <span class="comment">/* Describe slice in d to place pSource/nSource. */</span>
<a name="l00592"></a>00592   pTarget = r-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>;
<a name="l00593"></a>00593   <span class="keywordflow">if</span>( found ){
<a name="l00594"></a>00594     <a class="code" href="fts1_8c.html#a4bfe356b1bf6d861bee8dfebd13a7cde">skipDocument</a>(r);
<a name="l00595"></a>00595     nTarget = r-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>-pTarget;
<a name="l00596"></a>00596   }<span class="keywordflow">else</span>{
<a name="l00597"></a>00597     nTarget = 0;
<a name="l00598"></a>00598   }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600   <span class="comment">/* The sense of the following is that there are three possibilities.</span>
<a name="l00601"></a>00601 <span class="comment">  ** If nTarget==nSource, we should not move any memory nor realloc.</span>
<a name="l00602"></a>00602 <span class="comment">  ** If nTarget&gt;nSource, trim target and realloc.</span>
<a name="l00603"></a>00603 <span class="comment">  ** If nTarget&lt;nSource, realloc then expand target.</span>
<a name="l00604"></a>00604 <span class="comment">  */</span>
<a name="l00605"></a>00605   <span class="keywordflow">if</span>( nTarget&gt;nSource ){
<a name="l00606"></a>00606     memmove(pTarget+nSource, pTarget+nTarget, <a class="code" href="fts1_8c.html#a32c4b74e8bc1ccdfb04b8ef9e151775c">docListEnd</a>(d)-(pTarget+nTarget));
<a name="l00607"></a>00607   }
<a name="l00608"></a>00608   <span class="keywordflow">if</span>( nTarget!=nSource ){
<a name="l00609"></a>00609     <span class="keywordtype">int</span> iDoclist = pTarget-d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>;
<a name="l00610"></a>00610     d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a> = realloc(d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>, d-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>+nSource-nTarget);
<a name="l00611"></a>00611     pTarget = d-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>+iDoclist;
<a name="l00612"></a>00612   }
<a name="l00613"></a>00613   <span class="keywordflow">if</span>( nTarget&lt;nSource ){
<a name="l00614"></a>00614     memmove(pTarget+nSource, pTarget+nTarget, <a class="code" href="fts1_8c.html#a32c4b74e8bc1ccdfb04b8ef9e151775c">docListEnd</a>(d)-(pTarget+nTarget));
<a name="l00615"></a>00615   }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   memcpy(pTarget, pSource, nSource);
<a name="l00618"></a>00618   d-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a> += nSource-nTarget;
<a name="l00619"></a>00619   r-&gt;<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a> = pTarget+nSource;
<a name="l00620"></a>00620 }
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="comment">/* Insert/update pUpdate into the doclist. */</span>
<a name="l00623"></a><a class="code" href="fts1_8c.html#a943610659adb4c0b15897cb5d57aa3e2">00623</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a943610659adb4c0b15897cb5d57aa3e2">docListUpdate</a>(<a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>, <a class="code" href="structDocList.html">DocList</a> *pUpdate){
<a name="l00624"></a>00624   <a class="code" href="structDocListReader.html">DocListReader</a> reader;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626   assert( d!=NULL &amp;&amp; pUpdate!=NULL );
<a name="l00627"></a>00627   assert( d-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>==pUpdate-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>);
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;reader, d);
<a name="l00630"></a>00630   <a class="code" href="fts1_8c.html#ad19a2b404cf3d71b8950638d0ef534f0">docListSpliceElement</a>(&amp;reader, <a class="code" href="fts1_8c.html#a0c7e8e20502babc12c58345078bcec3b">firstDocid</a>(pUpdate),
<a name="l00631"></a>00631                        pUpdate-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>, pUpdate-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>);
<a name="l00632"></a>00632 }
<a name="l00633"></a>00633 
<a name="l00634"></a>00634 <span class="comment">/* Propagate elements from pUpdate to pAcc, overwriting elements with</span>
<a name="l00635"></a>00635 <span class="comment">** matching docids.</span>
<a name="l00636"></a>00636 <span class="comment">*/</span>
<a name="l00637"></a><a class="code" href="fts1_8c.html#ac74a82f8f6e2273fb58b6bdf1d1f3f31">00637</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#ac74a82f8f6e2273fb58b6bdf1d1f3f31">docListAccumulate</a>(<a class="code" href="structDocList.html">DocList</a> *pAcc, <a class="code" href="structDocList.html">DocList</a> *pUpdate){
<a name="l00638"></a>00638   <a class="code" href="structDocListReader.html">DocListReader</a> accReader, updateReader;
<a name="l00639"></a>00639 
<a name="l00640"></a>00640   <span class="comment">/* Handle edge cases where one doclist is empty. */</span>
<a name="l00641"></a>00641   assert( pAcc!=NULL );
<a name="l00642"></a>00642   <span class="keywordflow">if</span>( pUpdate==NULL || pUpdate-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>==0 ) <span class="keywordflow">return</span>;
<a name="l00643"></a>00643   <span class="keywordflow">if</span>( pAcc-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>==0 ){
<a name="l00644"></a>00644     pAcc-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a> = malloc(pUpdate-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>);
<a name="l00645"></a>00645     memcpy(pAcc-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>, pUpdate-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>, pUpdate-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>);
<a name="l00646"></a>00646     pAcc-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a> = pUpdate-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>;
<a name="l00647"></a>00647     <span class="keywordflow">return</span>;
<a name="l00648"></a>00648   }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;accReader, pAcc);
<a name="l00651"></a>00651   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;updateReader, pUpdate);
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <span class="keywordflow">while</span>( !<a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(&amp;updateReader) ){
<a name="l00654"></a>00654     <span class="keywordtype">char</span> *pSource = updateReader.<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>;
<a name="l00655"></a>00655     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid = <a class="code" href="fts1_8c.html#a9fb0f7bec80b2dbc1bc2afdb7a13b51d">readDocid</a>(&amp;updateReader);
<a name="l00656"></a>00656     <a class="code" href="fts1_8c.html#a19e60ea05015383b586aaf71b9bb20db">skipPositionList</a>(&amp;updateReader);
<a name="l00657"></a>00657     <a class="code" href="fts1_8c.html#ad19a2b404cf3d71b8950638d0ef534f0">docListSpliceElement</a>(&amp;accReader, iDocid, pSource, updateReader.<a class="code" href="structDocListReader.html#add4f84189d427052ea482390168b27f7">p</a>-pSource);
<a name="l00658"></a>00658   }
<a name="l00659"></a>00659 }
<a name="l00660"></a>00660 
<a name="l00661"></a>00661 <span class="comment">/*</span>
<a name="l00662"></a>00662 <span class="comment">** Read the next docid off of pIn.  Return 0 if we reach the end.</span>
<a name="l00663"></a>00663 <span class="comment">*</span>
<a name="l00664"></a>00664 <span class="comment">* TODO: This assumes that docids are never 0, but they may actually be 0 since</span>
<a name="l00665"></a>00665 <span class="comment">* users can choose docids when inserting into a full-text table.  Fix this.</span>
<a name="l00666"></a>00666 <span class="comment">*/</span>
<a name="l00667"></a><a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">00667</a> <span class="keyword">static</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(<a class="code" href="structDocListReader.html">DocListReader</a> *pIn){
<a name="l00668"></a>00668   <a class="code" href="fts1_8c.html#a19e60ea05015383b586aaf71b9bb20db">skipPositionList</a>(pIn);
<a name="l00669"></a>00669   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#a47a3f8a7b363e0f8d4552e62f771d9a8">atEnd</a>(pIn) ? 0 : <a class="code" href="fts1_8c.html#a9fb0f7bec80b2dbc1bc2afdb7a13b51d">readDocid</a>(pIn);
<a name="l00670"></a>00670 }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="comment">/*</span>
<a name="l00673"></a>00673 <span class="comment">** pLeft and pRight are two DocListReaders that are pointing to</span>
<a name="l00674"></a>00674 <span class="comment">** positions lists of the same document: iDocid. </span>
<a name="l00675"></a>00675 <span class="comment">**</span>
<a name="l00676"></a>00676 <span class="comment">** If there are no instances in pLeft or pRight where the position</span>
<a name="l00677"></a>00677 <span class="comment">** of pLeft is one less than the position of pRight, then this</span>
<a name="l00678"></a>00678 <span class="comment">** routine adds nothing to pOut.</span>
<a name="l00679"></a>00679 <span class="comment">**</span>
<a name="l00680"></a>00680 <span class="comment">** If there are one or more instances where positions from pLeft</span>
<a name="l00681"></a>00681 <span class="comment">** are exactly one less than positions from pRight, then add a new</span>
<a name="l00682"></a>00682 <span class="comment">** document record to pOut.  If pOut wants to hold positions, then</span>
<a name="l00683"></a>00683 <span class="comment">** include the positions from pRight that are one more than a</span>
<a name="l00684"></a>00684 <span class="comment">** position in pLeft.  In other words:  pRight.iPos==pLeft.iPos+1.</span>
<a name="l00685"></a>00685 <span class="comment">**</span>
<a name="l00686"></a>00686 <span class="comment">** pLeft and pRight are left pointing at the next document record.</span>
<a name="l00687"></a>00687 <span class="comment">*/</span>
<a name="l00688"></a><a class="code" href="fts1_8c.html#aa7f3f615cf55ee455e91a3f8dd53f8e8">00688</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#aa7f3f615cf55ee455e91a3f8dd53f8e8">mergePosList</a>(
<a name="l00689"></a>00689   <a class="code" href="structDocListReader.html">DocListReader</a> *pLeft,    <span class="comment">/* Left position list */</span>
<a name="l00690"></a>00690   <a class="code" href="structDocListReader.html">DocListReader</a> *pRight,   <span class="comment">/* Right position list */</span>
<a name="l00691"></a>00691   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid,     <span class="comment">/* The docid from pLeft and pRight */</span>
<a name="l00692"></a>00692   <a class="code" href="structDocList.html">DocList</a> *pOut            <span class="comment">/* Write the merged document record here */</span>
<a name="l00693"></a>00693 ){
<a name="l00694"></a>00694   <span class="keywordtype">int</span> iLeftCol, iLeftPos = <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(pLeft, &amp;iLeftCol);
<a name="l00695"></a>00695   <span class="keywordtype">int</span> iRightCol, iRightPos = <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(pRight, &amp;iRightCol);
<a name="l00696"></a>00696   <span class="keywordtype">int</span> <a class="code" href="lstrlib_8c.html#a52a45835b75e5d31ec66421456bbb728">match</a> = 0;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   <span class="comment">/* Loop until we&apos;ve reached the end of both position lists. */</span>
<a name="l00699"></a>00699   <span class="keywordflow">while</span>( iLeftPos!=-1 &amp;&amp; iRightPos!=-1 ){
<a name="l00700"></a>00700     <span class="keywordflow">if</span>( iLeftCol==iRightCol &amp;&amp; iLeftPos+1==iRightPos ){
<a name="l00701"></a>00701       <span class="keywordflow">if</span>( !match ){
<a name="l00702"></a>00702         <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(pOut, iDocid);
<a name="l00703"></a>00703         match = 1;
<a name="l00704"></a>00704       }
<a name="l00705"></a>00705       <span class="keywordflow">if</span>( pOut-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ){
<a name="l00706"></a>00706         <a class="code" href="fts1_8c.html#a105f3796bdaec568d23860c752aaab38">docListAddPos</a>(pOut, iRightCol, iRightPos);
<a name="l00707"></a>00707       }
<a name="l00708"></a>00708       iLeftPos = <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(pLeft, &amp;iLeftCol);
<a name="l00709"></a>00709       iRightPos = <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(pRight, &amp;iRightCol);
<a name="l00710"></a>00710     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( iRightCol&lt;iLeftCol ||
<a name="l00711"></a>00711               (iRightCol==iLeftCol &amp;&amp; iRightPos&lt;iLeftPos+1) ){
<a name="l00712"></a>00712       iRightPos = <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(pRight, &amp;iRightCol);
<a name="l00713"></a>00713     }<span class="keywordflow">else</span>{
<a name="l00714"></a>00714       iLeftPos = <a class="code" href="fts1_8c.html#ac36a29778e83c8ebfe04b675fda89d79">readPosition</a>(pLeft, &amp;iLeftCol);
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716   }
<a name="l00717"></a>00717   <span class="keywordflow">if</span>( iLeftPos&gt;=0 ) <a class="code" href="fts1_8c.html#a19e60ea05015383b586aaf71b9bb20db">skipPositionList</a>(pLeft);
<a name="l00718"></a>00718   <span class="keywordflow">if</span>( iRightPos&gt;=0 ) <a class="code" href="fts1_8c.html#a19e60ea05015383b586aaf71b9bb20db">skipPositionList</a>(pRight);
<a name="l00719"></a>00719 }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 <span class="comment">/* We have two doclists:  pLeft and pRight.</span>
<a name="l00722"></a>00722 <span class="comment">** Write the phrase intersection of these two doclists into pOut.</span>
<a name="l00723"></a>00723 <span class="comment">**</span>
<a name="l00724"></a>00724 <span class="comment">** A phrase intersection means that two documents only match</span>
<a name="l00725"></a>00725 <span class="comment">** if pLeft.iPos+1==pRight.iPos.</span>
<a name="l00726"></a>00726 <span class="comment">**</span>
<a name="l00727"></a>00727 <span class="comment">** The output pOut may or may not contain positions.  If pOut</span>
<a name="l00728"></a>00728 <span class="comment">** does contain positions, they are the positions of pRight.</span>
<a name="l00729"></a>00729 <span class="comment">*/</span>
<a name="l00730"></a><a class="code" href="fts1_8c.html#a784500b205fb2c1a6f5964bb9d71123c">00730</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a784500b205fb2c1a6f5964bb9d71123c">docListPhraseMerge</a>(
<a name="l00731"></a>00731   <a class="code" href="structDocList.html">DocList</a> *pLeft,    <span class="comment">/* Doclist resulting from the words on the left */</span>
<a name="l00732"></a>00732   <a class="code" href="structDocList.html">DocList</a> *pRight,   <span class="comment">/* Doclist for the next word to the right */</span>
<a name="l00733"></a>00733   <a class="code" href="structDocList.html">DocList</a> *pOut      <span class="comment">/* Write the combined doclist here */</span>
<a name="l00734"></a>00734 ){
<a name="l00735"></a>00735   <a class="code" href="structDocListReader.html">DocListReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l00736"></a>00736   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> docidLeft, docidRight;
<a name="l00737"></a>00737 
<a name="l00738"></a>00738   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;left, pLeft);
<a name="l00739"></a>00739   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;right, pRight);
<a name="l00740"></a>00740   docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00741"></a>00741   docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00742"></a>00742 
<a name="l00743"></a>00743   <span class="keywordflow">while</span>( docidLeft&gt;0 &amp;&amp; docidRight&gt;0 ){
<a name="l00744"></a>00744     <span class="keywordflow">if</span>( docidLeft&lt;docidRight ){
<a name="l00745"></a>00745       docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00746"></a>00746     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( docidRight&lt;docidLeft ){
<a name="l00747"></a>00747       docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00748"></a>00748     }<span class="keywordflow">else</span>{
<a name="l00749"></a>00749       <a class="code" href="fts1_8c.html#aa7f3f615cf55ee455e91a3f8dd53f8e8">mergePosList</a>(&amp;left, &amp;right, docidLeft, pOut);
<a name="l00750"></a>00750       docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00751"></a>00751       docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00752"></a>00752     }
<a name="l00753"></a>00753   }
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 <span class="comment">/* We have two doclists:  pLeft and pRight.</span>
<a name="l00757"></a>00757 <span class="comment">** Write the intersection of these two doclists into pOut.</span>
<a name="l00758"></a>00758 <span class="comment">** Only docids are matched.  Position information is ignored.</span>
<a name="l00759"></a>00759 <span class="comment">**</span>
<a name="l00760"></a>00760 <span class="comment">** The output pOut never holds positions.</span>
<a name="l00761"></a>00761 <span class="comment">*/</span>
<a name="l00762"></a><a class="code" href="fts1_8c.html#a541c327a224f0af61097c21eabd9c5d4">00762</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a541c327a224f0af61097c21eabd9c5d4">docListAndMerge</a>(
<a name="l00763"></a>00763   <a class="code" href="structDocList.html">DocList</a> *pLeft,    <span class="comment">/* Doclist resulting from the words on the left */</span>
<a name="l00764"></a>00764   <a class="code" href="structDocList.html">DocList</a> *pRight,   <span class="comment">/* Doclist for the next word to the right */</span>
<a name="l00765"></a>00765   <a class="code" href="structDocList.html">DocList</a> *pOut      <span class="comment">/* Write the combined doclist here */</span>
<a name="l00766"></a>00766 ){
<a name="l00767"></a>00767   <a class="code" href="structDocListReader.html">DocListReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l00768"></a>00768   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> docidLeft, docidRight;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770   assert( pOut-&gt;<a class="code" href="structDocList.html#a2df3a2f3feeeb9b380bbc501d80ce77f">iType</a>&lt;<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> );
<a name="l00771"></a>00771 
<a name="l00772"></a>00772   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;left, pLeft);
<a name="l00773"></a>00773   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;right, pRight);
<a name="l00774"></a>00774   docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00775"></a>00775   docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00776"></a>00776 
<a name="l00777"></a>00777   <span class="keywordflow">while</span>( docidLeft&gt;0 &amp;&amp; docidRight&gt;0 ){
<a name="l00778"></a>00778     <span class="keywordflow">if</span>( docidLeft&lt;docidRight ){
<a name="l00779"></a>00779       docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00780"></a>00780     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( docidRight&lt;docidLeft ){
<a name="l00781"></a>00781       docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00782"></a>00782     }<span class="keywordflow">else</span>{
<a name="l00783"></a>00783       <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(pOut, docidLeft);
<a name="l00784"></a>00784       docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00785"></a>00785       docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00786"></a>00786     }
<a name="l00787"></a>00787   }
<a name="l00788"></a>00788 }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 <span class="comment">/* We have two doclists:  pLeft and pRight.</span>
<a name="l00791"></a>00791 <span class="comment">** Write the union of these two doclists into pOut.</span>
<a name="l00792"></a>00792 <span class="comment">** Only docids are matched.  Position information is ignored.</span>
<a name="l00793"></a>00793 <span class="comment">**</span>
<a name="l00794"></a>00794 <span class="comment">** The output pOut never holds positions.</span>
<a name="l00795"></a>00795 <span class="comment">*/</span>
<a name="l00796"></a><a class="code" href="fts1_8c.html#a2e2342760a086ba0823b626776c63079">00796</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a2e2342760a086ba0823b626776c63079">docListOrMerge</a>(
<a name="l00797"></a>00797   <a class="code" href="structDocList.html">DocList</a> *pLeft,    <span class="comment">/* Doclist resulting from the words on the left */</span>
<a name="l00798"></a>00798   <a class="code" href="structDocList.html">DocList</a> *pRight,   <span class="comment">/* Doclist for the next word to the right */</span>
<a name="l00799"></a>00799   <a class="code" href="structDocList.html">DocList</a> *pOut      <span class="comment">/* Write the combined doclist here */</span>
<a name="l00800"></a>00800 ){
<a name="l00801"></a>00801   <a class="code" href="structDocListReader.html">DocListReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l00802"></a>00802   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> docidLeft, docidRight, priorLeft;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;left, pLeft);
<a name="l00805"></a>00805   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;right, pRight);
<a name="l00806"></a>00806   docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00807"></a>00807   docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00808"></a>00808 
<a name="l00809"></a>00809   <span class="keywordflow">while</span>( docidLeft&gt;0 &amp;&amp; docidRight&gt;0 ){
<a name="l00810"></a>00810     <span class="keywordflow">if</span>( docidLeft&lt;=docidRight ){
<a name="l00811"></a>00811       <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(pOut, docidLeft);
<a name="l00812"></a>00812     }<span class="keywordflow">else</span>{
<a name="l00813"></a>00813       <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(pOut, docidRight);
<a name="l00814"></a>00814     }
<a name="l00815"></a>00815     priorLeft = docidLeft;
<a name="l00816"></a>00816     <span class="keywordflow">if</span>( docidLeft&lt;=docidRight ){
<a name="l00817"></a>00817       docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00818"></a>00818     }
<a name="l00819"></a>00819     <span class="keywordflow">if</span>( docidRight&gt;0 &amp;&amp; docidRight&lt;=priorLeft ){
<a name="l00820"></a>00820       docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00821"></a>00821     }
<a name="l00822"></a>00822   }
<a name="l00823"></a>00823   <span class="keywordflow">while</span>( docidLeft&gt;0 ){
<a name="l00824"></a>00824     <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(pOut, docidLeft);
<a name="l00825"></a>00825     docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00826"></a>00826   }
<a name="l00827"></a>00827   <span class="keywordflow">while</span>( docidRight&gt;0 ){
<a name="l00828"></a>00828     <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(pOut, docidRight);
<a name="l00829"></a>00829     docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00830"></a>00830   }
<a name="l00831"></a>00831 }
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 <span class="comment">/* We have two doclists:  pLeft and pRight.</span>
<a name="l00834"></a>00834 <span class="comment">** Write into pOut all documents that occur in pLeft but not</span>
<a name="l00835"></a>00835 <span class="comment">** in pRight.</span>
<a name="l00836"></a>00836 <span class="comment">**</span>
<a name="l00837"></a>00837 <span class="comment">** Only docids are matched.  Position information is ignored.</span>
<a name="l00838"></a>00838 <span class="comment">**</span>
<a name="l00839"></a>00839 <span class="comment">** The output pOut never holds positions.</span>
<a name="l00840"></a>00840 <span class="comment">*/</span>
<a name="l00841"></a><a class="code" href="fts1_8c.html#ad8c4948e85c6c7fd1e4b324beeaf2b46">00841</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#ad8c4948e85c6c7fd1e4b324beeaf2b46">docListExceptMerge</a>(
<a name="l00842"></a>00842   <a class="code" href="structDocList.html">DocList</a> *pLeft,    <span class="comment">/* Doclist resulting from the words on the left */</span>
<a name="l00843"></a>00843   <a class="code" href="structDocList.html">DocList</a> *pRight,   <span class="comment">/* Doclist for the next word to the right */</span>
<a name="l00844"></a>00844   <a class="code" href="structDocList.html">DocList</a> *pOut      <span class="comment">/* Write the combined doclist here */</span>
<a name="l00845"></a>00845 ){
<a name="l00846"></a>00846   <a class="code" href="structDocListReader.html">DocListReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l00847"></a>00847   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> docidLeft, docidRight, priorLeft;
<a name="l00848"></a>00848 
<a name="l00849"></a>00849   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;left, pLeft);
<a name="l00850"></a>00850   <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;right, pRight);
<a name="l00851"></a>00851   docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00852"></a>00852   docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00853"></a>00853 
<a name="l00854"></a>00854   <span class="keywordflow">while</span>( docidLeft&gt;0 &amp;&amp; docidRight&gt;0 ){
<a name="l00855"></a>00855     priorLeft = docidLeft;
<a name="l00856"></a>00856     <span class="keywordflow">if</span>( docidLeft&lt;docidRight ){
<a name="l00857"></a>00857       <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(pOut, docidLeft);
<a name="l00858"></a>00858     }
<a name="l00859"></a>00859     <span class="keywordflow">if</span>( docidLeft&lt;=docidRight ){
<a name="l00860"></a>00860       docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00861"></a>00861     }
<a name="l00862"></a>00862     <span class="keywordflow">if</span>( docidRight&gt;0 &amp;&amp; docidRight&lt;=priorLeft ){
<a name="l00863"></a>00863       docidRight = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;right);
<a name="l00864"></a>00864     }
<a name="l00865"></a>00865   }
<a name="l00866"></a>00866   <span class="keywordflow">while</span>( docidLeft&gt;0 ){
<a name="l00867"></a>00867     <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(pOut, docidLeft);
<a name="l00868"></a>00868     docidLeft = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;left);
<a name="l00869"></a>00869   }
<a name="l00870"></a>00870 }
<a name="l00871"></a>00871 
<a name="l00872"></a><a class="code" href="fts1_8c.html#a1bd93cdd9e47ca6e2aeb514b515c221b">00872</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts1_8c.html#a1bd93cdd9e47ca6e2aeb514b515c221b">string_dup_n</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> n){
<a name="l00873"></a>00873   <span class="keywordtype">char</span> *str = malloc(n + 1);
<a name="l00874"></a>00874   memcpy(str, s, n);
<a name="l00875"></a>00875   str[n] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00876"></a>00876   <span class="keywordflow">return</span> str;
<a name="l00877"></a>00877 }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879 <span class="comment">/* Duplicate a string; the caller must free() the returned string.</span>
<a name="l00880"></a>00880 <span class="comment"> * (We don&apos;t use strdup() since it is not part of the standard C library and</span>
<a name="l00881"></a>00881 <span class="comment"> * may not be available everywhere.) */</span>
<a name="l00882"></a><a class="code" href="fts1_8c.html#a7a1ca6e7e7b15d27e59df8a9da195d77">00882</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts1_8c.html#a7a1ca6e7e7b15d27e59df8a9da195d77">string_dup</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s){
<a name="l00883"></a>00883   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#a1bd93cdd9e47ca6e2aeb514b515c221b">string_dup_n</a>(s, strlen(s));
<a name="l00884"></a>00884 }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 <span class="comment">/* Format a string, replacing each occurrence of the % character with</span>
<a name="l00887"></a>00887 <span class="comment"> * zDb.zName.  This may be more convenient than sqlite_mprintf()</span>
<a name="l00888"></a>00888 <span class="comment"> * when one string is used repeatedly in a format string.</span>
<a name="l00889"></a>00889 <span class="comment"> * The caller must free() the returned string. */</span>
<a name="l00890"></a><a class="code" href="fts1_8c.html#ae30be3db8b2e8e3fc7675a0683646676">00890</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts1_8c.html#ae30be3db8b2e8e3fc7675a0683646676">string_format</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat,
<a name="l00891"></a>00891                            <span class="keyword">const</span> <span class="keywordtype">char</span> *zDb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zName){
<a name="l00892"></a>00892   <span class="keyword">const</span> <span class="keywordtype">char</span> *p;
<a name="l00893"></a>00893   <span class="keywordtype">size_t</span> len = 0;
<a name="l00894"></a>00894   <span class="keywordtype">size_t</span> nDb = strlen(zDb);
<a name="l00895"></a>00895   <span class="keywordtype">size_t</span> nName = strlen(zName);
<a name="l00896"></a>00896   <span class="keywordtype">size_t</span> nFullTableName = nDb+1+nName;
<a name="l00897"></a>00897   <span class="keywordtype">char</span> *result;
<a name="l00898"></a>00898   <span class="keywordtype">char</span> *r;
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   <span class="comment">/* first compute length needed */</span>
<a name="l00901"></a>00901   <span class="keywordflow">for</span>(p = zFormat ; *p ; ++p){
<a name="l00902"></a>00902     len += (*p==<span class="charliteral">&apos;%&apos;</span> ? nFullTableName : 1);
<a name="l00903"></a>00903   }
<a name="l00904"></a>00904   len += 1;  <span class="comment">/* for null terminator */</span>
<a name="l00905"></a>00905 
<a name="l00906"></a>00906   r = result = malloc(len);
<a name="l00907"></a>00907   <span class="keywordflow">for</span>(p = zFormat; *p; ++p){
<a name="l00908"></a>00908     <span class="keywordflow">if</span>( *p==<span class="charliteral">&apos;%&apos;</span> ){
<a name="l00909"></a>00909       memcpy(r, zDb, nDb);
<a name="l00910"></a>00910       r += nDb;
<a name="l00911"></a>00911       *r++ = <span class="charliteral">&apos;.&apos;</span>;
<a name="l00912"></a>00912       memcpy(r, zName, nName);
<a name="l00913"></a>00913       r += nName;
<a name="l00914"></a>00914     } <span class="keywordflow">else</span> {
<a name="l00915"></a>00915       *r++ = *p;
<a name="l00916"></a>00916     }
<a name="l00917"></a>00917   }
<a name="l00918"></a>00918   *r++ = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00919"></a>00919   assert( r == result + len );
<a name="l00920"></a>00920   <span class="keywordflow">return</span> result;
<a name="l00921"></a>00921 }
<a name="l00922"></a>00922 
<a name="l00923"></a><a class="code" href="fts1_8c.html#a39d956ab682bbd568f87016368f26aee">00923</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a39d956ab682bbd568f87016368f26aee">sql_exec</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *zDb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,
<a name="l00924"></a>00924                     <span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat){
<a name="l00925"></a>00925   <span class="keywordtype">char</span> *zCommand = <a class="code" href="fts1_8c.html#ae30be3db8b2e8e3fc7675a0683646676">string_format</a>(zFormat, zDb, zName);
<a name="l00926"></a>00926   <span class="keywordtype">int</span> rc;
<a name="l00927"></a>00927   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 sql: %s\n&quot;</span>, zCommand));
<a name="l00928"></a>00928   rc = <a class="code" href="legacy_8c.html#ada787486cf95a994521cfd0c64e853e4">sqlite3_exec</a>(db, zCommand, NULL, 0, NULL);
<a name="l00929"></a>00929   free(zCommand);
<a name="l00930"></a>00930   <span class="keywordflow">return</span> rc;
<a name="l00931"></a>00931 }
<a name="l00932"></a>00932 
<a name="l00933"></a><a class="code" href="fts1_8c.html#a90c49c1625eff6f726a4ce28200e24d4">00933</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a90c49c1625eff6f726a4ce28200e24d4">sql_prepare</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *zDb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,
<a name="l00934"></a>00934                        <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> **ppStmt, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat){
<a name="l00935"></a>00935   <span class="keywordtype">char</span> *zCommand = <a class="code" href="fts1_8c.html#ae30be3db8b2e8e3fc7675a0683646676">string_format</a>(zFormat, zDb, zName);
<a name="l00936"></a>00936   <span class="keywordtype">int</span> rc;
<a name="l00937"></a>00937   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 prepare: %s\n&quot;</span>, zCommand));
<a name="l00938"></a>00938   rc = <a class="code" href="prepare_8c.html#a2322405eadeb95539ec7c96e2cfdf38b">sqlite3_prepare</a>(db, zCommand, -1, ppStmt, NULL);
<a name="l00939"></a>00939   free(zCommand);
<a name="l00940"></a>00940   <span class="keywordflow">return</span> rc;
<a name="l00941"></a>00941 }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943 <span class="comment">/* end utility functions */</span>
<a name="l00944"></a>00944 
<a name="l00945"></a>00945 <span class="comment">/* Forward reference */</span>
<a name="l00946"></a><a class="code" href="fts1_8c.html#a51038c9c7231d3309a70de308e15f6dc">00946</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a>;
<a name="l00947"></a>00947 
<a name="l00948"></a>00948 <span class="comment">/* A single term in a query is represented by an instances of</span>
<a name="l00949"></a>00949 <span class="comment">** the following structure.</span>
<a name="l00950"></a>00950 <span class="comment">*/</span>
<a name="l00951"></a><a class="code" href="structQueryTerm.html">00951</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structQueryTerm.html">QueryTerm</a> {
<a name="l00952"></a><a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">00952</a>   <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a>; <span class="comment">/* How many following terms are part of the same phrase */</span>
<a name="l00953"></a><a class="code" href="structQueryTerm.html#abea35c7535689b4425baad079834a74c">00953</a>   <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structQueryTerm.html#abea35c7535689b4425baad079834a74c">iPhrase</a>; <span class="comment">/* This is the i-th term of a phrase. */</span>
<a name="l00954"></a><a class="code" href="structQueryTerm.html#a71a4c3b5b3246a6e2e7347d0d71edf2c">00954</a>   <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structQueryTerm.html#a71a4c3b5b3246a6e2e7347d0d71edf2c">iColumn</a>; <span class="comment">/* Column of the index that must match this term */</span>
<a name="l00955"></a><a class="code" href="structQueryTerm.html#af7018292d462a2b11f4acd1dd440bf03">00955</a>   <span class="keywordtype">signed</span> <span class="keywordtype">char</span> <a class="code" href="structQueryTerm.html#af7018292d462a2b11f4acd1dd440bf03">isOr</a>;  <span class="comment">/* this term is preceded by &quot;OR&quot; */</span>
<a name="l00956"></a><a class="code" href="structQueryTerm.html#a173e6f424ffb75f22ac977b041511361">00956</a>   <span class="keywordtype">signed</span> <span class="keywordtype">char</span> <a class="code" href="structQueryTerm.html#a173e6f424ffb75f22ac977b041511361">isNot</a>; <span class="comment">/* this term is preceded by &quot;-&quot; */</span>
<a name="l00957"></a><a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">00957</a>   <span class="keywordtype">char</span> *<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>;       <span class="comment">/* text of the term.  &apos;\000&apos; terminated.  malloced */</span>
<a name="l00958"></a><a class="code" href="structQueryTerm.html#aeeb3d5a5c0c62dc9d0966204c8cae819">00958</a>   <span class="keywordtype">int</span> <a class="code" href="structQueryTerm.html#aeeb3d5a5c0c62dc9d0966204c8cae819">nTerm</a>;         <span class="comment">/* Number of bytes in pTerm[] */</span>
<a name="l00959"></a>00959 } <a class="code" href="structQueryTerm.html">QueryTerm</a>;
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 <span class="comment">/* A query string is parsed into a Query structure.</span>
<a name="l00963"></a>00963 <span class="comment"> *</span>
<a name="l00964"></a>00964 <span class="comment"> * We could, in theory, allow query strings to be complicated</span>
<a name="l00965"></a>00965 <span class="comment"> * nested expressions with precedence determined by parentheses.</span>
<a name="l00966"></a>00966 <span class="comment"> * But none of the major search engines do this.  (Perhaps the</span>
<a name="l00967"></a>00967 <span class="comment"> * feeling is that an parenthesized expression is two complex of</span>
<a name="l00968"></a>00968 <span class="comment"> * an idea for the average user to grasp.)  Taking our lead from</span>
<a name="l00969"></a>00969 <span class="comment"> * the major search engines, we will allow queries to be a list</span>
<a name="l00970"></a>00970 <span class="comment"> * of terms (with an implied AND operator) or phrases in double-quotes,</span>
<a name="l00971"></a>00971 <span class="comment"> * with a single optional &quot;-&quot; before each non-phrase term to designate</span>
<a name="l00972"></a>00972 <span class="comment"> * negation and an optional OR connector.</span>
<a name="l00973"></a>00973 <span class="comment"> *</span>
<a name="l00974"></a>00974 <span class="comment"> * OR binds more tightly than the implied AND, which is what the</span>
<a name="l00975"></a>00975 <span class="comment"> * major search engines seem to do.  So, for example:</span>
<a name="l00976"></a>00976 <span class="comment"> * </span>
<a name="l00977"></a>00977 <span class="comment"> *    [one two OR three]     ==&gt;    one AND (two OR three)</span>
<a name="l00978"></a>00978 <span class="comment"> *    [one OR two three]     ==&gt;    (one OR two) AND three</span>
<a name="l00979"></a>00979 <span class="comment"> *</span>
<a name="l00980"></a>00980 <span class="comment"> * A &quot;-&quot; before a term matches all entries that lack that term.</span>
<a name="l00981"></a>00981 <span class="comment"> * The &quot;-&quot; must occur immediately before the term with in intervening</span>
<a name="l00982"></a>00982 <span class="comment"> * space.  This is how the search engines do it.</span>
<a name="l00983"></a>00983 <span class="comment"> *</span>
<a name="l00984"></a>00984 <span class="comment"> * A NOT term cannot be the right-hand operand of an OR.  If this</span>
<a name="l00985"></a>00985 <span class="comment"> * occurs in the query string, the NOT is ignored:</span>
<a name="l00986"></a>00986 <span class="comment"> *</span>
<a name="l00987"></a>00987 <span class="comment"> *    [one OR -two]          ==&gt;    one OR two</span>
<a name="l00988"></a>00988 <span class="comment"> *</span>
<a name="l00989"></a>00989 <span class="comment"> */</span>
<a name="l00990"></a><a class="code" href="structQuery.html">00990</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structQuery.html">Query</a> {
<a name="l00991"></a><a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">00991</a>   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a>;  <span class="comment">/* The full text index */</span>
<a name="l00992"></a><a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">00992</a>   <span class="keywordtype">int</span> <a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;           <span class="comment">/* Number of terms in the query */</span>
<a name="l00993"></a><a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">00993</a>   <a class="code" href="structQueryTerm.html">QueryTerm</a> *<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>;    <span class="comment">/* Array of terms.  Space obtained from malloc() */</span>
<a name="l00994"></a><a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">00994</a>   <span class="keywordtype">int</span> <a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a>;         <span class="comment">/* Set the isOr flag on the next inserted term */</span>
<a name="l00995"></a><a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">00995</a>   <span class="keywordtype">int</span> <a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a>;       <span class="comment">/* Next word parsed must be in this column */</span>
<a name="l00996"></a><a class="code" href="structQuery.html#af4b5b552a7646059a60c1eace4d2a020">00996</a>   <span class="keywordtype">int</span> <a class="code" href="structQuery.html#af4b5b552a7646059a60c1eace4d2a020">dfltColumn</a>;       <span class="comment">/* The default column */</span>
<a name="l00997"></a>00997 } <a class="code" href="structQuery.html">Query</a>;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999 
<a name="l01000"></a>01000 <span class="comment">/*</span>
<a name="l01001"></a>01001 <span class="comment">** An instance of the following structure keeps track of generated</span>
<a name="l01002"></a>01002 <span class="comment">** matching-word offset information and snippets.</span>
<a name="l01003"></a>01003 <span class="comment">*/</span>
<a name="l01004"></a><a class="code" href="structSnippet.html">01004</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structSnippet.html">Snippet</a> {
<a name="l01005"></a><a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">01005</a>   <span class="keywordtype">int</span> <a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>;     <span class="comment">/* Total number of matches */</span>
<a name="l01006"></a><a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">01006</a>   <span class="keywordtype">int</span> <a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a>;     <span class="comment">/* Space allocated for aMatch[] */</span>
<a name="l01007"></a><a class="code" href="structSnippet_1_1snippetMatch.html">01007</a>   <span class="keyword">struct </span><a class="code" href="structSnippet_1_1snippetMatch.html">snippetMatch</a> { <span class="comment">/* One entry for each matching term */</span>
<a name="l01008"></a><a class="code" href="structSnippet_1_1snippetMatch.html#ac598af81a9803bc14821f25c793b0b71">01008</a>     <span class="keywordtype">char</span> <a class="code" href="structSnippet_1_1snippetMatch.html#ac598af81a9803bc14821f25c793b0b71">snStatus</a>;       <span class="comment">/* Status flag for use while constructing snippets */</span>
<a name="l01009"></a><a class="code" href="structSnippet_1_1snippetMatch.html#aaf3b1781a511ec1a2e459d49ff805538">01009</a>     <span class="keywordtype">short</span> <span class="keywordtype">int</span> iCol;      <span class="comment">/* The column that contains the match */</span>
<a name="l01010"></a><a class="code" href="structSnippet_1_1snippetMatch.html#a0741681e81d0310741da5745ccca9976">01010</a>     <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structSnippet_1_1snippetMatch.html#a0741681e81d0310741da5745ccca9976">iTerm</a>;     <span class="comment">/* The index in Query.pTerms[] of the matching term */</span>
<a name="l01011"></a><a class="code" href="structSnippet_1_1snippetMatch.html#a6b5e06d6f74d8c8467ffec2f0ccff571">01011</a>     <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structSnippet_1_1snippetMatch.html#a6b5e06d6f74d8c8467ffec2f0ccff571">nByte</a>;     <span class="comment">/* Number of bytes in the term */</span>
<a name="l01012"></a><a class="code" href="structSnippet_1_1snippetMatch.html#aaeeac51c4caa2b18402547755de70894">01012</a>     <span class="keywordtype">int</span> <a class="code" href="structSnippet_1_1snippetMatch.html#aaeeac51c4caa2b18402547755de70894">iStart</a>;          <span class="comment">/* The offset to the first character of the term */</span>
<a name="l01013"></a>01013   } *<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>;      <span class="comment">/* Points to space obtained from malloc */</span>
<a name="l01014"></a><a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">01014</a>   <span class="keywordtype">char</span> *<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a>;  <span class="comment">/* Text rendering of aMatch[] */</span>
<a name="l01015"></a><a class="code" href="structSnippet.html#a68aacd704960f6ab1c8f7de23a5d0730">01015</a>   <span class="keywordtype">int</span> <a class="code" href="structSnippet.html#a68aacd704960f6ab1c8f7de23a5d0730">nOffset</a>;    <span class="comment">/* strlen(zOffset) */</span>
<a name="l01016"></a><a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">01016</a>   <span class="keywordtype">char</span> *<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a>; <span class="comment">/* Snippet text */</span>
<a name="l01017"></a><a class="code" href="structSnippet.html#a467392bb026bc056ab7c5466873f8f11">01017</a>   <span class="keywordtype">int</span> <a class="code" href="structSnippet.html#a467392bb026bc056ab7c5466873f8f11">nSnippet</a>;   <span class="comment">/* strlen(zSnippet) */</span>
<a name="l01018"></a>01018 } <a class="code" href="structSnippet.html">Snippet</a>;
<a name="l01019"></a>01019 
<a name="l01020"></a>01020 
<a name="l01021"></a><a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ec">01021</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ec">QueryType</a> {
<a name="l01022"></a><a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">01022</a>   <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">QUERY_GENERIC</a>,   <span class="comment">/* table scan */</span>
<a name="l01023"></a><a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ecadfa9dc6cb33447260116307a64a3c657">01023</a>   <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ecadfa9dc6cb33447260116307a64a3c657">QUERY_ROWID</a>,     <span class="comment">/* lookup by rowid */</span>
<a name="l01024"></a><a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">01024</a>   <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a>   <span class="comment">/* QUERY_FULLTEXT + [i] is a full-text search for column i*/</span>
<a name="l01025"></a>01025 } <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ec">QueryType</a>;
<a name="l01026"></a>01026 
<a name="l01027"></a>01027 <span class="comment">/* TODO(shess) CHUNK_MAX controls how much data we allow in segment 0</span>
<a name="l01028"></a>01028 <span class="comment">** before we start aggregating into larger segments.  Lower CHUNK_MAX</span>
<a name="l01029"></a>01029 <span class="comment">** means that for a given input we have more individual segments per</span>
<a name="l01030"></a>01030 <span class="comment">** term, which means more rows in the table and a bigger index (due to</span>
<a name="l01031"></a>01031 <span class="comment">** both more rows and bigger rowids).  But it also reduces the average</span>
<a name="l01032"></a>01032 <span class="comment">** cost of adding new elements to the segment 0 doclist, and it seems</span>
<a name="l01033"></a>01033 <span class="comment">** to reduce the number of pages read and written during inserts.  256</span>
<a name="l01034"></a>01034 <span class="comment">** was chosen by measuring insertion times for a certain input (first</span>
<a name="l01035"></a>01035 <span class="comment">** 10k documents of Enron corpus), though including query performance</span>
<a name="l01036"></a>01036 <span class="comment">** in the decision may argue for a larger value.</span>
<a name="l01037"></a>01037 <span class="comment">*/</span>
<a name="l01038"></a><a class="code" href="fts1_8c.html#a0cbd9294d93f70cb6650e46ca274704e">01038</a> <span class="preprocessor">#define CHUNK_MAX 256</span>
<a name="l01039"></a>01039 <span class="preprocessor"></span>
<a name="l01040"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">01040</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">fulltext_statement</a> {
<a name="l01041"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ae800de40a0ad0185ff0335c967411a84">01041</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ae800de40a0ad0185ff0335c967411a84">CONTENT_INSERT_STMT</a>,
<a name="l01042"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abfdc634e15bbc89a90bdaf76034fe478">01042</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abfdc634e15bbc89a90bdaf76034fe478">CONTENT_SELECT_STMT</a>,
<a name="l01043"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a016651ce129880970fb699b09f85576c">01043</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a016651ce129880970fb699b09f85576c">CONTENT_UPDATE_STMT</a>,
<a name="l01044"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789acdb161caf82c5437390779f9e886d62e">01044</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789acdb161caf82c5437390779f9e886d62e">CONTENT_DELETE_STMT</a>,
<a name="l01045"></a>01045 
<a name="l01046"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a9b993e3f8dafdad5bca22007262b8fbd">01046</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a9b993e3f8dafdad5bca22007262b8fbd">TERM_SELECT_STMT</a>,
<a name="l01047"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a6fa1db4630bd9cf0a75ff87d4e28d70b">01047</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a6fa1db4630bd9cf0a75ff87d4e28d70b">TERM_SELECT_ALL_STMT</a>,
<a name="l01048"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a288af155f10a1c8bfa8536df50b9d9bb">01048</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a288af155f10a1c8bfa8536df50b9d9bb">TERM_INSERT_STMT</a>,
<a name="l01049"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ab0611ad228ba30414cf6fe9d98c5c4ff">01049</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ab0611ad228ba30414cf6fe9d98c5c4ff">TERM_UPDATE_STMT</a>,
<a name="l01050"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ac194a29a06661801b9758762fd0737e6">01050</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ac194a29a06661801b9758762fd0737e6">TERM_DELETE_STMT</a>,
<a name="l01051"></a>01051 
<a name="l01052"></a><a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">01052</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a>                     <span class="comment">/* Always at end! */</span>
<a name="l01053"></a>01053 } <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">fulltext_statement</a>;
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 <span class="comment">/* These must exactly match the enum above. */</span>
<a name="l01056"></a>01056 <span class="comment">/* TODO(adam): Is there some risk that a statement (in particular,</span>
<a name="l01057"></a>01057 <span class="comment">** pTermSelectStmt) will be used in two cursors at once, e.g.  if a</span>
<a name="l01058"></a>01058 <span class="comment">** query joins a virtual table to itself?  If so perhaps we should</span>
<a name="l01059"></a>01059 <span class="comment">** move some of these to the cursor object.</span>
<a name="l01060"></a>01060 <span class="comment">*/</span>
<a name="l01061"></a><a class="code" href="fts1_8c.html#aa858a7ad9f41049729d556509e08aaf0">01061</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> <a class="code" href="fts1_8c.html#aa858a7ad9f41049729d556509e08aaf0">fulltext_zStatement</a>[<a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a>] = {
<a name="l01062"></a>01062   <span class="comment">/* CONTENT_INSERT */</span> NULL,  <span class="comment">/* generated in contentInsertStatement() */</span>
<a name="l01063"></a>01063   <span class="comment">/* CONTENT_SELECT */</span> <span class="stringliteral">&quot;select * from %_content where rowid = ?&quot;</span>,
<a name="l01064"></a>01064   <span class="comment">/* CONTENT_UPDATE */</span> NULL,  <span class="comment">/* generated in contentUpdateStatement() */</span>
<a name="l01065"></a>01065   <span class="comment">/* CONTENT_DELETE */</span> <span class="stringliteral">&quot;delete from %_content where rowid = ?&quot;</span>,
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="comment">/* TERM_SELECT */</span>
<a name="l01068"></a>01068   <span class="stringliteral">&quot;select rowid, doclist from %_term where term = ? and segment = ?&quot;</span>,
<a name="l01069"></a>01069   <span class="comment">/* TERM_SELECT_ALL */</span>
<a name="l01070"></a>01070   <span class="stringliteral">&quot;select doclist from %_term where term = ? order by segment&quot;</span>,
<a name="l01071"></a>01071   <span class="comment">/* TERM_INSERT */</span>
<a name="l01072"></a>01072   <span class="stringliteral">&quot;insert into %_term (rowid, term, segment, doclist) values (?, ?, ?, ?)&quot;</span>,
<a name="l01073"></a>01073   <span class="comment">/* TERM_UPDATE */</span> <span class="stringliteral">&quot;update %_term set doclist = ? where rowid = ?&quot;</span>,
<a name="l01074"></a>01074   <span class="comment">/* TERM_DELETE */</span> <span class="stringliteral">&quot;delete from %_term where rowid = ?&quot;</span>,
<a name="l01075"></a>01075 };
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 <span class="comment">/*</span>
<a name="l01078"></a>01078 <span class="comment">** A connection to a fulltext index is an instance of the following</span>
<a name="l01079"></a>01079 <span class="comment">** structure.  The xCreate and xConnect methods create an instance</span>
<a name="l01080"></a>01080 <span class="comment">** of this structure and xDestroy and xDisconnect free that instance.</span>
<a name="l01081"></a>01081 <span class="comment">** All other methods receive a pointer to the structure as one of their</span>
<a name="l01082"></a>01082 <span class="comment">** arguments.</span>
<a name="l01083"></a>01083 <span class="comment">*/</span>
<a name="l01084"></a><a class="code" href="structfulltext__vtab.html">01084</a> <span class="keyword">struct </span><a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> {
<a name="l01085"></a><a class="code" href="structfulltext__vtab.html#a8e711ebd8423f2581ac15dd3a25f4353">01085</a>   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> <a class="code" href="structfulltext__vtab.html#a8e711ebd8423f2581ac15dd3a25f4353">base</a>;               <span class="comment">/* Base class used by SQLite core */</span>
<a name="l01086"></a><a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">01086</a>   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>;                     <span class="comment">/* The database connection */</span>
<a name="l01087"></a><a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">01087</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>;                 <span class="comment">/* logical database name */</span>
<a name="l01088"></a><a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">01088</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>;               <span class="comment">/* virtual table name */</span>
<a name="l01089"></a><a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">01089</a>   <span class="keywordtype">int</span> <a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>;                     <span class="comment">/* number of columns in virtual table */</span>
<a name="l01090"></a><a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">01090</a>   <span class="keywordtype">char</span> **<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>;                 <span class="comment">/* column names.  malloced */</span>
<a name="l01091"></a><a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">01091</a>   <span class="keywordtype">char</span> **<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>;          <span class="comment">/* column names in content table; malloced */</span>
<a name="l01092"></a><a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">01092</a>   <a class="code" href="structsqlite3__tokenizer.html">sqlite3_tokenizer</a> *<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>;   <span class="comment">/* tokenizer for inserts and queries */</span>
<a name="l01093"></a>01093 
<a name="l01094"></a>01094   <span class="comment">/* Precompiled statements which we keep as long as the table is</span>
<a name="l01095"></a>01095 <span class="comment">  ** open.</span>
<a name="l01096"></a>01096 <span class="comment">  */</span>
<a name="l01097"></a><a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">01097</a>   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[<a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a>];
<a name="l01098"></a>01098 };
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 <span class="comment">/*</span>
<a name="l01101"></a>01101 <span class="comment">** When the core wants to do a query, it create a cursor using a</span>
<a name="l01102"></a>01102 <span class="comment">** call to xOpen.  This structure is an instance of a cursor.  It</span>
<a name="l01103"></a>01103 <span class="comment">** is destroyed by xClose.</span>
<a name="l01104"></a>01104 <span class="comment">*/</span>
<a name="l01105"></a><a class="code" href="structfulltext__cursor.html">01105</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> {
<a name="l01106"></a><a class="code" href="structfulltext__cursor.html#a81a33bdfcda3fbe7a0170224d8442a5c">01106</a>   <a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> <a class="code" href="structfulltext__cursor.html#a81a33bdfcda3fbe7a0170224d8442a5c">base</a>;        <span class="comment">/* Base class used by SQLite core */</span>
<a name="l01107"></a><a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">01107</a>   <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ec">QueryType</a> <a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a>;           <span class="comment">/* Copy of sqlite3_index_info.idxNum */</span>
<a name="l01108"></a><a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">01108</a>   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>;             <span class="comment">/* Prepared statement in use by the cursor */</span>
<a name="l01109"></a><a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">01109</a>   <span class="keywordtype">int</span> <a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a>;                         <span class="comment">/* True if at End Of Results */</span>
<a name="l01110"></a><a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">01110</a>   <a class="code" href="structQuery.html">Query</a> <a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>;                         <span class="comment">/* Parsed query string */</span>
<a name="l01111"></a><a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">01111</a>   <a class="code" href="structSnippet.html">Snippet</a> <a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>;                 <span class="comment">/* Cached snippet for the current row */</span>
<a name="l01112"></a><a class="code" href="structfulltext__cursor.html#a1f988ebd94b599b84d18e224f90f110d">01112</a>   <span class="keywordtype">int</span> <a class="code" href="structfulltext__cursor.html#a1f988ebd94b599b84d18e224f90f110d">iColumn</a>;                     <span class="comment">/* Column being searched */</span>
<a name="l01113"></a><a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">01113</a>   <a class="code" href="structDocListReader.html">DocListReader</a> <a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>;  <span class="comment">/* used when iCursorType == QUERY_FULLTEXT */</span> 
<a name="l01114"></a>01114 } <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a>;
<a name="l01115"></a>01115 
<a name="l01116"></a><a class="code" href="fts1_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">01116</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *<a class="code" href="fts1_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">cursor_vtab</a>(<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c){
<a name="l01117"></a>01117   <span class="keywordflow">return</span> (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *) c-&gt;<a class="code" href="structfulltext__cursor.html#a81a33bdfcda3fbe7a0170224d8442a5c">base</a>.<a class="code" href="structsqlite3__vtab__cursor.html#a2989d9f84a35506c3ef9fe9e9ecd3365">pVtab</a>;
<a name="l01118"></a>01118 }
<a name="l01119"></a>01119 
<a name="l01120"></a><a class="code" href="fts1_8c.html#a126de222ab5c383706236b3ebca3c686">01120</a> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> <a class="code" href="fts1_8c.html#a126de222ab5c383706236b3ebca3c686">fulltextModule</a>;   <span class="comment">/* forward declaration */</span>
<a name="l01121"></a>01121 
<a name="l01122"></a>01122 <span class="comment">/* Append a list of strings separated by commas to a StringBuffer. */</span>
<a name="l01123"></a><a class="code" href="fts1_8c.html#a25815e8e930bcd9e3eabfe5ee1c9412f">01123</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a25815e8e930bcd9e3eabfe5ee1c9412f">appendList</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb, <span class="keywordtype">int</span> nString, <span class="keywordtype">char</span> **azString){
<a name="l01124"></a>01124   <span class="keywordtype">int</span> i;
<a name="l01125"></a>01125   <span class="keywordflow">for</span>(i=0; i&lt;nString; ++i){
<a name="l01126"></a>01126     <span class="keywordflow">if</span>( i&gt;0 ) <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(sb, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l01127"></a>01127     <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(sb, azString[i]);
<a name="l01128"></a>01128   }
<a name="l01129"></a>01129 }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131 <span class="comment">/* Return a dynamically generated statement of the form</span>
<a name="l01132"></a>01132 <span class="comment"> *   insert into %_content (rowid, ...) values (?, ...)</span>
<a name="l01133"></a>01133 <span class="comment"> */</span>
<a name="l01134"></a><a class="code" href="fts1_8c.html#a64d2e6d573a9a737fcf9fd5578d8b400">01134</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts1_8c.html#a64d2e6d573a9a737fcf9fd5578d8b400">contentInsertStatement</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l01135"></a>01135   <a class="code" href="structStringBuffer.html">StringBuffer</a> sb;
<a name="l01136"></a>01136   <span class="keywordtype">int</span> i;
<a name="l01137"></a>01137 
<a name="l01138"></a>01138   <a class="code" href="fts1_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;sb);
<a name="l01139"></a>01139   <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;insert into %_content (rowid, &quot;</span>);
<a name="l01140"></a>01140   <a class="code" href="fts1_8c.html#a25815e8e930bcd9e3eabfe5ee1c9412f">appendList</a>(&amp;sb, v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>);
<a name="l01141"></a>01141   <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;) values (?&quot;</span>);
<a name="l01142"></a>01142   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i)
<a name="l01143"></a>01143     <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;, ?&quot;</span>);
<a name="l01144"></a>01144   <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;)&quot;</span>);
<a name="l01145"></a>01145   <span class="keywordflow">return</span> sb.<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>;
<a name="l01146"></a>01146 }
<a name="l01147"></a>01147 
<a name="l01148"></a>01148 <span class="comment">/* Return a dynamically generated statement of the form</span>
<a name="l01149"></a>01149 <span class="comment"> *   update %_content set [col_0] = ?, [col_1] = ?, ...</span>
<a name="l01150"></a>01150 <span class="comment"> *                    where rowid = ?</span>
<a name="l01151"></a>01151 <span class="comment"> */</span>
<a name="l01152"></a><a class="code" href="fts1_8c.html#af131b6e23b7bd297c4c502da7fd88c97">01152</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts1_8c.html#af131b6e23b7bd297c4c502da7fd88c97">contentUpdateStatement</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l01153"></a>01153   <a class="code" href="structStringBuffer.html">StringBuffer</a> sb;
<a name="l01154"></a>01154   <span class="keywordtype">int</span> i;
<a name="l01155"></a>01155 
<a name="l01156"></a>01156   <a class="code" href="fts1_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;sb);
<a name="l01157"></a>01157   <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;update %_content set &quot;</span>);
<a name="l01158"></a>01158   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i) {
<a name="l01159"></a>01159     <span class="keywordflow">if</span>( i&gt;0 ){
<a name="l01160"></a>01160       <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l01161"></a>01161     }
<a name="l01162"></a>01162     <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>[i]);
<a name="l01163"></a>01163     <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot; = ?&quot;</span>);
<a name="l01164"></a>01164   }
<a name="l01165"></a>01165   <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot; where rowid = ?&quot;</span>);
<a name="l01166"></a>01166   <span class="keywordflow">return</span> sb.<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>;
<a name="l01167"></a>01167 }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169 <span class="comment">/* Puts a freshly-prepared statement determined by iStmt in *ppStmt.</span>
<a name="l01170"></a>01170 <span class="comment">** If the indicated statement has never been prepared, it is prepared</span>
<a name="l01171"></a>01171 <span class="comment">** and cached, otherwise the cached version is reset.</span>
<a name="l01172"></a>01172 <span class="comment">*/</span>
<a name="l01173"></a><a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">01173</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">fulltext_statement</a> iStmt,
<a name="l01174"></a>01174                              <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> **ppStmt){
<a name="l01175"></a>01175   assert( iStmt&lt;<a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a> );
<a name="l01176"></a>01176   <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt]==NULL ){
<a name="l01177"></a>01177     <span class="keyword">const</span> <span class="keywordtype">char</span> *zStmt;
<a name="l01178"></a>01178     <span class="keywordtype">int</span> rc;
<a name="l01179"></a>01179     <span class="keywordflow">switch</span>( iStmt ){
<a name="l01180"></a>01180       <span class="keywordflow">case</span> <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ae800de40a0ad0185ff0335c967411a84">CONTENT_INSERT_STMT</a>:
<a name="l01181"></a>01181         zStmt = <a class="code" href="fts1_8c.html#a64d2e6d573a9a737fcf9fd5578d8b400">contentInsertStatement</a>(v); <span class="keywordflow">break</span>;
<a name="l01182"></a>01182       <span class="keywordflow">case</span> <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a016651ce129880970fb699b09f85576c">CONTENT_UPDATE_STMT</a>:
<a name="l01183"></a>01183         zStmt = <a class="code" href="fts1_8c.html#af131b6e23b7bd297c4c502da7fd88c97">contentUpdateStatement</a>(v); <span class="keywordflow">break</span>;
<a name="l01184"></a>01184       <span class="keywordflow">default</span>:
<a name="l01185"></a>01185         zStmt = fulltext_zStatement[iStmt];
<a name="l01186"></a>01186     }
<a name="l01187"></a>01187     rc = <a class="code" href="fts1_8c.html#a90c49c1625eff6f726a4ce28200e24d4">sql_prepare</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt],
<a name="l01188"></a>01188                          zStmt);
<a name="l01189"></a>01189     <span class="keywordflow">if</span>( zStmt != fulltext_zStatement[iStmt]) free((<span class="keywordtype">void</span> *) zStmt);
<a name="l01190"></a>01190     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01191"></a>01191   } <span class="keywordflow">else</span> {
<a name="l01192"></a>01192     <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt]);
<a name="l01193"></a>01193     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01194"></a>01194   }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196   *ppStmt = v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt];
<a name="l01197"></a>01197   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01198"></a>01198 }
<a name="l01199"></a>01199 
<a name="l01200"></a>01200 <span class="comment">/* Step the indicated statement, handling errors SQLITE_BUSY (by</span>
<a name="l01201"></a>01201 <span class="comment">** retrying) and SQLITE_SCHEMA (by re-preparing and transferring</span>
<a name="l01202"></a>01202 <span class="comment">** bindings to the new statement).</span>
<a name="l01203"></a>01203 <span class="comment">** TODO(adam): We should extend this function so that it can work with</span>
<a name="l01204"></a>01204 <span class="comment">** statements declared locally, not only globally cached statements.</span>
<a name="l01205"></a>01205 <span class="comment">*/</span>
<a name="l01206"></a><a class="code" href="fts1_8c.html#a29d68bada6f9f24ca76759f353191684">01206</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a29d68bada6f9f24ca76759f353191684">sql_step_statement</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">fulltext_statement</a> iStmt,
<a name="l01207"></a>01207                               <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> **ppStmt){
<a name="l01208"></a>01208   <span class="keywordtype">int</span> rc;
<a name="l01209"></a>01209   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s = *ppStmt;
<a name="l01210"></a>01210   assert( iStmt&lt;<a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a> );
<a name="l01211"></a>01211   assert( s==v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt] );
<a name="l01212"></a>01212 
<a name="l01213"></a>01213   <span class="keywordflow">while</span>( (rc=<a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s))!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> &amp;&amp; rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l01214"></a>01214     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a> ) <span class="keywordflow">continue</span>;
<a name="l01215"></a>01215     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a> ) <span class="keywordflow">return</span> rc;
<a name="l01216"></a>01216 
<a name="l01217"></a>01217     <span class="comment">/* If an SQLITE_SCHEMA error has occured, then finalizing this</span>
<a name="l01218"></a>01218 <span class="comment">     * statement is going to delete the fulltext_vtab structure. If</span>
<a name="l01219"></a>01219 <span class="comment">     * the statement just executed is in the pFulltextStatements[]</span>
<a name="l01220"></a>01220 <span class="comment">     * array, it will be finalized twice. So remove it before</span>
<a name="l01221"></a>01221 <span class="comment">     * calling sqlite3_finalize().</span>
<a name="l01222"></a>01222 <span class="comment">     */</span>
<a name="l01223"></a>01223     v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt] = NULL;
<a name="l01224"></a>01224     rc = <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(s);
<a name="l01225"></a>01225     <span class="keywordflow">break</span>;
<a name="l01226"></a>01226   }
<a name="l01227"></a>01227   <span class="keywordflow">return</span> rc;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229  err:
<a name="l01230"></a>01230   <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(s);
<a name="l01231"></a>01231   <span class="keywordflow">return</span> rc;
<a name="l01232"></a>01232 }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 <span class="comment">/* Like sql_step_statement(), but convert SQLITE_DONE to SQLITE_OK.</span>
<a name="l01235"></a>01235 <span class="comment">** Useful for statements like UPDATE, where we expect no results.</span>
<a name="l01236"></a>01236 <span class="comment">*/</span>
<a name="l01237"></a><a class="code" href="fts1_8c.html#ab54fc55181e0b47f145e11fc559fa6d8">01237</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ab54fc55181e0b47f145e11fc559fa6d8">sql_single_step_statement</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,
<a name="l01238"></a>01238                                      <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">fulltext_statement</a> iStmt,
<a name="l01239"></a>01239                                      <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> **ppStmt){
<a name="l01240"></a>01240   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a29d68bada6f9f24ca76759f353191684">sql_step_statement</a>(v, iStmt, ppStmt);
<a name="l01241"></a>01241   <span class="keywordflow">return</span> (rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>) ? <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> : rc;
<a name="l01242"></a>01242 }
<a name="l01243"></a>01243 
<a name="l01244"></a>01244 <span class="comment">/* insert into %_content (rowid, ...) values ([rowid], [pValues]) */</span>
<a name="l01245"></a><a class="code" href="fts1_8c.html#a97f61f9291ab35fbfe2c39993ec56796">01245</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a97f61f9291ab35fbfe2c39993ec56796">content_insert</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structMem.html">sqlite3_value</a> *rowid,
<a name="l01246"></a>01246                           <a class="code" href="structMem.html">sqlite3_value</a> **pValues){
<a name="l01247"></a>01247   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l01248"></a>01248   <span class="keywordtype">int</span> i;
<a name="l01249"></a>01249   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ae800de40a0ad0185ff0335c967411a84">CONTENT_INSERT_STMT</a>, &amp;s);
<a name="l01250"></a>01250   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01251"></a>01251 
<a name="l01252"></a>01252   rc = <a class="code" href="sqlite3_8h.html#ae2de595a4a816aa57435c9247839d86a">sqlite3_bind_value</a>(s, 1, rowid);
<a name="l01253"></a>01253   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01254"></a>01254 
<a name="l01255"></a>01255   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i){
<a name="l01256"></a>01256     rc = <a class="code" href="sqlite3_8h.html#ae2de595a4a816aa57435c9247839d86a">sqlite3_bind_value</a>(s, 2+i, pValues[i]);
<a name="l01257"></a>01257     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01258"></a>01258   }
<a name="l01259"></a>01259 
<a name="l01260"></a>01260   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#ab54fc55181e0b47f145e11fc559fa6d8">sql_single_step_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ae800de40a0ad0185ff0335c967411a84">CONTENT_INSERT_STMT</a>, &amp;s);
<a name="l01261"></a>01261 }
<a name="l01262"></a>01262 
<a name="l01263"></a>01263 <span class="comment">/* update %_content set col0 = pValues[0], col1 = pValues[1], ...</span>
<a name="l01264"></a>01264 <span class="comment"> *                  where rowid = [iRowid] */</span>
<a name="l01265"></a><a class="code" href="fts1_8c.html#aff98794eedf8ff43e623a00e0634c566">01265</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#aff98794eedf8ff43e623a00e0634c566">content_update</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structMem.html">sqlite3_value</a> **pValues,
<a name="l01266"></a>01266                           <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRowid){
<a name="l01267"></a>01267   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l01268"></a>01268   <span class="keywordtype">int</span> i;
<a name="l01269"></a>01269   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a016651ce129880970fb699b09f85576c">CONTENT_UPDATE_STMT</a>, &amp;s);
<a name="l01270"></a>01270   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01271"></a>01271 
<a name="l01272"></a>01272   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i){
<a name="l01273"></a>01273     rc = <a class="code" href="sqlite3_8h.html#ae2de595a4a816aa57435c9247839d86a">sqlite3_bind_value</a>(s, 1+i, pValues[i]);
<a name="l01274"></a>01274     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01275"></a>01275   }
<a name="l01276"></a>01276 
<a name="l01277"></a>01277   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1+v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, iRowid);
<a name="l01278"></a>01278   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01279"></a>01279 
<a name="l01280"></a>01280   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#ab54fc55181e0b47f145e11fc559fa6d8">sql_single_step_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a016651ce129880970fb699b09f85576c">CONTENT_UPDATE_STMT</a>, &amp;s);
<a name="l01281"></a>01281 }
<a name="l01282"></a>01282 
<a name="l01283"></a><a class="code" href="fts1_8c.html#a217321df065d27f4580f1affa711f23b">01283</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a217321df065d27f4580f1affa711f23b">freeStringArray</a>(<span class="keywordtype">int</span> nString, <span class="keyword">const</span> <span class="keywordtype">char</span> **pString){
<a name="l01284"></a>01284   <span class="keywordtype">int</span> i;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286   <span class="keywordflow">for</span> (i=0 ; i &lt; nString ; ++i) {
<a name="l01287"></a>01287     <span class="keywordflow">if</span>( pString[i]!=NULL ) free((<span class="keywordtype">void</span> *) pString[i]);
<a name="l01288"></a>01288   }
<a name="l01289"></a>01289   free((<span class="keywordtype">void</span> *) pString);
<a name="l01290"></a>01290 }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292 <span class="comment">/* select * from %_content where rowid = [iRow]</span>
<a name="l01293"></a>01293 <span class="comment"> * The caller must delete the returned array and all strings in it.</span>
<a name="l01294"></a>01294 <span class="comment"> * null fields will be NULL in the returned array.</span>
<a name="l01295"></a>01295 <span class="comment"> *</span>
<a name="l01296"></a>01296 <span class="comment"> * TODO: Perhaps we should return pointer/length strings here for consistency</span>
<a name="l01297"></a>01297 <span class="comment"> * with other code which uses pointer/length. */</span>
<a name="l01298"></a><a class="code" href="fts1_8c.html#a45b9abe0a1f6a081cab0c2eeda68794d">01298</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a45b9abe0a1f6a081cab0c2eeda68794d">content_select</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRow,
<a name="l01299"></a>01299                           <span class="keyword">const</span> <span class="keywordtype">char</span> ***pValues){
<a name="l01300"></a>01300   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l01301"></a>01301   <span class="keyword">const</span> <span class="keywordtype">char</span> **values;
<a name="l01302"></a>01302   <span class="keywordtype">int</span> i;
<a name="l01303"></a>01303   <span class="keywordtype">int</span> rc;
<a name="l01304"></a>01304 
<a name="l01305"></a>01305   *pValues = NULL;
<a name="l01306"></a>01306 
<a name="l01307"></a>01307   rc = <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abfdc634e15bbc89a90bdaf76034fe478">CONTENT_SELECT_STMT</a>, &amp;s);
<a name="l01308"></a>01308   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01309"></a>01309 
<a name="l01310"></a>01310   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, iRow);
<a name="l01311"></a>01311   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01312"></a>01312 
<a name="l01313"></a>01313   rc = <a class="code" href="fts1_8c.html#a29d68bada6f9f24ca76759f353191684">sql_step_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abfdc634e15bbc89a90bdaf76034fe478">CONTENT_SELECT_STMT</a>, &amp;s);
<a name="l01314"></a>01314   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> rc;
<a name="l01315"></a>01315 
<a name="l01316"></a>01316   values = (<span class="keyword">const</span> <span class="keywordtype">char</span> **) malloc(v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a> * <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *));
<a name="l01317"></a>01317   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i){
<a name="l01318"></a>01318     <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a7e076f91f53b4936cd6f2ce4b078bcc1">sqlite3_column_type</a>(s, i)==<a class="code" href="sqlite3_8h.html#afd180931f2d06d6c245791d187da5802">SQLITE_NULL</a> ){
<a name="l01319"></a>01319       values[i] = NULL;
<a name="l01320"></a>01320     }<span class="keywordflow">else</span>{
<a name="l01321"></a>01321       values[i] = <a class="code" href="fts1_8c.html#a7a1ca6e7e7b15d27e59df8a9da195d77">string_dup</a>((<span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#adebe4cf494727dd2e9c0d22c2a629d2f">sqlite3_column_text</a>(s, i));
<a name="l01322"></a>01322     }
<a name="l01323"></a>01323   }
<a name="l01324"></a>01324 
<a name="l01325"></a>01325   <span class="comment">/* We expect only one row.  We must execute another sqlite3_step()</span>
<a name="l01326"></a>01326 <span class="comment">   * to complete the iteration; otherwise the table will remain locked. */</span>
<a name="l01327"></a>01327   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l01328"></a>01328   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l01329"></a>01329     *pValues = values;
<a name="l01330"></a>01330     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01331"></a>01331   }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333   <a class="code" href="fts1_8c.html#a217321df065d27f4580f1affa711f23b">freeStringArray</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, values);
<a name="l01334"></a>01334   <span class="keywordflow">return</span> rc;
<a name="l01335"></a>01335 }
<a name="l01336"></a>01336 
<a name="l01337"></a>01337 <span class="comment">/* delete from %_content where rowid = [iRow ] */</span>
<a name="l01338"></a><a class="code" href="fts1_8c.html#a8d2f433ca2290904b916ff1972b921c3">01338</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a8d2f433ca2290904b916ff1972b921c3">content_delete</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRow){
<a name="l01339"></a>01339   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l01340"></a>01340   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789acdb161caf82c5437390779f9e886d62e">CONTENT_DELETE_STMT</a>, &amp;s);
<a name="l01341"></a>01341   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01342"></a>01342 
<a name="l01343"></a>01343   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, iRow);
<a name="l01344"></a>01344   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01345"></a>01345 
<a name="l01346"></a>01346   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#ab54fc55181e0b47f145e11fc559fa6d8">sql_single_step_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789acdb161caf82c5437390779f9e886d62e">CONTENT_DELETE_STMT</a>, &amp;s);
<a name="l01347"></a>01347 }
<a name="l01348"></a>01348 
<a name="l01349"></a>01349 <span class="comment">/* select rowid, doclist from %_term</span>
<a name="l01350"></a>01350 <span class="comment"> *  where term = [pTerm] and segment = [iSegment]</span>
<a name="l01351"></a>01351 <span class="comment"> * If found, returns SQLITE_ROW; the caller must free the</span>
<a name="l01352"></a>01352 <span class="comment"> * returned doclist.  If no rows found, returns SQLITE_DONE. */</span>
<a name="l01353"></a><a class="code" href="fts1_8c.html#a937305225088f05991aa7c6d1d6ec48f">01353</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a937305225088f05991aa7c6d1d6ec48f">term_select</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm,
<a name="l01354"></a>01354                        <span class="keywordtype">int</span> iSegment,
<a name="l01355"></a>01355                        <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *rowid, <a class="code" href="structDocList.html">DocList</a> *out){
<a name="l01356"></a>01356   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l01357"></a>01357   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a9b993e3f8dafdad5bca22007262b8fbd">TERM_SELECT_STMT</a>, &amp;s);
<a name="l01358"></a>01358   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01359"></a>01359 
<a name="l01360"></a>01360   rc = <a class="code" href="sqlite3_8h.html#a154a83560a7c30758ad266cbb248de11">sqlite3_bind_text</a>(s, 1, pTerm, nTerm, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l01361"></a>01361   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01362"></a>01362 
<a name="l01363"></a>01363   rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 2, iSegment);
<a name="l01364"></a>01364   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366   rc = <a class="code" href="fts1_8c.html#a29d68bada6f9f24ca76759f353191684">sql_step_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a9b993e3f8dafdad5bca22007262b8fbd">TERM_SELECT_STMT</a>, &amp;s);
<a name="l01367"></a>01367   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> rc;
<a name="l01368"></a>01368 
<a name="l01369"></a>01369   *rowid = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 0);
<a name="l01370"></a>01370   <a class="code" href="fts1_8c.html#ab9c4fadccc51f39560c880c3d031a27b">docListInit</a>(out, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>,
<a name="l01371"></a>01371               <a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(s, 1), <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(s, 1));
<a name="l01372"></a>01372 
<a name="l01373"></a>01373   <span class="comment">/* We expect only one row.  We must execute another sqlite3_step()</span>
<a name="l01374"></a>01374 <span class="comment">   * to complete the iteration; otherwise the table will remain locked. */</span>
<a name="l01375"></a>01375   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l01376"></a>01376   <span class="keywordflow">return</span> rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ? <a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> : rc;
<a name="l01377"></a>01377 }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379 <span class="comment">/* Load the segment doclists for term pTerm and merge them in</span>
<a name="l01380"></a>01380 <span class="comment">** appropriate order into out.  Returns SQLITE_OK if successful.  If</span>
<a name="l01381"></a>01381 <span class="comment">** there are no segments for pTerm, successfully returns an empty</span>
<a name="l01382"></a>01382 <span class="comment">** doclist in out.</span>
<a name="l01383"></a>01383 <span class="comment">**</span>
<a name="l01384"></a>01384 <span class="comment">** Each document consists of 1 or more &quot;columns&quot;.  The number of</span>
<a name="l01385"></a>01385 <span class="comment">** columns is v-&gt;nColumn.  If iColumn==v-&gt;nColumn, then return</span>
<a name="l01386"></a>01386 <span class="comment">** position information about all columns.  If iColumn&lt;v-&gt;nColumn,</span>
<a name="l01387"></a>01387 <span class="comment">** then only return position information about the iColumn-th column</span>
<a name="l01388"></a>01388 <span class="comment">** (where the first column is 0).</span>
<a name="l01389"></a>01389 <span class="comment">*/</span>
<a name="l01390"></a><a class="code" href="fts1_8c.html#acc673d898d6cd6f15b994abb2d0a2ac9">01390</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#acc673d898d6cd6f15b994abb2d0a2ac9">term_select_all</a>(
<a name="l01391"></a>01391   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,     <span class="comment">/* The fulltext index we are querying against */</span>
<a name="l01392"></a>01392   <span class="keywordtype">int</span> iColumn,          <span class="comment">/* If &lt;nColumn, only look at the iColumn-th column */</span>
<a name="l01393"></a>01393   <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm,    <span class="comment">/* The term whose posting lists we want */</span>
<a name="l01394"></a>01394   <span class="keywordtype">int</span> nTerm,            <span class="comment">/* Number of bytes in pTerm */</span>
<a name="l01395"></a>01395   <a class="code" href="structDocList.html">DocList</a> *out          <span class="comment">/* Write the resulting doclist here */</span>
<a name="l01396"></a>01396 ){
<a name="l01397"></a>01397   <a class="code" href="structDocList.html">DocList</a> doclist;
<a name="l01398"></a>01398   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l01399"></a>01399   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a6fa1db4630bd9cf0a75ff87d4e28d70b">TERM_SELECT_ALL_STMT</a>, &amp;s);
<a name="l01400"></a>01400   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01401"></a>01401 
<a name="l01402"></a>01402   rc = <a class="code" href="sqlite3_8h.html#a154a83560a7c30758ad266cbb248de11">sqlite3_bind_text</a>(s, 1, pTerm, nTerm, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l01403"></a>01403   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01404"></a>01404 
<a name="l01405"></a>01405   <a class="code" href="fts1_8c.html#ab9c4fadccc51f39560c880c3d031a27b">docListInit</a>(&amp;doclist, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, 0, 0);
<a name="l01406"></a>01406 
<a name="l01407"></a>01407   <span class="comment">/* TODO(shess) Handle schema and busy errors. */</span>
<a name="l01408"></a>01408   <span class="keywordflow">while</span>( (rc=<a class="code" href="fts1_8c.html#a29d68bada6f9f24ca76759f353191684">sql_step_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a6fa1db4630bd9cf0a75ff87d4e28d70b">TERM_SELECT_ALL_STMT</a>, &amp;s))==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l01409"></a>01409     <a class="code" href="structDocList.html">DocList</a> old;
<a name="l01410"></a>01410 
<a name="l01411"></a>01411     <span class="comment">/* TODO(shess) If we processed doclists from oldest to newest, we</span>
<a name="l01412"></a>01412 <span class="comment">    ** could skip the malloc() involved with the following call.  For</span>
<a name="l01413"></a>01413 <span class="comment">    ** now, I&apos;d rather keep this logic similar to index_insert_term().</span>
<a name="l01414"></a>01414 <span class="comment">    ** We could additionally drop elements when we see deletes, but</span>
<a name="l01415"></a>01415 <span class="comment">    ** that would require a distinct version of docListAccumulate().</span>
<a name="l01416"></a>01416 <span class="comment">    */</span>
<a name="l01417"></a>01417     <a class="code" href="fts1_8c.html#ab9c4fadccc51f39560c880c3d031a27b">docListInit</a>(&amp;old, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>,
<a name="l01418"></a>01418                 <a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(s, 0), <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(s, 0));
<a name="l01419"></a>01419 
<a name="l01420"></a>01420     <span class="keywordflow">if</span>( iColumn&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a> ){   <span class="comment">/* querying a single column */</span>
<a name="l01421"></a>01421       <a class="code" href="fts1_8c.html#a259026659139162c0c753eb05ad14d4c">docListRestrictColumn</a>(&amp;old, iColumn);
<a name="l01422"></a>01422     }
<a name="l01423"></a>01423 
<a name="l01424"></a>01424     <span class="comment">/* doclist contains the newer data, so write it over old.  Then</span>
<a name="l01425"></a>01425 <span class="comment">    ** steal accumulated result for doclist.</span>
<a name="l01426"></a>01426 <span class="comment">    */</span>
<a name="l01427"></a>01427     <a class="code" href="fts1_8c.html#ac74a82f8f6e2273fb58b6bdf1d1f3f31">docListAccumulate</a>(&amp;old, &amp;doclist);
<a name="l01428"></a>01428     <a class="code" href="fts1_8c.html#afc9760991434278d35e17d8b0ab59001">docListDestroy</a>(&amp;doclist);
<a name="l01429"></a>01429     doclist = old;
<a name="l01430"></a>01430   }
<a name="l01431"></a>01431   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l01432"></a>01432     <a class="code" href="fts1_8c.html#afc9760991434278d35e17d8b0ab59001">docListDestroy</a>(&amp;doclist);
<a name="l01433"></a>01433     <span class="keywordflow">return</span> rc;
<a name="l01434"></a>01434   }
<a name="l01435"></a>01435 
<a name="l01436"></a>01436   <a class="code" href="fts1_8c.html#a7cf5f4570dc1141fb188267caec8a6da">docListDiscardEmpty</a>(&amp;doclist);
<a name="l01437"></a>01437   *out = doclist;
<a name="l01438"></a>01438   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01439"></a>01439 }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441 <span class="comment">/* insert into %_term (rowid, term, segment, doclist)</span>
<a name="l01442"></a>01442 <span class="comment">               values ([piRowid], [pTerm], [iSegment], [doclist])</span>
<a name="l01443"></a>01443 <span class="comment">** Lets sqlite select rowid if piRowid is NULL, else uses *piRowid.</span>
<a name="l01444"></a>01444 <span class="comment">**</span>
<a name="l01445"></a>01445 <span class="comment">** NOTE(shess) piRowid is IN, with values of &quot;space of int64&quot; plus</span>
<a name="l01446"></a>01446 <span class="comment">** null, it is not used to pass data back to the caller.</span>
<a name="l01447"></a>01447 <span class="comment">*/</span>
<a name="l01448"></a><a class="code" href="fts1_8c.html#ae4055e878ea04eb206c38f7a1f5f59ac">01448</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ae4055e878ea04eb206c38f7a1f5f59ac">term_insert</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piRowid,
<a name="l01449"></a>01449                        <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm,
<a name="l01450"></a>01450                        <span class="keywordtype">int</span> iSegment, <a class="code" href="structDocList.html">DocList</a> *doclist){
<a name="l01451"></a>01451   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l01452"></a>01452   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a288af155f10a1c8bfa8536df50b9d9bb">TERM_INSERT_STMT</a>, &amp;s);
<a name="l01453"></a>01453   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01454"></a>01454 
<a name="l01455"></a>01455   <span class="keywordflow">if</span>( piRowid==NULL ){
<a name="l01456"></a>01456     rc = <a class="code" href="sqlite3_8h.html#a361e2e79de6e4a728c4ec7d48f1762ea">sqlite3_bind_null</a>(s, 1);
<a name="l01457"></a>01457   }<span class="keywordflow">else</span>{
<a name="l01458"></a>01458     rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, *piRowid);
<a name="l01459"></a>01459   }
<a name="l01460"></a>01460   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01461"></a>01461 
<a name="l01462"></a>01462   rc = <a class="code" href="sqlite3_8h.html#a154a83560a7c30758ad266cbb248de11">sqlite3_bind_text</a>(s, 2, pTerm, nTerm, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l01463"></a>01463   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01464"></a>01464 
<a name="l01465"></a>01465   rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 3, iSegment);
<a name="l01466"></a>01466   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01467"></a>01467 
<a name="l01468"></a>01468   rc = <a class="code" href="sqlite3_8h.html#a31729e3159ba77c17d7fb51a7f468e8e">sqlite3_bind_blob</a>(s, 4, doclist-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>, doclist-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l01469"></a>01469   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01470"></a>01470 
<a name="l01471"></a>01471   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#ab54fc55181e0b47f145e11fc559fa6d8">sql_single_step_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a288af155f10a1c8bfa8536df50b9d9bb">TERM_INSERT_STMT</a>, &amp;s);
<a name="l01472"></a>01472 }
<a name="l01473"></a>01473 
<a name="l01474"></a>01474 <span class="comment">/* update %_term set doclist = [doclist] where rowid = [rowid] */</span>
<a name="l01475"></a><a class="code" href="fts1_8c.html#abf72e9c113f42e1e93f0f96ba83f135c">01475</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#abf72e9c113f42e1e93f0f96ba83f135c">term_update</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> rowid,
<a name="l01476"></a>01476                        <a class="code" href="structDocList.html">DocList</a> *doclist){
<a name="l01477"></a>01477   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l01478"></a>01478   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ab0611ad228ba30414cf6fe9d98c5c4ff">TERM_UPDATE_STMT</a>, &amp;s);
<a name="l01479"></a>01479   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01480"></a>01480 
<a name="l01481"></a>01481   rc = <a class="code" href="sqlite3_8h.html#a31729e3159ba77c17d7fb51a7f468e8e">sqlite3_bind_blob</a>(s, 1, doclist-&gt;<a class="code" href="structDocList.html#ae179bf561c06eeea1605d8155282b5a5">pData</a>, doclist-&gt;<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l01482"></a>01482   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01483"></a>01483 
<a name="l01484"></a>01484   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 2, rowid);
<a name="l01485"></a>01485   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01486"></a>01486 
<a name="l01487"></a>01487   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#ab54fc55181e0b47f145e11fc559fa6d8">sql_single_step_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ab0611ad228ba30414cf6fe9d98c5c4ff">TERM_UPDATE_STMT</a>, &amp;s);
<a name="l01488"></a>01488 }
<a name="l01489"></a>01489 
<a name="l01490"></a><a class="code" href="fts1_8c.html#a72ace762cfb611748520a875dad83eab">01490</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a72ace762cfb611748520a875dad83eab">term_delete</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> rowid){
<a name="l01491"></a>01491   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l01492"></a>01492   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ac194a29a06661801b9758762fd0737e6">TERM_DELETE_STMT</a>, &amp;s);
<a name="l01493"></a>01493   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01494"></a>01494 
<a name="l01495"></a>01495   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, rowid);
<a name="l01496"></a>01496   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01497"></a>01497 
<a name="l01498"></a>01498   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#ab54fc55181e0b47f145e11fc559fa6d8">sql_single_step_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ac194a29a06661801b9758762fd0737e6">TERM_DELETE_STMT</a>, &amp;s);
<a name="l01499"></a>01499 }
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 <span class="comment">/*</span>
<a name="l01502"></a>01502 <span class="comment">** Free the memory used to contain a fulltext_vtab structure.</span>
<a name="l01503"></a>01503 <span class="comment">*/</span>
<a name="l01504"></a><a class="code" href="fts1_8c.html#aec311e3893b552f3ae7b70311bb70280">01504</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#aec311e3893b552f3ae7b70311bb70280">fulltext_vtab_destroy</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l01505"></a>01505   <span class="keywordtype">int</span> iStmt, i;
<a name="l01506"></a>01506 
<a name="l01507"></a>01507   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Destroy %p\n&quot;</span>, v));
<a name="l01508"></a>01508   <span class="keywordflow">for</span>( iStmt=0; iStmt&lt;<a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a>; iStmt++ ){
<a name="l01509"></a>01509     <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt]!=NULL ){
<a name="l01510"></a>01510       <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt]);
<a name="l01511"></a>01511       v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt] = NULL;
<a name="l01512"></a>01512     }
<a name="l01513"></a>01513   }
<a name="l01514"></a>01514 
<a name="l01515"></a>01515   <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>!=NULL ){
<a name="l01516"></a>01516     v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#ab9b545740a7dbd6528ba294e6b456f7d">xDestroy</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>);
<a name="l01517"></a>01517     v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a> = NULL;
<a name="l01518"></a>01518   }
<a name="l01519"></a>01519   
<a name="l01520"></a>01520   free(v-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>);
<a name="l01521"></a>01521   <span class="keywordflow">for</span>(i = 0; i &lt; v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i) {
<a name="l01522"></a>01522     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>[i]);
<a name="l01523"></a>01523   }
<a name="l01524"></a>01524   free(v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>);
<a name="l01525"></a>01525   free(v);
<a name="l01526"></a>01526 }
<a name="l01527"></a>01527 
<a name="l01528"></a>01528 <span class="comment">/*</span>
<a name="l01529"></a>01529 <span class="comment">** Token types for parsing the arguments to xConnect or xCreate.</span>
<a name="l01530"></a>01530 <span class="comment">*/</span>
<a name="l01531"></a><a class="code" href="fts1_8c.html#af447f39a147c39c7304edbc1e2794405">01531</a> <span class="preprocessor">#define TOKEN_EOF         0    </span><span class="comment">/* End of file */</span>
<a name="l01532"></a><a class="code" href="fts1_8c.html#a353479c59d2069c4456ac5561d255a5d">01532</a> <span class="preprocessor">#define TOKEN_SPACE       1    </span><span class="comment">/* Any kind of whitespace */</span>
<a name="l01533"></a><a class="code" href="fts1_8c.html#a404b774530b3e491cd6afffa0caebc7a">01533</a> <span class="preprocessor">#define TOKEN_ID          2    </span><span class="comment">/* An identifier */</span>
<a name="l01534"></a><a class="code" href="fts1_8c.html#a7c4ffd4f88cfd9c44737230ad6e34e35">01534</a> <span class="preprocessor">#define TOKEN_STRING      3    </span><span class="comment">/* A string literal */</span>
<a name="l01535"></a><a class="code" href="fts1_8c.html#a1831e10448b8343472b14186f534519a">01535</a> <span class="preprocessor">#define TOKEN_PUNCT       4    </span><span class="comment">/* A single punctuation character */</span>
<a name="l01536"></a>01536 
<a name="l01537"></a>01537 <span class="comment">/*</span>
<a name="l01538"></a>01538 <span class="comment">** If X is a character that can be used in an identifier then</span>
<a name="l01539"></a>01539 <span class="comment">** IdChar(X) will be true.  Otherwise it is false.</span>
<a name="l01540"></a>01540 <span class="comment">**</span>
<a name="l01541"></a>01541 <span class="comment">** For ASCII, any character with the high-order bit set is</span>
<a name="l01542"></a>01542 <span class="comment">** allowed in an identifier.  For 7-bit characters, </span>
<a name="l01543"></a>01543 <span class="comment">** sqlite3IsIdChar[X] must be 1.</span>
<a name="l01544"></a>01544 <span class="comment">**</span>
<a name="l01545"></a>01545 <span class="comment">** Ticket #1066.  the SQL standard does not allow &apos;$&apos; in the</span>
<a name="l01546"></a>01546 <span class="comment">** middle of identfiers.  But many SQL implementations do. </span>
<a name="l01547"></a>01547 <span class="comment">** SQLite will allow &apos;$&apos; in identifiers for compatibility.</span>
<a name="l01548"></a>01548 <span class="comment">** But the feature is undocumented.</span>
<a name="l01549"></a>01549 <span class="comment">*/</span>
<a name="l01550"></a><a class="code" href="fts1_8c.html#aa72da15488fa2850cc0a2fccd83fc61f">01550</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="fts1_8c.html#aa72da15488fa2850cc0a2fccd83fc61f">isIdChar</a>[] = {
<a name="l01551"></a>01551 <span class="comment">/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */</span>
<a name="l01552"></a>01552     0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  <span class="comment">/* 2x */</span>
<a name="l01553"></a>01553     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  <span class="comment">/* 3x */</span>
<a name="l01554"></a>01554     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  <span class="comment">/* 4x */</span>
<a name="l01555"></a>01555     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  <span class="comment">/* 5x */</span>
<a name="l01556"></a>01556     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  <span class="comment">/* 6x */</span>
<a name="l01557"></a>01557     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  <span class="comment">/* 7x */</span>
<a name="l01558"></a>01558 };
<a name="l01559"></a><a class="code" href="fts1_8c.html#a26191b553b179817d928443be24f2dab">01559</a> <span class="preprocessor">#define IdChar(C)  (((c=C)&amp;0x80)!=0 || (c&gt;0x1f &amp;&amp; isIdChar[c-0x20]))</span>
<a name="l01560"></a>01560 <span class="preprocessor"></span>
<a name="l01561"></a>01561 
<a name="l01562"></a>01562 <span class="comment">/*</span>
<a name="l01563"></a>01563 <span class="comment">** Return the length of the token that begins at z[0]. </span>
<a name="l01564"></a>01564 <span class="comment">** Store the token type in *tokenType before returning.</span>
<a name="l01565"></a>01565 <span class="comment">*/</span>
<a name="l01566"></a><a class="code" href="fts1_8c.html#a81bf14af50f9d8908ce332aa32761ef4">01566</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a81bf14af50f9d8908ce332aa32761ef4">getToken</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *z, <span class="keywordtype">int</span> *tokenType){
<a name="l01567"></a>01567   <span class="keywordtype">int</span> i, c;
<a name="l01568"></a>01568   <span class="keywordflow">switch</span>( *z ){
<a name="l01569"></a>01569     <span class="keywordflow">case</span> 0: {
<a name="l01570"></a>01570       *tokenType = <a class="code" href="fts1_8c.html#af447f39a147c39c7304edbc1e2794405">TOKEN_EOF</a>;
<a name="l01571"></a>01571       <span class="keywordflow">return</span> 0;
<a name="l01572"></a>01572     }
<a name="l01573"></a>01573     <span class="keywordflow">case</span> <span class="charliteral">&apos; &apos;</span>: <span class="keywordflow">case</span> <span class="charliteral">&apos;\t&apos;</span>: <span class="keywordflow">case</span> <span class="charliteral">&apos;\n&apos;</span>: <span class="keywordflow">case</span> <span class="charliteral">&apos;\f&apos;</span>: <span class="keywordflow">case</span> <span class="charliteral">&apos;\r&apos;</span>: {
<a name="l01574"></a>01574       <span class="keywordflow">for</span>(i=1; <a class="code" href="fts1_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(z[i]); i++){}
<a name="l01575"></a>01575       *tokenType = <a class="code" href="fts1_8c.html#a353479c59d2069c4456ac5561d255a5d">TOKEN_SPACE</a>;
<a name="l01576"></a>01576       <span class="keywordflow">return</span> i;
<a name="l01577"></a>01577     }
<a name="l01578"></a>01578     <span class="keywordflow">case</span> <span class="charliteral">&apos;`&apos;</span>:
<a name="l01579"></a>01579     <span class="keywordflow">case</span> <span class="charliteral">&apos;\&apos;&apos;</span>:
<a name="l01580"></a>01580     <span class="keywordflow">case</span> <span class="charliteral">&apos;&quot;&apos;</span>: {
<a name="l01581"></a>01581       <span class="keywordtype">int</span> delim = z[0];
<a name="l01582"></a>01582       <span class="keywordflow">for</span>(i=1; (c=z[i])!=0; i++){
<a name="l01583"></a>01583         <span class="keywordflow">if</span>( c==delim ){
<a name="l01584"></a>01584           <span class="keywordflow">if</span>( z[i+1]==delim ){
<a name="l01585"></a>01585             i++;
<a name="l01586"></a>01586           }<span class="keywordflow">else</span>{
<a name="l01587"></a>01587             <span class="keywordflow">break</span>;
<a name="l01588"></a>01588           }
<a name="l01589"></a>01589         }
<a name="l01590"></a>01590       }
<a name="l01591"></a>01591       *tokenType = <a class="code" href="fts1_8c.html#a7c4ffd4f88cfd9c44737230ad6e34e35">TOKEN_STRING</a>;
<a name="l01592"></a>01592       <span class="keywordflow">return</span> i + (c!=0);
<a name="l01593"></a>01593     }
<a name="l01594"></a>01594     <span class="keywordflow">case</span> <span class="charliteral">&apos;[&apos;</span>: {
<a name="l01595"></a>01595       <span class="keywordflow">for</span>(i=1, c=z[0]; c!=<span class="charliteral">&apos;]&apos;</span> &amp;&amp; (c=z[i])!=0; i++){}
<a name="l01596"></a>01596       *tokenType = <a class="code" href="fts1_8c.html#a404b774530b3e491cd6afffa0caebc7a">TOKEN_ID</a>;
<a name="l01597"></a>01597       <span class="keywordflow">return</span> i;
<a name="l01598"></a>01598     }
<a name="l01599"></a>01599     <span class="keywordflow">default</span>: {
<a name="l01600"></a>01600       <span class="keywordflow">if</span>( !<a class="code" href="fts1_8c.html#a26191b553b179817d928443be24f2dab">IdChar</a>(*z) ){
<a name="l01601"></a>01601         <span class="keywordflow">break</span>;
<a name="l01602"></a>01602       }
<a name="l01603"></a>01603       <span class="keywordflow">for</span>(i=1; <a class="code" href="fts1_8c.html#a26191b553b179817d928443be24f2dab">IdChar</a>(z[i]); i++){}
<a name="l01604"></a>01604       *tokenType = <a class="code" href="fts1_8c.html#a404b774530b3e491cd6afffa0caebc7a">TOKEN_ID</a>;
<a name="l01605"></a>01605       <span class="keywordflow">return</span> i;
<a name="l01606"></a>01606     }
<a name="l01607"></a>01607   }
<a name="l01608"></a>01608   *tokenType = <a class="code" href="fts1_8c.html#a1831e10448b8343472b14186f534519a">TOKEN_PUNCT</a>;
<a name="l01609"></a>01609   <span class="keywordflow">return</span> 1;
<a name="l01610"></a>01610 }
<a name="l01611"></a>01611 
<a name="l01612"></a>01612 <span class="comment">/*</span>
<a name="l01613"></a>01613 <span class="comment">** A token extracted from a string is an instance of the following</span>
<a name="l01614"></a>01614 <span class="comment">** structure.</span>
<a name="l01615"></a>01615 <span class="comment">*/</span>
<a name="l01616"></a>01616 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structToken.html">Token</a> {
<a name="l01617"></a><a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">01617</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>;       <span class="comment">/* Pointer to token text.  Not &apos;\000&apos; terminated */</span>
<a name="l01618"></a><a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">01618</a>   <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a>;         <span class="comment">/* Length of the token text in bytes. */</span>
<a name="l01619"></a>01619 } <a class="code" href="structToken.html">Token</a>;
<a name="l01620"></a>01620 
<a name="l01621"></a>01621 <span class="comment">/*</span>
<a name="l01622"></a>01622 <span class="comment">** Given a input string (which is really one of the argv[] parameters</span>
<a name="l01623"></a>01623 <span class="comment">** passed into xConnect or xCreate) split the string up into tokens.</span>
<a name="l01624"></a>01624 <span class="comment">** Return an array of pointers to &apos;\000&apos; terminated strings, one string</span>
<a name="l01625"></a>01625 <span class="comment">** for each non-whitespace token.</span>
<a name="l01626"></a>01626 <span class="comment">**</span>
<a name="l01627"></a>01627 <span class="comment">** The returned array is terminated by a single NULL pointer.</span>
<a name="l01628"></a>01628 <span class="comment">**</span>
<a name="l01629"></a>01629 <span class="comment">** Space to hold the returned array is obtained from a single</span>
<a name="l01630"></a>01630 <span class="comment">** malloc and should be freed by passing the return value to free().</span>
<a name="l01631"></a>01631 <span class="comment">** The individual strings within the token list are all a part of</span>
<a name="l01632"></a>01632 <span class="comment">** the single memory allocation and will all be freed at once.</span>
<a name="l01633"></a>01633 <span class="comment">*/</span>
<a name="l01634"></a><a class="code" href="fts1_8c.html#a3ea56dae76c51349cbdef32a7215bcbb">01634</a> <span class="keyword">static</span> <span class="keywordtype">char</span> **<a class="code" href="fts1_8c.html#a3ea56dae76c51349cbdef32a7215bcbb">tokenizeString</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *z, <span class="keywordtype">int</span> *pnToken){
<a name="l01635"></a>01635   <span class="keywordtype">int</span> nToken = 0;
<a name="l01636"></a>01636   <a class="code" href="structToken.html">Token</a> *aToken = malloc( strlen(z) * <span class="keyword">sizeof</span>(aToken[0]) );
<a name="l01637"></a>01637   <span class="keywordtype">int</span> n = 1;
<a name="l01638"></a>01638   <span class="keywordtype">int</span> e, i;
<a name="l01639"></a>01639   <span class="keywordtype">int</span> totalSize = 0;
<a name="l01640"></a>01640   <span class="keywordtype">char</span> **azToken;
<a name="l01641"></a>01641   <span class="keywordtype">char</span> *zCopy;
<a name="l01642"></a>01642   <span class="keywordflow">while</span>( n&gt;0 ){
<a name="l01643"></a>01643     n = <a class="code" href="fts1_8c.html#a81bf14af50f9d8908ce332aa32761ef4">getToken</a>(z, &amp;e);
<a name="l01644"></a>01644     <span class="keywordflow">if</span>( e!=<a class="code" href="fts1_8c.html#a353479c59d2069c4456ac5561d255a5d">TOKEN_SPACE</a> ){
<a name="l01645"></a>01645       aToken[nToken].<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> = z;
<a name="l01646"></a>01646       aToken[nToken].<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> = n;
<a name="l01647"></a>01647       nToken++;
<a name="l01648"></a>01648       totalSize += n+1;
<a name="l01649"></a>01649     }
<a name="l01650"></a>01650     z += n;
<a name="l01651"></a>01651   }
<a name="l01652"></a>01652   azToken = (<span class="keywordtype">char</span>**)malloc( nToken*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*) + totalSize );
<a name="l01653"></a>01653   zCopy = (<span class="keywordtype">char</span>*)&amp;azToken[nToken];
<a name="l01654"></a>01654   nToken--;
<a name="l01655"></a>01655   <span class="keywordflow">for</span>(i=0; i&lt;nToken; i++){
<a name="l01656"></a>01656     azToken[i] = zCopy;
<a name="l01657"></a>01657     n = aToken[i].<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a>;
<a name="l01658"></a>01658     memcpy(zCopy, aToken[i].z, n);
<a name="l01659"></a>01659     zCopy[n] = 0;
<a name="l01660"></a>01660     zCopy += n+1;
<a name="l01661"></a>01661   }
<a name="l01662"></a>01662   azToken[nToken] = 0;
<a name="l01663"></a>01663   free(aToken);
<a name="l01664"></a>01664   *pnToken = nToken;
<a name="l01665"></a>01665   <span class="keywordflow">return</span> azToken;
<a name="l01666"></a>01666 }
<a name="l01667"></a>01667 
<a name="l01668"></a>01668 <span class="comment">/*</span>
<a name="l01669"></a>01669 <span class="comment">** Convert an SQL-style quoted string into a normal string by removing</span>
<a name="l01670"></a>01670 <span class="comment">** the quote characters.  The conversion is done in-place.  If the</span>
<a name="l01671"></a>01671 <span class="comment">** input does not begin with a quote character, then this routine</span>
<a name="l01672"></a>01672 <span class="comment">** is a no-op.</span>
<a name="l01673"></a>01673 <span class="comment">**</span>
<a name="l01674"></a>01674 <span class="comment">** Examples:</span>
<a name="l01675"></a>01675 <span class="comment">**</span>
<a name="l01676"></a>01676 <span class="comment">**     &quot;abc&quot;   becomes   abc</span>
<a name="l01677"></a>01677 <span class="comment">**     &apos;xyz&apos;   becomes   xyz</span>
<a name="l01678"></a>01678 <span class="comment">**     [pqr]   becomes   pqr</span>
<a name="l01679"></a>01679 <span class="comment">**     `mno`   becomes   mno</span>
<a name="l01680"></a>01680 <span class="comment">*/</span>
<a name="l01681"></a><a class="code" href="fts1_8c.html#a407801ec85fdd038cfa6789058685d80">01681</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a407801ec85fdd038cfa6789058685d80">dequoteString</a>(<span class="keywordtype">char</span> *z){
<a name="l01682"></a>01682   <span class="keywordtype">int</span> quote;
<a name="l01683"></a>01683   <span class="keywordtype">int</span> i, j;
<a name="l01684"></a>01684   <span class="keywordflow">if</span>( z==0 ) <span class="keywordflow">return</span>;
<a name="l01685"></a>01685   quote = z[0];
<a name="l01686"></a>01686   <span class="keywordflow">switch</span>( quote ){
<a name="l01687"></a>01687     <span class="keywordflow">case</span> <span class="charliteral">&apos;\&apos;&apos;</span>:  <span class="keywordflow">break</span>;
<a name="l01688"></a>01688     <span class="keywordflow">case</span> <span class="charliteral">&apos;&quot;&apos;</span>:   <span class="keywordflow">break</span>;
<a name="l01689"></a>01689     <span class="keywordflow">case</span> <span class="charliteral">&apos;`&apos;</span>:   <span class="keywordflow">break</span>;                <span class="comment">/* For MySQL compatibility */</span>
<a name="l01690"></a>01690     <span class="keywordflow">case</span> <span class="charliteral">&apos;[&apos;</span>:   quote = <span class="charliteral">&apos;]&apos;</span>;  <span class="keywordflow">break</span>;  <span class="comment">/* For MS SqlServer compatibility */</span>
<a name="l01691"></a>01691     <span class="keywordflow">default</span>:    <span class="keywordflow">return</span>;
<a name="l01692"></a>01692   }
<a name="l01693"></a>01693   <span class="keywordflow">for</span>(i=1, j=0; z[i]; i++){
<a name="l01694"></a>01694     <span class="keywordflow">if</span>( z[i]==quote ){
<a name="l01695"></a>01695       <span class="keywordflow">if</span>( z[i+1]==quote ){
<a name="l01696"></a>01696         z[j++] = quote;
<a name="l01697"></a>01697         i++;
<a name="l01698"></a>01698       }<span class="keywordflow">else</span>{
<a name="l01699"></a>01699         z[j++] = 0;
<a name="l01700"></a>01700         <span class="keywordflow">break</span>;
<a name="l01701"></a>01701       }
<a name="l01702"></a>01702     }<span class="keywordflow">else</span>{
<a name="l01703"></a>01703       z[j++] = z[i];
<a name="l01704"></a>01704     }
<a name="l01705"></a>01705   }
<a name="l01706"></a>01706 }
<a name="l01707"></a>01707 
<a name="l01708"></a>01708 <span class="comment">/*</span>
<a name="l01709"></a>01709 <span class="comment">** The input azIn is a NULL-terminated list of tokens.  Remove the first</span>
<a name="l01710"></a>01710 <span class="comment">** token and all punctuation tokens.  Remove the quotes from</span>
<a name="l01711"></a>01711 <span class="comment">** around string literal tokens.</span>
<a name="l01712"></a>01712 <span class="comment">**</span>
<a name="l01713"></a>01713 <span class="comment">** Example:</span>
<a name="l01714"></a>01714 <span class="comment">**</span>
<a name="l01715"></a>01715 <span class="comment">**     input:      tokenize chinese ( &apos;simplifed&apos; , &apos;mixed&apos; )</span>
<a name="l01716"></a>01716 <span class="comment">**     output:     chinese simplifed mixed</span>
<a name="l01717"></a>01717 <span class="comment">**</span>
<a name="l01718"></a>01718 <span class="comment">** Another example:</span>
<a name="l01719"></a>01719 <span class="comment">**</span>
<a name="l01720"></a>01720 <span class="comment">**     input:      delimiters ( &apos;[&apos; , &apos;]&apos; , &apos;...&apos; )</span>
<a name="l01721"></a>01721 <span class="comment">**     output:     [ ] ...</span>
<a name="l01722"></a>01722 <span class="comment">*/</span>
<a name="l01723"></a><a class="code" href="fts1_8c.html#aa1202d8ce261dc098a68360d002b7420">01723</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#aa1202d8ce261dc098a68360d002b7420">tokenListToIdList</a>(<span class="keywordtype">char</span> **azIn){
<a name="l01724"></a>01724   <span class="keywordtype">int</span> i, j;
<a name="l01725"></a>01725   <span class="keywordflow">if</span>( azIn ){
<a name="l01726"></a>01726     <span class="keywordflow">for</span>(i=0, j=-1; azIn[i]; i++){
<a name="l01727"></a>01727       <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">safe_isalnum</a>(azIn[i][0]) || azIn[i][1] ){
<a name="l01728"></a>01728         <a class="code" href="fts1_8c.html#a407801ec85fdd038cfa6789058685d80">dequoteString</a>(azIn[i]);
<a name="l01729"></a>01729         <span class="keywordflow">if</span>( j&gt;=0 ){
<a name="l01730"></a>01730           azIn[j] = azIn[i];
<a name="l01731"></a>01731         }
<a name="l01732"></a>01732         j++;
<a name="l01733"></a>01733       }
<a name="l01734"></a>01734     }
<a name="l01735"></a>01735     azIn[j] = 0;
<a name="l01736"></a>01736   }
<a name="l01737"></a>01737 }
<a name="l01738"></a>01738 
<a name="l01739"></a>01739 
<a name="l01740"></a>01740 <span class="comment">/*</span>
<a name="l01741"></a>01741 <span class="comment">** Find the first alphanumeric token in the string zIn.  Null-terminate</span>
<a name="l01742"></a>01742 <span class="comment">** this token.  Remove any quotation marks.  And return a pointer to</span>
<a name="l01743"></a>01743 <span class="comment">** the result.</span>
<a name="l01744"></a>01744 <span class="comment">*/</span>
<a name="l01745"></a><a class="code" href="fts1_8c.html#a3948d23d2ee53a6cbcc9a546734acb38">01745</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts1_8c.html#a3948d23d2ee53a6cbcc9a546734acb38">firstToken</a>(<span class="keywordtype">char</span> *zIn, <span class="keywordtype">char</span> **pzTail){
<a name="l01746"></a>01746   <span class="keywordtype">int</span> n, <a class="code" href="lobject_8h.html#acd205ab396b96fba48e1f758c17a2cf3">ttype</a>;
<a name="l01747"></a>01747   <span class="keywordflow">while</span>(1){
<a name="l01748"></a>01748     n = <a class="code" href="fts1_8c.html#a81bf14af50f9d8908ce332aa32761ef4">getToken</a>(zIn, &amp;ttype);
<a name="l01749"></a>01749     <span class="keywordflow">if</span>( ttype==<a class="code" href="fts1_8c.html#a353479c59d2069c4456ac5561d255a5d">TOKEN_SPACE</a> ){
<a name="l01750"></a>01750       zIn += n;
<a name="l01751"></a>01751     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( ttype==<a class="code" href="fts1_8c.html#af447f39a147c39c7304edbc1e2794405">TOKEN_EOF</a> ){
<a name="l01752"></a>01752       *pzTail = zIn;
<a name="l01753"></a>01753       <span class="keywordflow">return</span> 0;
<a name="l01754"></a>01754     }<span class="keywordflow">else</span>{
<a name="l01755"></a>01755       zIn[n] = 0;
<a name="l01756"></a>01756       *pzTail = &amp;zIn[1];
<a name="l01757"></a>01757       <a class="code" href="fts1_8c.html#a407801ec85fdd038cfa6789058685d80">dequoteString</a>(zIn);
<a name="l01758"></a>01758       <span class="keywordflow">return</span> zIn;
<a name="l01759"></a>01759     }
<a name="l01760"></a>01760   }
<a name="l01761"></a>01761   <span class="comment">/*NOTREACHED*/</span>
<a name="l01762"></a>01762 }
<a name="l01763"></a>01763 
<a name="l01764"></a>01764 <span class="comment">/* Return true if...</span>
<a name="l01765"></a>01765 <span class="comment">**</span>
<a name="l01766"></a>01766 <span class="comment">**   *  s begins with the string t, ignoring case</span>
<a name="l01767"></a>01767 <span class="comment">**   *  s is longer than t</span>
<a name="l01768"></a>01768 <span class="comment">**   *  The first character of s beyond t is not a alphanumeric</span>
<a name="l01769"></a>01769 <span class="comment">** </span>
<a name="l01770"></a>01770 <span class="comment">** Ignore leading space in *s.</span>
<a name="l01771"></a>01771 <span class="comment">**</span>
<a name="l01772"></a>01772 <span class="comment">** To put it another way, return true if the first token of</span>
<a name="l01773"></a>01773 <span class="comment">** s[] is t[].</span>
<a name="l01774"></a>01774 <span class="comment">*/</span>
<a name="l01775"></a><a class="code" href="fts1_8c.html#ae6de35868033307bf1b589708be561c3">01775</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ae6de35868033307bf1b589708be561c3">startsWith</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *t){
<a name="l01776"></a>01776   <span class="keywordflow">while</span>( <a class="code" href="fts1_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(*s) ){ s++; }
<a name="l01777"></a>01777   <span class="keywordflow">while</span>( *t ){
<a name="l01778"></a>01778     <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#aa13290c27de028c6f1886f82656482fa">safe_tolower</a>(*s++)!=<a class="code" href="fts1_8c.html#aa13290c27de028c6f1886f82656482fa">safe_tolower</a>(*t++) ) <span class="keywordflow">return</span> 0;
<a name="l01779"></a>01779   }
<a name="l01780"></a>01780   <span class="keywordflow">return</span> *s!=<span class="charliteral">&apos;_&apos;</span> &amp;&amp; !<a class="code" href="fts1_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">safe_isalnum</a>(*s);
<a name="l01781"></a>01781 }
<a name="l01782"></a>01782 
<a name="l01783"></a>01783 <span class="comment">/*</span>
<a name="l01784"></a>01784 <span class="comment">** An instance of this structure defines the &quot;spec&quot; of a</span>
<a name="l01785"></a>01785 <span class="comment">** full text index.  This structure is populated by parseSpec</span>
<a name="l01786"></a>01786 <span class="comment">** and use by fulltextConnect and fulltextCreate.</span>
<a name="l01787"></a>01787 <span class="comment">*/</span>
<a name="l01788"></a><a class="code" href="structTableSpec.html">01788</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structTableSpec.html">TableSpec</a> {
<a name="l01789"></a><a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">01789</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a>;         <span class="comment">/* Logical database name */</span>
<a name="l01790"></a><a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">01790</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>;       <span class="comment">/* Name of the full-text index */</span>
<a name="l01791"></a><a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">01791</a>   <span class="keywordtype">int</span> <a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>;             <span class="comment">/* Number of columns to be indexed */</span>
<a name="l01792"></a><a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">01792</a>   <span class="keywordtype">char</span> **<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a>;         <span class="comment">/* Original names of columns to be indexed */</span>
<a name="l01793"></a><a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">01793</a>   <span class="keywordtype">char</span> **<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>;  <span class="comment">/* Column names for %_content */</span>
<a name="l01794"></a><a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">01794</a>   <span class="keywordtype">char</span> **<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>;      <span class="comment">/* Name of tokenizer and its arguments */</span>
<a name="l01795"></a>01795 } <a class="code" href="structTableSpec.html">TableSpec</a>;
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 <span class="comment">/*</span>
<a name="l01798"></a>01798 <span class="comment">** Reclaim all of the memory used by a TableSpec</span>
<a name="l01799"></a>01799 <span class="comment">*/</span>
<a name="l01800"></a><a class="code" href="fts1_8c.html#a558f389157af9866b165a9f1138d077d">01800</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a558f389157af9866b165a9f1138d077d">clearTableSpec</a>(<a class="code" href="structTableSpec.html">TableSpec</a> *p) {
<a name="l01801"></a>01801   free(p-&gt;<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a>);
<a name="l01802"></a>01802   free(p-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>);
<a name="l01803"></a>01803   free(p-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>);
<a name="l01804"></a>01804 }
<a name="l01805"></a>01805 
<a name="l01806"></a>01806 <span class="comment">/* Parse a CREATE VIRTUAL TABLE statement, which looks like this:</span>
<a name="l01807"></a>01807 <span class="comment"> *</span>
<a name="l01808"></a>01808 <span class="comment"> * CREATE VIRTUAL TABLE email</span>
<a name="l01809"></a>01809 <span class="comment"> *        USING fts1(subject, body, tokenize mytokenizer(myarg))</span>
<a name="l01810"></a>01810 <span class="comment"> *</span>
<a name="l01811"></a>01811 <span class="comment"> * We return parsed information in a TableSpec structure.</span>
<a name="l01812"></a>01812 <span class="comment"> * </span>
<a name="l01813"></a>01813 <span class="comment"> */</span>
<a name="l01814"></a><a class="code" href="fts1_8c.html#ab2b3c8fa2bbe697f78bc3a84b61ef0ce">01814</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ab2b3c8fa2bbe697f78bc3a84b61ef0ce">parseSpec</a>(<a class="code" href="structTableSpec.html">TableSpec</a> *pSpec, <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span>*argv,
<a name="l01815"></a>01815                      <span class="keywordtype">char</span>**pzErr){
<a name="l01816"></a>01816   <span class="keywordtype">int</span> i, n;
<a name="l01817"></a>01817   <span class="keywordtype">char</span> *z, *zDummy;
<a name="l01818"></a>01818   <span class="keywordtype">char</span> **azArg;
<a name="l01819"></a>01819   <span class="keyword">const</span> <span class="keywordtype">char</span> *zTokenizer = 0;    <span class="comment">/* argv[] entry describing the tokenizer */</span>
<a name="l01820"></a>01820 
<a name="l01821"></a>01821   assert( argc&gt;=3 );
<a name="l01822"></a>01822   <span class="comment">/* Current interface:</span>
<a name="l01823"></a>01823 <span class="comment">  ** argv[0] - module name</span>
<a name="l01824"></a>01824 <span class="comment">  ** argv[1] - database name</span>
<a name="l01825"></a>01825 <span class="comment">  ** argv[2] - table name</span>
<a name="l01826"></a>01826 <span class="comment">  ** argv[3..] - columns, optionally followed by tokenizer specification</span>
<a name="l01827"></a>01827 <span class="comment">  **             and snippet delimiters specification.</span>
<a name="l01828"></a>01828 <span class="comment">  */</span>
<a name="l01829"></a>01829 
<a name="l01830"></a>01830   <span class="comment">/* Make a copy of the complete argv[][] array in a single allocation.</span>
<a name="l01831"></a>01831 <span class="comment">  ** The argv[][] array is read-only and transient.  We can write to the</span>
<a name="l01832"></a>01832 <span class="comment">  ** copy in order to modify things and the copy is persistent.</span>
<a name="l01833"></a>01833 <span class="comment">  */</span>
<a name="l01834"></a>01834   memset(pSpec, 0, <span class="keyword">sizeof</span>(*pSpec));
<a name="l01835"></a>01835   <span class="keywordflow">for</span>(i=n=0; i&lt;argc; i++){
<a name="l01836"></a>01836     n += strlen(argv[i]) + 1;
<a name="l01837"></a>01837   }
<a name="l01838"></a>01838   azArg = malloc( <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*)*argc + n );
<a name="l01839"></a>01839   <span class="keywordflow">if</span>( azArg==0 ){
<a name="l01840"></a>01840     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01841"></a>01841   }
<a name="l01842"></a>01842   z = (<span class="keywordtype">char</span>*)&amp;azArg[argc];
<a name="l01843"></a>01843   <span class="keywordflow">for</span>(i=0; i&lt;argc; i++){
<a name="l01844"></a>01844     azArg[i] = z;
<a name="l01845"></a>01845     strcpy(z, argv[i]);
<a name="l01846"></a>01846     z += strlen(z)+1;
<a name="l01847"></a>01847   }
<a name="l01848"></a>01848 
<a name="l01849"></a>01849   <span class="comment">/* Identify the column names and the tokenizer and delimiter arguments</span>
<a name="l01850"></a>01850 <span class="comment">  ** in the argv[][] array.</span>
<a name="l01851"></a>01851 <span class="comment">  */</span>
<a name="l01852"></a>01852   pSpec-&gt;<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a> = azArg[1];
<a name="l01853"></a>01853   pSpec-&gt;<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a> = azArg[2];
<a name="l01854"></a>01854   pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a> = 0;
<a name="l01855"></a>01855   pSpec-&gt;<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a> = azArg;
<a name="l01856"></a>01856   zTokenizer = <span class="stringliteral">&quot;tokenize simple&quot;</span>;
<a name="l01857"></a>01857   <span class="keywordflow">for</span>(i=3; i&lt;argc; ++i){
<a name="l01858"></a>01858     <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#ae6de35868033307bf1b589708be561c3">startsWith</a>(azArg[i],<span class="stringliteral">&quot;tokenize&quot;</span>) ){
<a name="l01859"></a>01859       zTokenizer = azArg[i];
<a name="l01860"></a>01860     }<span class="keywordflow">else</span>{
<a name="l01861"></a>01861       z = azArg[pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>] = <a class="code" href="fts1_8c.html#a3948d23d2ee53a6cbcc9a546734acb38">firstToken</a>(azArg[i], &amp;zDummy);
<a name="l01862"></a>01862       pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>++;
<a name="l01863"></a>01863     }
<a name="l01864"></a>01864   }
<a name="l01865"></a>01865   <span class="keywordflow">if</span>( pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>==0 ){
<a name="l01866"></a>01866     azArg[0] = <span class="stringliteral">&quot;content&quot;</span>;
<a name="l01867"></a>01867     pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a> = 1;
<a name="l01868"></a>01868   }
<a name="l01869"></a>01869 
<a name="l01870"></a>01870   <span class="comment">/*</span>
<a name="l01871"></a>01871 <span class="comment">  ** Construct the list of content column names.</span>
<a name="l01872"></a>01872 <span class="comment">  **</span>
<a name="l01873"></a>01873 <span class="comment">  ** Each content column name will be of the form cNNAAAA</span>
<a name="l01874"></a>01874 <span class="comment">  ** where NN is the column number and AAAA is the sanitized</span>
<a name="l01875"></a>01875 <span class="comment">  ** column name.  &quot;sanitized&quot; means that special characters are</span>
<a name="l01876"></a>01876 <span class="comment">  ** converted to &quot;_&quot;.  The cNN prefix guarantees that all column</span>
<a name="l01877"></a>01877 <span class="comment">  ** names are unique.</span>
<a name="l01878"></a>01878 <span class="comment">  **</span>
<a name="l01879"></a>01879 <span class="comment">  ** The AAAA suffix is not strictly necessary.  It is included</span>
<a name="l01880"></a>01880 <span class="comment">  ** for the convenience of people who might examine the generated</span>
<a name="l01881"></a>01881 <span class="comment">  ** %_content table and wonder what the columns are used for.</span>
<a name="l01882"></a>01882 <span class="comment">  */</span>
<a name="l01883"></a>01883   pSpec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a> = malloc( pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *) );
<a name="l01884"></a>01884   <span class="keywordflow">if</span>( pSpec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>==0 ){
<a name="l01885"></a>01885     <a class="code" href="fts1_8c.html#a558f389157af9866b165a9f1138d077d">clearTableSpec</a>(pSpec);
<a name="l01886"></a>01886     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01887"></a>01887   }
<a name="l01888"></a>01888   <span class="keywordflow">for</span>(i=0; i&lt;pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>; i++){
<a name="l01889"></a>01889     <span class="keywordtype">char</span> *p;
<a name="l01890"></a>01890     pSpec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>[i] = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;c%d%s&quot;</span>, i, azArg[i]);
<a name="l01891"></a>01891     <span class="keywordflow">for</span> (p = pSpec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>[i]; *p ; ++p) {
<a name="l01892"></a>01892       <span class="keywordflow">if</span>( !<a class="code" href="fts1_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">safe_isalnum</a>(*p) ) *p = <span class="charliteral">&apos;_&apos;</span>;
<a name="l01893"></a>01893     }
<a name="l01894"></a>01894   }
<a name="l01895"></a>01895 
<a name="l01896"></a>01896   <span class="comment">/*</span>
<a name="l01897"></a>01897 <span class="comment">  ** Parse the tokenizer specification string.</span>
<a name="l01898"></a>01898 <span class="comment">  */</span>
<a name="l01899"></a>01899   pSpec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a> = <a class="code" href="fts1_8c.html#a3ea56dae76c51349cbdef32a7215bcbb">tokenizeString</a>(zTokenizer, &amp;n);
<a name="l01900"></a>01900   <a class="code" href="fts1_8c.html#aa1202d8ce261dc098a68360d002b7420">tokenListToIdList</a>(pSpec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>);
<a name="l01901"></a>01901 
<a name="l01902"></a>01902   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01903"></a>01903 }
<a name="l01904"></a>01904 
<a name="l01905"></a>01905 <span class="comment">/*</span>
<a name="l01906"></a>01906 <span class="comment">** Generate a CREATE TABLE statement that describes the schema of</span>
<a name="l01907"></a>01907 <span class="comment">** the virtual table.  Return a pointer to this schema string.</span>
<a name="l01908"></a>01908 <span class="comment">**</span>
<a name="l01909"></a>01909 <span class="comment">** Space is obtained from sqlite3_mprintf() and should be freed</span>
<a name="l01910"></a>01910 <span class="comment">** using sqlite3_free().</span>
<a name="l01911"></a>01911 <span class="comment">*/</span>
<a name="l01912"></a><a class="code" href="fts1_8c.html#a679cfcb66f0cbef9c8af06fb107b93ae">01912</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts1_8c.html#a679cfcb66f0cbef9c8af06fb107b93ae">fulltextSchema</a>(
<a name="l01913"></a>01913   <span class="keywordtype">int</span> nColumn,                  <span class="comment">/* Number of columns */</span>
<a name="l01914"></a>01914   <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span>* azColumn,  <span class="comment">/* List of columns */</span>
<a name="l01915"></a>01915   <span class="keyword">const</span> <span class="keywordtype">char</span> *zTableName        <span class="comment">/* Name of the table */</span>
<a name="l01916"></a>01916 ){
<a name="l01917"></a>01917   <span class="keywordtype">int</span> i;
<a name="l01918"></a>01918   <span class="keywordtype">char</span> *zSchema, *zNext;
<a name="l01919"></a>01919   <span class="keyword">const</span> <span class="keywordtype">char</span> *zSep = <span class="stringliteral">&quot;(&quot;</span>;
<a name="l01920"></a>01920   zSchema = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;CREATE TABLE x&quot;</span>);
<a name="l01921"></a>01921   <span class="keywordflow">for</span>(i=0; i&lt;nColumn; i++){
<a name="l01922"></a>01922     zNext = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;%s%s%Q&quot;</span>, zSchema, zSep, azColumn[i]);
<a name="l01923"></a>01923     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zSchema);
<a name="l01924"></a>01924     zSchema = zNext;
<a name="l01925"></a>01925     zSep = <span class="stringliteral">&quot;,&quot;</span>;
<a name="l01926"></a>01926   }
<a name="l01927"></a>01927   zNext = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;%s,%Q)&quot;</span>, zSchema, zTableName);
<a name="l01928"></a>01928   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zSchema);
<a name="l01929"></a>01929   <span class="keywordflow">return</span> zNext;
<a name="l01930"></a>01930 }
<a name="l01931"></a>01931 
<a name="l01932"></a>01932 <span class="comment">/*</span>
<a name="l01933"></a>01933 <span class="comment">** Build a new sqlite3_vtab structure that will describe the</span>
<a name="l01934"></a>01934 <span class="comment">** fulltext index defined by spec.</span>
<a name="l01935"></a>01935 <span class="comment">*/</span>
<a name="l01936"></a><a class="code" href="fts1_8c.html#a48a432cf3a6a79ca20ad3d0148bef8a2">01936</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a48a432cf3a6a79ca20ad3d0148bef8a2">constructVtab</a>(
<a name="l01937"></a>01937   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>,              <span class="comment">/* The SQLite database connection */</span>
<a name="l01938"></a>01938   <a class="code" href="structTableSpec.html">TableSpec</a> *spec,          <span class="comment">/* Parsed spec information from parseSpec() */</span>
<a name="l01939"></a>01939   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> **ppVTab,    <span class="comment">/* Write the resulting vtab structure here */</span>
<a name="l01940"></a>01940   <span class="keywordtype">char</span> **pzErr              <span class="comment">/* Write any error message here */</span>
<a name="l01941"></a>01941 ){
<a name="l01942"></a>01942   <span class="keywordtype">int</span> rc;
<a name="l01943"></a>01943   <span class="keywordtype">int</span> n;
<a name="l01944"></a>01944   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = 0;
<a name="l01945"></a>01945   <span class="keyword">const</span> <a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *m = NULL;
<a name="l01946"></a>01946   <span class="keywordtype">char</span> *schema;
<a name="l01947"></a>01947 
<a name="l01948"></a>01948   v = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a>));
<a name="l01949"></a>01949   <span class="keywordflow">if</span>( v==0 ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01950"></a>01950   memset(v, 0, <span class="keyword">sizeof</span>(*v));
<a name="l01951"></a>01951   <span class="comment">/* sqlite will initialize v-&gt;base */</span>
<a name="l01952"></a>01952   v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a> = db;
<a name="l01953"></a>01953   v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a> = spec-&gt;<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a>;       <span class="comment">/* Freed when azColumn is freed */</span>
<a name="l01954"></a>01954   v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a> = spec-&gt;<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>;   <span class="comment">/* Freed when azColumn is freed */</span>
<a name="l01955"></a>01955   v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a> = spec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>;
<a name="l01956"></a>01956   v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a> = spec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>;
<a name="l01957"></a>01957   spec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a> = 0;
<a name="l01958"></a>01958   v-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a> = spec-&gt;<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a>;
<a name="l01959"></a>01959   spec-&gt;<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a> = 0;
<a name="l01960"></a>01960 
<a name="l01961"></a>01961   <span class="keywordflow">if</span>( spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>==0 ){
<a name="l01962"></a>01962     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01963"></a>01963   }
<a name="l01964"></a>01964   <span class="comment">/* TODO(shess) For now, add new tokenizers as else if clauses. */</span>
<a name="l01965"></a>01965   <span class="keywordflow">if</span>( spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[0]==0 || <a class="code" href="fts1_8c.html#ae6de35868033307bf1b589708be561c3">startsWith</a>(spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[0], <span class="stringliteral">&quot;simple&quot;</span>) ){
<a name="l01966"></a>01966     <a class="code" href="fts1__tokenizer_8h.html#aac78bb2b488ddae5cb88281ca1305f16">sqlite3Fts1SimpleTokenizerModule</a>(&amp;m);
<a name="l01967"></a>01967   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#ae6de35868033307bf1b589708be561c3">startsWith</a>(spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[0], <span class="stringliteral">&quot;porter&quot;</span>) ){
<a name="l01968"></a>01968     <a class="code" href="fts1__porter_8c.html#adbd32162b8b7131ec495fe78f3889a6c">sqlite3Fts1PorterTokenizerModule</a>(&amp;m);
<a name="l01969"></a>01969   }<span class="keywordflow">else</span>{
<a name="l01970"></a>01970     *pzErr = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;unknown tokenizer: %s&quot;</span>, spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[0]);
<a name="l01971"></a>01971     rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l01972"></a>01972     <span class="keywordflow">goto</span> err;
<a name="l01973"></a>01973   }
<a name="l01974"></a>01974   <span class="keywordflow">for</span>(n=0; spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[n]; n++){}
<a name="l01975"></a>01975   <span class="keywordflow">if</span>( n ){
<a name="l01976"></a>01976     rc = m-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#af23cec0bb84594e9c28c6892e2bb917a">xCreate</a>(n-1, (<span class="keyword">const</span> <span class="keywordtype">char</span>*<span class="keyword">const</span>*)&amp;spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[1],
<a name="l01977"></a>01977                     &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>);
<a name="l01978"></a>01978   }<span class="keywordflow">else</span>{
<a name="l01979"></a>01979     rc = m-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#af23cec0bb84594e9c28c6892e2bb917a">xCreate</a>(0, 0, &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>);
<a name="l01980"></a>01980   }
<a name="l01981"></a>01981   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l01982"></a>01982   v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a> = m;
<a name="l01983"></a>01983 
<a name="l01984"></a>01984   <span class="comment">/* TODO: verify the existence of backing tables foo_content, foo_term */</span>
<a name="l01985"></a>01985 
<a name="l01986"></a>01986   schema = <a class="code" href="fts1_8c.html#a679cfcb66f0cbef9c8af06fb107b93ae">fulltextSchema</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*<span class="keyword">const</span>*)v-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>,
<a name="l01987"></a>01987                           spec-&gt;<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>);
<a name="l01988"></a>01988   rc = <a class="code" href="sqlite3_8h.html#aefa1dcc35bfd08140af3073d08e20029">sqlite3_declare_vtab</a>(db, schema);
<a name="l01989"></a>01989   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(schema);
<a name="l01990"></a>01990   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l01991"></a>01991 
<a name="l01992"></a>01992   memset(v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>, 0, <span class="keyword">sizeof</span>(v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>));
<a name="l01993"></a>01993 
<a name="l01994"></a>01994   *ppVTab = &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#a8e711ebd8423f2581ac15dd3a25f4353">base</a>;
<a name="l01995"></a>01995   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Connect %p\n&quot;</span>, v));
<a name="l01996"></a>01996 
<a name="l01997"></a>01997   <span class="keywordflow">return</span> rc;
<a name="l01998"></a>01998 
<a name="l01999"></a>01999 err:
<a name="l02000"></a>02000   <a class="code" href="fts1_8c.html#aec311e3893b552f3ae7b70311bb70280">fulltext_vtab_destroy</a>(v);
<a name="l02001"></a>02001   <span class="keywordflow">return</span> rc;
<a name="l02002"></a>02002 }
<a name="l02003"></a>02003 
<a name="l02004"></a><a class="code" href="fts1_8c.html#a42d060bb429eb8ae7a86e9042b4fb232">02004</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a42d060bb429eb8ae7a86e9042b4fb232">fulltextConnect</a>(
<a name="l02005"></a>02005   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>,
<a name="l02006"></a>02006   <span class="keywordtype">void</span> *pAux,
<a name="l02007"></a>02007   <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span>*argv,
<a name="l02008"></a>02008   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> **ppVTab,
<a name="l02009"></a>02009   <span class="keywordtype">char</span> **pzErr
<a name="l02010"></a>02010 ){
<a name="l02011"></a>02011   <a class="code" href="structTableSpec.html">TableSpec</a> spec;
<a name="l02012"></a>02012   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#ab2b3c8fa2bbe697f78bc3a84b61ef0ce">parseSpec</a>(&amp;spec, argc, argv, pzErr);
<a name="l02013"></a>02013   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02014"></a>02014 
<a name="l02015"></a>02015   rc = <a class="code" href="fts1_8c.html#a48a432cf3a6a79ca20ad3d0148bef8a2">constructVtab</a>(db, &amp;spec, ppVTab, pzErr);
<a name="l02016"></a>02016   <a class="code" href="fts1_8c.html#a558f389157af9866b165a9f1138d077d">clearTableSpec</a>(&amp;spec);
<a name="l02017"></a>02017   <span class="keywordflow">return</span> rc;
<a name="l02018"></a>02018 }
<a name="l02019"></a>02019 
<a name="l02020"></a>02020   <span class="comment">/* The %_content table holds the text of each document, with</span>
<a name="l02021"></a>02021 <span class="comment">  ** the rowid used as the docid.</span>
<a name="l02022"></a>02022 <span class="comment">  **</span>
<a name="l02023"></a>02023 <span class="comment">  ** The %_term table maps each term to a document list blob</span>
<a name="l02024"></a>02024 <span class="comment">  ** containing elements sorted by ascending docid, each element</span>
<a name="l02025"></a>02025 <span class="comment">  ** encoded as:</span>
<a name="l02026"></a>02026 <span class="comment">  **</span>
<a name="l02027"></a>02027 <span class="comment">  **   docid varint-encoded</span>
<a name="l02028"></a>02028 <span class="comment">  **   token elements:</span>
<a name="l02029"></a>02029 <span class="comment">  **     position+1 varint-encoded as delta from previous position</span>
<a name="l02030"></a>02030 <span class="comment">  **     start offset varint-encoded as delta from previous start offset</span>
<a name="l02031"></a>02031 <span class="comment">  **     end offset varint-encoded as delta from start offset</span>
<a name="l02032"></a>02032 <span class="comment">  **</span>
<a name="l02033"></a>02033 <span class="comment">  ** The sentinel position of 0 indicates the end of the token list.</span>
<a name="l02034"></a>02034 <span class="comment">  **</span>
<a name="l02035"></a>02035 <span class="comment">  ** Additionally, doclist blobs are chunked into multiple segments,</span>
<a name="l02036"></a>02036 <span class="comment">  ** using segment to order the segments.  New elements are added to</span>
<a name="l02037"></a>02037 <span class="comment">  ** the segment at segment 0, until it exceeds CHUNK_MAX.  Then</span>
<a name="l02038"></a>02038 <span class="comment">  ** segment 0 is deleted, and the doclist is inserted at segment 1.</span>
<a name="l02039"></a>02039 <span class="comment">  ** If there is already a doclist at segment 1, the segment 0 doclist</span>
<a name="l02040"></a>02040 <span class="comment">  ** is merged with it, the segment 1 doclist is deleted, and the</span>
<a name="l02041"></a>02041 <span class="comment">  ** merged doclist is inserted at segment 2, repeating those</span>
<a name="l02042"></a>02042 <span class="comment">  ** operations until an insert succeeds.</span>
<a name="l02043"></a>02043 <span class="comment">  **</span>
<a name="l02044"></a>02044 <span class="comment">  ** Since this structure doesn&apos;t allow us to update elements in place</span>
<a name="l02045"></a>02045 <span class="comment">  ** in case of deletion or update, these are simply written to</span>
<a name="l02046"></a>02046 <span class="comment">  ** segment 0 (with an empty token list in case of deletion), with</span>
<a name="l02047"></a>02047 <span class="comment">  ** docListAccumulate() taking care to retain lower-segment</span>
<a name="l02048"></a>02048 <span class="comment">  ** information in preference to higher-segment information.</span>
<a name="l02049"></a>02049 <span class="comment">  */</span>
<a name="l02050"></a>02050   <span class="comment">/* TODO(shess) Provide a VACUUM type operation which both removes</span>
<a name="l02051"></a>02051 <span class="comment">  ** deleted elements which are no longer necessary, and duplicated</span>
<a name="l02052"></a>02052 <span class="comment">  ** elements.  I suspect this will probably not be necessary in</span>
<a name="l02053"></a>02053 <span class="comment">  ** practice, though.</span>
<a name="l02054"></a>02054 <span class="comment">  */</span>
<a name="l02055"></a><a class="code" href="fts1_8c.html#a0d5b27c0376561066f14ab3a59d8b6a2">02055</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a0d5b27c0376561066f14ab3a59d8b6a2">fulltextCreate</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <span class="keywordtype">void</span> *pAux,
<a name="l02056"></a>02056                           <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> *argv,
<a name="l02057"></a>02057                           <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> **ppVTab, <span class="keywordtype">char</span> **pzErr){
<a name="l02058"></a>02058   <span class="keywordtype">int</span> rc;
<a name="l02059"></a>02059   <a class="code" href="structTableSpec.html">TableSpec</a> spec;
<a name="l02060"></a>02060   <a class="code" href="structStringBuffer.html">StringBuffer</a> schema;
<a name="l02061"></a>02061   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Create\n&quot;</span>));
<a name="l02062"></a>02062 
<a name="l02063"></a>02063   rc = <a class="code" href="fts1_8c.html#ab2b3c8fa2bbe697f78bc3a84b61ef0ce">parseSpec</a>(&amp;spec, argc, argv, pzErr);
<a name="l02064"></a>02064   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02065"></a>02065 
<a name="l02066"></a>02066   <a class="code" href="fts1_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;schema);
<a name="l02067"></a>02067   <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;schema, <span class="stringliteral">&quot;CREATE TABLE %_content(&quot;</span>);
<a name="l02068"></a>02068   <a class="code" href="fts1_8c.html#a25815e8e930bcd9e3eabfe5ee1c9412f">appendList</a>(&amp;schema, spec.<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>, spec.<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>);
<a name="l02069"></a>02069   <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;schema, <span class="stringliteral">&quot;)&quot;</span>);
<a name="l02070"></a>02070   rc = <a class="code" href="fts1_8c.html#a39d956ab682bbd568f87016368f26aee">sql_exec</a>(db, spec.<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a>, spec.<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>, schema.<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>);
<a name="l02071"></a>02071   free(schema.<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>);
<a name="l02072"></a>02072   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> out;
<a name="l02073"></a>02073 
<a name="l02074"></a>02074   rc = <a class="code" href="fts1_8c.html#a39d956ab682bbd568f87016368f26aee">sql_exec</a>(db, spec.<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a>, spec.<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>,
<a name="l02075"></a>02075     <span class="stringliteral">&quot;create table %_term(term text, segment integer, doclist blob, &quot;</span>
<a name="l02076"></a>02076                         <span class="stringliteral">&quot;primary key(term, segment));&quot;</span>);
<a name="l02077"></a>02077   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> out;
<a name="l02078"></a>02078 
<a name="l02079"></a>02079   rc = <a class="code" href="fts1_8c.html#a48a432cf3a6a79ca20ad3d0148bef8a2">constructVtab</a>(db, &amp;spec, ppVTab, pzErr);
<a name="l02080"></a>02080 
<a name="l02081"></a>02081 out:
<a name="l02082"></a>02082   <a class="code" href="fts1_8c.html#a558f389157af9866b165a9f1138d077d">clearTableSpec</a>(&amp;spec);
<a name="l02083"></a>02083   <span class="keywordflow">return</span> rc;
<a name="l02084"></a>02084 }
<a name="l02085"></a>02085 
<a name="l02086"></a>02086 <span class="comment">/* Decide how to handle an SQL query. */</span>
<a name="l02087"></a><a class="code" href="fts1_8c.html#abf18e0da44ece3b370a714c8e95e2de6">02087</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#abf18e0da44ece3b370a714c8e95e2de6">fulltextBestIndex</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVTab, <a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> *pInfo){
<a name="l02088"></a>02088   <span class="keywordtype">int</span> i;
<a name="l02089"></a>02089   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 BestIndex\n&quot;</span>));
<a name="l02090"></a>02090 
<a name="l02091"></a>02091   <span class="keywordflow">for</span>(i=0; i&lt;pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#ae861993a30ce914a5214eab2579d935a">nConstraint</a>; ++i){
<a name="l02092"></a>02092     <span class="keyword">const</span> <span class="keyword">struct </span>sqlite3_index_constraint *pConstraint;
<a name="l02093"></a>02093     pConstraint = &amp;pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a>[i];
<a name="l02094"></a>02094     <span class="keywordflow">if</span>( pConstraint-&gt;usable ) {
<a name="l02095"></a>02095       <span class="keywordflow">if</span>( pConstraint-&gt;iColumn==-1 &amp;&amp;
<a name="l02096"></a>02096           pConstraint-&gt;op==<a class="code" href="sqlite3_8h.html#a82727c6d3191174cb4e900a70a3434a4">SQLITE_INDEX_CONSTRAINT_EQ</a> ){
<a name="l02097"></a>02097         pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a> = <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ecadfa9dc6cb33447260116307a64a3c657">QUERY_ROWID</a>;      <span class="comment">/* lookup by rowid */</span>
<a name="l02098"></a>02098         <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 QUERY_ROWID\n&quot;</span>));
<a name="l02099"></a>02099       } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pConstraint-&gt;iColumn&gt;=0 &amp;&amp;
<a name="l02100"></a>02100                  pConstraint-&gt;op==<a class="code" href="sqlite3_8h.html#a5f5c5144477960f96f6d49bce0598e9a">SQLITE_INDEX_CONSTRAINT_MATCH</a> ){
<a name="l02101"></a>02101         <span class="comment">/* full-text search */</span>
<a name="l02102"></a>02102         pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a> = <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a> + pConstraint-&gt;iColumn;
<a name="l02103"></a>02103         <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 QUERY_FULLTEXT %d\n&quot;</span>, pConstraint-&gt;iColumn));
<a name="l02104"></a>02104       } <span class="keywordflow">else</span> <span class="keywordflow">continue</span>;
<a name="l02105"></a>02105 
<a name="l02106"></a>02106       pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a79b8a969dd7d582fc2ea3c0fbc5adb56">aConstraintUsage</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint__usage.html#a2cbf680033c2937b3de226e091743a94">argvIndex</a> = 1;
<a name="l02107"></a>02107       pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a79b8a969dd7d582fc2ea3c0fbc5adb56">aConstraintUsage</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint__usage.html#ad07fa17d30e4fb3abe23ceaf84edf0ef">omit</a> = 1;
<a name="l02108"></a>02108 
<a name="l02109"></a>02109       <span class="comment">/* An arbitrary value for now.</span>
<a name="l02110"></a>02110 <span class="comment">       * TODO: Perhaps rowid matches should be considered cheaper than</span>
<a name="l02111"></a>02111 <span class="comment">       * full-text searches. */</span>
<a name="l02112"></a>02112       pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#aa8b4fe1d2ee38aab57ba5e1da00d7830">estimatedCost</a> = 1.0;   
<a name="l02113"></a>02113 
<a name="l02114"></a>02114       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02115"></a>02115     }
<a name="l02116"></a>02116   }
<a name="l02117"></a>02117   pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a> = <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">QUERY_GENERIC</a>;
<a name="l02118"></a>02118   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02119"></a>02119 }
<a name="l02120"></a>02120 
<a name="l02121"></a><a class="code" href="fts1_8c.html#a8314ee27dd1e598b803db35bf1aa393d">02121</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a8314ee27dd1e598b803db35bf1aa393d">fulltextDisconnect</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVTab){
<a name="l02122"></a>02122   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Disconnect %p\n&quot;</span>, pVTab));
<a name="l02123"></a>02123   <a class="code" href="fts1_8c.html#aec311e3893b552f3ae7b70311bb70280">fulltext_vtab_destroy</a>((<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVTab);
<a name="l02124"></a>02124   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02125"></a>02125 }
<a name="l02126"></a>02126 
<a name="l02127"></a><a class="code" href="fts1_8c.html#ace0e89f70928f42ce6dc7769c8309ba6">02127</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ace0e89f70928f42ce6dc7769c8309ba6">fulltextDestroy</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVTab){
<a name="l02128"></a>02128   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVTab;
<a name="l02129"></a>02129   <span class="keywordtype">int</span> rc;
<a name="l02130"></a>02130 
<a name="l02131"></a>02131   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Destroy %p\n&quot;</span>, pVTab));
<a name="l02132"></a>02132   rc = <a class="code" href="fts1_8c.html#a39d956ab682bbd568f87016368f26aee">sql_exec</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>,
<a name="l02133"></a>02133                 <span class="stringliteral">&quot;drop table if exists %_content;&quot;</span>
<a name="l02134"></a>02134                 <span class="stringliteral">&quot;drop table if exists %_term;&quot;</span>
<a name="l02135"></a>02135                 );
<a name="l02136"></a>02136   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02137"></a>02137 
<a name="l02138"></a>02138   <a class="code" href="fts1_8c.html#aec311e3893b552f3ae7b70311bb70280">fulltext_vtab_destroy</a>((<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVTab);
<a name="l02139"></a>02139   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02140"></a>02140 }
<a name="l02141"></a>02141 
<a name="l02142"></a><a class="code" href="fts1_8c.html#a124d1580023f422308936a6fad63ce4f">02142</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a124d1580023f422308936a6fad63ce4f">fulltextOpen</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVTab, <a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> **ppCursor){
<a name="l02143"></a>02143   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c;
<a name="l02144"></a>02144 
<a name="l02145"></a>02145   c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) calloc(<span class="keyword">sizeof</span>(<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a>), 1);
<a name="l02146"></a>02146   <span class="comment">/* sqlite will initialize c-&gt;base */</span>
<a name="l02147"></a>02147   *ppCursor = &amp;c-&gt;<a class="code" href="structfulltext__cursor.html#a81a33bdfcda3fbe7a0170224d8442a5c">base</a>;
<a name="l02148"></a>02148   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Open %p: %p\n&quot;</span>, pVTab, c));
<a name="l02149"></a>02149 
<a name="l02150"></a>02150   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02151"></a>02151 }
<a name="l02152"></a>02152 
<a name="l02153"></a>02153 
<a name="l02154"></a>02154 <span class="comment">/* Free all of the dynamically allocated memory held by *q</span>
<a name="l02155"></a>02155 <span class="comment">*/</span>
<a name="l02156"></a><a class="code" href="fts1_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">02156</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(<a class="code" href="structQuery.html">Query</a> *q){
<a name="l02157"></a>02157   <span class="keywordtype">int</span> i;
<a name="l02158"></a>02158   <span class="keywordflow">for</span>(i = 0; i &lt; q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>; ++i){
<a name="l02159"></a>02159     free(q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[i].<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>);
<a name="l02160"></a>02160   }
<a name="l02161"></a>02161   free(q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>);
<a name="l02162"></a>02162   memset(q, 0, <span class="keyword">sizeof</span>(*q));
<a name="l02163"></a>02163 }
<a name="l02164"></a>02164 
<a name="l02165"></a>02165 <span class="comment">/* Free all of the dynamically allocated memory held by the</span>
<a name="l02166"></a>02166 <span class="comment">** Snippet</span>
<a name="l02167"></a>02167 <span class="comment">*/</span>
<a name="l02168"></a><a class="code" href="fts1_8c.html#ac4854671b9ca8b41ca0f7bd78f090eee">02168</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#ac4854671b9ca8b41ca0f7bd78f090eee">snippetClear</a>(<a class="code" href="structSnippet.html">Snippet</a> *p){
<a name="l02169"></a>02169   free(p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>);
<a name="l02170"></a>02170   free(p-&gt;<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a>);
<a name="l02171"></a>02171   free(p-&gt;<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a>);
<a name="l02172"></a>02172   memset(p, 0, <span class="keyword">sizeof</span>(*p));
<a name="l02173"></a>02173 }
<a name="l02174"></a>02174 <span class="comment">/*</span>
<a name="l02175"></a>02175 <span class="comment">** Append a single entry to the p-&gt;aMatch[] log.</span>
<a name="l02176"></a>02176 <span class="comment">*/</span>
<a name="l02177"></a><a class="code" href="fts1_8c.html#a656691e1d431166d866f0ce903aa7dd0">02177</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a656691e1d431166d866f0ce903aa7dd0">snippetAppendMatch</a>(
<a name="l02178"></a>02178   <a class="code" href="structSnippet.html">Snippet</a> *p,               <span class="comment">/* Append the entry to this snippet */</span>
<a name="l02179"></a>02179   <span class="keywordtype">int</span> iCol, <span class="keywordtype">int</span> iTerm,      <span class="comment">/* The column and query term */</span>
<a name="l02180"></a>02180   <span class="keywordtype">int</span> iStart, <span class="keywordtype">int</span> nByte     <span class="comment">/* Offset and size of the match */</span>
<a name="l02181"></a>02181 ){
<a name="l02182"></a>02182   <span class="keywordtype">int</span> i;
<a name="l02183"></a>02183   <span class="keyword">struct </span>snippetMatch *pMatch;
<a name="l02184"></a>02184   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>+1&gt;=p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a> ){
<a name="l02185"></a>02185     p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a> = p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a>*2 + 10;
<a name="l02186"></a>02186     p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a> = realloc(p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>, p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a>*<span class="keyword">sizeof</span>(p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>[0]) );
<a name="l02187"></a>02187     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>==0 ){
<a name="l02188"></a>02188       p-&gt;<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a> = 0;
<a name="l02189"></a>02189       p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a> = 0;
<a name="l02190"></a>02190       <span class="keywordflow">return</span>;
<a name="l02191"></a>02191     }
<a name="l02192"></a>02192   }
<a name="l02193"></a>02193   i = p-&gt;<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>++;
<a name="l02194"></a>02194   pMatch = &amp;p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>[i];
<a name="l02195"></a>02195   pMatch-&gt;<a class="code" href="structSnippet_1_1snippetMatch.html#aaf3b1781a511ec1a2e459d49ff805538">iCol</a> = iCol;
<a name="l02196"></a>02196   pMatch-&gt;iTerm = iTerm;
<a name="l02197"></a>02197   pMatch-&gt;iStart = iStart;
<a name="l02198"></a>02198   pMatch-&gt;nByte = nByte;
<a name="l02199"></a>02199 }
<a name="l02200"></a>02200 
<a name="l02201"></a>02201 <span class="comment">/*</span>
<a name="l02202"></a>02202 <span class="comment">** Sizing information for the circular buffer used in snippetOffsetsOfColumn()</span>
<a name="l02203"></a>02203 <span class="comment">*/</span>
<a name="l02204"></a><a class="code" href="fts1_8c.html#a66211590a3b35555f2f64621f5bb8c09">02204</a> <span class="preprocessor">#define FTS1_ROTOR_SZ   (32)</span>
<a name="l02205"></a><a class="code" href="fts1_8c.html#af469fbdd407ad3216f8ca4f0f487a8c2">02205</a> <span class="preprocessor"></span><span class="preprocessor">#define FTS1_ROTOR_MASK (FTS1_ROTOR_SZ-1)</span>
<a name="l02206"></a>02206 <span class="preprocessor"></span>
<a name="l02207"></a>02207 <span class="comment">/*</span>
<a name="l02208"></a>02208 <span class="comment">** Add entries to pSnippet-&gt;aMatch[] for every match that occurs against</span>
<a name="l02209"></a>02209 <span class="comment">** document zDoc[0..nDoc-1] which is stored in column iColumn.</span>
<a name="l02210"></a>02210 <span class="comment">*/</span>
<a name="l02211"></a><a class="code" href="fts1_8c.html#af987482c53c99bf0c1222b650f7ad533">02211</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#af987482c53c99bf0c1222b650f7ad533">snippetOffsetsOfColumn</a>(
<a name="l02212"></a>02212   <a class="code" href="structQuery.html">Query</a> *pQuery,
<a name="l02213"></a>02213   <a class="code" href="structSnippet.html">Snippet</a> *pSnippet,
<a name="l02214"></a>02214   <span class="keywordtype">int</span> iColumn,
<a name="l02215"></a>02215   <span class="keyword">const</span> <span class="keywordtype">char</span> *zDoc,
<a name="l02216"></a>02216   <span class="keywordtype">int</span> nDoc
<a name="l02217"></a>02217 ){
<a name="l02218"></a>02218   <span class="keyword">const</span> <a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *pTModule;  <span class="comment">/* The tokenizer module */</span>
<a name="l02219"></a>02219   <a class="code" href="structsqlite3__tokenizer.html">sqlite3_tokenizer</a> *pTokenizer;             <span class="comment">/* The specific tokenizer */</span>
<a name="l02220"></a>02220   <a class="code" href="structsqlite3__tokenizer__cursor.html">sqlite3_tokenizer_cursor</a> *pTCursor;        <span class="comment">/* Tokenizer cursor */</span>
<a name="l02221"></a>02221   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *pVtab;                <span class="comment">/* The full text index */</span>
<a name="l02222"></a>02222   <span class="keywordtype">int</span> nColumn;                         <span class="comment">/* Number of columns in the index */</span>
<a name="l02223"></a>02223   <span class="keyword">const</span> <a class="code" href="structQueryTerm.html">QueryTerm</a> *aTerm;              <span class="comment">/* Query string terms */</span>
<a name="l02224"></a>02224   <span class="keywordtype">int</span> nTerm;                           <span class="comment">/* Number of query string terms */</span>  
<a name="l02225"></a>02225   <span class="keywordtype">int</span> i, j;                            <span class="comment">/* Loop counters */</span>
<a name="l02226"></a>02226   <span class="keywordtype">int</span> rc;                              <span class="comment">/* Return code */</span>
<a name="l02227"></a>02227   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="lstrlib_8c.html#a52a45835b75e5d31ec66421456bbb728">match</a>, prevMatch;       <span class="comment">/* Phrase search bitmasks */</span>
<a name="l02228"></a>02228   <span class="keyword">const</span> <span class="keywordtype">char</span> *zToken;                  <span class="comment">/* Next token from the tokenizer */</span>
<a name="l02229"></a>02229   <span class="keywordtype">int</span> nToken;                          <span class="comment">/* Size of zToken */</span>
<a name="l02230"></a>02230   <span class="keywordtype">int</span> iBegin, iEnd, iPos;              <span class="comment">/* Offsets of beginning and end */</span>
<a name="l02231"></a>02231 
<a name="l02232"></a>02232   <span class="comment">/* The following variables keep a circular buffer of the last</span>
<a name="l02233"></a>02233 <span class="comment">  ** few tokens */</span>
<a name="l02234"></a>02234   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iRotor = 0;             <span class="comment">/* Index of current token */</span>
<a name="l02235"></a>02235   <span class="keywordtype">int</span> iRotorBegin[<a class="code" href="fts1_8c.html#a66211590a3b35555f2f64621f5bb8c09">FTS1_ROTOR_SZ</a>];      <span class="comment">/* Beginning offset of token */</span>
<a name="l02236"></a>02236   <span class="keywordtype">int</span> iRotorLen[<a class="code" href="fts1_8c.html#a66211590a3b35555f2f64621f5bb8c09">FTS1_ROTOR_SZ</a>];        <span class="comment">/* Length of token */</span>
<a name="l02237"></a>02237 
<a name="l02238"></a>02238   pVtab = pQuery-&gt;<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a>;
<a name="l02239"></a>02239   nColumn = pVtab-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>;
<a name="l02240"></a>02240   pTokenizer = pVtab-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>;
<a name="l02241"></a>02241   pTModule = pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>;
<a name="l02242"></a>02242   rc = pTModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a44ab0f8ad43cd5900d5ab59f899f6acd">xOpen</a>(pTokenizer, zDoc, nDoc, &amp;pTCursor);
<a name="l02243"></a>02243   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span>;
<a name="l02244"></a>02244   pTCursor-&gt;<a class="code" href="structsqlite3__tokenizer__cursor.html#aa0ec54f843cb47b54daa4e8c8c6013c0">pTokenizer</a> = pTokenizer;
<a name="l02245"></a>02245   aTerm = pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>;
<a name="l02246"></a>02246   nTerm = pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;
<a name="l02247"></a>02247   <span class="keywordflow">if</span>( nTerm&gt;=<a class="code" href="fts1_8c.html#a66211590a3b35555f2f64621f5bb8c09">FTS1_ROTOR_SZ</a> ){
<a name="l02248"></a>02248     nTerm = <a class="code" href="fts1_8c.html#a66211590a3b35555f2f64621f5bb8c09">FTS1_ROTOR_SZ</a> - 1;
<a name="l02249"></a>02249   }
<a name="l02250"></a>02250   prevMatch = 0;
<a name="l02251"></a>02251   <span class="keywordflow">while</span>(1){
<a name="l02252"></a>02252     rc = pTModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a13443eb8fac89e3031f601a38564e2cc">xNext</a>(pTCursor, &amp;zToken, &amp;nToken, &amp;iBegin, &amp;iEnd, &amp;iPos);
<a name="l02253"></a>02253     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">break</span>;
<a name="l02254"></a>02254     iRotorBegin[iRotor&amp;<a class="code" href="fts1_8c.html#af469fbdd407ad3216f8ca4f0f487a8c2">FTS1_ROTOR_MASK</a>] = iBegin;
<a name="l02255"></a>02255     iRotorLen[iRotor&amp;<a class="code" href="fts1_8c.html#af469fbdd407ad3216f8ca4f0f487a8c2">FTS1_ROTOR_MASK</a>] = iEnd-iBegin;
<a name="l02256"></a>02256     match = 0;
<a name="l02257"></a>02257     <span class="keywordflow">for</span>(i=0; i&lt;nTerm; i++){
<a name="l02258"></a>02258       <span class="keywordtype">int</span> iCol;
<a name="l02259"></a>02259       iCol = aTerm[i].<a class="code" href="structQueryTerm.html#a71a4c3b5b3246a6e2e7347d0d71edf2c">iColumn</a>;
<a name="l02260"></a>02260       <span class="keywordflow">if</span>( iCol&gt;=0 &amp;&amp; iCol&lt;nColumn &amp;&amp; iCol!=iColumn ) <span class="keywordflow">continue</span>;
<a name="l02261"></a>02261       <span class="keywordflow">if</span>( aTerm[i].nTerm!=nToken ) <span class="keywordflow">continue</span>;
<a name="l02262"></a>02262       <span class="keywordflow">if</span>( memcmp(aTerm[i].pTerm, zToken, nToken) ) <span class="keywordflow">continue</span>;
<a name="l02263"></a>02263       <span class="keywordflow">if</span>( aTerm[i].iPhrase&gt;1 &amp;&amp; (prevMatch &amp; (1&lt;&lt;i))==0 ) <span class="keywordflow">continue</span>;
<a name="l02264"></a>02264       match |= 1&lt;&lt;i;
<a name="l02265"></a>02265       <span class="keywordflow">if</span>( i==nTerm-1 || aTerm[i+1].iPhrase==1 ){
<a name="l02266"></a>02266         <span class="keywordflow">for</span>(j=aTerm[i].iPhrase-1; j&gt;=0; j--){
<a name="l02267"></a>02267           <span class="keywordtype">int</span> k = (iRotor-j) &amp; <a class="code" href="fts1_8c.html#af469fbdd407ad3216f8ca4f0f487a8c2">FTS1_ROTOR_MASK</a>;
<a name="l02268"></a>02268           <a class="code" href="fts1_8c.html#a656691e1d431166d866f0ce903aa7dd0">snippetAppendMatch</a>(pSnippet, iColumn, i-j,
<a name="l02269"></a>02269                 iRotorBegin[k], iRotorLen[k]);
<a name="l02270"></a>02270         }
<a name="l02271"></a>02271       }
<a name="l02272"></a>02272     }
<a name="l02273"></a>02273     prevMatch = match&lt;&lt;1;
<a name="l02274"></a>02274     iRotor++;
<a name="l02275"></a>02275   }
<a name="l02276"></a>02276   pTModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#ad8bb92424245a38583cbaf36b509efd6">xClose</a>(pTCursor);  
<a name="l02277"></a>02277 }
<a name="l02278"></a>02278 
<a name="l02279"></a>02279 
<a name="l02280"></a>02280 <span class="comment">/*</span>
<a name="l02281"></a>02281 <span class="comment">** Compute all offsets for the current row of the query.  </span>
<a name="l02282"></a>02282 <span class="comment">** If the offsets have already been computed, this routine is a no-op.</span>
<a name="l02283"></a>02283 <span class="comment">*/</span>
<a name="l02284"></a><a class="code" href="fts1_8c.html#a59f88d7e78ca82c2ded0ad6d0dc761cf">02284</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a59f88d7e78ca82c2ded0ad6d0dc761cf">snippetAllOffsets</a>(<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *p){
<a name="l02285"></a>02285   <span class="keywordtype">int</span> nColumn;
<a name="l02286"></a>02286   <span class="keywordtype">int</span> iColumn, i;
<a name="l02287"></a>02287   <span class="keywordtype">int</span> iFirst, iLast;
<a name="l02288"></a>02288   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *pFts;
<a name="l02289"></a>02289 
<a name="l02290"></a>02290   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a> ) <span class="keywordflow">return</span>;
<a name="l02291"></a>02291   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>.<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>==0 ) <span class="keywordflow">return</span>;
<a name="l02292"></a>02292   pFts = p-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>.<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a>;
<a name="l02293"></a>02293   nColumn = pFts-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>;
<a name="l02294"></a>02294   iColumn = p-&gt;<a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a> - <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a>;
<a name="l02295"></a>02295   <span class="keywordflow">if</span>( iColumn&lt;0 || iColumn&gt;=nColumn ){
<a name="l02296"></a>02296     iFirst = 0;
<a name="l02297"></a>02297     iLast = nColumn-1;
<a name="l02298"></a>02298   }<span class="keywordflow">else</span>{
<a name="l02299"></a>02299     iFirst = iColumn;
<a name="l02300"></a>02300     iLast = iColumn;
<a name="l02301"></a>02301   }
<a name="l02302"></a>02302   <span class="keywordflow">for</span>(i=iFirst; i&lt;=iLast; i++){
<a name="l02303"></a>02303     <span class="keyword">const</span> <span class="keywordtype">char</span> *zDoc;
<a name="l02304"></a>02304     <span class="keywordtype">int</span> nDoc;
<a name="l02305"></a>02305     zDoc = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#adebe4cf494727dd2e9c0d22c2a629d2f">sqlite3_column_text</a>(p-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, i+1);
<a name="l02306"></a>02306     nDoc = <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(p-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, i+1);
<a name="l02307"></a>02307     <a class="code" href="fts1_8c.html#af987482c53c99bf0c1222b650f7ad533">snippetOffsetsOfColumn</a>(&amp;p-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>, &amp;p-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>, i, zDoc, nDoc);
<a name="l02308"></a>02308   }
<a name="l02309"></a>02309 }
<a name="l02310"></a>02310 
<a name="l02311"></a>02311 <span class="comment">/*</span>
<a name="l02312"></a>02312 <span class="comment">** Convert the information in the aMatch[] array of the snippet</span>
<a name="l02313"></a>02313 <span class="comment">** into the string zOffset[0..nOffset-1].</span>
<a name="l02314"></a>02314 <span class="comment">*/</span>
<a name="l02315"></a><a class="code" href="fts1_8c.html#a0be87d3def9290916cff3b6cb84f04bc">02315</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a0be87d3def9290916cff3b6cb84f04bc">snippetOffsetText</a>(<a class="code" href="structSnippet.html">Snippet</a> *p){
<a name="l02316"></a>02316   <span class="keywordtype">int</span> i;
<a name="l02317"></a>02317   <span class="keywordtype">int</span> cnt = 0;
<a name="l02318"></a>02318   <a class="code" href="structStringBuffer.html">StringBuffer</a> sb;
<a name="l02319"></a>02319   <span class="keywordtype">char</span> zBuf[200];
<a name="l02320"></a>02320   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a> ) <span class="keywordflow">return</span>;
<a name="l02321"></a>02321   <a class="code" href="fts1_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;sb);
<a name="l02322"></a>02322   <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>; i++){
<a name="l02323"></a>02323     <span class="keyword">struct </span>snippetMatch *pMatch = &amp;p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>[i];
<a name="l02324"></a>02324     zBuf[0] = <span class="charliteral">&apos; &apos;</span>;
<a name="l02325"></a>02325     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zBuf)-1, &amp;zBuf[cnt&gt;0], <span class="stringliteral">&quot;%d %d %d %d&quot;</span>,
<a name="l02326"></a>02326         pMatch-&gt;iCol, pMatch-&gt;iTerm, pMatch-&gt;iStart, pMatch-&gt;nByte);
<a name="l02327"></a>02327     <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zBuf);
<a name="l02328"></a>02328     cnt++;
<a name="l02329"></a>02329   }
<a name="l02330"></a>02330   p-&gt;<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a> = sb.<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>;
<a name="l02331"></a>02331   p-&gt;<a class="code" href="structSnippet.html#a68aacd704960f6ab1c8f7de23a5d0730">nOffset</a> = sb.<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>;
<a name="l02332"></a>02332 }
<a name="l02333"></a>02333 
<a name="l02334"></a>02334 <span class="comment">/*</span>
<a name="l02335"></a>02335 <span class="comment">** zDoc[0..nDoc-1] is phrase of text.  aMatch[0..nMatch-1] are a set</span>
<a name="l02336"></a>02336 <span class="comment">** of matching words some of which might be in zDoc.  zDoc is column</span>
<a name="l02337"></a>02337 <span class="comment">** number iCol.</span>
<a name="l02338"></a>02338 <span class="comment">**</span>
<a name="l02339"></a>02339 <span class="comment">** iBreak is suggested spot in zDoc where we could begin or end an</span>
<a name="l02340"></a>02340 <span class="comment">** excerpt.  Return a value similar to iBreak but possibly adjusted</span>
<a name="l02341"></a>02341 <span class="comment">** to be a little left or right so that the break point is better.</span>
<a name="l02342"></a>02342 <span class="comment">*/</span>
<a name="l02343"></a><a class="code" href="fts1_8c.html#adf761f2ec01d20bb458fa8f2f04b2246">02343</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#adf761f2ec01d20bb458fa8f2f04b2246">wordBoundary</a>(
<a name="l02344"></a>02344   <span class="keywordtype">int</span> iBreak,                   <span class="comment">/* The suggested break point */</span>
<a name="l02345"></a>02345   <span class="keyword">const</span> <span class="keywordtype">char</span> *zDoc,             <span class="comment">/* Document text */</span>
<a name="l02346"></a>02346   <span class="keywordtype">int</span> nDoc,                     <span class="comment">/* Number of bytes in zDoc[] */</span>
<a name="l02347"></a>02347   <span class="keyword">struct</span> snippetMatch *aMatch,  <span class="comment">/* Matching words */</span>
<a name="l02348"></a>02348   <span class="keywordtype">int</span> nMatch,                   <span class="comment">/* Number of entries in aMatch[] */</span>
<a name="l02349"></a>02349   <span class="keywordtype">int</span> iCol                      <span class="comment">/* The column number for zDoc[] */</span>
<a name="l02350"></a>02350 ){
<a name="l02351"></a>02351   <span class="keywordtype">int</span> i;
<a name="l02352"></a>02352   <span class="keywordflow">if</span>( iBreak&lt;=10 ){
<a name="l02353"></a>02353     <span class="keywordflow">return</span> 0;
<a name="l02354"></a>02354   }
<a name="l02355"></a>02355   <span class="keywordflow">if</span>( iBreak&gt;=nDoc-10 ){
<a name="l02356"></a>02356     <span class="keywordflow">return</span> nDoc;
<a name="l02357"></a>02357   }
<a name="l02358"></a>02358   <span class="keywordflow">for</span>(i=0; i&lt;nMatch &amp;&amp; aMatch[i].iCol&lt;iCol; i++){}
<a name="l02359"></a>02359   <span class="keywordflow">while</span>( i&lt;nMatch &amp;&amp; aMatch[i].iStart+aMatch[i].nByte&lt;iBreak ){ i++; }
<a name="l02360"></a>02360   <span class="keywordflow">if</span>( i&lt;nMatch ){
<a name="l02361"></a>02361     <span class="keywordflow">if</span>( aMatch[i].iStart&lt;iBreak+10 ){
<a name="l02362"></a>02362       <span class="keywordflow">return</span> aMatch[i].iStart;
<a name="l02363"></a>02363     }
<a name="l02364"></a>02364     <span class="keywordflow">if</span>( i&gt;0 &amp;&amp; aMatch[i-1].iStart+aMatch[i-1].nByte&gt;=iBreak ){
<a name="l02365"></a>02365       <span class="keywordflow">return</span> aMatch[i-1].iStart;
<a name="l02366"></a>02366     }
<a name="l02367"></a>02367   }
<a name="l02368"></a>02368   <span class="keywordflow">for</span>(i=1; i&lt;=10; i++){
<a name="l02369"></a>02369     <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(zDoc[iBreak-i]) ){
<a name="l02370"></a>02370       <span class="keywordflow">return</span> iBreak - i + 1;
<a name="l02371"></a>02371     }
<a name="l02372"></a>02372     <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(zDoc[iBreak+i]) ){
<a name="l02373"></a>02373       <span class="keywordflow">return</span> iBreak + i + 1;
<a name="l02374"></a>02374     }
<a name="l02375"></a>02375   }
<a name="l02376"></a>02376   <span class="keywordflow">return</span> iBreak;
<a name="l02377"></a>02377 }
<a name="l02378"></a>02378 
<a name="l02379"></a>02379 <span class="comment">/*</span>
<a name="l02380"></a>02380 <span class="comment">** If the StringBuffer does not end in white space, add a single</span>
<a name="l02381"></a>02381 <span class="comment">** space character to the end.</span>
<a name="l02382"></a>02382 <span class="comment">*/</span>
<a name="l02383"></a><a class="code" href="fts1_8c.html#ad5cddce8600a160495ae0fa2f778fde4">02383</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#ad5cddce8600a160495ae0fa2f778fde4">appendWhiteSpace</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *p){
<a name="l02384"></a>02384   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>==0 ) <span class="keywordflow">return</span>;
<a name="l02385"></a>02385   <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(p-&gt;<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>[p-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>-1]) ) <span class="keywordflow">return</span>;
<a name="l02386"></a>02386   <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(p, <span class="stringliteral">&quot; &quot;</span>);
<a name="l02387"></a>02387 }
<a name="l02388"></a>02388 
<a name="l02389"></a>02389 <span class="comment">/*</span>
<a name="l02390"></a>02390 <span class="comment">** Remove white space from teh end of the StringBuffer</span>
<a name="l02391"></a>02391 <span class="comment">*/</span>
<a name="l02392"></a><a class="code" href="fts1_8c.html#a5afad57e102ddaa7772992b7a69bc6a6">02392</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a5afad57e102ddaa7772992b7a69bc6a6">trimWhiteSpace</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *p){
<a name="l02393"></a>02393   <span class="keywordflow">while</span>( p-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>&gt;0 &amp;&amp; <a class="code" href="fts1_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(p-&gt;<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>[p-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>-1]) ){
<a name="l02394"></a>02394     p-&gt;<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>--;
<a name="l02395"></a>02395   }
<a name="l02396"></a>02396 }
<a name="l02397"></a>02397 
<a name="l02398"></a>02398 
<a name="l02399"></a>02399 
<a name="l02400"></a>02400 <span class="comment">/*</span>
<a name="l02401"></a>02401 <span class="comment">** Allowed values for Snippet.aMatch[].snStatus</span>
<a name="l02402"></a>02402 <span class="comment">*/</span>
<a name="l02403"></a><a class="code" href="fts1_8c.html#af1ddee38ad072b0e25eded90ed70b4ff">02403</a> <span class="preprocessor">#define SNIPPET_IGNORE  0   </span><span class="comment">/* It is ok to omit this match from the snippet */</span>
<a name="l02404"></a><a class="code" href="fts1_8c.html#a102500074009acfa3810201ce27c0e15">02404</a> <span class="preprocessor">#define SNIPPET_DESIRED 1   </span><span class="comment">/* We want to include this match in the snippet */</span>
<a name="l02405"></a>02405 
<a name="l02406"></a>02406 <span class="comment">/*</span>
<a name="l02407"></a>02407 <span class="comment">** Generate the text of a snippet.</span>
<a name="l02408"></a>02408 <span class="comment">*/</span>
<a name="l02409"></a><a class="code" href="fts1_8c.html#a27d12dfb6aab92e44fc0af3dc2a72ad7">02409</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a27d12dfb6aab92e44fc0af3dc2a72ad7">snippetText</a>(
<a name="l02410"></a>02410   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *pCursor,   <span class="comment">/* The cursor we need the snippet for */</span>
<a name="l02411"></a>02411   <span class="keyword">const</span> <span class="keywordtype">char</span> *zStartMark,     <span class="comment">/* Markup to appear before each match */</span>
<a name="l02412"></a>02412   <span class="keyword">const</span> <span class="keywordtype">char</span> *zEndMark,       <span class="comment">/* Markup to appear after each match */</span>
<a name="l02413"></a>02413   <span class="keyword">const</span> <span class="keywordtype">char</span> *zEllipsis       <span class="comment">/* Ellipsis mark */</span>
<a name="l02414"></a>02414 ){
<a name="l02415"></a>02415   <span class="keywordtype">int</span> i, j;
<a name="l02416"></a>02416   <span class="keyword">struct </span>snippetMatch *aMatch;
<a name="l02417"></a>02417   <span class="keywordtype">int</span> nMatch;
<a name="l02418"></a>02418   <span class="keywordtype">int</span> nDesired;
<a name="l02419"></a>02419   <a class="code" href="structStringBuffer.html">StringBuffer</a> sb;
<a name="l02420"></a>02420   <span class="keywordtype">int</span> tailCol;
<a name="l02421"></a>02421   <span class="keywordtype">int</span> tailOffset;
<a name="l02422"></a>02422   <span class="keywordtype">int</span> iCol;
<a name="l02423"></a>02423   <span class="keywordtype">int</span> nDoc;
<a name="l02424"></a>02424   <span class="keyword">const</span> <span class="keywordtype">char</span> *zDoc;
<a name="l02425"></a>02425   <span class="keywordtype">int</span> iStart, iEnd;
<a name="l02426"></a>02426   <span class="keywordtype">int</span> tailEllipsis = 0;
<a name="l02427"></a>02427   <span class="keywordtype">int</span> iMatch;
<a name="l02428"></a>02428   
<a name="l02429"></a>02429 
<a name="l02430"></a>02430   free(pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a>);
<a name="l02431"></a>02431   pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a> = 0;
<a name="l02432"></a>02432   aMatch = pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>;
<a name="l02433"></a>02433   nMatch = pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>;
<a name="l02434"></a>02434   <a class="code" href="fts1_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;sb);
<a name="l02435"></a>02435 
<a name="l02436"></a>02436   <span class="keywordflow">for</span>(i=0; i&lt;nMatch; i++){
<a name="l02437"></a>02437     aMatch[i].snStatus = <a class="code" href="fts1_8c.html#af1ddee38ad072b0e25eded90ed70b4ff">SNIPPET_IGNORE</a>;
<a name="l02438"></a>02438   }
<a name="l02439"></a>02439   nDesired = 0;
<a name="l02440"></a>02440   <span class="keywordflow">for</span>(i=0; i&lt;pCursor-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>.<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>; i++){
<a name="l02441"></a>02441     <span class="keywordflow">for</span>(j=0; j&lt;nMatch; j++){
<a name="l02442"></a>02442       <span class="keywordflow">if</span>( aMatch[j].iTerm==i ){
<a name="l02443"></a>02443         aMatch[j].snStatus = <a class="code" href="fts1_8c.html#a102500074009acfa3810201ce27c0e15">SNIPPET_DESIRED</a>;
<a name="l02444"></a>02444         nDesired++;
<a name="l02445"></a>02445         <span class="keywordflow">break</span>;
<a name="l02446"></a>02446       }
<a name="l02447"></a>02447     }
<a name="l02448"></a>02448   }
<a name="l02449"></a>02449 
<a name="l02450"></a>02450   iMatch = 0;
<a name="l02451"></a>02451   tailCol = -1;
<a name="l02452"></a>02452   tailOffset = 0;
<a name="l02453"></a>02453   <span class="keywordflow">for</span>(i=0; i&lt;nMatch &amp;&amp; nDesired&gt;0; i++){
<a name="l02454"></a>02454     <span class="keywordflow">if</span>( aMatch[i].snStatus!=<a class="code" href="fts1_8c.html#a102500074009acfa3810201ce27c0e15">SNIPPET_DESIRED</a> ) <span class="keywordflow">continue</span>;
<a name="l02455"></a>02455     nDesired--;
<a name="l02456"></a>02456     iCol = aMatch[i].iCol;
<a name="l02457"></a>02457     zDoc = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#adebe4cf494727dd2e9c0d22c2a629d2f">sqlite3_column_text</a>(pCursor-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, iCol+1);
<a name="l02458"></a>02458     nDoc = <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(pCursor-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, iCol+1);
<a name="l02459"></a>02459     iStart = aMatch[i].iStart - 40;
<a name="l02460"></a>02460     iStart = <a class="code" href="fts1_8c.html#adf761f2ec01d20bb458fa8f2f04b2246">wordBoundary</a>(iStart, zDoc, nDoc, aMatch, nMatch, iCol);
<a name="l02461"></a>02461     <span class="keywordflow">if</span>( iStart&lt;=10 ){
<a name="l02462"></a>02462       iStart = 0;
<a name="l02463"></a>02463     }
<a name="l02464"></a>02464     <span class="keywordflow">if</span>( iCol==tailCol &amp;&amp; iStart&lt;=tailOffset+20 ){
<a name="l02465"></a>02465       iStart = tailOffset;
<a name="l02466"></a>02466     }
<a name="l02467"></a>02467     <span class="keywordflow">if</span>( (iCol!=tailCol &amp;&amp; tailCol&gt;=0) || iStart!=tailOffset ){
<a name="l02468"></a>02468       <a class="code" href="fts1_8c.html#a5afad57e102ddaa7772992b7a69bc6a6">trimWhiteSpace</a>(&amp;sb);
<a name="l02469"></a>02469       <a class="code" href="fts1_8c.html#ad5cddce8600a160495ae0fa2f778fde4">appendWhiteSpace</a>(&amp;sb);
<a name="l02470"></a>02470       <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zEllipsis);
<a name="l02471"></a>02471       <a class="code" href="fts1_8c.html#ad5cddce8600a160495ae0fa2f778fde4">appendWhiteSpace</a>(&amp;sb);
<a name="l02472"></a>02472     }
<a name="l02473"></a>02473     iEnd = aMatch[i].iStart + aMatch[i].nByte + 40;
<a name="l02474"></a>02474     iEnd = <a class="code" href="fts1_8c.html#adf761f2ec01d20bb458fa8f2f04b2246">wordBoundary</a>(iEnd, zDoc, nDoc, aMatch, nMatch, iCol);
<a name="l02475"></a>02475     <span class="keywordflow">if</span>( iEnd&gt;=nDoc-10 ){
<a name="l02476"></a>02476       iEnd = nDoc;
<a name="l02477"></a>02477       tailEllipsis = 0;
<a name="l02478"></a>02478     }<span class="keywordflow">else</span>{
<a name="l02479"></a>02479       tailEllipsis = 1;
<a name="l02480"></a>02480     }
<a name="l02481"></a>02481     <span class="keywordflow">while</span>( iMatch&lt;nMatch &amp;&amp; aMatch[iMatch].iCol&lt;iCol ){ iMatch++; }
<a name="l02482"></a>02482     <span class="keywordflow">while</span>( iStart&lt;iEnd ){
<a name="l02483"></a>02483       <span class="keywordflow">while</span>( iMatch&lt;nMatch &amp;&amp; aMatch[iMatch].iStart&lt;iStart
<a name="l02484"></a>02484              &amp;&amp; aMatch[iMatch].iCol&lt;=iCol ){
<a name="l02485"></a>02485         iMatch++;
<a name="l02486"></a>02486       }
<a name="l02487"></a>02487       <span class="keywordflow">if</span>( iMatch&lt;nMatch &amp;&amp; aMatch[iMatch].iStart&lt;iEnd
<a name="l02488"></a>02488              &amp;&amp; aMatch[iMatch].iCol==iCol ){
<a name="l02489"></a>02489         <a class="code" href="fts1_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(&amp;sb, &amp;zDoc[iStart], aMatch[iMatch].iStart - iStart);
<a name="l02490"></a>02490         iStart = aMatch[iMatch].iStart;
<a name="l02491"></a>02491         <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zStartMark);
<a name="l02492"></a>02492         <a class="code" href="fts1_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(&amp;sb, &amp;zDoc[iStart], aMatch[iMatch].nByte);
<a name="l02493"></a>02493         <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zEndMark);
<a name="l02494"></a>02494         iStart += aMatch[iMatch].nByte;
<a name="l02495"></a>02495         <span class="keywordflow">for</span>(j=iMatch+1; j&lt;nMatch; j++){
<a name="l02496"></a>02496           <span class="keywordflow">if</span>( aMatch[j].iTerm==aMatch[iMatch].iTerm
<a name="l02497"></a>02497               &amp;&amp; aMatch[j].snStatus==<a class="code" href="fts1_8c.html#a102500074009acfa3810201ce27c0e15">SNIPPET_DESIRED</a> ){
<a name="l02498"></a>02498             nDesired--;
<a name="l02499"></a>02499             aMatch[j].snStatus = <a class="code" href="fts1_8c.html#af1ddee38ad072b0e25eded90ed70b4ff">SNIPPET_IGNORE</a>;
<a name="l02500"></a>02500           }
<a name="l02501"></a>02501         }
<a name="l02502"></a>02502       }<span class="keywordflow">else</span>{
<a name="l02503"></a>02503         <a class="code" href="fts1_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(&amp;sb, &amp;zDoc[iStart], iEnd - iStart);
<a name="l02504"></a>02504         iStart = iEnd;
<a name="l02505"></a>02505       }
<a name="l02506"></a>02506     }
<a name="l02507"></a>02507     tailCol = iCol;
<a name="l02508"></a>02508     tailOffset = iEnd;
<a name="l02509"></a>02509   }
<a name="l02510"></a>02510   <a class="code" href="fts1_8c.html#a5afad57e102ddaa7772992b7a69bc6a6">trimWhiteSpace</a>(&amp;sb);
<a name="l02511"></a>02511   <span class="keywordflow">if</span>( tailEllipsis ){
<a name="l02512"></a>02512     <a class="code" href="fts1_8c.html#ad5cddce8600a160495ae0fa2f778fde4">appendWhiteSpace</a>(&amp;sb);
<a name="l02513"></a>02513     <a class="code" href="fts1_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zEllipsis);
<a name="l02514"></a>02514   }
<a name="l02515"></a>02515   pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a> = sb.<a class="code" href="structStringBuffer.html#a2575b45f08d9c35b156be1e6b9fa0dc5">s</a>;
<a name="l02516"></a>02516   pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a467392bb026bc056ab7c5466873f8f11">nSnippet</a> = sb.<a class="code" href="structStringBuffer.html#aa5a1de09aac538be7b8c77b20c2d13c9">len</a>;  
<a name="l02517"></a>02517 }
<a name="l02518"></a>02518 
<a name="l02519"></a>02519 
<a name="l02520"></a>02520 <span class="comment">/*</span>
<a name="l02521"></a>02521 <span class="comment">** Close the cursor.  For additional information see the documentation</span>
<a name="l02522"></a>02522 <span class="comment">** on the xClose method of the virtual table interface.</span>
<a name="l02523"></a>02523 <span class="comment">*/</span>
<a name="l02524"></a><a class="code" href="fts1_8c.html#ae78b3ae93fcfb9b8b2e8b4dc9a380ad7">02524</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ae78b3ae93fcfb9b8b2e8b4dc9a380ad7">fulltextClose</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor){
<a name="l02525"></a>02525   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l02526"></a>02526   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Close %p\n&quot;</span>, c));
<a name="l02527"></a>02527   <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l02528"></a>02528   <a class="code" href="fts1_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>);
<a name="l02529"></a>02529   <a class="code" href="fts1_8c.html#ac4854671b9ca8b41ca0f7bd78f090eee">snippetClear</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>);
<a name="l02530"></a>02530   <span class="keywordflow">if</span>( c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>!=NULL ){
<a name="l02531"></a>02531     <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>);
<a name="l02532"></a>02532   }
<a name="l02533"></a>02533   free(c);
<a name="l02534"></a>02534   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02535"></a>02535 }
<a name="l02536"></a>02536 
<a name="l02537"></a><a class="code" href="fts1_8c.html#a27014ab01a3b771ad685bf0a66ae0f74">02537</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a27014ab01a3b771ad685bf0a66ae0f74">fulltextNext</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor){
<a name="l02538"></a>02538   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l02539"></a>02539   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid;
<a name="l02540"></a>02540   <span class="keywordtype">int</span> rc;
<a name="l02541"></a>02541 
<a name="l02542"></a>02542   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Next %p\n&quot;</span>, pCursor));
<a name="l02543"></a>02543   <a class="code" href="fts1_8c.html#ac4854671b9ca8b41ca0f7bd78f090eee">snippetClear</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>);
<a name="l02544"></a>02544   <span class="keywordflow">if</span>( c-&gt;<a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a> &lt; <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a> ){
<a name="l02545"></a>02545     <span class="comment">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</span>
<a name="l02546"></a>02546     rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l02547"></a>02547     <span class="keywordflow">switch</span>( rc ){
<a name="l02548"></a>02548       <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a>:
<a name="l02549"></a>02549         c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 0;
<a name="l02550"></a>02550         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02551"></a>02551       <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>:
<a name="l02552"></a>02552         c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 1;
<a name="l02553"></a>02553         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02554"></a>02554       <span class="keywordflow">default</span>:
<a name="l02555"></a>02555         c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 1;
<a name="l02556"></a>02556         <span class="keywordflow">return</span> rc;
<a name="l02557"></a>02557     }
<a name="l02558"></a>02558   } <span class="keywordflow">else</span> {  <span class="comment">/* full-text query */</span>
<a name="l02559"></a>02559     rc = <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l02560"></a>02560     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02561"></a>02561 
<a name="l02562"></a>02562     iDocid = <a class="code" href="fts1_8c.html#a9986bd64e7fa3f0c4f18340a7e3c9fc6">nextDocid</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>);
<a name="l02563"></a>02563     <span class="keywordflow">if</span>( iDocid==0 ){
<a name="l02564"></a>02564       c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 1;
<a name="l02565"></a>02565       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02566"></a>02566     }
<a name="l02567"></a>02567     rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, 1, iDocid);
<a name="l02568"></a>02568     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02569"></a>02569     <span class="comment">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</span>
<a name="l02570"></a>02570     rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l02571"></a>02571     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){   <span class="comment">/* the case we expect */</span>
<a name="l02572"></a>02572       c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 0;
<a name="l02573"></a>02573       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02574"></a>02574     }
<a name="l02575"></a>02575     <span class="comment">/* an error occurred; abort */</span>
<a name="l02576"></a>02576     <span class="keywordflow">return</span> rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ? <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a> : rc;
<a name="l02577"></a>02577   }
<a name="l02578"></a>02578 }
<a name="l02579"></a>02579 
<a name="l02580"></a>02580 
<a name="l02581"></a>02581 <span class="comment">/* Return a DocList corresponding to the query term *pTerm.  If *pTerm</span>
<a name="l02582"></a>02582 <span class="comment">** is the first term of a phrase query, go ahead and evaluate the phrase</span>
<a name="l02583"></a>02583 <span class="comment">** query and return the doclist for the entire phrase query.</span>
<a name="l02584"></a>02584 <span class="comment">**</span>
<a name="l02585"></a>02585 <span class="comment">** The result is stored in pTerm-&gt;doclist.</span>
<a name="l02586"></a>02586 <span class="comment">*/</span>
<a name="l02587"></a><a class="code" href="fts1_8c.html#ac94fa84a731e6ff057686bd0f33a066f">02587</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ac94fa84a731e6ff057686bd0f33a066f">docListOfTerm</a>(
<a name="l02588"></a>02588   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,     <span class="comment">/* The full text index */</span>
<a name="l02589"></a>02589   <span class="keywordtype">int</span> iColumn,          <span class="comment">/* column to restrict to.  No restrition if &gt;=nColumn */</span>
<a name="l02590"></a>02590   <a class="code" href="structQueryTerm.html">QueryTerm</a> *pQTerm,    <span class="comment">/* Term we are looking for, or 1st term of a phrase */</span>
<a name="l02591"></a>02591   <a class="code" href="structDocList.html">DocList</a> **ppResult    <span class="comment">/* Write the result here */</span>
<a name="l02592"></a>02592 ){
<a name="l02593"></a>02593   <a class="code" href="structDocList.html">DocList</a> *pLeft, *pRight, *pNew;
<a name="l02594"></a>02594   <span class="keywordtype">int</span> i, rc;
<a name="l02595"></a>02595 
<a name="l02596"></a>02596   pLeft = <a class="code" href="fts1_8c.html#a17dda48d7ada1bbe7a4cd214fcf00865">docListNew</a>(<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a>);
<a name="l02597"></a>02597   rc = <a class="code" href="fts1_8c.html#acc673d898d6cd6f15b994abb2d0a2ac9">term_select_all</a>(v, iColumn, pQTerm-&gt;<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>, pQTerm-&gt;<a class="code" href="structQueryTerm.html#aeeb3d5a5c0c62dc9d0966204c8cae819">nTerm</a>, pLeft);
<a name="l02598"></a>02598   <span class="keywordflow">if</span>( rc ){
<a name="l02599"></a>02599     <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pLeft);
<a name="l02600"></a>02600     <span class="keywordflow">return</span> rc;
<a name="l02601"></a>02601   }
<a name="l02602"></a>02602   <span class="keywordflow">for</span>(i=1; i&lt;=pQTerm-&gt;<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a>; i++){
<a name="l02603"></a>02603     pRight = <a class="code" href="fts1_8c.html#a17dda48d7ada1bbe7a4cd214fcf00865">docListNew</a>(<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a>);
<a name="l02604"></a>02604     rc = <a class="code" href="fts1_8c.html#acc673d898d6cd6f15b994abb2d0a2ac9">term_select_all</a>(v, iColumn, pQTerm[i].pTerm, pQTerm[i].nTerm, pRight);
<a name="l02605"></a>02605     <span class="keywordflow">if</span>( rc ){
<a name="l02606"></a>02606       <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pLeft);
<a name="l02607"></a>02607       <span class="keywordflow">return</span> rc;
<a name="l02608"></a>02608     }
<a name="l02609"></a>02609     pNew = <a class="code" href="fts1_8c.html#a17dda48d7ada1bbe7a4cd214fcf00865">docListNew</a>(i&lt;pQTerm-&gt;nPhrase ? <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> : <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>);
<a name="l02610"></a>02610     <a class="code" href="fts1_8c.html#a784500b205fb2c1a6f5964bb9d71123c">docListPhraseMerge</a>(pLeft, pRight, pNew);
<a name="l02611"></a>02611     <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pLeft);
<a name="l02612"></a>02612     <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pRight);
<a name="l02613"></a>02613     pLeft = pNew;
<a name="l02614"></a>02614   }
<a name="l02615"></a>02615   *ppResult = pLeft;
<a name="l02616"></a>02616   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02617"></a>02617 }
<a name="l02618"></a>02618 
<a name="l02619"></a>02619 <span class="comment">/* Add a new term pTerm[0..nTerm-1] to the query *q.</span>
<a name="l02620"></a>02620 <span class="comment">*/</span>
<a name="l02621"></a><a class="code" href="fts1_8c.html#a7ccacb0137b581bffc5942a4074f78d7">02621</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a7ccacb0137b581bffc5942a4074f78d7">queryAdd</a>(<a class="code" href="structQuery.html">Query</a> *q, <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm){
<a name="l02622"></a>02622   <a class="code" href="structQueryTerm.html">QueryTerm</a> *t;
<a name="l02623"></a>02623   ++q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;
<a name="l02624"></a>02624   q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a> = realloc(q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>, q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> * <span class="keyword">sizeof</span>(q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[0]));
<a name="l02625"></a>02625   <span class="keywordflow">if</span>( q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>==0 ){
<a name="l02626"></a>02626     q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> = 0;
<a name="l02627"></a>02627     <span class="keywordflow">return</span>;
<a name="l02628"></a>02628   }
<a name="l02629"></a>02629   t = &amp;q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> - 1];
<a name="l02630"></a>02630   memset(t, 0, <span class="keyword">sizeof</span>(*t));
<a name="l02631"></a>02631   t-&gt;<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a> = malloc(nTerm+1);
<a name="l02632"></a>02632   memcpy(t-&gt;<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>, pTerm, nTerm);
<a name="l02633"></a>02633   t-&gt;<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>[nTerm] = 0;
<a name="l02634"></a>02634   t-&gt;<a class="code" href="structQueryTerm.html#aeeb3d5a5c0c62dc9d0966204c8cae819">nTerm</a> = nTerm;
<a name="l02635"></a>02635   t-&gt;<a class="code" href="structQueryTerm.html#af7018292d462a2b11f4acd1dd440bf03">isOr</a> = q-&gt;<a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a>;
<a name="l02636"></a>02636   q-&gt;<a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a> = 0;
<a name="l02637"></a>02637   t-&gt;<a class="code" href="structQueryTerm.html#a71a4c3b5b3246a6e2e7347d0d71edf2c">iColumn</a> = q-&gt;<a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a>;
<a name="l02638"></a>02638   q-&gt;<a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a> = q-&gt;<a class="code" href="structQuery.html#af4b5b552a7646059a60c1eace4d2a020">dfltColumn</a>;
<a name="l02639"></a>02639 }
<a name="l02640"></a>02640 
<a name="l02641"></a>02641 <span class="comment">/*</span>
<a name="l02642"></a>02642 <span class="comment">** Check to see if the string zToken[0...nToken-1] matches any</span>
<a name="l02643"></a>02643 <span class="comment">** column name in the virtual table.   If it does,</span>
<a name="l02644"></a>02644 <span class="comment">** return the zero-indexed column number.  If not, return -1.</span>
<a name="l02645"></a>02645 <span class="comment">*/</span>
<a name="l02646"></a><a class="code" href="fts1_8c.html#ab010222acbfa0974c8b91832c5530dd5">02646</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ab010222acbfa0974c8b91832c5530dd5">checkColumnSpecifier</a>(
<a name="l02647"></a>02647   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *pVtab,    <span class="comment">/* The virtual table */</span>
<a name="l02648"></a>02648   <span class="keyword">const</span> <span class="keywordtype">char</span> *zToken,      <span class="comment">/* Text of the token */</span>
<a name="l02649"></a>02649   <span class="keywordtype">int</span> nToken               <span class="comment">/* Number of characters in the token */</span>
<a name="l02650"></a>02650 ){
<a name="l02651"></a>02651   <span class="keywordtype">int</span> i;
<a name="l02652"></a>02652   <span class="keywordflow">for</span>(i=0; i&lt;pVtab-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; i++){
<a name="l02653"></a>02653     <span class="keywordflow">if</span>( memcmp(pVtab-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>[i], zToken, nToken)==0
<a name="l02654"></a>02654         &amp;&amp; pVtab-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>[i][nToken]==0 ){
<a name="l02655"></a>02655       <span class="keywordflow">return</span> i;
<a name="l02656"></a>02656     }
<a name="l02657"></a>02657   }
<a name="l02658"></a>02658   <span class="keywordflow">return</span> -1;
<a name="l02659"></a>02659 }
<a name="l02660"></a>02660 
<a name="l02661"></a>02661 <span class="comment">/*</span>
<a name="l02662"></a>02662 <span class="comment">** Parse the text at pSegment[0..nSegment-1].  Add additional terms</span>
<a name="l02663"></a>02663 <span class="comment">** to the query being assemblied in pQuery.</span>
<a name="l02664"></a>02664 <span class="comment">**</span>
<a name="l02665"></a>02665 <span class="comment">** inPhrase is true if pSegment[0..nSegement-1] is contained within</span>
<a name="l02666"></a>02666 <span class="comment">** double-quotes.  If inPhrase is true, then the first term</span>
<a name="l02667"></a>02667 <span class="comment">** is marked with the number of terms in the phrase less one and</span>
<a name="l02668"></a>02668 <span class="comment">** OR and &quot;-&quot; syntax is ignored.  If inPhrase is false, then every</span>
<a name="l02669"></a>02669 <span class="comment">** term found is marked with nPhrase=0 and OR and &quot;-&quot; syntax is significant.</span>
<a name="l02670"></a>02670 <span class="comment">*/</span>
<a name="l02671"></a><a class="code" href="fts1_8c.html#a2b3fe867e6a4a792af87698942f40a4a">02671</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a2b3fe867e6a4a792af87698942f40a4a">tokenizeSegment</a>(
<a name="l02672"></a>02672   <a class="code" href="structsqlite3__tokenizer.html">sqlite3_tokenizer</a> *pTokenizer,          <span class="comment">/* The tokenizer to use */</span>
<a name="l02673"></a>02673   <span class="keyword">const</span> <span class="keywordtype">char</span> *pSegment, <span class="keywordtype">int</span> nSegment,     <span class="comment">/* Query expression being parsed */</span>
<a name="l02674"></a>02674   <span class="keywordtype">int</span> inPhrase,                           <span class="comment">/* True if within &quot;...&quot; */</span>
<a name="l02675"></a>02675   <a class="code" href="structQuery.html">Query</a> *pQuery                           <span class="comment">/* Append results here */</span>
<a name="l02676"></a>02676 ){
<a name="l02677"></a>02677   <span class="keyword">const</span> <a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *pModule = pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>;
<a name="l02678"></a>02678   <a class="code" href="structsqlite3__tokenizer__cursor.html">sqlite3_tokenizer_cursor</a> *pCursor;
<a name="l02679"></a>02679   <span class="keywordtype">int</span> firstIndex = pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;
<a name="l02680"></a>02680   <span class="keywordtype">int</span> iCol;
<a name="l02681"></a>02681   <span class="keywordtype">int</span> nTerm = 1;
<a name="l02682"></a>02682   
<a name="l02683"></a>02683   <span class="keywordtype">int</span> rc = pModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a44ab0f8ad43cd5900d5ab59f899f6acd">xOpen</a>(pTokenizer, pSegment, nSegment, &amp;pCursor);
<a name="l02684"></a>02684   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02685"></a>02685   pCursor-&gt;<a class="code" href="structsqlite3__tokenizer__cursor.html#aa0ec54f843cb47b54daa4e8c8c6013c0">pTokenizer</a> = pTokenizer;
<a name="l02686"></a>02686 
<a name="l02687"></a>02687   <span class="keywordflow">while</span>( 1 ){
<a name="l02688"></a>02688     <span class="keyword">const</span> <span class="keywordtype">char</span> *pToken;
<a name="l02689"></a>02689     <span class="keywordtype">int</span> nToken, iBegin, iEnd, iPos;
<a name="l02690"></a>02690 
<a name="l02691"></a>02691     rc = pModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a13443eb8fac89e3031f601a38564e2cc">xNext</a>(pCursor,
<a name="l02692"></a>02692                         &amp;pToken, &amp;nToken,
<a name="l02693"></a>02693                         &amp;iBegin, &amp;iEnd, &amp;iPos);
<a name="l02694"></a>02694     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">break</span>;
<a name="l02695"></a>02695     <span class="keywordflow">if</span>( !inPhrase &amp;&amp;
<a name="l02696"></a>02696         pSegment[iEnd]==<span class="charliteral">&apos;:&apos;</span> &amp;&amp;
<a name="l02697"></a>02697          (iCol = <a class="code" href="fts1_8c.html#ab010222acbfa0974c8b91832c5530dd5">checkColumnSpecifier</a>(pQuery-&gt;<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a>, pToken, nToken))&gt;=0 ){
<a name="l02698"></a>02698       pQuery-&gt;<a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a> = iCol;
<a name="l02699"></a>02699       <span class="keywordflow">continue</span>;
<a name="l02700"></a>02700     }
<a name="l02701"></a>02701     <span class="keywordflow">if</span>( !inPhrase &amp;&amp; pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>&gt;0 &amp;&amp; nToken==2
<a name="l02702"></a>02702          &amp;&amp; pSegment[iBegin]==<span class="charliteral">&apos;O&apos;</span> &amp;&amp; pSegment[iBegin+1]==<span class="charliteral">&apos;R&apos;</span> ){
<a name="l02703"></a>02703       pQuery-&gt;<a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a> = 1;
<a name="l02704"></a>02704       <span class="keywordflow">continue</span>;
<a name="l02705"></a>02705     }
<a name="l02706"></a>02706     <a class="code" href="fts1_8c.html#a7ccacb0137b581bffc5942a4074f78d7">queryAdd</a>(pQuery, pToken, nToken);
<a name="l02707"></a>02707     <span class="keywordflow">if</span>( !inPhrase &amp;&amp; iBegin&gt;0 &amp;&amp; pSegment[iBegin-1]==<span class="charliteral">&apos;-&apos;</span> ){
<a name="l02708"></a>02708       pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>-1].<a class="code" href="structQueryTerm.html#a173e6f424ffb75f22ac977b041511361">isNot</a> = 1;
<a name="l02709"></a>02709     }
<a name="l02710"></a>02710     pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>-1].<a class="code" href="structQueryTerm.html#abea35c7535689b4425baad079834a74c">iPhrase</a> = nTerm;
<a name="l02711"></a>02711     <span class="keywordflow">if</span>( inPhrase ){
<a name="l02712"></a>02712       nTerm++;
<a name="l02713"></a>02713     }
<a name="l02714"></a>02714   }
<a name="l02715"></a>02715 
<a name="l02716"></a>02716   <span class="keywordflow">if</span>( inPhrase &amp;&amp; pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>&gt;firstIndex ){
<a name="l02717"></a>02717     pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[firstIndex].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> = pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> - firstIndex - 1;
<a name="l02718"></a>02718   }
<a name="l02719"></a>02719 
<a name="l02720"></a>02720   <span class="keywordflow">return</span> pModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#ad8bb92424245a38583cbaf36b509efd6">xClose</a>(pCursor);
<a name="l02721"></a>02721 }
<a name="l02722"></a>02722 
<a name="l02723"></a>02723 <span class="comment">/* Parse a query string, yielding a Query object pQuery.</span>
<a name="l02724"></a>02724 <span class="comment">**</span>
<a name="l02725"></a>02725 <span class="comment">** The calling function will need to queryClear() to clean up</span>
<a name="l02726"></a>02726 <span class="comment">** the dynamically allocated memory held by pQuery.</span>
<a name="l02727"></a>02727 <span class="comment">*/</span>
<a name="l02728"></a><a class="code" href="fts1_8c.html#a28b0578ebe0882fe104d34ddf4d9208c">02728</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a28b0578ebe0882fe104d34ddf4d9208c">parseQuery</a>(
<a name="l02729"></a>02729   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,        <span class="comment">/* The fulltext index */</span>
<a name="l02730"></a>02730   <span class="keyword">const</span> <span class="keywordtype">char</span> *zInput,      <span class="comment">/* Input text of the query string */</span>
<a name="l02731"></a>02731   <span class="keywordtype">int</span> nInput,              <span class="comment">/* Size of the input text */</span>
<a name="l02732"></a>02732   <span class="keywordtype">int</span> dfltColumn,          <span class="comment">/* Default column of the index to match against */</span>
<a name="l02733"></a>02733   <a class="code" href="structQuery.html">Query</a> *pQuery            <span class="comment">/* Write the parse results here. */</span>
<a name="l02734"></a>02734 ){
<a name="l02735"></a>02735   <span class="keywordtype">int</span> iInput, inPhrase = 0;
<a name="l02736"></a>02736 
<a name="l02737"></a>02737   <span class="keywordflow">if</span>( zInput==0 ) nInput = 0;
<a name="l02738"></a>02738   <span class="keywordflow">if</span>( nInput&lt;0 ) nInput = strlen(zInput);
<a name="l02739"></a>02739   pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> = 0;
<a name="l02740"></a>02740   pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a> = NULL;
<a name="l02741"></a>02741   pQuery-&gt;<a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a> = 0;
<a name="l02742"></a>02742   pQuery-&gt;<a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a> = dfltColumn;
<a name="l02743"></a>02743   pQuery-&gt;<a class="code" href="structQuery.html#af4b5b552a7646059a60c1eace4d2a020">dfltColumn</a> = dfltColumn;
<a name="l02744"></a>02744   pQuery-&gt;<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a> = v;
<a name="l02745"></a>02745 
<a name="l02746"></a>02746   <span class="keywordflow">for</span>(iInput=0; iInput&lt;nInput; ++iInput){
<a name="l02747"></a>02747     <span class="keywordtype">int</span> i;
<a name="l02748"></a>02748     <span class="keywordflow">for</span>(i=iInput; i&lt;nInput &amp;&amp; zInput[i]!=<span class="charliteral">&apos;&quot;&apos;</span>; ++i){}
<a name="l02749"></a>02749     <span class="keywordflow">if</span>( i&gt;iInput ){
<a name="l02750"></a>02750       <a class="code" href="fts1_8c.html#a2b3fe867e6a4a792af87698942f40a4a">tokenizeSegment</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>, zInput+iInput, i-iInput, inPhrase,
<a name="l02751"></a>02751                        pQuery);
<a name="l02752"></a>02752     }
<a name="l02753"></a>02753     iInput = i;
<a name="l02754"></a>02754     <span class="keywordflow">if</span>( i&lt;nInput ){
<a name="l02755"></a>02755       assert( zInput[i]==<span class="charliteral">&apos;&quot;&apos;</span> );
<a name="l02756"></a>02756       inPhrase = !inPhrase;
<a name="l02757"></a>02757     }
<a name="l02758"></a>02758   }
<a name="l02759"></a>02759 
<a name="l02760"></a>02760   <span class="keywordflow">if</span>( inPhrase ){
<a name="l02761"></a>02761     <span class="comment">/* unmatched quote */</span>
<a name="l02762"></a>02762     <a class="code" href="fts1_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(pQuery);
<a name="l02763"></a>02763     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02764"></a>02764   }
<a name="l02765"></a>02765   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02766"></a>02766 }
<a name="l02767"></a>02767 
<a name="l02768"></a>02768 <span class="comment">/* Perform a full-text query using the search expression in</span>
<a name="l02769"></a>02769 <span class="comment">** zInput[0..nInput-1].  Return a list of matching documents</span>
<a name="l02770"></a>02770 <span class="comment">** in pResult.</span>
<a name="l02771"></a>02771 <span class="comment">**</span>
<a name="l02772"></a>02772 <span class="comment">** Queries must match column iColumn.  Or if iColumn&gt;=nColumn</span>
<a name="l02773"></a>02773 <span class="comment">** they are allowed to match against any column.</span>
<a name="l02774"></a>02774 <span class="comment">*/</span>
<a name="l02775"></a><a class="code" href="fts1_8c.html#ab884971785d5c284f562a85b51d8c91e">02775</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ab884971785d5c284f562a85b51d8c91e">fulltextQuery</a>(
<a name="l02776"></a>02776   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,      <span class="comment">/* The full text index */</span>
<a name="l02777"></a>02777   <span class="keywordtype">int</span> iColumn,           <span class="comment">/* Match against this column by default */</span>
<a name="l02778"></a>02778   <span class="keyword">const</span> <span class="keywordtype">char</span> *zInput,    <span class="comment">/* The query string */</span>
<a name="l02779"></a>02779   <span class="keywordtype">int</span> nInput,            <span class="comment">/* Number of bytes in zInput[] */</span>
<a name="l02780"></a>02780   <a class="code" href="structDocList.html">DocList</a> **pResult,     <span class="comment">/* Write the result doclist here */</span>
<a name="l02781"></a>02781   <a class="code" href="structQuery.html">Query</a> *pQuery          <span class="comment">/* Put parsed query string here */</span>
<a name="l02782"></a>02782 ){
<a name="l02783"></a>02783   <span class="keywordtype">int</span> i, iNext, rc;
<a name="l02784"></a>02784   <a class="code" href="structDocList.html">DocList</a> *pLeft = NULL;
<a name="l02785"></a>02785   <a class="code" href="structDocList.html">DocList</a> *pRight, *pNew, *pOr;
<a name="l02786"></a>02786   <span class="keywordtype">int</span> nNot = 0;
<a name="l02787"></a>02787   <a class="code" href="structQueryTerm.html">QueryTerm</a> *aTerm;
<a name="l02788"></a>02788 
<a name="l02789"></a>02789   rc = <a class="code" href="fts1_8c.html#a28b0578ebe0882fe104d34ddf4d9208c">parseQuery</a>(v, zInput, nInput, iColumn, pQuery);
<a name="l02790"></a>02790   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02791"></a>02791 
<a name="l02792"></a>02792   <span class="comment">/* Merge AND terms. */</span>
<a name="l02793"></a>02793   aTerm = pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>;
<a name="l02794"></a>02794   <span class="keywordflow">for</span>(i = 0; i&lt;pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>; i=iNext){
<a name="l02795"></a>02795     <span class="keywordflow">if</span>( aTerm[i].isNot ){
<a name="l02796"></a>02796       <span class="comment">/* Handle all NOT terms in a separate pass */</span>
<a name="l02797"></a>02797       nNot++;
<a name="l02798"></a>02798       iNext = i + aTerm[i].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a>+1;
<a name="l02799"></a>02799       <span class="keywordflow">continue</span>;
<a name="l02800"></a>02800     }
<a name="l02801"></a>02801     iNext = i + aTerm[i].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> + 1;
<a name="l02802"></a>02802     rc = <a class="code" href="fts1_8c.html#ac94fa84a731e6ff057686bd0f33a066f">docListOfTerm</a>(v, aTerm[i].iColumn, &amp;aTerm[i], &amp;pRight);
<a name="l02803"></a>02803     <span class="keywordflow">if</span>( rc ){
<a name="l02804"></a>02804       <a class="code" href="fts1_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(pQuery);
<a name="l02805"></a>02805       <span class="keywordflow">return</span> rc;
<a name="l02806"></a>02806     }
<a name="l02807"></a>02807     <span class="keywordflow">while</span>( iNext&lt;pQuery-&gt;nTerms &amp;&amp; aTerm[iNext].isOr ){
<a name="l02808"></a>02808       rc = <a class="code" href="fts1_8c.html#ac94fa84a731e6ff057686bd0f33a066f">docListOfTerm</a>(v, aTerm[iNext].iColumn, &amp;aTerm[iNext], &amp;pOr);
<a name="l02809"></a>02809       iNext += aTerm[iNext].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> + 1;
<a name="l02810"></a>02810       <span class="keywordflow">if</span>( rc ){
<a name="l02811"></a>02811         <a class="code" href="fts1_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(pQuery);
<a name="l02812"></a>02812         <span class="keywordflow">return</span> rc;
<a name="l02813"></a>02813       }
<a name="l02814"></a>02814       pNew = <a class="code" href="fts1_8c.html#a17dda48d7ada1bbe7a4cd214fcf00865">docListNew</a>(<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>);
<a name="l02815"></a>02815       <a class="code" href="fts1_8c.html#a2e2342760a086ba0823b626776c63079">docListOrMerge</a>(pRight, pOr, pNew);
<a name="l02816"></a>02816       <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pRight);
<a name="l02817"></a>02817       <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pOr);
<a name="l02818"></a>02818       pRight = pNew;
<a name="l02819"></a>02819     }
<a name="l02820"></a>02820     <span class="keywordflow">if</span>( pLeft==0 ){
<a name="l02821"></a>02821       pLeft = pRight;
<a name="l02822"></a>02822     }<span class="keywordflow">else</span>{
<a name="l02823"></a>02823       pNew = <a class="code" href="fts1_8c.html#a17dda48d7ada1bbe7a4cd214fcf00865">docListNew</a>(<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>);
<a name="l02824"></a>02824       <a class="code" href="fts1_8c.html#a541c327a224f0af61097c21eabd9c5d4">docListAndMerge</a>(pLeft, pRight, pNew);
<a name="l02825"></a>02825       <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pRight);
<a name="l02826"></a>02826       <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pLeft);
<a name="l02827"></a>02827       pLeft = pNew;
<a name="l02828"></a>02828     }
<a name="l02829"></a>02829   }
<a name="l02830"></a>02830 
<a name="l02831"></a>02831   <span class="keywordflow">if</span>( nNot &amp;&amp; pLeft==0 ){
<a name="l02832"></a>02832     <span class="comment">/* We do not yet know how to handle a query of only NOT terms */</span>
<a name="l02833"></a>02833     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02834"></a>02834   }
<a name="l02835"></a>02835 
<a name="l02836"></a>02836   <span class="comment">/* Do the EXCEPT terms */</span>
<a name="l02837"></a>02837   <span class="keywordflow">for</span>(i=0; i&lt;pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;  i += aTerm[i].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> + 1){
<a name="l02838"></a>02838     <span class="keywordflow">if</span>( !aTerm[i].isNot ) <span class="keywordflow">continue</span>;
<a name="l02839"></a>02839     rc = <a class="code" href="fts1_8c.html#ac94fa84a731e6ff057686bd0f33a066f">docListOfTerm</a>(v, aTerm[i].iColumn, &amp;aTerm[i], &amp;pRight);
<a name="l02840"></a>02840     <span class="keywordflow">if</span>( rc ){
<a name="l02841"></a>02841       <a class="code" href="fts1_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(pQuery);
<a name="l02842"></a>02842       <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pLeft);
<a name="l02843"></a>02843       <span class="keywordflow">return</span> rc;
<a name="l02844"></a>02844     }
<a name="l02845"></a>02845     pNew = <a class="code" href="fts1_8c.html#a17dda48d7ada1bbe7a4cd214fcf00865">docListNew</a>(<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>);
<a name="l02846"></a>02846     <a class="code" href="fts1_8c.html#ad8c4948e85c6c7fd1e4b324beeaf2b46">docListExceptMerge</a>(pLeft, pRight, pNew);
<a name="l02847"></a>02847     <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pRight);
<a name="l02848"></a>02848     <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(pLeft);
<a name="l02849"></a>02849     pLeft = pNew;
<a name="l02850"></a>02850   }
<a name="l02851"></a>02851 
<a name="l02852"></a>02852   *pResult = pLeft;
<a name="l02853"></a>02853   <span class="keywordflow">return</span> rc;
<a name="l02854"></a>02854 }
<a name="l02855"></a>02855 
<a name="l02856"></a>02856 <span class="comment">/*</span>
<a name="l02857"></a>02857 <span class="comment">** This is the xFilter interface for the virtual table.  See</span>
<a name="l02858"></a>02858 <span class="comment">** the virtual table xFilter method documentation for additional</span>
<a name="l02859"></a>02859 <span class="comment">** information.</span>
<a name="l02860"></a>02860 <span class="comment">**</span>
<a name="l02861"></a>02861 <span class="comment">** If idxNum==QUERY_GENERIC then do a full table scan against</span>
<a name="l02862"></a>02862 <span class="comment">** the %_content table.</span>
<a name="l02863"></a>02863 <span class="comment">**</span>
<a name="l02864"></a>02864 <span class="comment">** If idxNum==QUERY_ROWID then do a rowid lookup for a single entry</span>
<a name="l02865"></a>02865 <span class="comment">** in the %_content table.</span>
<a name="l02866"></a>02866 <span class="comment">**</span>
<a name="l02867"></a>02867 <span class="comment">** If idxNum&gt;=QUERY_FULLTEXT then use the full text index.  The</span>
<a name="l02868"></a>02868 <span class="comment">** column on the left-hand side of the MATCH operator is column</span>
<a name="l02869"></a>02869 <span class="comment">** number idxNum-QUERY_FULLTEXT, 0 indexed.  argv[0] is the right-hand</span>
<a name="l02870"></a>02870 <span class="comment">** side of the MATCH operator.</span>
<a name="l02871"></a>02871 <span class="comment">*/</span>
<a name="l02872"></a>02872 <span class="comment">/* TODO(shess) Upgrade the cursor initialization and destruction to</span>
<a name="l02873"></a>02873 <span class="comment">** account for fulltextFilter() being called multiple times on the</span>
<a name="l02874"></a>02874 <span class="comment">** same cursor.  The current solution is very fragile.  Apply fix to</span>
<a name="l02875"></a>02875 <span class="comment">** fts2 as appropriate.</span>
<a name="l02876"></a>02876 <span class="comment">*/</span>
<a name="l02877"></a><a class="code" href="fts1_8c.html#a77f0a9cad4b0dcb1a60143d08036b466">02877</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a77f0a9cad4b0dcb1a60143d08036b466">fulltextFilter</a>(
<a name="l02878"></a>02878   <a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor,     <span class="comment">/* The cursor used for this query */</span>
<a name="l02879"></a>02879   <span class="keywordtype">int</span> idxNum, <span class="keyword">const</span> <span class="keywordtype">char</span> *idxStr,   <span class="comment">/* Which indexing scheme to use */</span>
<a name="l02880"></a>02880   <span class="keywordtype">int</span> argc, <a class="code" href="structMem.html">sqlite3_value</a> **argv    <span class="comment">/* Arguments for the indexing scheme */</span>
<a name="l02881"></a>02881 ){
<a name="l02882"></a>02882   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l02883"></a>02883   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = <a class="code" href="fts1_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">cursor_vtab</a>(c);
<a name="l02884"></a>02884   <span class="keywordtype">int</span> rc;
<a name="l02885"></a>02885   <span class="keywordtype">char</span> *zSql;
<a name="l02886"></a>02886 
<a name="l02887"></a>02887   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Filter %p\n&quot;</span>,pCursor));
<a name="l02888"></a>02888 
<a name="l02889"></a>02889   zSql = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;select rowid, * from %%_content %s&quot;</span>,
<a name="l02890"></a>02890                           idxNum==<a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">QUERY_GENERIC</a> ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;where rowid=?&quot;</span>);
<a name="l02891"></a>02891   <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l02892"></a>02892   rc = <a class="code" href="fts1_8c.html#a90c49c1625eff6f726a4ce28200e24d4">sql_prepare</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, &amp;c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, zSql);
<a name="l02893"></a>02893   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zSql);
<a name="l02894"></a>02894   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02895"></a>02895 
<a name="l02896"></a>02896   c-&gt;<a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a> = idxNum;
<a name="l02897"></a>02897   <span class="keywordflow">switch</span>( idxNum ){
<a name="l02898"></a>02898     <span class="keywordflow">case</span> <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">QUERY_GENERIC</a>:
<a name="l02899"></a>02899       <span class="keywordflow">break</span>;
<a name="l02900"></a>02900 
<a name="l02901"></a>02901     <span class="keywordflow">case</span> <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ecadfa9dc6cb33447260116307a64a3c657">QUERY_ROWID</a>:
<a name="l02902"></a>02902       rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, 1, <a class="code" href="sqlite3_8h.html#a8e6a9f5cda11dec1ca742f58695feded">sqlite3_value_int64</a>(argv[0]));
<a name="l02903"></a>02903       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02904"></a>02904       <span class="keywordflow">break</span>;
<a name="l02905"></a>02905 
<a name="l02906"></a>02906     <span class="keywordflow">default</span>:   <span class="comment">/* full-text search */</span>
<a name="l02907"></a>02907     {
<a name="l02908"></a>02908       <span class="keyword">const</span> <span class="keywordtype">char</span> *zQuery = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[0]);
<a name="l02909"></a>02909       <a class="code" href="structDocList.html">DocList</a> *pResult;
<a name="l02910"></a>02910       assert( idxNum&lt;=QUERY_FULLTEXT+v-&gt;nColumn);
<a name="l02911"></a>02911       assert( argc==1 );
<a name="l02912"></a>02912       <a class="code" href="fts1_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>);
<a name="l02913"></a>02913       rc = <a class="code" href="fts1_8c.html#ab884971785d5c284f562a85b51d8c91e">fulltextQuery</a>(v, idxNum-<a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a>, zQuery, -1, &amp;pResult, &amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>);
<a name="l02914"></a>02914       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02915"></a>02915       <span class="keywordflow">if</span>( c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>!=NULL ) <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.<a class="code" href="structDocListReader.html#aa1871db3d4464dbc5fc7456e31f4d769">pDoclist</a>);
<a name="l02916"></a>02916       <a class="code" href="fts1_8c.html#af918141b6d62b711b146a10e4cee4129">readerInit</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>, pResult);
<a name="l02917"></a>02917       <span class="keywordflow">break</span>;
<a name="l02918"></a>02918     }
<a name="l02919"></a>02919   }
<a name="l02920"></a>02920 
<a name="l02921"></a>02921   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#a27014ab01a3b771ad685bf0a66ae0f74">fulltextNext</a>(pCursor);
<a name="l02922"></a>02922 }
<a name="l02923"></a>02923 
<a name="l02924"></a>02924 <span class="comment">/* This is the xEof method of the virtual table.  The SQLite core</span>
<a name="l02925"></a>02925 <span class="comment">** calls this routine to find out if it has reached the end of</span>
<a name="l02926"></a>02926 <span class="comment">** a query&apos;s results set.</span>
<a name="l02927"></a>02927 <span class="comment">*/</span>
<a name="l02928"></a><a class="code" href="fts1_8c.html#a04b7b39869da7e2457f1605884eaada7">02928</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a04b7b39869da7e2457f1605884eaada7">fulltextEof</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor){
<a name="l02929"></a>02929   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l02930"></a>02930   <span class="keywordflow">return</span> c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a>;
<a name="l02931"></a>02931 }
<a name="l02932"></a>02932 
<a name="l02933"></a>02933 <span class="comment">/* This is the xColumn method of the virtual table.  The SQLite</span>
<a name="l02934"></a>02934 <span class="comment">** core calls this method during a query when it needs the value</span>
<a name="l02935"></a>02935 <span class="comment">** of a column from the virtual table.  This method needs to use</span>
<a name="l02936"></a>02936 <span class="comment">** one of the sqlite3_result_*() routines to store the requested</span>
<a name="l02937"></a>02937 <span class="comment">** value back in the pContext.</span>
<a name="l02938"></a>02938 <span class="comment">*/</span>
<a name="l02939"></a><a class="code" href="fts1_8c.html#a1150d2b45c324680b8f663999690251f">02939</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a1150d2b45c324680b8f663999690251f">fulltextColumn</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor,
<a name="l02940"></a>02940                           <a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext, <span class="keywordtype">int</span> idxCol){
<a name="l02941"></a>02941   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l02942"></a>02942   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = <a class="code" href="fts1_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">cursor_vtab</a>(c);
<a name="l02943"></a>02943 
<a name="l02944"></a>02944   <span class="keywordflow">if</span>( idxCol&lt;v-&gt;nColumn ){
<a name="l02945"></a>02945     <a class="code" href="structMem.html">sqlite3_value</a> *pVal = <a class="code" href="sqlite3_8h.html#aab0b080ede916c9dee19b6a29138e0b7">sqlite3_column_value</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, idxCol+1);
<a name="l02946"></a>02946     <a class="code" href="sqlite3_8h.html#a7cd28ba7a4256aec12262ed3d75bb39a">sqlite3_result_value</a>(pContext, pVal);
<a name="l02947"></a>02947   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( idxCol==v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a> ){
<a name="l02948"></a>02948     <span class="comment">/* The extra column whose name is the same as the table.</span>
<a name="l02949"></a>02949 <span class="comment">    ** Return a blob which is a pointer to the cursor</span>
<a name="l02950"></a>02950 <span class="comment">    */</span>
<a name="l02951"></a>02951     <a class="code" href="sqlite3_8h.html#a7dabc96652dbaf414a4dc55176a11158">sqlite3_result_blob</a>(pContext, &amp;c, <span class="keyword">sizeof</span>(c), <a class="code" href="sqlite3_8h.html#adec3d88e3dff21d4c566daccbede9b3b">SQLITE_TRANSIENT</a>);
<a name="l02952"></a>02952   }
<a name="l02953"></a>02953   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02954"></a>02954 }
<a name="l02955"></a>02955 
<a name="l02956"></a>02956 <span class="comment">/* This is the xRowid method.  The SQLite core calls this routine to</span>
<a name="l02957"></a>02957 <span class="comment">** retrive the rowid for the current row of the result set.  The</span>
<a name="l02958"></a>02958 <span class="comment">** rowid should be written to *pRowid.</span>
<a name="l02959"></a>02959 <span class="comment">*/</span>
<a name="l02960"></a><a class="code" href="fts1_8c.html#a4ede5546134709d20eed03b0b16c85e1">02960</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a4ede5546134709d20eed03b0b16c85e1">fulltextRowid</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *pRowid){
<a name="l02961"></a>02961   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l02962"></a>02962 
<a name="l02963"></a>02963   *pRowid = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, 0);
<a name="l02964"></a>02964   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02965"></a>02965 }
<a name="l02966"></a>02966 
<a name="l02967"></a>02967 <span class="comment">/* Add all terms in [zText] to the given hash table.  If [iColumn] &gt; 0,</span>
<a name="l02968"></a>02968 <span class="comment"> * we also store positions and offsets in the hash table using the given</span>
<a name="l02969"></a>02969 <span class="comment"> * column number. */</span>
<a name="l02970"></a><a class="code" href="fts1_8c.html#ad416bc05fe0874420ee5e2351d7a9e2f">02970</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ad416bc05fe0874420ee5e2351d7a9e2f">buildTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structfts1Hash.html">fts1Hash</a> *terms, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid,
<a name="l02971"></a>02971                       <span class="keyword">const</span> <span class="keywordtype">char</span> *zText, <span class="keywordtype">int</span> iColumn){
<a name="l02972"></a>02972   <a class="code" href="structsqlite3__tokenizer.html">sqlite3_tokenizer</a> *pTokenizer = v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>;
<a name="l02973"></a>02973   <a class="code" href="structsqlite3__tokenizer__cursor.html">sqlite3_tokenizer_cursor</a> *pCursor;
<a name="l02974"></a>02974   <span class="keyword">const</span> <span class="keywordtype">char</span> *pToken;
<a name="l02975"></a>02975   <span class="keywordtype">int</span> nTokenBytes;
<a name="l02976"></a>02976   <span class="keywordtype">int</span> iStartOffset, iEndOffset, iPosition;
<a name="l02977"></a>02977   <span class="keywordtype">int</span> rc;
<a name="l02978"></a>02978 
<a name="l02979"></a>02979   rc = pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a44ab0f8ad43cd5900d5ab59f899f6acd">xOpen</a>(pTokenizer, zText, -1, &amp;pCursor);
<a name="l02980"></a>02980   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02981"></a>02981 
<a name="l02982"></a>02982   pCursor-&gt;<a class="code" href="structsqlite3__tokenizer__cursor.html#aa0ec54f843cb47b54daa4e8c8c6013c0">pTokenizer</a> = pTokenizer;
<a name="l02983"></a>02983   <span class="keywordflow">while</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a13443eb8fac89e3031f601a38564e2cc">xNext</a>(pCursor,
<a name="l02984"></a>02984                                                &amp;pToken, &amp;nTokenBytes,
<a name="l02985"></a>02985                                                &amp;iStartOffset, &amp;iEndOffset,
<a name="l02986"></a>02986                                                &amp;iPosition) ){
<a name="l02987"></a>02987     <a class="code" href="structDocList.html">DocList</a> *p;
<a name="l02988"></a>02988 
<a name="l02989"></a>02989     <span class="comment">/* Positions can&apos;t be negative; we use -1 as a terminator internally. */</span>
<a name="l02990"></a>02990     <span class="keywordflow">if</span>( iPosition&lt;0 ){
<a name="l02991"></a>02991       pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#ad8bb92424245a38583cbaf36b509efd6">xClose</a>(pCursor);
<a name="l02992"></a>02992       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02993"></a>02993     }
<a name="l02994"></a>02994 
<a name="l02995"></a>02995     p = <a class="code" href="fts1__hash_8h.html#ae5a6310b6fda7843a6ea8b4911651e9f">fts1HashFind</a>(terms, pToken, nTokenBytes);
<a name="l02996"></a>02996     <span class="keywordflow">if</span>( p==NULL ){
<a name="l02997"></a>02997       p = <a class="code" href="fts1_8c.html#a17dda48d7ada1bbe7a4cd214fcf00865">docListNew</a>(<a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>);
<a name="l02998"></a>02998       <a class="code" href="fts1_8c.html#a7b5d60c72e2e9ab5b77e41c694516738">docListAddDocid</a>(p, iDocid);
<a name="l02999"></a>02999       <a class="code" href="fts1__hash_8h.html#ad43c8293f3051f6bb610a791e2d2dfe1">fts1HashInsert</a>(terms, pToken, nTokenBytes, p);
<a name="l03000"></a>03000     }
<a name="l03001"></a>03001     <span class="keywordflow">if</span>( iColumn&gt;=0 ){
<a name="l03002"></a>03002       <a class="code" href="fts1_8c.html#ad8a22ce767c69c39f134e5127c1d7bb5">docListAddPosOffset</a>(p, iColumn, iPosition, iStartOffset, iEndOffset);
<a name="l03003"></a>03003     }
<a name="l03004"></a>03004   }
<a name="l03005"></a>03005 
<a name="l03006"></a>03006   <span class="comment">/* TODO(shess) Check return?  Should this be able to cause errors at</span>
<a name="l03007"></a>03007 <span class="comment">  ** this point?  Actually, same question about sqlite3_finalize(),</span>
<a name="l03008"></a>03008 <span class="comment">  ** though one could argue that failure there means that the data is</span>
<a name="l03009"></a>03009 <span class="comment">  ** not durable.  *ponder*</span>
<a name="l03010"></a>03010 <span class="comment">  */</span>
<a name="l03011"></a>03011   pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#ad8bb92424245a38583cbaf36b509efd6">xClose</a>(pCursor);
<a name="l03012"></a>03012   <span class="keywordflow">return</span> rc;
<a name="l03013"></a>03013 }
<a name="l03014"></a>03014 
<a name="l03015"></a>03015 <span class="comment">/* Update the %_terms table to map the term [pTerm] to the given rowid. */</span>
<a name="l03016"></a><a class="code" href="fts1_8c.html#aba0937b81a566d26440d0c3ad97d9c4c">03016</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#aba0937b81a566d26440d0c3ad97d9c4c">index_insert_term</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm,
<a name="l03017"></a>03017                              <a class="code" href="structDocList.html">DocList</a> *<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>){
<a name="l03018"></a>03018   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iIndexRow;
<a name="l03019"></a>03019   <a class="code" href="structDocList.html">DocList</a> doclist;
<a name="l03020"></a>03020   <span class="keywordtype">int</span> iSegment = 0, rc;
<a name="l03021"></a>03021 
<a name="l03022"></a>03022   rc = <a class="code" href="fts1_8c.html#a937305225088f05991aa7c6d1d6ec48f">term_select</a>(v, pTerm, nTerm, iSegment, &amp;iIndexRow, &amp;doclist);
<a name="l03023"></a>03023   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l03024"></a>03024     <a class="code" href="fts1_8c.html#ab9c4fadccc51f39560c880c3d031a27b">docListInit</a>(&amp;doclist, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, 0, 0);
<a name="l03025"></a>03025     <a class="code" href="fts1_8c.html#a943610659adb4c0b15897cb5d57aa3e2">docListUpdate</a>(&amp;doclist, d);
<a name="l03026"></a>03026     <span class="comment">/* TODO(shess) Consider length(doclist)&gt;CHUNK_MAX? */</span>
<a name="l03027"></a>03027     rc = <a class="code" href="fts1_8c.html#ae4055e878ea04eb206c38f7a1f5f59ac">term_insert</a>(v, NULL, pTerm, nTerm, iSegment, &amp;doclist);
<a name="l03028"></a>03028     <span class="keywordflow">goto</span> err;
<a name="l03029"></a>03029   }
<a name="l03030"></a>03030   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l03031"></a>03031 
<a name="l03032"></a>03032   <a class="code" href="fts1_8c.html#a943610659adb4c0b15897cb5d57aa3e2">docListUpdate</a>(&amp;doclist, d);
<a name="l03033"></a>03033   <span class="keywordflow">if</span>( doclist.<a class="code" href="structDocList.html#a32fbc3423aae0847704a962a45fd3ca2">nData</a>&lt;=<a class="code" href="fts1_8c.html#a0cbd9294d93f70cb6650e46ca274704e">CHUNK_MAX</a> ){
<a name="l03034"></a>03034     rc = <a class="code" href="fts1_8c.html#abf72e9c113f42e1e93f0f96ba83f135c">term_update</a>(v, iIndexRow, &amp;doclist);
<a name="l03035"></a>03035     <span class="keywordflow">goto</span> err;
<a name="l03036"></a>03036   }
<a name="l03037"></a>03037 
<a name="l03038"></a>03038   <span class="comment">/* Doclist doesn&apos;t fit, delete what&apos;s there, and accumulate</span>
<a name="l03039"></a>03039 <span class="comment">  ** forward.</span>
<a name="l03040"></a>03040 <span class="comment">  */</span>
<a name="l03041"></a>03041   rc = <a class="code" href="fts1_8c.html#a72ace762cfb611748520a875dad83eab">term_delete</a>(v, iIndexRow);
<a name="l03042"></a>03042   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l03043"></a>03043 
<a name="l03044"></a>03044   <span class="comment">/* Try to insert the doclist into a higher segment bucket.  On</span>
<a name="l03045"></a>03045 <span class="comment">  ** failure, accumulate existing doclist with the doclist from that</span>
<a name="l03046"></a>03046 <span class="comment">  ** bucket, and put results in the next bucket.</span>
<a name="l03047"></a>03047 <span class="comment">  */</span>
<a name="l03048"></a>03048   iSegment++;
<a name="l03049"></a>03049   <span class="keywordflow">while</span>( (rc=<a class="code" href="fts1_8c.html#ae4055e878ea04eb206c38f7a1f5f59ac">term_insert</a>(v, &amp;iIndexRow, pTerm, nTerm, iSegment,
<a name="l03050"></a>03050                          &amp;doclist))!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03051"></a>03051     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iSegmentRow;
<a name="l03052"></a>03052     <a class="code" href="structDocList.html">DocList</a> old;
<a name="l03053"></a>03053     <span class="keywordtype">int</span> rc2;
<a name="l03054"></a>03054 
<a name="l03055"></a>03055     <span class="comment">/* Retain old error in case the term_insert() error was really an</span>
<a name="l03056"></a>03056 <span class="comment">    ** error rather than a bounced insert.</span>
<a name="l03057"></a>03057 <span class="comment">    */</span>
<a name="l03058"></a>03058     rc2 = <a class="code" href="fts1_8c.html#a937305225088f05991aa7c6d1d6ec48f">term_select</a>(v, pTerm, nTerm, iSegment, &amp;iSegmentRow, &amp;old);
<a name="l03059"></a>03059     <span class="keywordflow">if</span>( rc2!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">goto</span> err;
<a name="l03060"></a>03060 
<a name="l03061"></a>03061     rc = <a class="code" href="fts1_8c.html#a72ace762cfb611748520a875dad83eab">term_delete</a>(v, iSegmentRow);
<a name="l03062"></a>03062     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l03063"></a>03063 
<a name="l03064"></a>03064     <span class="comment">/* Reusing lowest-number deleted row keeps the index smaller. */</span>
<a name="l03065"></a>03065     <span class="keywordflow">if</span>( iSegmentRow&lt;iIndexRow ) iIndexRow = iSegmentRow;
<a name="l03066"></a>03066 
<a name="l03067"></a>03067     <span class="comment">/* doclist contains the newer data, so accumulate it over old.</span>
<a name="l03068"></a>03068 <span class="comment">    ** Then steal accumulated data for doclist.</span>
<a name="l03069"></a>03069 <span class="comment">    */</span>
<a name="l03070"></a>03070     <a class="code" href="fts1_8c.html#ac74a82f8f6e2273fb58b6bdf1d1f3f31">docListAccumulate</a>(&amp;old, &amp;doclist);
<a name="l03071"></a>03071     <a class="code" href="fts1_8c.html#afc9760991434278d35e17d8b0ab59001">docListDestroy</a>(&amp;doclist);
<a name="l03072"></a>03072     doclist = old;
<a name="l03073"></a>03073 
<a name="l03074"></a>03074     iSegment++;
<a name="l03075"></a>03075   }
<a name="l03076"></a>03076 
<a name="l03077"></a>03077  err:
<a name="l03078"></a>03078   <a class="code" href="fts1_8c.html#afc9760991434278d35e17d8b0ab59001">docListDestroy</a>(&amp;doclist);
<a name="l03079"></a>03079   <span class="keywordflow">return</span> rc;
<a name="l03080"></a>03080 }
<a name="l03081"></a>03081 
<a name="l03082"></a>03082 <span class="comment">/* Add doclists for all terms in [pValues] to the hash table [terms]. */</span>
<a name="l03083"></a><a class="code" href="fts1_8c.html#ab6f5bb21a1f3d8760208930829abdf89">03083</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ab6f5bb21a1f3d8760208930829abdf89">insertTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structfts1Hash.html">fts1Hash</a> *terms, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRowid,
<a name="l03084"></a>03084                 <a class="code" href="structMem.html">sqlite3_value</a> **pValues){
<a name="l03085"></a>03085   <span class="keywordtype">int</span> i;
<a name="l03086"></a>03086   <span class="keywordflow">for</span>(i = 0; i &lt; v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a> ; ++i){
<a name="l03087"></a>03087     <span class="keywordtype">char</span> *zText = (<span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(pValues[i]);
<a name="l03088"></a>03088     <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#ad416bc05fe0874420ee5e2351d7a9e2f">buildTerms</a>(v, terms, iRowid, zText, i);
<a name="l03089"></a>03089     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03090"></a>03090   }
<a name="l03091"></a>03091   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03092"></a>03092 }
<a name="l03093"></a>03093 
<a name="l03094"></a>03094 <span class="comment">/* Add empty doclists for all terms in the given row&apos;s content to the hash</span>
<a name="l03095"></a>03095 <span class="comment"> * table [pTerms]. */</span>
<a name="l03096"></a><a class="code" href="fts1_8c.html#a97dca21bb283b2dce0e716905d5f8f56">03096</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a97dca21bb283b2dce0e716905d5f8f56">deleteTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structfts1Hash.html">fts1Hash</a> *pTerms, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRowid){
<a name="l03097"></a>03097   <span class="keyword">const</span> <span class="keywordtype">char</span> **pValues;
<a name="l03098"></a>03098   <span class="keywordtype">int</span> i;
<a name="l03099"></a>03099 
<a name="l03100"></a>03100   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a45b9abe0a1f6a081cab0c2eeda68794d">content_select</a>(v, iRowid, &amp;pValues);
<a name="l03101"></a>03101   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03102"></a>03102 
<a name="l03103"></a>03103   <span class="keywordflow">for</span>(i = 0 ; i &lt; v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i) {
<a name="l03104"></a>03104     rc = <a class="code" href="fts1_8c.html#ad416bc05fe0874420ee5e2351d7a9e2f">buildTerms</a>(v, pTerms, iRowid, pValues[i], -1);
<a name="l03105"></a>03105     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">break</span>;
<a name="l03106"></a>03106   }
<a name="l03107"></a>03107 
<a name="l03108"></a>03108   <a class="code" href="fts1_8c.html#a217321df065d27f4580f1affa711f23b">freeStringArray</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, pValues);
<a name="l03109"></a>03109   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03110"></a>03110 }
<a name="l03111"></a>03111 
<a name="l03112"></a>03112 <span class="comment">/* Insert a row into the %_content table; set *piRowid to be the ID of the</span>
<a name="l03113"></a>03113 <span class="comment"> * new row.  Fill [pTerms] with new doclists for the %_term table. */</span>
<a name="l03114"></a><a class="code" href="fts1_8c.html#a200dacd6961c91ef95a928fbafb3a351">03114</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a200dacd6961c91ef95a928fbafb3a351">index_insert</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structMem.html">sqlite3_value</a> *pRequestRowid,
<a name="l03115"></a>03115                         <a class="code" href="structMem.html">sqlite3_value</a> **pValues,
<a name="l03116"></a>03116                         <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piRowid, <a class="code" href="structfts1Hash.html">fts1Hash</a> *pTerms){
<a name="l03117"></a>03117   <span class="keywordtype">int</span> rc;
<a name="l03118"></a>03118 
<a name="l03119"></a>03119   rc = <a class="code" href="fts1_8c.html#a97f61f9291ab35fbfe2c39993ec56796">content_insert</a>(v, pRequestRowid, pValues);  <span class="comment">/* execute an SQL INSERT */</span>
<a name="l03120"></a>03120   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03121"></a>03121   *piRowid = <a class="code" href="main_8c.html#ac09d49376c77414ba143635184b7ee10">sqlite3_last_insert_rowid</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>);
<a name="l03122"></a>03122   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#ab6f5bb21a1f3d8760208930829abdf89">insertTerms</a>(v, pTerms, *piRowid, pValues);
<a name="l03123"></a>03123 }
<a name="l03124"></a>03124 
<a name="l03125"></a>03125 <span class="comment">/* Delete a row from the %_content table; fill [pTerms] with empty doclists</span>
<a name="l03126"></a>03126 <span class="comment"> * to be written to the %_term table. */</span>
<a name="l03127"></a><a class="code" href="fts1_8c.html#ad8e31a65fc8cce832e14d8c8cf27d65b">03127</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#ad8e31a65fc8cce832e14d8c8cf27d65b">index_delete</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRow, <a class="code" href="structfts1Hash.html">fts1Hash</a> *pTerms){
<a name="l03128"></a>03128   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a97dca21bb283b2dce0e716905d5f8f56">deleteTerms</a>(v, pTerms, iRow);
<a name="l03129"></a>03129   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03130"></a>03130   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#a8d2f433ca2290904b916ff1972b921c3">content_delete</a>(v, iRow);  <span class="comment">/* execute an SQL DELETE */</span>
<a name="l03131"></a>03131 }
<a name="l03132"></a>03132 
<a name="l03133"></a>03133 <span class="comment">/* Update a row in the %_content table; fill [pTerms] with new doclists for the</span>
<a name="l03134"></a>03134 <span class="comment"> * %_term table. */</span>
<a name="l03135"></a><a class="code" href="fts1_8c.html#a25c0013ac7c8edabf28bb58d5c1a3801">03135</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a25c0013ac7c8edabf28bb58d5c1a3801">index_update</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRow,
<a name="l03136"></a>03136                         <a class="code" href="structMem.html">sqlite3_value</a> **pValues, <a class="code" href="structfts1Hash.html">fts1Hash</a> *pTerms){
<a name="l03137"></a>03137   <span class="comment">/* Generate an empty doclist for each term that previously appeared in this</span>
<a name="l03138"></a>03138 <span class="comment">   * row. */</span>
<a name="l03139"></a>03139   <span class="keywordtype">int</span> rc = <a class="code" href="fts1_8c.html#a97dca21bb283b2dce0e716905d5f8f56">deleteTerms</a>(v, pTerms, iRow);
<a name="l03140"></a>03140   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03141"></a>03141 
<a name="l03142"></a>03142   rc = <a class="code" href="fts1_8c.html#aff98794eedf8ff43e623a00e0634c566">content_update</a>(v, pValues, iRow);  <span class="comment">/* execute an SQL UPDATE */</span>
<a name="l03143"></a>03143   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03144"></a>03144 
<a name="l03145"></a>03145   <span class="comment">/* Now add positions for terms which appear in the updated row. */</span>
<a name="l03146"></a>03146   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#ab6f5bb21a1f3d8760208930829abdf89">insertTerms</a>(v, pTerms, iRow, pValues);
<a name="l03147"></a>03147 }
<a name="l03148"></a>03148 
<a name="l03149"></a>03149 <span class="comment">/* This function implements the xUpdate callback; it is the top-level entry</span>
<a name="l03150"></a>03150 <span class="comment"> * point for inserting, deleting or updating a row in a full-text table. */</span>
<a name="l03151"></a><a class="code" href="fts1_8c.html#a8e291fd12023cffe80976a33530e839d">03151</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a8e291fd12023cffe80976a33530e839d">fulltextUpdate</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab, <span class="keywordtype">int</span> nArg, <a class="code" href="structMem.html">sqlite3_value</a> **ppArg,
<a name="l03152"></a>03152                    <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *pRowid){
<a name="l03153"></a>03153   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *) pVtab;
<a name="l03154"></a>03154   <a class="code" href="structfts1Hash.html">fts1Hash</a> terms;   <span class="comment">/* maps term string -&gt; PosList */</span>
<a name="l03155"></a>03155   <span class="keywordtype">int</span> rc;
<a name="l03156"></a>03156   <a class="code" href="structfts1HashElem.html">fts1HashElem</a> *e;
<a name="l03157"></a>03157 
<a name="l03158"></a>03158   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS1 Update %p\n&quot;</span>, pVtab));
<a name="l03159"></a>03159   
<a name="l03160"></a>03160   <a class="code" href="fts1__hash_8h.html#abfeba97d0917bd640a2434fca4ecd2ad">fts1HashInit</a>(&amp;terms, <a class="code" href="fts1__hash_8h.html#a8664cef5282a3b4bbd8c66ba1549c6f5">FTS1_HASH_STRING</a>, 1);
<a name="l03161"></a>03161 
<a name="l03162"></a>03162   <span class="keywordflow">if</span>( nArg&lt;2 ){
<a name="l03163"></a>03163     rc = <a class="code" href="fts1_8c.html#ad8e31a65fc8cce832e14d8c8cf27d65b">index_delete</a>(v, <a class="code" href="sqlite3_8h.html#a8e6a9f5cda11dec1ca742f58695feded">sqlite3_value_int64</a>(ppArg[0]), &amp;terms);
<a name="l03164"></a>03164   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(ppArg[0]) != <a class="code" href="sqlite3_8h.html#afd180931f2d06d6c245791d187da5802">SQLITE_NULL</a> ){
<a name="l03165"></a>03165     <span class="comment">/* An update:</span>
<a name="l03166"></a>03166 <span class="comment">     * ppArg[0] = old rowid</span>
<a name="l03167"></a>03167 <span class="comment">     * ppArg[1] = new rowid</span>
<a name="l03168"></a>03168 <span class="comment">     * ppArg[2..2+v-&gt;nColumn-1] = values</span>
<a name="l03169"></a>03169 <span class="comment">     * ppArg[2+v-&gt;nColumn] = value for magic column (we ignore this)</span>
<a name="l03170"></a>03170 <span class="comment">     */</span>
<a name="l03171"></a>03171     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> rowid = <a class="code" href="sqlite3_8h.html#a8e6a9f5cda11dec1ca742f58695feded">sqlite3_value_int64</a>(ppArg[0]);
<a name="l03172"></a>03172     <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(ppArg[1]) != <a class="code" href="sqlite3_8h.html#a7453d71905f10fa330940428f8abe21c">SQLITE_INTEGER</a> ||
<a name="l03173"></a>03173       <a class="code" href="sqlite3_8h.html#a8e6a9f5cda11dec1ca742f58695feded">sqlite3_value_int64</a>(ppArg[1]) != rowid ){
<a name="l03174"></a>03174       rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;  <span class="comment">/* we don&apos;t allow changing the rowid */</span>
<a name="l03175"></a>03175     } <span class="keywordflow">else</span> {
<a name="l03176"></a>03176       assert( nArg==2+v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>+1);
<a name="l03177"></a>03177       rc = <a class="code" href="fts1_8c.html#a25c0013ac7c8edabf28bb58d5c1a3801">index_update</a>(v, rowid, &amp;ppArg[2], &amp;terms);
<a name="l03178"></a>03178     }
<a name="l03179"></a>03179   } <span class="keywordflow">else</span> {
<a name="l03180"></a>03180     <span class="comment">/* An insert:</span>
<a name="l03181"></a>03181 <span class="comment">     * ppArg[1] = requested rowid</span>
<a name="l03182"></a>03182 <span class="comment">     * ppArg[2..2+v-&gt;nColumn-1] = values</span>
<a name="l03183"></a>03183 <span class="comment">     * ppArg[2+v-&gt;nColumn] = value for magic column (we ignore this)</span>
<a name="l03184"></a>03184 <span class="comment">     */</span>
<a name="l03185"></a>03185     assert( nArg==2+v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>+1);
<a name="l03186"></a>03186     rc = <a class="code" href="fts1_8c.html#a200dacd6961c91ef95a928fbafb3a351">index_insert</a>(v, ppArg[1], &amp;ppArg[2], pRowid, &amp;terms);
<a name="l03187"></a>03187   }
<a name="l03188"></a>03188 
<a name="l03189"></a>03189   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03190"></a>03190     <span class="comment">/* Write updated doclists to disk. */</span>
<a name="l03191"></a>03191     <span class="keywordflow">for</span>(e=<a class="code" href="fts1__hash_8h.html#a20ef0b4363e4b642b6baa1a654a701bd">fts1HashFirst</a>(&amp;terms); e; e=<a class="code" href="fts1__hash_8h.html#afb418fb2236e682dc0781eaffc85f9aa">fts1HashNext</a>(e)){
<a name="l03192"></a>03192       <a class="code" href="structDocList.html">DocList</a> *p = <a class="code" href="fts1__hash_8h.html#ab83cae1a632f93a54adeff9e4977562f">fts1HashData</a>(e);
<a name="l03193"></a>03193       rc = <a class="code" href="fts1_8c.html#aba0937b81a566d26440d0c3ad97d9c4c">index_insert_term</a>(v, <a class="code" href="fts1__hash_8h.html#a7a6523f3f868158372a4d0044d478066">fts1HashKey</a>(e), <a class="code" href="fts1__hash_8h.html#aecb7de3afc23e5e5cf949729569e419a">fts1HashKeysize</a>(e), p);
<a name="l03194"></a>03194       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">break</span>;
<a name="l03195"></a>03195     }
<a name="l03196"></a>03196   }
<a name="l03197"></a>03197 
<a name="l03198"></a>03198   <span class="comment">/* clean up */</span>
<a name="l03199"></a>03199   <span class="keywordflow">for</span>(e=<a class="code" href="fts1__hash_8h.html#a20ef0b4363e4b642b6baa1a654a701bd">fts1HashFirst</a>(&amp;terms); e; e=<a class="code" href="fts1__hash_8h.html#afb418fb2236e682dc0781eaffc85f9aa">fts1HashNext</a>(e)){
<a name="l03200"></a>03200     <a class="code" href="structDocList.html">DocList</a> *p = <a class="code" href="fts1__hash_8h.html#ab83cae1a632f93a54adeff9e4977562f">fts1HashData</a>(e);
<a name="l03201"></a>03201     <a class="code" href="fts1_8c.html#a16c580a525881f436c524bc73c75ce90">docListDelete</a>(p);
<a name="l03202"></a>03202   }
<a name="l03203"></a>03203   <a class="code" href="fts1__hash_8h.html#afc0f84dab481bfde979f381b7e586758">fts1HashClear</a>(&amp;terms);
<a name="l03204"></a>03204 
<a name="l03205"></a>03205   <span class="keywordflow">return</span> rc;
<a name="l03206"></a>03206 }
<a name="l03207"></a>03207 
<a name="l03208"></a>03208 <span class="comment">/*</span>
<a name="l03209"></a>03209 <span class="comment">** Implementation of the snippet() function for FTS1</span>
<a name="l03210"></a>03210 <span class="comment">*/</span>
<a name="l03211"></a><a class="code" href="fts1_8c.html#a57b1d2e6eb52243a8c4a2a32f238dc03">03211</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a57b1d2e6eb52243a8c4a2a32f238dc03">snippetFunc</a>(
<a name="l03212"></a>03212   <a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext,
<a name="l03213"></a>03213   <span class="keywordtype">int</span> argc,
<a name="l03214"></a>03214   <a class="code" href="structMem.html">sqlite3_value</a> **argv
<a name="l03215"></a>03215 ){
<a name="l03216"></a>03216   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *pCursor;
<a name="l03217"></a>03217   <span class="keywordflow">if</span>( argc&lt;1 ) <span class="keywordflow">return</span>;
<a name="l03218"></a>03218   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(argv[0])!=<a class="code" href="sqlite3_8h.html#a26c29a137b2a35bbde7048e5e48b794a">SQLITE_BLOB</a> ||
<a name="l03219"></a>03219       <a class="code" href="sqlite3_8h.html#a2aff2bf1311b5bd05d8e30738445b186">sqlite3_value_bytes</a>(argv[0])!=<span class="keyword">sizeof</span>(pCursor) ){
<a name="l03220"></a>03220     <a class="code" href="sqlite3_8h.html#a02826d87e45fd4f04445a3c99a14b54e">sqlite3_result_error</a>(pContext, <span class="stringliteral">&quot;illegal first argument to html_snippet&quot;</span>,-1);
<a name="l03221"></a>03221   }<span class="keywordflow">else</span>{
<a name="l03222"></a>03222     <span class="keyword">const</span> <span class="keywordtype">char</span> *zStart = <span class="stringliteral">&quot;&lt;b&gt;&quot;</span>;
<a name="l03223"></a>03223     <span class="keyword">const</span> <span class="keywordtype">char</span> *zEnd = <span class="stringliteral">&quot;&lt;/b&gt;&quot;</span>;
<a name="l03224"></a>03224     <span class="keyword">const</span> <span class="keywordtype">char</span> *zEllipsis = <span class="stringliteral">&quot;&lt;b&gt;...&lt;/b&gt;&quot;</span>;
<a name="l03225"></a>03225     memcpy(&amp;pCursor, <a class="code" href="sqlite3_8h.html#a81138be97f3e5124e33fb50925b710b6">sqlite3_value_blob</a>(argv[0]), <span class="keyword">sizeof</span>(pCursor));
<a name="l03226"></a>03226     <span class="keywordflow">if</span>( argc&gt;=2 ){
<a name="l03227"></a>03227       zStart = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[1]);
<a name="l03228"></a>03228       <span class="keywordflow">if</span>( argc&gt;=3 ){
<a name="l03229"></a>03229         zEnd = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[2]);
<a name="l03230"></a>03230         <span class="keywordflow">if</span>( argc&gt;=4 ){
<a name="l03231"></a>03231           zEllipsis = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[3]);
<a name="l03232"></a>03232         }
<a name="l03233"></a>03233       }
<a name="l03234"></a>03234     }
<a name="l03235"></a>03235     <a class="code" href="fts1_8c.html#a59f88d7e78ca82c2ded0ad6d0dc761cf">snippetAllOffsets</a>(pCursor);
<a name="l03236"></a>03236     <a class="code" href="fts1_8c.html#a27d12dfb6aab92e44fc0af3dc2a72ad7">snippetText</a>(pCursor, zStart, zEnd, zEllipsis);
<a name="l03237"></a>03237     <a class="code" href="sqlite3_8h.html#a2dfd2d971e743b8d5a24725606a733ac">sqlite3_result_text</a>(pContext, pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a>,
<a name="l03238"></a>03238                         pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a467392bb026bc056ab7c5466873f8f11">nSnippet</a>, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l03239"></a>03239   }
<a name="l03240"></a>03240 }
<a name="l03241"></a>03241 
<a name="l03242"></a>03242 <span class="comment">/*</span>
<a name="l03243"></a>03243 <span class="comment">** Implementation of the offsets() function for FTS1</span>
<a name="l03244"></a>03244 <span class="comment">*/</span>
<a name="l03245"></a><a class="code" href="fts1_8c.html#a3f6879fa82ea5cee0633e4f0c2acb89e">03245</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts1_8c.html#a3f6879fa82ea5cee0633e4f0c2acb89e">snippetOffsetsFunc</a>(
<a name="l03246"></a>03246   <a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext,
<a name="l03247"></a>03247   <span class="keywordtype">int</span> argc,
<a name="l03248"></a>03248   <a class="code" href="structMem.html">sqlite3_value</a> **argv
<a name="l03249"></a>03249 ){
<a name="l03250"></a>03250   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *pCursor;
<a name="l03251"></a>03251   <span class="keywordflow">if</span>( argc&lt;1 ) <span class="keywordflow">return</span>;
<a name="l03252"></a>03252   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(argv[0])!=<a class="code" href="sqlite3_8h.html#a26c29a137b2a35bbde7048e5e48b794a">SQLITE_BLOB</a> ||
<a name="l03253"></a>03253       <a class="code" href="sqlite3_8h.html#a2aff2bf1311b5bd05d8e30738445b186">sqlite3_value_bytes</a>(argv[0])!=<span class="keyword">sizeof</span>(pCursor) ){
<a name="l03254"></a>03254     <a class="code" href="sqlite3_8h.html#a02826d87e45fd4f04445a3c99a14b54e">sqlite3_result_error</a>(pContext, <span class="stringliteral">&quot;illegal first argument to offsets&quot;</span>,-1);
<a name="l03255"></a>03255   }<span class="keywordflow">else</span>{
<a name="l03256"></a>03256     memcpy(&amp;pCursor, <a class="code" href="sqlite3_8h.html#a81138be97f3e5124e33fb50925b710b6">sqlite3_value_blob</a>(argv[0]), <span class="keyword">sizeof</span>(pCursor));
<a name="l03257"></a>03257     <a class="code" href="fts1_8c.html#a59f88d7e78ca82c2ded0ad6d0dc761cf">snippetAllOffsets</a>(pCursor);
<a name="l03258"></a>03258     <a class="code" href="fts1_8c.html#a0be87d3def9290916cff3b6cb84f04bc">snippetOffsetText</a>(&amp;pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>);
<a name="l03259"></a>03259     <a class="code" href="sqlite3_8h.html#a2dfd2d971e743b8d5a24725606a733ac">sqlite3_result_text</a>(pContext,
<a name="l03260"></a>03260                         pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a>, pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a68aacd704960f6ab1c8f7de23a5d0730">nOffset</a>,
<a name="l03261"></a>03261                         <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l03262"></a>03262   }
<a name="l03263"></a>03263 }
<a name="l03264"></a>03264 
<a name="l03265"></a>03265 <span class="comment">/*</span>
<a name="l03266"></a>03266 <span class="comment">** This routine implements the xFindFunction method for the FTS1</span>
<a name="l03267"></a>03267 <span class="comment">** virtual table.</span>
<a name="l03268"></a>03268 <span class="comment">*/</span>
<a name="l03269"></a><a class="code" href="fts1_8c.html#a7cb32fb10372dfd938ed8fe350c6be86">03269</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a7cb32fb10372dfd938ed8fe350c6be86">fulltextFindFunction</a>(
<a name="l03270"></a>03270   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab,
<a name="l03271"></a>03271   <span class="keywordtype">int</span> nArg,
<a name="l03272"></a>03272   <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,
<a name="l03273"></a>03273   <span class="keywordtype">void</span> (**pxFunc)(<a class="code" href="structsqlite3__context.html">sqlite3_context</a>*,<span class="keywordtype">int</span>,<a class="code" href="structMem.html">sqlite3_value</a>**),
<a name="l03274"></a>03274   <span class="keywordtype">void</span> **ppArg
<a name="l03275"></a>03275 ){
<a name="l03276"></a>03276   <span class="keywordflow">if</span>( strcmp(zName,<span class="stringliteral">&quot;snippet&quot;</span>)==0 ){
<a name="l03277"></a>03277     *pxFunc = <a class="code" href="fts1_8c.html#a57b1d2e6eb52243a8c4a2a32f238dc03">snippetFunc</a>;
<a name="l03278"></a>03278     <span class="keywordflow">return</span> 1;
<a name="l03279"></a>03279   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( strcmp(zName,<span class="stringliteral">&quot;offsets&quot;</span>)==0 ){
<a name="l03280"></a>03280     *pxFunc = <a class="code" href="fts1_8c.html#a3f6879fa82ea5cee0633e4f0c2acb89e">snippetOffsetsFunc</a>;
<a name="l03281"></a>03281     <span class="keywordflow">return</span> 1;
<a name="l03282"></a>03282   }
<a name="l03283"></a>03283   <span class="keywordflow">return</span> 0;
<a name="l03284"></a>03284 }
<a name="l03285"></a>03285 
<a name="l03286"></a>03286 <span class="comment">/*</span>
<a name="l03287"></a>03287 <span class="comment">** Rename an fts1 table.</span>
<a name="l03288"></a>03288 <span class="comment">*/</span>
<a name="l03289"></a><a class="code" href="fts1_8c.html#a960164105e1dc37b37c8bde9edac2bfc">03289</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#a960164105e1dc37b37c8bde9edac2bfc">fulltextRename</a>(
<a name="l03290"></a>03290   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab,
<a name="l03291"></a>03291   <span class="keyword">const</span> <span class="keywordtype">char</span> *zName
<a name="l03292"></a>03292 ){
<a name="l03293"></a>03293   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *p = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVtab;
<a name="l03294"></a>03294   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l03295"></a>03295   <span class="keywordtype">char</span> *zSql = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(
<a name="l03296"></a>03296     <span class="stringliteral">&quot;ALTER TABLE %Q.&apos;%q_content&apos;  RENAME TO &apos;%q_content&apos;;&quot;</span>
<a name="l03297"></a>03297     <span class="stringliteral">&quot;ALTER TABLE %Q.&apos;%q_term&apos; RENAME TO &apos;%q_term&apos;;&quot;</span>
<a name="l03298"></a>03298     , p-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, p-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, zName
<a name="l03299"></a>03299     , p-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, p-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, zName
<a name="l03300"></a>03300   );
<a name="l03301"></a>03301   <span class="keywordflow">if</span>( zSql ){
<a name="l03302"></a>03302     rc = <a class="code" href="legacy_8c.html#ada787486cf95a994521cfd0c64e853e4">sqlite3_exec</a>(p-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, zSql, 0, 0, 0);
<a name="l03303"></a>03303     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zSql);
<a name="l03304"></a>03304   }
<a name="l03305"></a>03305   <span class="keywordflow">return</span> rc;
<a name="l03306"></a>03306 }
<a name="l03307"></a>03307 
<a name="l03308"></a>03308 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> fulltextModule = {
<a name="l03309"></a>03309   <span class="comment">/* iVersion      */</span> 0,
<a name="l03310"></a>03310   <span class="comment">/* xCreate       */</span> <a class="code" href="fts1_8c.html#a0d5b27c0376561066f14ab3a59d8b6a2">fulltextCreate</a>,
<a name="l03311"></a>03311   <span class="comment">/* xConnect      */</span> <a class="code" href="fts1_8c.html#a42d060bb429eb8ae7a86e9042b4fb232">fulltextConnect</a>,
<a name="l03312"></a>03312   <span class="comment">/* xBestIndex    */</span> <a class="code" href="fts1_8c.html#abf18e0da44ece3b370a714c8e95e2de6">fulltextBestIndex</a>,
<a name="l03313"></a>03313   <span class="comment">/* xDisconnect   */</span> <a class="code" href="fts1_8c.html#a8314ee27dd1e598b803db35bf1aa393d">fulltextDisconnect</a>,
<a name="l03314"></a>03314   <span class="comment">/* xDestroy      */</span> <a class="code" href="fts1_8c.html#ace0e89f70928f42ce6dc7769c8309ba6">fulltextDestroy</a>,
<a name="l03315"></a>03315   <span class="comment">/* xOpen         */</span> <a class="code" href="fts1_8c.html#a124d1580023f422308936a6fad63ce4f">fulltextOpen</a>,
<a name="l03316"></a>03316   <span class="comment">/* xClose        */</span> <a class="code" href="fts1_8c.html#ae78b3ae93fcfb9b8b2e8b4dc9a380ad7">fulltextClose</a>,
<a name="l03317"></a>03317   <span class="comment">/* xFilter       */</span> <a class="code" href="fts1_8c.html#a77f0a9cad4b0dcb1a60143d08036b466">fulltextFilter</a>,
<a name="l03318"></a>03318   <span class="comment">/* xNext         */</span> <a class="code" href="fts1_8c.html#a27014ab01a3b771ad685bf0a66ae0f74">fulltextNext</a>,
<a name="l03319"></a>03319   <span class="comment">/* xEof          */</span> <a class="code" href="fts1_8c.html#a04b7b39869da7e2457f1605884eaada7">fulltextEof</a>,
<a name="l03320"></a>03320   <span class="comment">/* xColumn       */</span> <a class="code" href="fts1_8c.html#a1150d2b45c324680b8f663999690251f">fulltextColumn</a>,
<a name="l03321"></a>03321   <span class="comment">/* xRowid        */</span> <a class="code" href="fts1_8c.html#a4ede5546134709d20eed03b0b16c85e1">fulltextRowid</a>,
<a name="l03322"></a>03322   <span class="comment">/* xUpdate       */</span> <a class="code" href="fts1_8c.html#a8e291fd12023cffe80976a33530e839d">fulltextUpdate</a>,
<a name="l03323"></a>03323   <span class="comment">/* xBegin        */</span> 0, 
<a name="l03324"></a>03324   <span class="comment">/* xSync         */</span> 0,
<a name="l03325"></a>03325   <span class="comment">/* xCommit       */</span> 0,
<a name="l03326"></a>03326   <span class="comment">/* xRollback     */</span> 0,
<a name="l03327"></a>03327   <span class="comment">/* xFindFunction */</span> <a class="code" href="fts1_8c.html#a7cb32fb10372dfd938ed8fe350c6be86">fulltextFindFunction</a>,
<a name="l03328"></a>03328   <span class="comment">/* xRename       */</span> <a class="code" href="fts1_8c.html#a960164105e1dc37b37c8bde9edac2bfc">fulltextRename</a>,
<a name="l03329"></a>03329 };
<a name="l03330"></a>03330 
<a name="l03331"></a><a class="code" href="fts1_8h.html#afcb112c295d00de42e534e51d51db017">03331</a> <span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#afcb112c295d00de42e534e51d51db017">sqlite3Fts1Init</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>){
<a name="l03332"></a>03332   <a class="code" href="main_8c.html#a6bb015d93679bb25951ed1ce935a4261">sqlite3_overload_function</a>(db, <span class="stringliteral">&quot;snippet&quot;</span>, -1);
<a name="l03333"></a>03333   <a class="code" href="main_8c.html#a6bb015d93679bb25951ed1ce935a4261">sqlite3_overload_function</a>(db, <span class="stringliteral">&quot;offsets&quot;</span>, -1);
<a name="l03334"></a>03334   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#aa7c20cb7a8d6657d5ef52760429b2cd8">sqlite3_create_module</a>(db, <span class="stringliteral">&quot;fts1&quot;</span>, &amp;fulltextModule, 0);
<a name="l03335"></a>03335 }
<a name="l03336"></a>03336 
<a name="l03337"></a>03337 <span class="preprocessor">#if !SQLITE_CORE</span>
<a name="l03338"></a><a class="code" href="fts1_8c.html#aa42ef32f7f9c08b35a1c1984e1006606">03338</a> <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#aa42ef32f7f9c08b35a1c1984e1006606">sqlite3_extension_init</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <span class="keywordtype">char</span> **pzErrMsg,
<a name="l03339"></a>03339                            <span class="keyword">const</span> <a class="code" href="structsqlite3__api__routines.html">sqlite3_api_routines</a> *pApi){
<a name="l03340"></a>03340   <a class="code" href="sqlite3ext_8h.html#a472c32f7c8217246a63b2bceb680d273">SQLITE_EXTENSION_INIT2</a>(pApi)
<a name="l03341"></a>03341   <span class="keywordflow">return</span> <a class="code" href="fts1_8c.html#afcb112c295d00de42e534e51d51db017">sqlite3Fts1Init</a>(db);
<a name="l03342"></a>03342 }
<a name="l03343"></a>03343 <span class="preprocessor">#endif</span>
<a name="l03344"></a>03344 <span class="preprocessor"></span>
<a name="l03345"></a>03345 <span class="preprocessor">#endif </span><span class="comment">/* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1) */</span>
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:53 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
