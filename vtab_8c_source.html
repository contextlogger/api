<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: vtab.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>vtab.c</h1><a href="vtab_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">** 2006 June 10</span>
<a name="l00003"></a>00003 <span class="comment">**</span>
<a name="l00004"></a>00004 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00005"></a>00005 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00006"></a>00006 <span class="comment">**</span>
<a name="l00007"></a>00007 <span class="comment">**    May you do good and not evil.</span>
<a name="l00008"></a>00008 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00009"></a>00009 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">*************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment">** This file contains code used to help implement virtual tables.</span>
<a name="l00013"></a>00013 <span class="comment">**</span>
<a name="l00014"></a>00014 <span class="comment">** $Id: vtab.c,v 1.76 2008/08/20 16:35:10 drh Exp $</span>
<a name="l00015"></a>00015 <span class="comment">*/</span>
<a name="l00016"></a>00016 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="sqliteInt_8h.html">sqliteInt.h</a>&quot;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a><a class="code" href="vtab_8c.html#a77134e0947164db4ca98b4b516bfdf6b">00019</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="vtab_8c.html#a77134e0947164db4ca98b4b516bfdf6b">createModule</a>(
<a name="l00020"></a>00020   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>,                    <span class="comment">/* Database in which module is registered */</span>
<a name="l00021"></a>00021   <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,              <span class="comment">/* Name assigned to this module */</span>
<a name="l00022"></a>00022   <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule,  <span class="comment">/* The definition of the module */</span>
<a name="l00023"></a>00023   <span class="keywordtype">void</span> *pAux,                     <span class="comment">/* Context pointer for xCreate/xConnect */</span>
<a name="l00024"></a>00024   <span class="keywordtype">void</span> (*xDestroy)(<span class="keywordtype">void</span> *)        <span class="comment">/* Module destructor function */</span>
<a name="l00025"></a>00025 ) {
<a name="l00026"></a>00026   <span class="keywordtype">int</span> rc, nName;
<a name="l00027"></a>00027   <a class="code" href="structModule.html">Module</a> *pMod;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029   <a class="code" href="mutex_8h.html#afbab5dc0108b65678f2fa579473041ac">sqlite3_mutex_enter</a>(db-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>);
<a name="l00030"></a>00030   nName = strlen(zName);
<a name="l00031"></a>00031   pMod = (<a class="code" href="structModule.html">Module</a> *)<a class="code" href="malloc_8c.html#a043f868d32456bd7cdca4a62837277c1">sqlite3DbMallocRaw</a>(db, <span class="keyword">sizeof</span>(<a class="code" href="structModule.html">Module</a>) + nName + 1);
<a name="l00032"></a>00032   <span class="keywordflow">if</span>( pMod ){
<a name="l00033"></a>00033     <a class="code" href="structModule.html">Module</a> *pDel;
<a name="l00034"></a>00034     <span class="keywordtype">char</span> *zCopy = (<span class="keywordtype">char</span> *)(&amp;pMod[1]);
<a name="l00035"></a>00035     memcpy(zCopy, zName, nName+1);
<a name="l00036"></a>00036     pMod-&gt;<a class="code" href="structModule.html#a45a5f5b43926b8ebf3e13e46a6534810">zName</a> = zCopy;
<a name="l00037"></a>00037     pMod-&gt;<a class="code" href="structModule.html#a65d2539d71ea028b505b2fb33563bfd7">pModule</a> = pModule;
<a name="l00038"></a>00038     pMod-&gt;<a class="code" href="structModule.html#ae3b827fee4c8b4f3ff38c86c2e2f48cd">pAux</a> = pAux;
<a name="l00039"></a>00039     pMod-&gt;<a class="code" href="structModule.html#a4be509110a1a2f2c06a5d69af45704ca">xDestroy</a> = xDestroy;
<a name="l00040"></a>00040     pDel = (<a class="code" href="structModule.html">Module</a> *)<a class="code" href="hash_8c.html#af5451f0baf1a33b5e006c9312e326dc8">sqlite3HashInsert</a>(&amp;db-&gt;<a class="code" href="structsqlite3.html#a1e03e1fdee6fb7cb7337628c7f9b37c4">aModule</a>, zCopy, nName, (<span class="keywordtype">void</span>*)pMod);
<a name="l00041"></a>00041     <span class="keywordflow">if</span>( pDel &amp;&amp; pDel-&gt;<a class="code" href="structModule.html#a4be509110a1a2f2c06a5d69af45704ca">xDestroy</a> ){
<a name="l00042"></a>00042       pDel-&gt;<a class="code" href="structModule.html#a4be509110a1a2f2c06a5d69af45704ca">xDestroy</a>(pDel-&gt;<a class="code" href="structModule.html#ae3b827fee4c8b4f3ff38c86c2e2f48cd">pAux</a>);
<a name="l00043"></a>00043     }
<a name="l00044"></a>00044     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pDel);
<a name="l00045"></a>00045     <span class="keywordflow">if</span>( pDel==pMod ){
<a name="l00046"></a>00046       db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l00047"></a>00047     }
<a name="l00048"></a>00048     <a class="code" href="build_8c.html#a67e7c0c4f9880fb86514ef03643b1cd2">sqlite3ResetInternalSchema</a>(db, 0);
<a name="l00049"></a>00049   }
<a name="l00050"></a>00050   rc = <a class="code" href="malloc_8c.html#a5ace6847fdf42079e5ec21f3d54d601b">sqlite3ApiExit</a>(db, <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>);
<a name="l00051"></a>00051   <a class="code" href="mutex_8h.html#aba06556afc1a17868af4675ba856701c">sqlite3_mutex_leave</a>(db-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>);
<a name="l00052"></a>00052   <span class="keywordflow">return</span> rc;
<a name="l00053"></a>00053 }
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">/*</span>
<a name="l00057"></a>00057 <span class="comment">** External API function used to create a new virtual-table module.</span>
<a name="l00058"></a>00058 <span class="comment">*/</span>
<a name="l00059"></a><a class="code" href="vtab_8c.html#af019ad95b7e9690edd88439a49384a70">00059</a> <span class="keywordtype">int</span> <a class="code" href="sqlite3_8h.html#aa7c20cb7a8d6657d5ef52760429b2cd8">sqlite3_create_module</a>(
<a name="l00060"></a>00060   <a class="code" href="structsqlite3.html">sqlite3</a> *db,                    <span class="comment">/* Database in which module is registered */</span>
<a name="l00061"></a>00061   <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,              <span class="comment">/* Name assigned to this module */</span>
<a name="l00062"></a>00062   <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule,  <span class="comment">/* The definition of the module */</span>
<a name="l00063"></a>00063   <span class="keywordtype">void</span> *pAux                      <span class="comment">/* Context pointer for xCreate/xConnect */</span>
<a name="l00064"></a>00064 ){
<a name="l00065"></a>00065   <span class="keywordflow">return</span> <a class="code" href="vtab_8c.html#a77134e0947164db4ca98b4b516bfdf6b">createModule</a>(db, zName, pModule, pAux, 0);
<a name="l00066"></a>00066 }
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="comment">/*</span>
<a name="l00069"></a>00069 <span class="comment">** External API function used to create a new virtual-table module.</span>
<a name="l00070"></a>00070 <span class="comment">*/</span>
<a name="l00071"></a><a class="code" href="vtab_8c.html#a8d3d71e870078f121a1b47ec61f11910">00071</a> <span class="keywordtype">int</span> <a class="code" href="sqlite3_8h.html#a721d3b2e12b6c39cf4bb21b678c403ce">sqlite3_create_module_v2</a>(
<a name="l00072"></a>00072   <a class="code" href="structsqlite3.html">sqlite3</a> *db,                    <span class="comment">/* Database in which module is registered */</span>
<a name="l00073"></a>00073   <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,              <span class="comment">/* Name assigned to this module */</span>
<a name="l00074"></a>00074   <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule,  <span class="comment">/* The definition of the module */</span>
<a name="l00075"></a>00075   <span class="keywordtype">void</span> *pAux,                     <span class="comment">/* Context pointer for xCreate/xConnect */</span>
<a name="l00076"></a>00076   <span class="keywordtype">void</span> (*xDestroy)(<span class="keywordtype">void</span> *)        <span class="comment">/* Module destructor function */</span>
<a name="l00077"></a>00077 ){
<a name="l00078"></a>00078   <span class="keywordflow">return</span> <a class="code" href="vtab_8c.html#a77134e0947164db4ca98b4b516bfdf6b">createModule</a>(db, zName, pModule, pAux, xDestroy);
<a name="l00079"></a>00079 }
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">/*</span>
<a name="l00082"></a>00082 <span class="comment">** Lock the virtual table so that it cannot be disconnected.</span>
<a name="l00083"></a>00083 <span class="comment">** Locks nest.  Every lock should have a corresponding unlock.</span>
<a name="l00084"></a>00084 <span class="comment">** If an unlock is omitted, resources leaks will occur.  </span>
<a name="l00085"></a>00085 <span class="comment">**</span>
<a name="l00086"></a>00086 <span class="comment">** If a disconnect is attempted while a virtual table is locked,</span>
<a name="l00087"></a>00087 <span class="comment">** the disconnect is deferred until all locks have been removed.</span>
<a name="l00088"></a>00088 <span class="comment">*/</span>
<a name="l00089"></a><a class="code" href="vtab_8c.html#a9064cca7694f546a3f7ce5a9b729356a">00089</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#abea58f5048efa3c3820a4ade28047696">sqlite3VtabLock</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab){
<a name="l00090"></a>00090   pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#ab3c80d385849bdd82363a0df7d6fcba8">nRef</a>++;
<a name="l00091"></a>00091 }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="comment">/*</span>
<a name="l00094"></a>00094 <span class="comment">** Unlock a virtual table.  When the last lock is removed,</span>
<a name="l00095"></a>00095 <span class="comment">** disconnect the virtual table.</span>
<a name="l00096"></a>00096 <span class="comment">*/</span>
<a name="l00097"></a><a class="code" href="vtab_8c.html#af042c53eedfd33fdbbb28f481e3b6c72">00097</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#a13ba8c3126d20b116817f197da61f0c9">sqlite3VtabUnlock</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab){
<a name="l00098"></a>00098   pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#ab3c80d385849bdd82363a0df7d6fcba8">nRef</a>--;
<a name="l00099"></a>00099   assert(db);
<a name="l00100"></a>00100   assert( <a class="code" href="sqliteInt_8h.html#aab020605a0d83080a5db8fae5e51db2e">sqlite3SafetyCheckOk</a>(db) );
<a name="l00101"></a>00101   <span class="keywordflow">if</span>( pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#ab3c80d385849bdd82363a0df7d6fcba8">nRef</a>==0 ){
<a name="l00102"></a>00102     <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a6d9069c555657020c5dd1532d8e9c3f9">magic</a>==<a class="code" href="sqliteInt_8h.html#ad024aa586d9bf98f26fccca95f21b265">SQLITE_MAGIC_BUSY</a> ){
<a name="l00103"></a>00103       (void)<a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db);
<a name="l00104"></a>00104       pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>-&gt;<a class="code" href="structsqlite3__module.html#a5dbaa6ff075eaff25ccfddaedba06934">xDisconnect</a>(pVtab);
<a name="l00105"></a>00105       (void)<a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db);
<a name="l00106"></a>00106     } <span class="keywordflow">else</span> {
<a name="l00107"></a>00107       pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>-&gt;<a class="code" href="structsqlite3__module.html#a5dbaa6ff075eaff25ccfddaedba06934">xDisconnect</a>(pVtab);
<a name="l00108"></a>00108     }
<a name="l00109"></a>00109   }
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">/*</span>
<a name="l00113"></a>00113 <span class="comment">** Clear any and all virtual-table information from the Table record.</span>
<a name="l00114"></a>00114 <span class="comment">** This routine is called, for example, just before deleting the Table</span>
<a name="l00115"></a>00115 <span class="comment">** record.</span>
<a name="l00116"></a>00116 <span class="comment">*/</span>
<a name="l00117"></a><a class="code" href="vtab_8c.html#aad087c55e0a472e0c0149894c608f0a5">00117</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#a263ed14245feeaa258a538fd02d5715a">sqlite3VtabClear</a>(<a class="code" href="structTable.html">Table</a> *p){
<a name="l00118"></a>00118   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = p-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a>;
<a name="l00119"></a>00119   <a class="code" href="structsqlite3.html">sqlite3</a> *db = p-&gt;<a class="code" href="structTable.html#af634cb1a4b17efc63af05dd1a7d65e63">db</a>;
<a name="l00120"></a>00120   <span class="keywordflow">if</span>( pVtab ){
<a name="l00121"></a>00121     assert( p-&gt;<a class="code" href="structTable.html#a6d371ddd8755a2b0a93413d99e683914">pMod</a> &amp;&amp; p-&gt;<a class="code" href="structTable.html#a6d371ddd8755a2b0a93413d99e683914">pMod</a>-&gt;<a class="code" href="structModule.html#a65d2539d71ea028b505b2fb33563bfd7">pModule</a> );
<a name="l00122"></a>00122     <a class="code" href="sqliteInt_8h.html#a13ba8c3126d20b116817f197da61f0c9">sqlite3VtabUnlock</a>(db, pVtab);
<a name="l00123"></a>00123     p-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a> = 0;
<a name="l00124"></a>00124   }
<a name="l00125"></a>00125   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a> ){
<a name="l00126"></a>00126     <span class="keywordtype">int</span> i;
<a name="l00127"></a>00127     <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structTable.html#a74a2c5547ea876ebe77dbea0d99361bf">nModuleArg</a>; i++){
<a name="l00128"></a>00128       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>[i]);
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>);
<a name="l00131"></a>00131   }
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="comment">/*</span>
<a name="l00135"></a>00135 <span class="comment">** Add a new module argument to pTable-&gt;azModuleArg[].</span>
<a name="l00136"></a>00136 <span class="comment">** The string is not copied - the pointer is stored.  The</span>
<a name="l00137"></a>00137 <span class="comment">** string will be freed automatically when the table is</span>
<a name="l00138"></a>00138 <span class="comment">** deleted.</span>
<a name="l00139"></a>00139 <span class="comment">*/</span>
<a name="l00140"></a><a class="code" href="vtab_8c.html#a3020ed4a4b05f9a18e8ab695a182ce92">00140</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vtab_8c.html#a3020ed4a4b05f9a18e8ab695a182ce92">addModuleArgument</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <a class="code" href="structTable.html">Table</a> *pTable, <span class="keywordtype">char</span> *zArg){
<a name="l00141"></a>00141   <span class="keywordtype">int</span> i = pTable-&gt;<a class="code" href="structTable.html#a74a2c5547ea876ebe77dbea0d99361bf">nModuleArg</a>++;
<a name="l00142"></a>00142   <span class="keywordtype">int</span> nBytes = <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *)*(1+pTable-&gt;<a class="code" href="structTable.html#a74a2c5547ea876ebe77dbea0d99361bf">nModuleArg</a>);
<a name="l00143"></a>00143   <span class="keywordtype">char</span> **azModuleArg;
<a name="l00144"></a>00144   azModuleArg = <a class="code" href="malloc_8c.html#a5fd070055efafc36faa4e6092329d224">sqlite3DbRealloc</a>(db, pTable-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>, nBytes);
<a name="l00145"></a>00145   <span class="keywordflow">if</span>( azModuleArg==0 ){
<a name="l00146"></a>00146     <span class="keywordtype">int</span> j;
<a name="l00147"></a>00147     <span class="keywordflow">for</span>(j=0; j&lt;i; j++){
<a name="l00148"></a>00148       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pTable-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>[j]);
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zArg);
<a name="l00151"></a>00151     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pTable-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>);
<a name="l00152"></a>00152     pTable-&gt;<a class="code" href="structTable.html#a74a2c5547ea876ebe77dbea0d99361bf">nModuleArg</a> = 0;
<a name="l00153"></a>00153   }<span class="keywordflow">else</span>{
<a name="l00154"></a>00154     azModuleArg[i] = zArg;
<a name="l00155"></a>00155     azModuleArg[i+1] = 0;
<a name="l00156"></a>00156   }
<a name="l00157"></a>00157   pTable-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a> = azModuleArg;
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="comment">/*</span>
<a name="l00161"></a>00161 <span class="comment">** The parser calls this routine when it first sees a CREATE VIRTUAL TABLE</span>
<a name="l00162"></a>00162 <span class="comment">** statement.  The module name has been parsed, but the optional list</span>
<a name="l00163"></a>00163 <span class="comment">** of parameters that follow the module name are still pending.</span>
<a name="l00164"></a>00164 <span class="comment">*/</span>
<a name="l00165"></a><a class="code" href="vtab_8c.html#a821d6e17697b5d50ddb67923273b88e1">00165</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#abc68cd7647f1cf55a581c3e1ae3ef44f">sqlite3VtabBeginParse</a>(
<a name="l00166"></a>00166   <a class="code" href="structParse.html">Parse</a> *pParse,        <span class="comment">/* Parsing context */</span>
<a name="l00167"></a>00167   <a class="code" href="structToken.html">Token</a> *pName1,        <span class="comment">/* Name of new table, or database name */</span>
<a name="l00168"></a>00168   <a class="code" href="structToken.html">Token</a> *pName2,        <span class="comment">/* Name of new table or NULL */</span>
<a name="l00169"></a>00169   <a class="code" href="structToken.html">Token</a> *pModuleName    <span class="comment">/* Name of the module for the virtual table */</span>
<a name="l00170"></a>00170 ){
<a name="l00171"></a>00171   <span class="keywordtype">int</span> iDb;              <span class="comment">/* The database the table is being created in */</span>
<a name="l00172"></a>00172   <a class="code" href="structTable.html">Table</a> *pTable;        <span class="comment">/* The new virtual table */</span>
<a name="l00173"></a>00173   <a class="code" href="structsqlite3.html">sqlite3</a> *db;          <span class="comment">/* Database connection */</span>
<a name="l00174"></a>00174 
<a name="l00175"></a>00175   <span class="keywordflow">if</span>( pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a7c5cd3f09f5f14658d2725833122563b">SQLITE_SharedCache</a> ){
<a name="l00176"></a>00176     <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;Cannot use virtual tables in shared-cache mode&quot;</span>);
<a name="l00177"></a>00177     <span class="keywordflow">return</span>;
<a name="l00178"></a>00178   }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180   <a class="code" href="build_8c.html#a12bca896cce6a5fbe72708eacdd4e800">sqlite3StartTable</a>(pParse, pName1, pName2, 0, 0, 1, 0);
<a name="l00181"></a>00181   pTable = pParse-&gt;<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>;
<a name="l00182"></a>00182   <span class="keywordflow">if</span>( pTable==0 || pParse-&gt;<a class="code" href="structParse.html#ac7206f0c7e580ab32b7dfb20950bb1c9">nErr</a> ) <span class="keywordflow">return</span>;
<a name="l00183"></a>00183   assert( 0==pTable-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a> );
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   db = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00186"></a>00186   iDb = <a class="code" href="prepare_8c.html#aecd8922611e561d76d5e9f16655e8a7c">sqlite3SchemaToIndex</a>(db, pTable-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>);
<a name="l00187"></a>00187   assert( iDb&gt;=0 );
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   pTable-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> |= <a class="code" href="sqliteInt_8h.html#a350a16ec7aacc6d6eb749ab327e7b4f1">TF_Virtual</a>;
<a name="l00190"></a>00190   pTable-&gt;<a class="code" href="structTable.html#a74a2c5547ea876ebe77dbea0d99361bf">nModuleArg</a> = 0;
<a name="l00191"></a>00191   <a class="code" href="vtab_8c.html#a3020ed4a4b05f9a18e8ab695a182ce92">addModuleArgument</a>(db, pTable, <a class="code" href="build_8c.html#a19bf99e43ecbf922cb3bba8777dbc381">sqlite3NameFromToken</a>(db, pModuleName));
<a name="l00192"></a>00192   <a class="code" href="vtab_8c.html#a3020ed4a4b05f9a18e8ab695a182ce92">addModuleArgument</a>(db, pTable, <a class="code" href="malloc_8c.html#aa75e87f512f3cb7a48175b26dba47ebb">sqlite3DbStrDup</a>(db, db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>));
<a name="l00193"></a>00193   <a class="code" href="vtab_8c.html#a3020ed4a4b05f9a18e8ab695a182ce92">addModuleArgument</a>(db, pTable, <a class="code" href="malloc_8c.html#aa75e87f512f3cb7a48175b26dba47ebb">sqlite3DbStrDup</a>(db, pTable-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>));
<a name="l00194"></a>00194   pParse-&gt;<a class="code" href="structParse.html#afd929c54566cfc4d6f748fcc6b79b973">sNameToken</a>.<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> = pModuleName-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> + pModuleName-&gt;<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> - pName1-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTHORIZATION</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>  <span class="comment">/* Creating a virtual table invokes the authorization callback twice.</span>
<a name="l00198"></a>00198 <span class="comment">  ** The first invocation, to obtain permission to INSERT a row into the</span>
<a name="l00199"></a>00199 <span class="comment">  ** sqlite_master table, has already been made by sqlite3StartTable().</span>
<a name="l00200"></a>00200 <span class="comment">  ** The second call, to obtain permission to create the table, is made now.</span>
<a name="l00201"></a>00201 <span class="comment">  */</span>
<a name="l00202"></a>00202   <span class="keywordflow">if</span>( pTable-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a> ){
<a name="l00203"></a>00203     <a class="code" href="auth_8c.html#a7c993bc216f5c07cf032f3123167d658">sqlite3AuthCheck</a>(pParse, <a class="code" href="sqlite3_8h.html#a561f96d54c59cc5df8f7d13489fd5820">SQLITE_CREATE_VTABLE</a>, pTable-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>, 
<a name="l00204"></a>00204             pTable-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>[0], pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>);
<a name="l00205"></a>00205   }
<a name="l00206"></a>00206 <span class="preprocessor">#endif</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span>}
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="comment">/*</span>
<a name="l00210"></a>00210 <span class="comment">** This routine takes the module argument that has been accumulating</span>
<a name="l00211"></a>00211 <span class="comment">** in pParse-&gt;zArg[] and appends it to the list of arguments on the</span>
<a name="l00212"></a>00212 <span class="comment">** virtual table currently under construction in pParse-&gt;pTable.</span>
<a name="l00213"></a>00213 <span class="comment">*/</span>
<a name="l00214"></a><a class="code" href="vtab_8c.html#aaf61ce8b4c243cd606a04cddde684b9c">00214</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vtab_8c.html#aaf61ce8b4c243cd606a04cddde684b9c">addArgumentToVtab</a>(<a class="code" href="structParse.html">Parse</a> *pParse){
<a name="l00215"></a>00215   <span class="keywordflow">if</span>( pParse-&gt;<a class="code" href="structParse.html#aa3fe38b31dd1cd0fbea4de0e77891642">sArg</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> &amp;&amp; pParse-&gt;<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a> ){
<a name="l00216"></a>00216     <span class="keyword">const</span> <span class="keywordtype">char</span> *z = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)pParse-&gt;<a class="code" href="structParse.html#aa3fe38b31dd1cd0fbea4de0e77891642">sArg</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>;
<a name="l00217"></a>00217     <span class="keywordtype">int</span> n = pParse-&gt;<a class="code" href="structParse.html#aa3fe38b31dd1cd0fbea4de0e77891642">sArg</a>.<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a>;
<a name="l00218"></a>00218     <a class="code" href="structsqlite3.html">sqlite3</a> *db = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00219"></a>00219     <a class="code" href="vtab_8c.html#a3020ed4a4b05f9a18e8ab695a182ce92">addModuleArgument</a>(db, pParse-&gt;<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>, <a class="code" href="malloc_8c.html#a17fab011bf22c10e5f74813f08404f63">sqlite3DbStrNDup</a>(db, z, n));
<a name="l00220"></a>00220   }
<a name="l00221"></a>00221 }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 <span class="comment">/*</span>
<a name="l00224"></a>00224 <span class="comment">** The parser calls this routine after the CREATE VIRTUAL TABLE statement</span>
<a name="l00225"></a>00225 <span class="comment">** has been completely parsed.</span>
<a name="l00226"></a>00226 <span class="comment">*/</span>
<a name="l00227"></a><a class="code" href="vtab_8c.html#a0df2c82a6d952e119ba51734af7035eb">00227</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#a9ee36621958797d62102347c82dd49a7">sqlite3VtabFinishParse</a>(<a class="code" href="structParse.html">Parse</a> *pParse, <a class="code" href="structToken.html">Token</a> *pEnd){
<a name="l00228"></a>00228   <a class="code" href="structTable.html">Table</a> *pTab;        <span class="comment">/* The table being constructed */</span>
<a name="l00229"></a>00229   <a class="code" href="structsqlite3.html">sqlite3</a> *db;        <span class="comment">/* The database connection */</span>
<a name="l00230"></a>00230   <span class="keywordtype">char</span> *zModule;      <span class="comment">/* The module name of the table: USING modulename */</span>
<a name="l00231"></a>00231   <a class="code" href="structModule.html">Module</a> *pMod = 0;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   <a class="code" href="vtab_8c.html#aaf61ce8b4c243cd606a04cddde684b9c">addArgumentToVtab</a>(pParse);
<a name="l00234"></a>00234   pParse-&gt;<a class="code" href="structParse.html#aa3fe38b31dd1cd0fbea4de0e77891642">sArg</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> = 0;
<a name="l00235"></a>00235 
<a name="l00236"></a>00236   <span class="comment">/* Lookup the module name. */</span>
<a name="l00237"></a>00237   pTab = pParse-&gt;<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>;
<a name="l00238"></a>00238   <span class="keywordflow">if</span>( pTab==0 ) <span class="keywordflow">return</span>;
<a name="l00239"></a>00239   db = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00240"></a>00240   <span class="keywordflow">if</span>( pTab-&gt;<a class="code" href="structTable.html#a74a2c5547ea876ebe77dbea0d99361bf">nModuleArg</a>&lt;1 ) <span class="keywordflow">return</span>;
<a name="l00241"></a>00241   zModule = pTab-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>[0];
<a name="l00242"></a>00242   pMod = (<a class="code" href="structModule.html">Module</a> *)<a class="code" href="hash_8c.html#a8245210f0a48939ff8e16119312c4c0b">sqlite3HashFind</a>(&amp;db-&gt;<a class="code" href="structsqlite3.html#a1e03e1fdee6fb7cb7337628c7f9b37c4">aModule</a>, zModule, strlen(zModule));
<a name="l00243"></a>00243   pTab-&gt;<a class="code" href="structTable.html#a6d371ddd8755a2b0a93413d99e683914">pMod</a> = pMod;
<a name="l00244"></a>00244   
<a name="l00245"></a>00245   <span class="comment">/* If the CREATE VIRTUAL TABLE statement is being entered for the</span>
<a name="l00246"></a>00246 <span class="comment">  ** first time (in other words if the virtual table is actually being</span>
<a name="l00247"></a>00247 <span class="comment">  ** created now instead of just being read out of sqlite_master) then</span>
<a name="l00248"></a>00248 <span class="comment">  ** do additional initialization work and store the statement text</span>
<a name="l00249"></a>00249 <span class="comment">  ** in the sqlite_master table.</span>
<a name="l00250"></a>00250 <span class="comment">  */</span>
<a name="l00251"></a>00251   <span class="keywordflow">if</span>( !db-&gt;<a class="code" href="structsqlite3.html#a14bb7fbfa6b662021069fcdf6b334d70">init</a>.<a class="code" href="structsqlite3_1_1sqlite3InitInfo.html#a6ac01842e0ae68023cb60fea93bd8688">busy</a> ){
<a name="l00252"></a>00252     <span class="keywordtype">char</span> *zStmt;
<a name="l00253"></a>00253     <span class="keywordtype">char</span> *zWhere;
<a name="l00254"></a>00254     <span class="keywordtype">int</span> iDb;
<a name="l00255"></a>00255     <a class="code" href="structVdbe.html">Vdbe</a> *v;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     <span class="comment">/* Compute the complete text of the CREATE VIRTUAL TABLE statement */</span>
<a name="l00258"></a>00258     <span class="keywordflow">if</span>( pEnd ){
<a name="l00259"></a>00259       pParse-&gt;<a class="code" href="structParse.html#afd929c54566cfc4d6f748fcc6b79b973">sNameToken</a>.<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> = pEnd-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> - pParse-&gt;<a class="code" href="structParse.html#afd929c54566cfc4d6f748fcc6b79b973">sNameToken</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> + pEnd-&gt;<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a>;
<a name="l00260"></a>00260     }
<a name="l00261"></a>00261     zStmt = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db, <span class="stringliteral">&quot;CREATE VIRTUAL TABLE %T&quot;</span>, &amp;pParse-&gt;<a class="code" href="structParse.html#afd929c54566cfc4d6f748fcc6b79b973">sNameToken</a>);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     <span class="comment">/* A slot for the record has already been allocated in the </span>
<a name="l00264"></a>00264 <span class="comment">    ** SQLITE_MASTER table.  We just need to update that slot with all</span>
<a name="l00265"></a>00265 <span class="comment">    ** the information we&apos;ve collected.  </span>
<a name="l00266"></a>00266 <span class="comment">    **</span>
<a name="l00267"></a>00267 <span class="comment">    ** The VM register number pParse-&gt;regRowid holds the rowid of an</span>
<a name="l00268"></a>00268 <span class="comment">    ** entry in the sqlite_master table tht was created for this vtab</span>
<a name="l00269"></a>00269 <span class="comment">    ** by sqlite3StartTable().</span>
<a name="l00270"></a>00270 <span class="comment">    */</span>
<a name="l00271"></a>00271     iDb = <a class="code" href="prepare_8c.html#aecd8922611e561d76d5e9f16655e8a7c">sqlite3SchemaToIndex</a>(db, pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>);
<a name="l00272"></a>00272     <a class="code" href="build_8c.html#a50023e7afea8ffcf644c1cbf2eedc6da">sqlite3NestedParse</a>(pParse,
<a name="l00273"></a>00273       <span class="stringliteral">&quot;UPDATE %Q.%s &quot;</span>
<a name="l00274"></a>00274          <span class="stringliteral">&quot;SET type=&apos;table&apos;, name=%Q, tbl_name=%Q, rootpage=0, sql=%Q &quot;</span>
<a name="l00275"></a>00275        <span class="stringliteral">&quot;WHERE rowid=#%d&quot;</span>,
<a name="l00276"></a>00276       db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>, <a class="code" href="sqliteInt_8h.html#a0393ad099b2c180c4c26c32c251baf37">SCHEMA_TABLE</a>(iDb),
<a name="l00277"></a>00277       pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>,
<a name="l00278"></a>00278       pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>,
<a name="l00279"></a>00279       zStmt,
<a name="l00280"></a>00280       pParse-&gt;<a class="code" href="structParse.html#a63f71c268a7a77cb0df5619dd8ebbacd">regRowid</a>
<a name="l00281"></a>00281     );
<a name="l00282"></a>00282     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zStmt);
<a name="l00283"></a>00283     v = <a class="code" href="select_8c.html#a5a1f85a5a6bef8f820dddfcb407b61dc">sqlite3GetVdbe</a>(pParse);
<a name="l00284"></a>00284     <a class="code" href="build_8c.html#a62eabe6ab94c0cb39cb0a5e918f27985">sqlite3ChangeCookie</a>(pParse, iDb);
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a78605af1570cfef575f7d040f001ef10">OP_Expire</a>, 0, 0);
<a name="l00287"></a>00287     zWhere = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db, <span class="stringliteral">&quot;name=&apos;%q&apos;&quot;</span>, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>);
<a name="l00288"></a>00288     <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a981a42c3f7d3d6e5d7023d4ce3ef354d">OP_ParseSchema</a>, iDb, 1, 0, zWhere, <a class="code" href="vdbe_8h.html#ae0cac143cf868ae8ec55be2ea9b13e7c">P4_DYNAMIC</a>);
<a name="l00289"></a>00289     <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a95f66d60979d7637c6088c2ac85a2b82">OP_VCreate</a>, iDb, 0, 0, 
<a name="l00290"></a>00290                          pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>, strlen(pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>) + 1);
<a name="l00291"></a>00291   }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   <span class="comment">/* If we are rereading the sqlite_master table create the in-memory</span>
<a name="l00294"></a>00294 <span class="comment">  ** record of the table. If the module has already been registered,</span>
<a name="l00295"></a>00295 <span class="comment">  ** also call the xConnect method here.</span>
<a name="l00296"></a>00296 <span class="comment">  */</span>
<a name="l00297"></a>00297   <span class="keywordflow">else</span> {
<a name="l00298"></a>00298     <a class="code" href="structTable.html">Table</a> *pOld;
<a name="l00299"></a>00299     <a class="code" href="structSchema.html">Schema</a> *pSchema = pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>;
<a name="l00300"></a>00300     <span class="keyword">const</span> <span class="keywordtype">char</span> *zName = pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>;
<a name="l00301"></a>00301     <span class="keywordtype">int</span> nName = strlen(zName) + 1;
<a name="l00302"></a>00302     pOld = <a class="code" href="hash_8c.html#af5451f0baf1a33b5e006c9312e326dc8">sqlite3HashInsert</a>(&amp;pSchema-&gt;<a class="code" href="structSchema.html#af841eadc93b289944b95f72b784bfaae">tblHash</a>, zName, nName, pTab);
<a name="l00303"></a>00303     <span class="keywordflow">if</span>( pOld ){
<a name="l00304"></a>00304       db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l00305"></a>00305       assert( pTab==pOld );  <span class="comment">/* Malloc must have failed inside HashInsert() */</span>
<a name="l00306"></a>00306       <span class="keywordflow">return</span>;
<a name="l00307"></a>00307     }
<a name="l00308"></a>00308     pSchema-&gt;<a class="code" href="structSchema.html#a9e552a1d4c2d09fdc41dcdd9fc74ad41">db</a> = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00309"></a>00309     pParse-&gt;<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a> = 0;
<a name="l00310"></a>00310   }
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="comment">/*</span>
<a name="l00314"></a>00314 <span class="comment">** The parser calls this routine when it sees the first token</span>
<a name="l00315"></a>00315 <span class="comment">** of an argument to the module name in a CREATE VIRTUAL TABLE statement.</span>
<a name="l00316"></a>00316 <span class="comment">*/</span>
<a name="l00317"></a><a class="code" href="vtab_8c.html#acb1693142c8516ad20c2ad24ec5fad5a">00317</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#a4f859d9a6f8678b6e4b1afb528143514">sqlite3VtabArgInit</a>(<a class="code" href="structParse.html">Parse</a> *pParse){
<a name="l00318"></a>00318   <a class="code" href="vtab_8c.html#aaf61ce8b4c243cd606a04cddde684b9c">addArgumentToVtab</a>(pParse);
<a name="l00319"></a>00319   pParse-&gt;<a class="code" href="structParse.html#aa3fe38b31dd1cd0fbea4de0e77891642">sArg</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> = 0;
<a name="l00320"></a>00320   pParse-&gt;<a class="code" href="structParse.html#aa3fe38b31dd1cd0fbea4de0e77891642">sArg</a>.<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> = 0;
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="comment">/*</span>
<a name="l00324"></a>00324 <span class="comment">** The parser calls this routine for each token after the first token</span>
<a name="l00325"></a>00325 <span class="comment">** in an argument to the module name in a CREATE VIRTUAL TABLE statement.</span>
<a name="l00326"></a>00326 <span class="comment">*/</span>
<a name="l00327"></a><a class="code" href="vtab_8c.html#ab5253de05265e4a8a32eda3bedcdbe51">00327</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#abe418cf8061e69e15a5899eba46d2bb2">sqlite3VtabArgExtend</a>(<a class="code" href="structParse.html">Parse</a> *pParse, <a class="code" href="structToken.html">Token</a> *p){
<a name="l00328"></a>00328   <a class="code" href="structToken.html">Token</a> *pArg = &amp;pParse-&gt;<a class="code" href="structParse.html#aa3fe38b31dd1cd0fbea4de0e77891642">sArg</a>;
<a name="l00329"></a>00329   <span class="keywordflow">if</span>( pArg-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>==0 ){
<a name="l00330"></a>00330     pArg-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> = p-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>;
<a name="l00331"></a>00331     pArg-&gt;<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> = p-&gt;<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a>;
<a name="l00332"></a>00332   }<span class="keywordflow">else</span>{
<a name="l00333"></a>00333     assert(pArg-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> &lt; p-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>);
<a name="l00334"></a>00334     pArg-&gt;<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> = (p-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> + p-&gt;<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> - pArg-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>);
<a name="l00335"></a>00335   }
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="comment">/*</span>
<a name="l00339"></a>00339 <span class="comment">** Invoke a virtual table constructor (either xCreate or xConnect). The</span>
<a name="l00340"></a>00340 <span class="comment">** pointer to the function to invoke is passed as the fourth parameter</span>
<a name="l00341"></a>00341 <span class="comment">** to this procedure.</span>
<a name="l00342"></a>00342 <span class="comment">*/</span>
<a name="l00343"></a><a class="code" href="vtab_8c.html#acae1b4d5d02b25f4cac29993dae7f983">00343</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="vtab_8c.html#acae1b4d5d02b25f4cac29993dae7f983">vtabCallConstructor</a>(
<a name="l00344"></a>00344   <a class="code" href="structsqlite3.html">sqlite3</a> *db, 
<a name="l00345"></a>00345   <a class="code" href="structTable.html">Table</a> *pTab,
<a name="l00346"></a>00346   <a class="code" href="structModule.html">Module</a> *pMod,
<a name="l00347"></a>00347   <span class="keywordtype">int</span> (*xConstruct)(<a class="code" href="structsqlite3.html">sqlite3</a>*,<span class="keywordtype">void</span>*,<span class="keywordtype">int</span>,<span class="keyword">const</span> <span class="keywordtype">char</span>*<span class="keyword">const</span>*,<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a>**,<span class="keywordtype">char</span>**),
<a name="l00348"></a>00348   <span class="keywordtype">char</span> **pzErr
<a name="l00349"></a>00349 ){
<a name="l00350"></a>00350   <span class="keywordtype">int</span> rc;
<a name="l00351"></a>00351   <span class="keywordtype">int</span> rc2;
<a name="l00352"></a>00352   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = 0;
<a name="l00353"></a>00353   <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span>*azArg = (<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span>*)pTab-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>;
<a name="l00354"></a>00354   <span class="keywordtype">int</span> nArg = pTab-&gt;<a class="code" href="structTable.html#a74a2c5547ea876ebe77dbea0d99361bf">nModuleArg</a>;
<a name="l00355"></a>00355   <span class="keywordtype">char</span> *zErr = 0;
<a name="l00356"></a>00356   <span class="keywordtype">char</span> *zModuleName = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db, <span class="stringliteral">&quot;%s&quot;</span>, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>);
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="keywordflow">if</span>( !zModuleName ){
<a name="l00359"></a>00359     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l00360"></a>00360   }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   assert( !db-&gt;<a class="code" href="structsqlite3.html#ad5c10e0d79663fd7e5b1f26f5925514c">pVTab</a> );
<a name="l00363"></a>00363   assert( xConstruct );
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   db-&gt;<a class="code" href="structsqlite3.html#ad5c10e0d79663fd7e5b1f26f5925514c">pVTab</a> = pTab;
<a name="l00366"></a>00366   rc = <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db);
<a name="l00367"></a>00367   assert( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> );
<a name="l00368"></a>00368   rc = xConstruct(db, pMod-&gt;<a class="code" href="structModule.html#ae3b827fee4c8b4f3ff38c86c2e2f48cd">pAux</a>, nArg, azArg, &amp;pVtab, &amp;zErr);
<a name="l00369"></a>00369   rc2 = <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db);
<a name="l00370"></a>00370   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; pVtab ){
<a name="l00371"></a>00371     pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a> = pMod-&gt;<a class="code" href="structModule.html#a65d2539d71ea028b505b2fb33563bfd7">pModule</a>;
<a name="l00372"></a>00372     pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#ab3c80d385849bdd82363a0df7d6fcba8">nRef</a> = 1;
<a name="l00373"></a>00373     pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a> = pVtab;
<a name="l00374"></a>00374   }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=rc ){
<a name="l00377"></a>00377     <span class="keywordflow">if</span>( zErr==0 ){
<a name="l00378"></a>00378       *pzErr = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db, <span class="stringliteral">&quot;vtable constructor failed: %s&quot;</span>, zModuleName);
<a name="l00379"></a>00379     }<span class="keywordflow">else</span> {
<a name="l00380"></a>00380       *pzErr = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db, <span class="stringliteral">&quot;%s&quot;</span>, zErr);
<a name="l00381"></a>00381       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zErr);
<a name="l00382"></a>00382     }
<a name="l00383"></a>00383   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#ad5c10e0d79663fd7e5b1f26f5925514c">pVTab</a> ){
<a name="l00384"></a>00384     <span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat = <span class="stringliteral">&quot;vtable constructor did not declare schema: %s&quot;</span>;
<a name="l00385"></a>00385     *pzErr = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db, zFormat, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>);
<a name="l00386"></a>00386     rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l00387"></a>00387   } 
<a name="l00388"></a>00388   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00389"></a>00389     rc = rc2;
<a name="l00390"></a>00390   }
<a name="l00391"></a>00391   db-&gt;<a class="code" href="structsqlite3.html#ad5c10e0d79663fd7e5b1f26f5925514c">pVTab</a> = 0;
<a name="l00392"></a>00392   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zModuleName);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394   <span class="comment">/* If everything went according to plan, loop through the columns</span>
<a name="l00395"></a>00395 <span class="comment">  ** of the table to see if any of them contain the token &quot;hidden&quot;.</span>
<a name="l00396"></a>00396 <span class="comment">  ** If so, set the Column.isHidden flag and remove the token from</span>
<a name="l00397"></a>00397 <span class="comment">  ** the type string.</span>
<a name="l00398"></a>00398 <span class="comment">  */</span>
<a name="l00399"></a>00399   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00400"></a>00400     <span class="keywordtype">int</span> iCol;
<a name="l00401"></a>00401     <span class="keywordflow">for</span>(iCol=0; iCol&lt;pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>; iCol++){
<a name="l00402"></a>00402       <span class="keywordtype">char</span> *zType = pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[iCol].<a class="code" href="structColumn.html#aef09f43479c4bd2d07f77d340020f95f">zType</a>;
<a name="l00403"></a>00403       <span class="keywordtype">int</span> nType;
<a name="l00404"></a>00404       <span class="keywordtype">int</span> i = 0;
<a name="l00405"></a>00405       <span class="keywordflow">if</span>( !zType ) <span class="keywordflow">continue</span>;
<a name="l00406"></a>00406       nType = strlen(zType);
<a name="l00407"></a>00407       <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#acd3b8a2e2ada99c161975ac30cb50877">sqlite3StrNICmp</a>(<span class="stringliteral">&quot;hidden&quot;</span>, zType, 6) || (zType[6] &amp;&amp; zType[6]!=<span class="charliteral">&apos; &apos;</span>) ){
<a name="l00408"></a>00408         <span class="keywordflow">for</span>(i=0; i&lt;nType; i++){
<a name="l00409"></a>00409           <span class="keywordflow">if</span>( (0==<a class="code" href="sqliteInt_8h.html#acd3b8a2e2ada99c161975ac30cb50877">sqlite3StrNICmp</a>(<span class="stringliteral">&quot; hidden&quot;</span>, &amp;zType[i], 7))
<a name="l00410"></a>00410            &amp;&amp; (zType[i+7]==<span class="charliteral">&apos;\0&apos;</span> || zType[i+7]==<span class="charliteral">&apos; &apos;</span>)
<a name="l00411"></a>00411           ){
<a name="l00412"></a>00412             i++;
<a name="l00413"></a>00413             <span class="keywordflow">break</span>;
<a name="l00414"></a>00414           }
<a name="l00415"></a>00415         }
<a name="l00416"></a>00416       }
<a name="l00417"></a>00417       <span class="keywordflow">if</span>( i&lt;nType ){
<a name="l00418"></a>00418         <span class="keywordtype">int</span> j;
<a name="l00419"></a>00419         <span class="keywordtype">int</span> nDel = 6 + (zType[i+6] ? 1 : 0);
<a name="l00420"></a>00420         <span class="keywordflow">for</span>(j=i; (j+nDel)&lt;=nType; j++){
<a name="l00421"></a>00421           zType[j] = zType[j+nDel];
<a name="l00422"></a>00422         }
<a name="l00423"></a>00423         <span class="keywordflow">if</span>( zType[i]==<span class="charliteral">&apos;\0&apos;</span> &amp;&amp; i&gt;0 ){
<a name="l00424"></a>00424           assert(zType[i-1]==<span class="charliteral">&apos; &apos;</span>);
<a name="l00425"></a>00425           zType[i-1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00426"></a>00426         }
<a name="l00427"></a>00427         pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[iCol].<a class="code" href="structColumn.html#aafdb39efd9b21476415c5beeb5a8b180">isHidden</a> = 1;
<a name="l00428"></a>00428       }
<a name="l00429"></a>00429     }
<a name="l00430"></a>00430   }
<a name="l00431"></a>00431   <span class="keywordflow">return</span> rc;
<a name="l00432"></a>00432 }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 <span class="comment">/*</span>
<a name="l00435"></a>00435 <span class="comment">** This function is invoked by the parser to call the xConnect() method</span>
<a name="l00436"></a>00436 <span class="comment">** of the virtual table pTab. If an error occurs, an error code is returned </span>
<a name="l00437"></a>00437 <span class="comment">** and an error left in pParse.</span>
<a name="l00438"></a>00438 <span class="comment">**</span>
<a name="l00439"></a>00439 <span class="comment">** This call is a no-op if table pTab is not a virtual table.</span>
<a name="l00440"></a>00440 <span class="comment">*/</span>
<a name="l00441"></a><a class="code" href="vtab_8c.html#ad491378dc8aa5cee9198efc053052980">00441</a> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#a1b24ef3ba15e50044d079ca8c2166398">sqlite3VtabCallConnect</a>(<a class="code" href="structParse.html">Parse</a> *pParse, <a class="code" href="structTable.html">Table</a> *pTab){
<a name="l00442"></a>00442   <a class="code" href="structModule.html">Module</a> *pMod;
<a name="l00443"></a>00443   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="keywordflow">if</span>( !pTab || (pTab-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a350a16ec7aacc6d6eb749ab327e7b4f1">TF_Virtual</a>)==0 || pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a> ){
<a name="l00446"></a>00446     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00447"></a>00447   }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   pMod = pTab-&gt;<a class="code" href="structTable.html#a6d371ddd8755a2b0a93413d99e683914">pMod</a>;
<a name="l00450"></a>00450   <span class="keywordflow">if</span>( !pMod ){
<a name="l00451"></a>00451     <span class="keyword">const</span> <span class="keywordtype">char</span> *zModule = pTab-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>[0];
<a name="l00452"></a>00452     <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;no such module: %s&quot;</span>, zModule);
<a name="l00453"></a>00453     rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l00454"></a>00454   } <span class="keywordflow">else</span> {
<a name="l00455"></a>00455     <span class="keywordtype">char</span> *zErr = 0;
<a name="l00456"></a>00456     <a class="code" href="structsqlite3.html">sqlite3</a> *db = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00457"></a>00457     rc = <a class="code" href="vtab_8c.html#acae1b4d5d02b25f4cac29993dae7f983">vtabCallConstructor</a>(db, pTab, pMod, pMod-&gt;<a class="code" href="structModule.html#a65d2539d71ea028b505b2fb33563bfd7">pModule</a>-&gt;<a class="code" href="structsqlite3__module.html#acdd9ccc4a6acff230b2d579172ae32d0">xConnect</a>, &amp;zErr);
<a name="l00458"></a>00458     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00459"></a>00459       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;%s&quot;</span>, zErr);
<a name="l00460"></a>00460     }
<a name="l00461"></a>00461     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zErr);
<a name="l00462"></a>00462   }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <span class="keywordflow">return</span> rc;
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="comment">/*</span>
<a name="l00468"></a>00468 <span class="comment">** Add the virtual table pVtab to the array sqlite3.aVTrans[].</span>
<a name="l00469"></a>00469 <span class="comment">*/</span>
<a name="l00470"></a><a class="code" href="vtab_8c.html#a02d80be70edcddfcaddfc9cc8c89b5a4">00470</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="vtab_8c.html#a02d80be70edcddfcaddfc9cc8c89b5a4">addToVTrans</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab){
<a name="l00471"></a>00471   <span class="keyword">const</span> <span class="keywordtype">int</span> ARRAY_INCR = 5;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   <span class="comment">/* Grow the sqlite3.aVTrans array if required */</span>
<a name="l00474"></a>00474   <span class="keywordflow">if</span>( (db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a>%ARRAY_INCR)==0 ){
<a name="l00475"></a>00475     <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> **aVTrans;
<a name="l00476"></a>00476     <span class="keywordtype">int</span> nBytes = <span class="keyword">sizeof</span>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *) * (db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a> + ARRAY_INCR);
<a name="l00477"></a>00477     aVTrans = <a class="code" href="malloc_8c.html#a5fd070055efafc36faa4e6092329d224">sqlite3DbRealloc</a>(db, (<span class="keywordtype">void</span> *)db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>, nBytes);
<a name="l00478"></a>00478     <span class="keywordflow">if</span>( !aVTrans ){
<a name="l00479"></a>00479       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l00480"></a>00480     }
<a name="l00481"></a>00481     memset(&amp;aVTrans[db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a>], 0, <span class="keyword">sizeof</span>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *)*ARRAY_INCR);
<a name="l00482"></a>00482     db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a> = aVTrans;
<a name="l00483"></a>00483   }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   <span class="comment">/* Add pVtab to the end of sqlite3.aVTrans */</span>
<a name="l00486"></a>00486   db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>[db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a>++] = pVtab;
<a name="l00487"></a>00487   <a class="code" href="sqliteInt_8h.html#abea58f5048efa3c3820a4ade28047696">sqlite3VtabLock</a>(pVtab);
<a name="l00488"></a>00488   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="comment">/*</span>
<a name="l00492"></a>00492 <span class="comment">** This function is invoked by the vdbe to call the xCreate method</span>
<a name="l00493"></a>00493 <span class="comment">** of the virtual table named zTab in database iDb. </span>
<a name="l00494"></a>00494 <span class="comment">**</span>
<a name="l00495"></a>00495 <span class="comment">** If an error occurs, *pzErr is set to point an an English language</span>
<a name="l00496"></a>00496 <span class="comment">** description of the error and an SQLITE_XXX error code is returned.</span>
<a name="l00497"></a>00497 <span class="comment">** In this case the caller must call sqlite3DbFree(db, ) on *pzErr.</span>
<a name="l00498"></a>00498 <span class="comment">*/</span>
<a name="l00499"></a><a class="code" href="vtab_8c.html#a207d2f52e716972037a35d0ae5a8354a">00499</a> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#a1231e3799c456638bf26bee86911486a">sqlite3VtabCallCreate</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <span class="keywordtype">int</span> iDb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zTab, <span class="keywordtype">char</span> **pzErr){
<a name="l00500"></a>00500   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00501"></a>00501   <a class="code" href="structTable.html">Table</a> *pTab;
<a name="l00502"></a>00502   <a class="code" href="structModule.html">Module</a> *pMod;
<a name="l00503"></a>00503   <span class="keyword">const</span> <span class="keywordtype">char</span> *zModule;
<a name="l00504"></a>00504 
<a name="l00505"></a>00505   pTab = <a class="code" href="build_8c.html#ad5aa86dccbdb717fa67a89732c05207a">sqlite3FindTable</a>(db, zTab, db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>);
<a name="l00506"></a>00506   assert(pTab &amp;&amp; (pTab-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a350a16ec7aacc6d6eb749ab327e7b4f1">TF_Virtual</a>)!=0 &amp;&amp; !pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a>);
<a name="l00507"></a>00507   pMod = pTab-&gt;<a class="code" href="structTable.html#a6d371ddd8755a2b0a93413d99e683914">pMod</a>;
<a name="l00508"></a>00508   zModule = pTab-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>[0];
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   <span class="comment">/* If the module has been registered and includes a Create method, </span>
<a name="l00511"></a>00511 <span class="comment">  ** invoke it now. If the module has not been registered, return an </span>
<a name="l00512"></a>00512 <span class="comment">  ** error. Otherwise, do nothing.</span>
<a name="l00513"></a>00513 <span class="comment">  */</span>
<a name="l00514"></a>00514   <span class="keywordflow">if</span>( !pMod ){
<a name="l00515"></a>00515     *pzErr = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db, <span class="stringliteral">&quot;no such module: %s&quot;</span>, zModule);
<a name="l00516"></a>00516     rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l00517"></a>00517   }<span class="keywordflow">else</span>{
<a name="l00518"></a>00518     rc = <a class="code" href="vtab_8c.html#acae1b4d5d02b25f4cac29993dae7f983">vtabCallConstructor</a>(db, pTab, pMod, pMod-&gt;<a class="code" href="structModule.html#a65d2539d71ea028b505b2fb33563bfd7">pModule</a>-&gt;<a class="code" href="structsqlite3__module.html#a95e327c9d32abd731013395d9e12b8f9">xCreate</a>, pzErr);
<a name="l00519"></a>00519   }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a> ){
<a name="l00522"></a>00522       rc = <a class="code" href="vtab_8c.html#a02d80be70edcddfcaddfc9cc8c89b5a4">addToVTrans</a>(db, pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a>);
<a name="l00523"></a>00523   }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525   <span class="keywordflow">return</span> rc;
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="comment">/*</span>
<a name="l00529"></a>00529 <span class="comment">** This function is used to set the schema of a virtual table.  It is only</span>
<a name="l00530"></a>00530 <span class="comment">** valid to call this function from within the xCreate() or xConnect() of a</span>
<a name="l00531"></a>00531 <span class="comment">** virtual table module.</span>
<a name="l00532"></a>00532 <span class="comment">*/</span>
<a name="l00533"></a><a class="code" href="vtab_8c.html#aacdbfaa339daf4f8c0523ae761365382">00533</a> <span class="keywordtype">int</span> <a class="code" href="sqlite3_8h.html#aefa1dcc35bfd08140af3073d08e20029">sqlite3_declare_vtab</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *zCreateTable){
<a name="l00534"></a>00534   <a class="code" href="structParse.html">Parse</a> sParse;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00537"></a>00537   <a class="code" href="structTable.html">Table</a> *pTab;
<a name="l00538"></a>00538   <span class="keywordtype">char</span> *zErr = 0;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540   <a class="code" href="mutex_8h.html#afbab5dc0108b65678f2fa579473041ac">sqlite3_mutex_enter</a>(db-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>);
<a name="l00541"></a>00541   pTab = db-&gt;<a class="code" href="structsqlite3.html#ad5c10e0d79663fd7e5b1f26f5925514c">pVTab</a>;
<a name="l00542"></a>00542   <span class="keywordflow">if</span>( !pTab ){
<a name="l00543"></a>00543     <a class="code" href="sqliteInt_8h.html#adf4434e94ac41a2abedd476047d49983">sqlite3Error</a>(db, <a class="code" href="sqlite3_8h.html#a34f01e4ee909e6b68be040868f7503bc">SQLITE_MISUSE</a>, 0);
<a name="l00544"></a>00544     <a class="code" href="mutex_8h.html#aba06556afc1a17868af4675ba856701c">sqlite3_mutex_leave</a>(db-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>);
<a name="l00545"></a>00545     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a34f01e4ee909e6b68be040868f7503bc">SQLITE_MISUSE</a>;
<a name="l00546"></a>00546   }
<a name="l00547"></a>00547   assert((pTab-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a350a16ec7aacc6d6eb749ab327e7b4f1">TF_Virtual</a>)!=0 &amp;&amp; pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>==0 &amp;&amp; pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>==0);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   memset(&amp;sParse, 0, <span class="keyword">sizeof</span>(<a class="code" href="structParse.html">Parse</a>));
<a name="l00550"></a>00550   sParse.<a class="code" href="structParse.html#a86c869df65cd788025680de9b6a9b1f1">declareVtab</a> = 1;
<a name="l00551"></a>00551   sParse.<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a> = db;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   <span class="keywordflow">if</span>( 
<a name="l00554"></a>00554       <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> == <a class="code" href="sqliteInt_8h.html#a012b875619bdd3e411e20471e044fc47">sqlite3RunParser</a>(&amp;sParse, zCreateTable, &amp;zErr) &amp;&amp; 
<a name="l00555"></a>00555       sParse.<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a> &amp;&amp; 
<a name="l00556"></a>00556       !sParse.<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>-&gt;<a class="code" href="structTable.html#a39d620182fe2174fc97d04094421fa60">pSelect</a> &amp;&amp; 
<a name="l00557"></a>00557       (sParse.<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a350a16ec7aacc6d6eb749ab327e7b4f1">TF_Virtual</a>)==0
<a name="l00558"></a>00558   ){
<a name="l00559"></a>00559     pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a> = sParse.<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>;
<a name="l00560"></a>00560     pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a> = sParse.<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>;
<a name="l00561"></a>00561     sParse.<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a> = 0;
<a name="l00562"></a>00562     sParse.<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a> = 0;
<a name="l00563"></a>00563     db-&gt;<a class="code" href="structsqlite3.html#ad5c10e0d79663fd7e5b1f26f5925514c">pVTab</a> = 0;
<a name="l00564"></a>00564   } <span class="keywordflow">else</span> {
<a name="l00565"></a>00565     <a class="code" href="sqliteInt_8h.html#adf4434e94ac41a2abedd476047d49983">sqlite3Error</a>(db, <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>, zErr);
<a name="l00566"></a>00566     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zErr);
<a name="l00567"></a>00567     rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l00568"></a>00568   }
<a name="l00569"></a>00569   sParse.<a class="code" href="structParse.html#a86c869df65cd788025680de9b6a9b1f1">declareVtab</a> = 0;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571   <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>((<a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a>*)sParse.<a class="code" href="structParse.html#a81774053fd5063046f532c07e3daa98b">pVdbe</a>);
<a name="l00572"></a>00572   <a class="code" href="build_8c.html#a643487b51d4e5baf37ac4d892963bab1">sqlite3DeleteTable</a>(sParse.<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a>);
<a name="l00573"></a>00573   sParse.<a class="code" href="structParse.html#a4788769c077dc86ffa3ee1e40ed6b4a1">pNewTable</a> = 0;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575   assert( (rc&amp;0xff)==rc );
<a name="l00576"></a>00576   rc = <a class="code" href="malloc_8c.html#a5ace6847fdf42079e5ec21f3d54d601b">sqlite3ApiExit</a>(db, rc);
<a name="l00577"></a>00577   <a class="code" href="mutex_8h.html#aba06556afc1a17868af4675ba856701c">sqlite3_mutex_leave</a>(db-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>);
<a name="l00578"></a>00578   <span class="keywordflow">return</span> rc;
<a name="l00579"></a>00579 }
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="comment">/*</span>
<a name="l00582"></a>00582 <span class="comment">** This function is invoked by the vdbe to call the xDestroy method</span>
<a name="l00583"></a>00583 <span class="comment">** of the virtual table named zTab in database iDb. This occurs</span>
<a name="l00584"></a>00584 <span class="comment">** when a DROP TABLE is mentioned.</span>
<a name="l00585"></a>00585 <span class="comment">**</span>
<a name="l00586"></a>00586 <span class="comment">** This call is a no-op if zTab is not a virtual table.</span>
<a name="l00587"></a>00587 <span class="comment">*/</span>
<a name="l00588"></a><a class="code" href="vtab_8c.html#af1eda662ee310f85daf838e74d9a3925">00588</a> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#a60ddbe3bf37aee4c819047a012f85046">sqlite3VtabCallDestroy</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <span class="keywordtype">int</span> iDb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zTab)
<a name="l00589"></a>00589 {
<a name="l00590"></a>00590   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00591"></a>00591   <a class="code" href="structTable.html">Table</a> *pTab;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   pTab = <a class="code" href="build_8c.html#ad5aa86dccbdb717fa67a89732c05207a">sqlite3FindTable</a>(db, zTab, db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>);
<a name="l00594"></a>00594   assert(pTab);
<a name="l00595"></a>00595   <span class="keywordflow">if</span>( pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a> ){
<a name="l00596"></a>00596     int (*xDestroy)(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVTab) = pTab-&gt;<a class="code" href="structTable.html#a6d371ddd8755a2b0a93413d99e683914">pMod</a>-&gt;<a class="code" href="structModule.html#a65d2539d71ea028b505b2fb33563bfd7">pModule</a>-&gt;<a class="code" href="structsqlite3__module.html#a296dae8dadd4eb1f7d0f1187650c7aa5">xDestroy</a>;
<a name="l00597"></a>00597     rc = <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db);
<a name="l00598"></a>00598     assert( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> );
<a name="l00599"></a>00599     <span class="keywordflow">if</span>( xDestroy ){
<a name="l00600"></a>00600       rc = xDestroy(pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a>);
<a name="l00601"></a>00601     }
<a name="l00602"></a>00602     (void)<a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db);
<a name="l00603"></a>00603     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00604"></a>00604       <span class="keywordtype">int</span> i;
<a name="l00605"></a>00605       <span class="keywordflow">for</span>(i=0; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a>; i++){
<a name="l00606"></a>00606         <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>[i]==pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a> ){
<a name="l00607"></a>00607           db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>[i] = db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>[--db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a>];
<a name="l00608"></a>00608           <span class="keywordflow">break</span>;
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610       }
<a name="l00611"></a>00611       pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a> = 0;
<a name="l00612"></a>00612     }
<a name="l00613"></a>00613   }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <span class="keywordflow">return</span> rc;
<a name="l00616"></a>00616 }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 <span class="comment">/*</span>
<a name="l00619"></a>00619 <span class="comment">** This function invokes either the xRollback or xCommit method</span>
<a name="l00620"></a>00620 <span class="comment">** of each of the virtual tables in the sqlite3.aVTrans array. The method</span>
<a name="l00621"></a>00621 <span class="comment">** called is identified by the second argument, &quot;offset&quot;, which is</span>
<a name="l00622"></a>00622 <span class="comment">** the offset of the method to call in the sqlite3_module structure.</span>
<a name="l00623"></a>00623 <span class="comment">**</span>
<a name="l00624"></a>00624 <span class="comment">** The array is cleared after invoking the callbacks. </span>
<a name="l00625"></a>00625 <span class="comment">*/</span>
<a name="l00626"></a><a class="code" href="vtab_8c.html#a22316908cc65af3d391ba12ab103edb9">00626</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vtab_8c.html#a22316908cc65af3d391ba12ab103edb9">callFinaliser</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <span class="keywordtype">int</span> offset){
<a name="l00627"></a>00627   <span class="keywordtype">int</span> i;
<a name="l00628"></a>00628   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a> ){
<a name="l00629"></a>00629     <span class="keywordflow">for</span>(i=0; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a> &amp;&amp; db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>[i]; i++){
<a name="l00630"></a>00630       <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>[i];
<a name="l00631"></a>00631       int (*x)(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *);
<a name="l00632"></a>00632       x = *(int (**)(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *))((<span class="keywordtype">char</span> *)pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a> + offset);
<a name="l00633"></a>00633       <span class="keywordflow">if</span>( x ) x(pVtab);
<a name="l00634"></a>00634       <a class="code" href="sqliteInt_8h.html#a13ba8c3126d20b116817f197da61f0c9">sqlite3VtabUnlock</a>(db, pVtab);
<a name="l00635"></a>00635     }
<a name="l00636"></a>00636     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>);
<a name="l00637"></a>00637     db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a> = 0;
<a name="l00638"></a>00638     db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a> = 0;
<a name="l00639"></a>00639   }
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="comment">/*</span>
<a name="l00643"></a>00643 <span class="comment">** Invoke the xSync method of all virtual tables in the sqlite3.aVTrans</span>
<a name="l00644"></a>00644 <span class="comment">** array. Return the error code for the first error that occurs, or</span>
<a name="l00645"></a>00645 <span class="comment">** SQLITE_OK if all xSync operations are successful.</span>
<a name="l00646"></a>00646 <span class="comment">**</span>
<a name="l00647"></a>00647 <span class="comment">** Set *pzErrmsg to point to a buffer that should be released using </span>
<a name="l00648"></a>00648 <span class="comment">** sqlite3DbFree() containing an error message, if one is available.</span>
<a name="l00649"></a>00649 <span class="comment">*/</span>
<a name="l00650"></a><a class="code" href="vtab_8c.html#a2981d7884aebcaa91c6c3cee7a38f50b">00650</a> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#a3133bbaa56e583e887c38a1d143ffb08">sqlite3VtabSync</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <span class="keywordtype">char</span> **pzErrmsg){
<a name="l00651"></a>00651   <span class="keywordtype">int</span> i;
<a name="l00652"></a>00652   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00653"></a>00653   <span class="keywordtype">int</span> rcsafety;
<a name="l00654"></a>00654   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> **aVTrans = db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>;
<a name="l00655"></a>00655 
<a name="l00656"></a>00656   rc = <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db);
<a name="l00657"></a>00657   db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a> = 0;
<a name="l00658"></a>00658   <span class="keywordflow">for</span>(i=0; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a> &amp;&amp; aVTrans[i]; i++){
<a name="l00659"></a>00659     <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = aVTrans[i];
<a name="l00660"></a>00660     int (*x)(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *);
<a name="l00661"></a>00661     x = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>-&gt;<a class="code" href="structsqlite3__module.html#a895d78529db2e28e13d1d842512770b6">xSync</a>;
<a name="l00662"></a>00662     <span class="keywordflow">if</span>( x ){
<a name="l00663"></a>00663       rc = x(pVtab);
<a name="l00664"></a>00664       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, *pzErrmsg);
<a name="l00665"></a>00665       *pzErrmsg = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>;
<a name="l00666"></a>00666       pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l00667"></a>00667     }
<a name="l00668"></a>00668   }
<a name="l00669"></a>00669   db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a> = aVTrans;
<a name="l00670"></a>00670   rcsafety = <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db);
<a name="l00671"></a>00671 
<a name="l00672"></a>00672   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00673"></a>00673     rc = rcsafety;
<a name="l00674"></a>00674   }
<a name="l00675"></a>00675   <span class="keywordflow">return</span> rc;
<a name="l00676"></a>00676 }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678 <span class="comment">/*</span>
<a name="l00679"></a>00679 <span class="comment">** Invoke the xRollback method of all virtual tables in the </span>
<a name="l00680"></a>00680 <span class="comment">** sqlite3.aVTrans array. Then clear the array itself.</span>
<a name="l00681"></a>00681 <span class="comment">*/</span>
<a name="l00682"></a><a class="code" href="vtab_8c.html#aaafabe54961ab7e6abeaab88be3f6ac9">00682</a> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#aaafabe54961ab7e6abeaab88be3f6ac9">sqlite3VtabRollback</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db){
<a name="l00683"></a>00683   <a class="code" href="vtab_8c.html#a22316908cc65af3d391ba12ab103edb9">callFinaliser</a>(db, <a class="code" href="sqliteInt_8h.html#a61da2bab632d8ccea4f9a3eddfb506e7">offsetof</a>(<a class="code" href="structsqlite3__module.html">sqlite3_module</a>,xRollback));
<a name="l00684"></a>00684   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00685"></a>00685 }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687 <span class="comment">/*</span>
<a name="l00688"></a>00688 <span class="comment">** Invoke the xCommit method of all virtual tables in the </span>
<a name="l00689"></a>00689 <span class="comment">** sqlite3.aVTrans array. Then clear the array itself.</span>
<a name="l00690"></a>00690 <span class="comment">*/</span>
<a name="l00691"></a><a class="code" href="vtab_8c.html#a31f47781e4e0664baa4688da7aea6b2b">00691</a> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#a31f47781e4e0664baa4688da7aea6b2b">sqlite3VtabCommit</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db){
<a name="l00692"></a>00692   <a class="code" href="vtab_8c.html#a22316908cc65af3d391ba12ab103edb9">callFinaliser</a>(db, <a class="code" href="sqliteInt_8h.html#a61da2bab632d8ccea4f9a3eddfb506e7">offsetof</a>(<a class="code" href="structsqlite3__module.html">sqlite3_module</a>,xCommit));
<a name="l00693"></a>00693   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00694"></a>00694 }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696 <span class="comment">/*</span>
<a name="l00697"></a>00697 <span class="comment">** If the virtual table pVtab supports the transaction interface</span>
<a name="l00698"></a>00698 <span class="comment">** (xBegin/xRollback/xCommit and optionally xSync) and a transaction is</span>
<a name="l00699"></a>00699 <span class="comment">** not currently open, invoke the xBegin method now.</span>
<a name="l00700"></a>00700 <span class="comment">**</span>
<a name="l00701"></a>00701 <span class="comment">** If the xBegin call is successful, place the sqlite3_vtab pointer</span>
<a name="l00702"></a>00702 <span class="comment">** in the sqlite3.aVTrans array.</span>
<a name="l00703"></a>00703 <span class="comment">*/</span>
<a name="l00704"></a><a class="code" href="vtab_8c.html#a1e29fec19f37ea2ef4cfcaf24b85cce1">00704</a> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#abdc5f94e9562d909ba32168ff6b01ce3">sqlite3VtabBegin</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *db, <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab){
<a name="l00705"></a>00705   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00706"></a>00706   <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708   <span class="comment">/* Special case: If db-&gt;aVTrans is NULL and db-&gt;nVTrans is greater</span>
<a name="l00709"></a>00709 <span class="comment">  ** than zero, then this function is being called from within a</span>
<a name="l00710"></a>00710 <span class="comment">  ** virtual module xSync() callback. It is illegal to write to </span>
<a name="l00711"></a>00711 <span class="comment">  ** virtual module tables in this case, so return SQLITE_LOCKED.</span>
<a name="l00712"></a>00712 <span class="comment">  */</span>
<a name="l00713"></a>00713   <span class="keywordflow">if</span>( 0==db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a> &amp;&amp; db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a>&gt;0 ){
<a name="l00714"></a>00714     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>;
<a name="l00715"></a>00715   }
<a name="l00716"></a>00716   <span class="keywordflow">if</span>( !pVtab ){
<a name="l00717"></a>00717     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00718"></a>00718   } 
<a name="l00719"></a>00719   pModule = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>;
<a name="l00720"></a>00720 
<a name="l00721"></a>00721   <span class="keywordflow">if</span>( pModule-&gt;<a class="code" href="structsqlite3__module.html#af3ea97df2b110da6ceb4797222e6d86f">xBegin</a> ){
<a name="l00722"></a>00722     <span class="keywordtype">int</span> i;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 
<a name="l00725"></a>00725     <span class="comment">/* If pVtab is already in the aVTrans array, return early */</span>
<a name="l00726"></a>00726     <span class="keywordflow">for</span>(i=0; (i&lt;db-&gt;<a class="code" href="structsqlite3.html#a895162274d29fcd0658901bc5dcce99b">nVTrans</a>) &amp;&amp; 0!=db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>[i]; i++){
<a name="l00727"></a>00727       <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#aa862b468d7573e11fb78500725121696">aVTrans</a>[i]==pVtab ){
<a name="l00728"></a>00728         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00729"></a>00729       }
<a name="l00730"></a>00730     }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732     <span class="comment">/* Invoke the xBegin method */</span>
<a name="l00733"></a>00733     rc = pModule-&gt;<a class="code" href="structsqlite3__module.html#af3ea97df2b110da6ceb4797222e6d86f">xBegin</a>(pVtab);
<a name="l00734"></a>00734     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00735"></a>00735       rc = <a class="code" href="vtab_8c.html#a02d80be70edcddfcaddfc9cc8c89b5a4">addToVTrans</a>(db, pVtab);
<a name="l00736"></a>00736     }
<a name="l00737"></a>00737   }
<a name="l00738"></a>00738   <span class="keywordflow">return</span> rc;
<a name="l00739"></a>00739 }
<a name="l00740"></a>00740 
<a name="l00741"></a>00741 <span class="comment">/*</span>
<a name="l00742"></a>00742 <span class="comment">** The first parameter (pDef) is a function implementation.  The</span>
<a name="l00743"></a>00743 <span class="comment">** second parameter (pExpr) is the first argument to this function.</span>
<a name="l00744"></a>00744 <span class="comment">** If pExpr is a column in a virtual table, then let the virtual</span>
<a name="l00745"></a>00745 <span class="comment">** table implementation have an opportunity to overload the function.</span>
<a name="l00746"></a>00746 <span class="comment">**</span>
<a name="l00747"></a>00747 <span class="comment">** This routine is used to allow virtual table implementations to</span>
<a name="l00748"></a>00748 <span class="comment">** overload MATCH, LIKE, GLOB, and REGEXP operators.</span>
<a name="l00749"></a>00749 <span class="comment">**</span>
<a name="l00750"></a>00750 <span class="comment">** Return either the pDef argument (indicating no change) or a </span>
<a name="l00751"></a>00751 <span class="comment">** new FuncDef structure that is marked as ephemeral using the</span>
<a name="l00752"></a>00752 <span class="comment">** SQLITE_FUNC_EPHEM flag.</span>
<a name="l00753"></a>00753 <span class="comment">*/</span>
<a name="l00754"></a><a class="code" href="vtab_8c.html#a92edc9c4d5a3356ba45739a112ce59b4">00754</a> <a class="code" href="structFuncDef.html">FuncDef</a> *<a class="code" href="sqliteInt_8h.html#a483b7b0b3b570d48e1c62da78d576be8">sqlite3VtabOverloadFunction</a>(
<a name="l00755"></a>00755   <a class="code" href="structsqlite3.html">sqlite3</a> *db,    <span class="comment">/* Database connection for reporting malloc problems */</span>
<a name="l00756"></a>00756   <a class="code" href="structFuncDef.html">FuncDef</a> *pDef,  <span class="comment">/* Function to possibly overload */</span>
<a name="l00757"></a>00757   <span class="keywordtype">int</span> nArg,       <span class="comment">/* Number of arguments to the function */</span>
<a name="l00758"></a>00758   <a class="code" href="structExpr.html">Expr</a> *pExpr     <span class="comment">/* First argument to the function */</span>
<a name="l00759"></a>00759 ){
<a name="l00760"></a>00760   <a class="code" href="structTable.html">Table</a> *pTab;
<a name="l00761"></a>00761   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab;
<a name="l00762"></a>00762   <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pMod;
<a name="l00763"></a>00763   void (*xFunc)(<a class="code" href="structsqlite3__context.html">sqlite3_context</a>*,int,<a class="code" href="structMem.html">sqlite3_value</a>**);
<a name="l00764"></a>00764   <span class="keywordtype">void</span> *pArg;
<a name="l00765"></a>00765   <a class="code" href="structFuncDef.html">FuncDef</a> *pNew;
<a name="l00766"></a>00766   <span class="keywordtype">int</span> rc = 0;
<a name="l00767"></a>00767   <span class="keywordtype">char</span> *zLowerName;
<a name="l00768"></a>00768   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *z;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 
<a name="l00771"></a>00771   <span class="comment">/* Check to see the left operand is a column in a virtual table */</span>
<a name="l00772"></a>00772   <span class="keywordflow">if</span>( pExpr==0 ) <span class="keywordflow">return</span> pDef;
<a name="l00773"></a>00773   <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> ) <span class="keywordflow">return</span> pDef;
<a name="l00774"></a>00774   pTab = pExpr-&gt;<a class="code" href="structExpr.html#a27c8824b41d853eeeebe61cf3ac1ae5a">pTab</a>;
<a name="l00775"></a>00775   <span class="keywordflow">if</span>( pTab==0 ) <span class="keywordflow">return</span> pDef;
<a name="l00776"></a>00776   <span class="keywordflow">if</span>( (pTab-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a350a16ec7aacc6d6eb749ab327e7b4f1">TF_Virtual</a>)==0 ) <span class="keywordflow">return</span> pDef;
<a name="l00777"></a>00777   pVtab = pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a>;
<a name="l00778"></a>00778   assert( pVtab!=0 );
<a name="l00779"></a>00779   assert( pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>!=0 );
<a name="l00780"></a>00780   pMod = (<a class="code" href="structsqlite3__module.html">sqlite3_module</a> *)pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>;
<a name="l00781"></a>00781   <span class="keywordflow">if</span>( pMod-&gt;<a class="code" href="structsqlite3__module.html#ae70a020a7dda960b91943e9f67695dbb">xFindFunction</a>==0 ) <span class="keywordflow">return</span> pDef;
<a name="l00782"></a>00782  
<a name="l00783"></a>00783   <span class="comment">/* Call the xFindFunction method on the virtual table implementation</span>
<a name="l00784"></a>00784 <span class="comment">  ** to see if the implementation wants to overload this function </span>
<a name="l00785"></a>00785 <span class="comment">  */</span>
<a name="l00786"></a>00786   zLowerName = <a class="code" href="malloc_8c.html#aa75e87f512f3cb7a48175b26dba47ebb">sqlite3DbStrDup</a>(db, pDef-&gt;<a class="code" href="structFuncDef.html#a1135e622a3a505c7c463e975846ef926">zName</a>);
<a name="l00787"></a>00787   <span class="keywordflow">if</span>( zLowerName ){
<a name="l00788"></a>00788     <span class="keywordflow">for</span>(z=(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)zLowerName; *z; z++){
<a name="l00789"></a>00789       *z = <a class="code" href="global_8c.html#a6bb61005ff51dbe22e7ab8acb9b01e77">sqlite3UpperToLower</a>[*z];
<a name="l00790"></a>00790     }
<a name="l00791"></a>00791     rc = pMod-&gt;<a class="code" href="structsqlite3__module.html#ae70a020a7dda960b91943e9f67695dbb">xFindFunction</a>(pVtab, nArg, zLowerName, &amp;xFunc, &amp;pArg);
<a name="l00792"></a>00792     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zLowerName);
<a name="l00793"></a>00793     <span class="keywordflow">if</span>( pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> ){
<a name="l00794"></a>00794       <a class="code" href="sqliteInt_8h.html#adf4434e94ac41a2abedd476047d49983">sqlite3Error</a>(db, rc, <span class="stringliteral">&quot;%s&quot;</span>, pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>);
<a name="l00795"></a>00795       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>);
<a name="l00796"></a>00796       pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l00797"></a>00797     }
<a name="l00798"></a>00798   }
<a name="l00799"></a>00799   <span class="keywordflow">if</span>( rc==0 ){
<a name="l00800"></a>00800     <span class="keywordflow">return</span> pDef;
<a name="l00801"></a>00801   }
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   <span class="comment">/* Create a new ephemeral function definition for the overloaded</span>
<a name="l00804"></a>00804 <span class="comment">  ** function */</span>
<a name="l00805"></a>00805   pNew = <a class="code" href="malloc_8c.html#a9cdef45d3f06c28e71d728e8b15ebc0f">sqlite3DbMallocZero</a>(db, <span class="keyword">sizeof</span>(*pNew) + strlen(pDef-&gt;<a class="code" href="structFuncDef.html#a1135e622a3a505c7c463e975846ef926">zName</a>) );
<a name="l00806"></a>00806   <span class="keywordflow">if</span>( pNew==0 ){
<a name="l00807"></a>00807     <span class="keywordflow">return</span> pDef;
<a name="l00808"></a>00808   }
<a name="l00809"></a>00809   *pNew = *pDef;
<a name="l00810"></a>00810   pNew-&gt;<a class="code" href="structFuncDef.html#a1135e622a3a505c7c463e975846ef926">zName</a> = (<span class="keywordtype">char</span> *)&amp;pNew[1];
<a name="l00811"></a>00811   memcpy(pNew-&gt;<a class="code" href="structFuncDef.html#a1135e622a3a505c7c463e975846ef926">zName</a>, pDef-&gt;<a class="code" href="structFuncDef.html#a1135e622a3a505c7c463e975846ef926">zName</a>, strlen(pDef-&gt;<a class="code" href="structFuncDef.html#a1135e622a3a505c7c463e975846ef926">zName</a>)+1);
<a name="l00812"></a>00812   pNew-&gt;<a class="code" href="structFuncDef.html#a1cfd07fdfe22ff504ea7f36c0752c1da">xFunc</a> = xFunc;
<a name="l00813"></a>00813   pNew-&gt;<a class="code" href="structFuncDef.html#a04fdde2f96be198823a483bebcfd3ae3">pUserData</a> = pArg;
<a name="l00814"></a>00814   pNew-&gt;<a class="code" href="structFuncDef.html#aed4dc88e58b7582668bcaf425c4d053f">flags</a> |= <a class="code" href="sqliteInt_8h.html#a57775215b5162121f33826ac2f38ef43">SQLITE_FUNC_EPHEM</a>;
<a name="l00815"></a>00815   <span class="keywordflow">return</span> pNew;
<a name="l00816"></a>00816 }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 <span class="comment">/*</span>
<a name="l00819"></a>00819 <span class="comment">** Make sure virtual table pTab is contained in the pParse-&gt;apVirtualLock[]</span>
<a name="l00820"></a>00820 <span class="comment">** array so that an OP_VBegin will get generated for it.  Add pTab to the</span>
<a name="l00821"></a>00821 <span class="comment">** array if it is missing.  If pTab is already in the array, this routine</span>
<a name="l00822"></a>00822 <span class="comment">** is a no-op.</span>
<a name="l00823"></a>00823 <span class="comment">*/</span>
<a name="l00824"></a><a class="code" href="vtab_8c.html#a559bc0001035939d81d1e19daeb2caeb">00824</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#acdaaf5dbcf0f65c36d821a9b126e0230">sqlite3VtabMakeWritable</a>(<a class="code" href="structParse.html">Parse</a> *pParse, <a class="code" href="structTable.html">Table</a> *pTab){
<a name="l00825"></a>00825   <span class="keywordtype">int</span> i, n;
<a name="l00826"></a>00826   assert( <a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) );
<a name="l00827"></a>00827   <span class="keywordflow">for</span>(i=0; i&lt;pParse-&gt;<a class="code" href="structParse.html#a7db8fe1ce2f0ec6bda7dc729a0e6a6e3">nVtabLock</a>; i++){
<a name="l00828"></a>00828     <span class="keywordflow">if</span>( pTab==pParse-&gt;<a class="code" href="structParse.html#acdfd318c0f04ec640d6affc85ef8a009">apVtabLock</a>[i] ) <span class="keywordflow">return</span>;
<a name="l00829"></a>00829   }
<a name="l00830"></a>00830   n = (pParse-&gt;<a class="code" href="structParse.html#a7db8fe1ce2f0ec6bda7dc729a0e6a6e3">nVtabLock</a>+1)*<span class="keyword">sizeof</span>(pParse-&gt;<a class="code" href="structParse.html#acdfd318c0f04ec640d6affc85ef8a009">apVtabLock</a>[0]);
<a name="l00831"></a>00831   pParse-&gt;<a class="code" href="structParse.html#acdfd318c0f04ec640d6affc85ef8a009">apVtabLock</a> = <a class="code" href="malloc_8c.html#a478028442c2ce4635eac464d47465c8f">sqlite3_realloc</a>(pParse-&gt;<a class="code" href="structParse.html#acdfd318c0f04ec640d6affc85ef8a009">apVtabLock</a>, n);
<a name="l00832"></a>00832   <span class="keywordflow">if</span>( pParse-&gt;<a class="code" href="structParse.html#acdfd318c0f04ec640d6affc85ef8a009">apVtabLock</a> ){
<a name="l00833"></a>00833     pParse-&gt;<a class="code" href="structParse.html#acdfd318c0f04ec640d6affc85ef8a009">apVtabLock</a>[pParse-&gt;<a class="code" href="structParse.html#a7db8fe1ce2f0ec6bda7dc729a0e6a6e3">nVtabLock</a>++] = pTab;
<a name="l00834"></a>00834   }<span class="keywordflow">else</span>{
<a name="l00835"></a>00835     pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l00836"></a>00836   }
<a name="l00837"></a>00837 }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:57 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
