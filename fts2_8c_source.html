<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: fts2.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>fts2.c</h1><a href="fts2_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* fts2 has a design flaw which can lead to database corruption (see</span>
<a name="l00002"></a>00002 <span class="comment">** below).  It is recommended not to use it any longer, instead use</span>
<a name="l00003"></a>00003 <span class="comment">** fts3 (or higher).  If you believe that your use of fts2 is safe,</span>
<a name="l00004"></a>00004 <span class="comment">** add -DSQLITE_ENABLE_BROKEN_FTS2=1 to your CFLAGS.</span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 <span class="preprocessor">#if (!defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS2)) \</span>
<a name="l00007"></a>00007 <span class="preprocessor">        &amp;&amp; !defined(SQLITE_ENABLE_BROKEN_FTS2)</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#error fts2 has a design flaw and has been deprecated.</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="comment">/* The flaw is that fts2 uses the content table&apos;s unaliased rowid as</span>
<a name="l00011"></a>00011 <span class="comment">** the unique docid.  fts2 embeds the rowid in the index it builds,</span>
<a name="l00012"></a>00012 <span class="comment">** and expects the rowid to not change.  The SQLite VACUUM operation</span>
<a name="l00013"></a>00013 <span class="comment">** will renumber such rowids, thereby breaking fts2.  If you are using</span>
<a name="l00014"></a>00014 <span class="comment">** fts2 in a system which has disabled VACUUM, then you can continue</span>
<a name="l00015"></a>00015 <span class="comment">** to use it safely.  Note that PRAGMA auto_vacuum does NOT disable</span>
<a name="l00016"></a>00016 <span class="comment">** VACUUM, though systems using auto_vacuum are unlikely to invoke</span>
<a name="l00017"></a>00017 <span class="comment">** VACUUM.</span>
<a name="l00018"></a>00018 <span class="comment">**</span>
<a name="l00019"></a>00019 <span class="comment">** Unlike fts1, which is safe across VACUUM if you never delete</span>
<a name="l00020"></a>00020 <span class="comment">** documents, fts2 has a second exposure to this flaw, in the segments</span>
<a name="l00021"></a>00021 <span class="comment">** table.  So fts2 should be considered unsafe across VACUUM in all</span>
<a name="l00022"></a>00022 <span class="comment">** cases.</span>
<a name="l00023"></a>00023 <span class="comment">*/</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">/*</span>
<a name="l00026"></a>00026 <span class="comment">** 2006 Oct 10</span>
<a name="l00027"></a>00027 <span class="comment">**</span>
<a name="l00028"></a>00028 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00029"></a>00029 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00030"></a>00030 <span class="comment">**</span>
<a name="l00031"></a>00031 <span class="comment">**    May you do good and not evil.</span>
<a name="l00032"></a>00032 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00033"></a>00033 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00034"></a>00034 <span class="comment">**</span>
<a name="l00035"></a>00035 <span class="comment">******************************************************************************</span>
<a name="l00036"></a>00036 <span class="comment">**</span>
<a name="l00037"></a>00037 <span class="comment">** This is an SQLite module implementing full-text search.</span>
<a name="l00038"></a>00038 <span class="comment">*/</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">/*</span>
<a name="l00041"></a>00041 <span class="comment">** The code in this file is only compiled if:</span>
<a name="l00042"></a>00042 <span class="comment">**</span>
<a name="l00043"></a>00043 <span class="comment">**     * The FTS2 module is being built as an extension</span>
<a name="l00044"></a>00044 <span class="comment">**       (in which case SQLITE_CORE is not defined), or</span>
<a name="l00045"></a>00045 <span class="comment">**</span>
<a name="l00046"></a>00046 <span class="comment">**     * The FTS2 module is being built into the core of</span>
<a name="l00047"></a>00047 <span class="comment">**       SQLite (in which case SQLITE_ENABLE_FTS2 is defined).</span>
<a name="l00048"></a>00048 <span class="comment">*/</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">/* TODO(shess) Consider exporting this comment to an HTML file or the</span>
<a name="l00051"></a>00051 <span class="comment">** wiki.</span>
<a name="l00052"></a>00052 <span class="comment">*/</span>
<a name="l00053"></a>00053 <span class="comment">/* The full-text index is stored in a series of b+tree (-like)</span>
<a name="l00054"></a>00054 <span class="comment">** structures called segments which map terms to doclists.  The</span>
<a name="l00055"></a>00055 <span class="comment">** structures are like b+trees in layout, but are constructed from the</span>
<a name="l00056"></a>00056 <span class="comment">** bottom up in optimal fashion and are not updatable.  Since trees</span>
<a name="l00057"></a>00057 <span class="comment">** are built from the bottom up, things will be described from the</span>
<a name="l00058"></a>00058 <span class="comment">** bottom up.</span>
<a name="l00059"></a>00059 <span class="comment">**</span>
<a name="l00060"></a>00060 <span class="comment">**</span>
<a name="l00061"></a>00061 <span class="comment">**** Varints ****</span>
<a name="l00062"></a>00062 <span class="comment">** The basic unit of encoding is a variable-length integer called a</span>
<a name="l00063"></a>00063 <span class="comment">** varint.  We encode variable-length integers in little-endian order</span>
<a name="l00064"></a>00064 <span class="comment">** using seven bits * per byte as follows:</span>
<a name="l00065"></a>00065 <span class="comment">**</span>
<a name="l00066"></a>00066 <span class="comment">** KEY:</span>
<a name="l00067"></a>00067 <span class="comment">**         A = 0xxxxxxx    7 bits of data and one flag bit</span>
<a name="l00068"></a>00068 <span class="comment">**         B = 1xxxxxxx    7 bits of data and one flag bit</span>
<a name="l00069"></a>00069 <span class="comment">**</span>
<a name="l00070"></a>00070 <span class="comment">**  7 bits - A</span>
<a name="l00071"></a>00071 <span class="comment">** 14 bits - BA</span>
<a name="l00072"></a>00072 <span class="comment">** 21 bits - BBA</span>
<a name="l00073"></a>00073 <span class="comment">** and so on.</span>
<a name="l00074"></a>00074 <span class="comment">**</span>
<a name="l00075"></a>00075 <span class="comment">** This is identical to how sqlite encodes varints (see util.c).</span>
<a name="l00076"></a>00076 <span class="comment">**</span>
<a name="l00077"></a>00077 <span class="comment">**</span>
<a name="l00078"></a>00078 <span class="comment">**** Document lists ****</span>
<a name="l00079"></a>00079 <span class="comment">** A doclist (document list) holds a docid-sorted list of hits for a</span>
<a name="l00080"></a>00080 <span class="comment">** given term.  Doclists hold docids, and can optionally associate</span>
<a name="l00081"></a>00081 <span class="comment">** token positions and offsets with docids.</span>
<a name="l00082"></a>00082 <span class="comment">**</span>
<a name="l00083"></a>00083 <span class="comment">** A DL_POSITIONS_OFFSETS doclist is stored like this:</span>
<a name="l00084"></a>00084 <span class="comment">**</span>
<a name="l00085"></a>00085 <span class="comment">** array {</span>
<a name="l00086"></a>00086 <span class="comment">**   varint docid;</span>
<a name="l00087"></a>00087 <span class="comment">**   array {                (position list for column 0)</span>
<a name="l00088"></a>00088 <span class="comment">**     varint position;     (delta from previous position plus POS_BASE)</span>
<a name="l00089"></a>00089 <span class="comment">**     varint startOffset;  (delta from previous startOffset)</span>
<a name="l00090"></a>00090 <span class="comment">**     varint endOffset;    (delta from startOffset)</span>
<a name="l00091"></a>00091 <span class="comment">**   }</span>
<a name="l00092"></a>00092 <span class="comment">**   array {</span>
<a name="l00093"></a>00093 <span class="comment">**     varint POS_COLUMN;   (marks start of position list for new column)</span>
<a name="l00094"></a>00094 <span class="comment">**     varint column;       (index of new column)</span>
<a name="l00095"></a>00095 <span class="comment">**     array {</span>
<a name="l00096"></a>00096 <span class="comment">**       varint position;   (delta from previous position plus POS_BASE)</span>
<a name="l00097"></a>00097 <span class="comment">**       varint startOffset;(delta from previous startOffset)</span>
<a name="l00098"></a>00098 <span class="comment">**       varint endOffset;  (delta from startOffset)</span>
<a name="l00099"></a>00099 <span class="comment">**     }</span>
<a name="l00100"></a>00100 <span class="comment">**   }</span>
<a name="l00101"></a>00101 <span class="comment">**   varint POS_END;        (marks end of positions for this document.</span>
<a name="l00102"></a>00102 <span class="comment">** }</span>
<a name="l00103"></a>00103 <span class="comment">**</span>
<a name="l00104"></a>00104 <span class="comment">** Here, array { X } means zero or more occurrences of X, adjacent in</span>
<a name="l00105"></a>00105 <span class="comment">** memory.  A &quot;position&quot; is an index of a token in the token stream</span>
<a name="l00106"></a>00106 <span class="comment">** generated by the tokenizer, while an &quot;offset&quot; is a byte offset,</span>
<a name="l00107"></a>00107 <span class="comment">** both based at 0.  Note that POS_END and POS_COLUMN occur in the</span>
<a name="l00108"></a>00108 <span class="comment">** same logical place as the position element, and act as sentinals</span>
<a name="l00109"></a>00109 <span class="comment">** ending a position list array.</span>
<a name="l00110"></a>00110 <span class="comment">**</span>
<a name="l00111"></a>00111 <span class="comment">** A DL_POSITIONS doclist omits the startOffset and endOffset</span>
<a name="l00112"></a>00112 <span class="comment">** information.  A DL_DOCIDS doclist omits both the position and</span>
<a name="l00113"></a>00113 <span class="comment">** offset information, becoming an array of varint-encoded docids.</span>
<a name="l00114"></a>00114 <span class="comment">**</span>
<a name="l00115"></a>00115 <span class="comment">** On-disk data is stored as type DL_DEFAULT, so we don&apos;t serialize</span>
<a name="l00116"></a>00116 <span class="comment">** the type.  Due to how deletion is implemented in the segmentation</span>
<a name="l00117"></a>00117 <span class="comment">** system, on-disk doclists MUST store at least positions.</span>
<a name="l00118"></a>00118 <span class="comment">**</span>
<a name="l00119"></a>00119 <span class="comment">**</span>
<a name="l00120"></a>00120 <span class="comment">**** Segment leaf nodes ****</span>
<a name="l00121"></a>00121 <span class="comment">** Segment leaf nodes store terms and doclists, ordered by term.  Leaf</span>
<a name="l00122"></a>00122 <span class="comment">** nodes are written using LeafWriter, and read using LeafReader (to</span>
<a name="l00123"></a>00123 <span class="comment">** iterate through a single leaf node&apos;s data) and LeavesReader (to</span>
<a name="l00124"></a>00124 <span class="comment">** iterate through a segment&apos;s entire leaf layer).  Leaf nodes have</span>
<a name="l00125"></a>00125 <span class="comment">** the format:</span>
<a name="l00126"></a>00126 <span class="comment">**</span>
<a name="l00127"></a>00127 <span class="comment">** varint iHeight;             (height from leaf level, always 0)</span>
<a name="l00128"></a>00128 <span class="comment">** varint nTerm;               (length of first term)</span>
<a name="l00129"></a>00129 <span class="comment">** char pTerm[nTerm];          (content of first term)</span>
<a name="l00130"></a>00130 <span class="comment">** varint nDoclist;            (length of term&apos;s associated doclist)</span>
<a name="l00131"></a>00131 <span class="comment">** char pDoclist[nDoclist];    (content of doclist)</span>
<a name="l00132"></a>00132 <span class="comment">** array {</span>
<a name="l00133"></a>00133 <span class="comment">**                             (further terms are delta-encoded)</span>
<a name="l00134"></a>00134 <span class="comment">**   varint nPrefix;           (length of prefix shared with previous term)</span>
<a name="l00135"></a>00135 <span class="comment">**   varint nSuffix;           (length of unshared suffix)</span>
<a name="l00136"></a>00136 <span class="comment">**   char pTermSuffix[nSuffix];(unshared suffix of next term)</span>
<a name="l00137"></a>00137 <span class="comment">**   varint nDoclist;          (length of term&apos;s associated doclist)</span>
<a name="l00138"></a>00138 <span class="comment">**   char pDoclist[nDoclist];  (content of doclist)</span>
<a name="l00139"></a>00139 <span class="comment">** }</span>
<a name="l00140"></a>00140 <span class="comment">**</span>
<a name="l00141"></a>00141 <span class="comment">** Here, array { X } means zero or more occurrences of X, adjacent in</span>
<a name="l00142"></a>00142 <span class="comment">** memory.</span>
<a name="l00143"></a>00143 <span class="comment">**</span>
<a name="l00144"></a>00144 <span class="comment">** Leaf nodes are broken into blocks which are stored contiguously in</span>
<a name="l00145"></a>00145 <span class="comment">** the %_segments table in sorted order.  This means that when the end</span>
<a name="l00146"></a>00146 <span class="comment">** of a node is reached, the next term is in the node with the next</span>
<a name="l00147"></a>00147 <span class="comment">** greater node id.</span>
<a name="l00148"></a>00148 <span class="comment">**</span>
<a name="l00149"></a>00149 <span class="comment">** New data is spilled to a new leaf node when the current node</span>
<a name="l00150"></a>00150 <span class="comment">** exceeds LEAF_MAX bytes (default 2048).  New data which itself is</span>
<a name="l00151"></a>00151 <span class="comment">** larger than STANDALONE_MIN (default 1024) is placed in a standalone</span>
<a name="l00152"></a>00152 <span class="comment">** node (a leaf node with a single term and doclist).  The goal of</span>
<a name="l00153"></a>00153 <span class="comment">** these settings is to pack together groups of small doclists while</span>
<a name="l00154"></a>00154 <span class="comment">** making it efficient to directly access large doclists.  The</span>
<a name="l00155"></a>00155 <span class="comment">** assumption is that large doclists represent terms which are more</span>
<a name="l00156"></a>00156 <span class="comment">** likely to be query targets.</span>
<a name="l00157"></a>00157 <span class="comment">**</span>
<a name="l00158"></a>00158 <span class="comment">** TODO(shess) It may be useful for blocking decisions to be more</span>
<a name="l00159"></a>00159 <span class="comment">** dynamic.  For instance, it may make more sense to have a 2.5k leaf</span>
<a name="l00160"></a>00160 <span class="comment">** node rather than splitting into 2k and .5k nodes.  My intuition is</span>
<a name="l00161"></a>00161 <span class="comment">** that this might extend through 2x or 4x the pagesize.</span>
<a name="l00162"></a>00162 <span class="comment">**</span>
<a name="l00163"></a>00163 <span class="comment">**</span>
<a name="l00164"></a>00164 <span class="comment">**** Segment interior nodes ****</span>
<a name="l00165"></a>00165 <span class="comment">** Segment interior nodes store blockids for subtree nodes and terms</span>
<a name="l00166"></a>00166 <span class="comment">** to describe what data is stored by the each subtree.  Interior</span>
<a name="l00167"></a>00167 <span class="comment">** nodes are written using InteriorWriter, and read using</span>
<a name="l00168"></a>00168 <span class="comment">** InteriorReader.  InteriorWriters are created as needed when</span>
<a name="l00169"></a>00169 <span class="comment">** SegmentWriter creates new leaf nodes, or when an interior node</span>
<a name="l00170"></a>00170 <span class="comment">** itself grows too big and must be split.  The format of interior</span>
<a name="l00171"></a>00171 <span class="comment">** nodes:</span>
<a name="l00172"></a>00172 <span class="comment">**</span>
<a name="l00173"></a>00173 <span class="comment">** varint iHeight;           (height from leaf level, always &gt;0)</span>
<a name="l00174"></a>00174 <span class="comment">** varint iBlockid;          (block id of node&apos;s leftmost subtree)</span>
<a name="l00175"></a>00175 <span class="comment">** optional {</span>
<a name="l00176"></a>00176 <span class="comment">**   varint nTerm;           (length of first term)</span>
<a name="l00177"></a>00177 <span class="comment">**   char pTerm[nTerm];      (content of first term)</span>
<a name="l00178"></a>00178 <span class="comment">**   array {</span>
<a name="l00179"></a>00179 <span class="comment">**                                (further terms are delta-encoded)</span>
<a name="l00180"></a>00180 <span class="comment">**     varint nPrefix;            (length of shared prefix with previous term)</span>
<a name="l00181"></a>00181 <span class="comment">**     varint nSuffix;            (length of unshared suffix)</span>
<a name="l00182"></a>00182 <span class="comment">**     char pTermSuffix[nSuffix]; (unshared suffix of next term)</span>
<a name="l00183"></a>00183 <span class="comment">**   }</span>
<a name="l00184"></a>00184 <span class="comment">** }</span>
<a name="l00185"></a>00185 <span class="comment">**</span>
<a name="l00186"></a>00186 <span class="comment">** Here, optional { X } means an optional element, while array { X }</span>
<a name="l00187"></a>00187 <span class="comment">** means zero or more occurrences of X, adjacent in memory.</span>
<a name="l00188"></a>00188 <span class="comment">**</span>
<a name="l00189"></a>00189 <span class="comment">** An interior node encodes n terms separating n+1 subtrees.  The</span>
<a name="l00190"></a>00190 <span class="comment">** subtree blocks are contiguous, so only the first subtree&apos;s blockid</span>
<a name="l00191"></a>00191 <span class="comment">** is encoded.  The subtree at iBlockid will contain all terms less</span>
<a name="l00192"></a>00192 <span class="comment">** than the first term encoded (or all terms if no term is encoded).</span>
<a name="l00193"></a>00193 <span class="comment">** Otherwise, for terms greater than or equal to pTerm[i] but less</span>
<a name="l00194"></a>00194 <span class="comment">** than pTerm[i+1], the subtree for that term will be rooted at</span>
<a name="l00195"></a>00195 <span class="comment">** iBlockid+i.  Interior nodes only store enough term data to</span>
<a name="l00196"></a>00196 <span class="comment">** distinguish adjacent children (if the rightmost term of the left</span>
<a name="l00197"></a>00197 <span class="comment">** child is &quot;something&quot;, and the leftmost term of the right child is</span>
<a name="l00198"></a>00198 <span class="comment">** &quot;wicked&quot;, only &quot;w&quot; is stored).</span>
<a name="l00199"></a>00199 <span class="comment">**</span>
<a name="l00200"></a>00200 <span class="comment">** New data is spilled to a new interior node at the same height when</span>
<a name="l00201"></a>00201 <span class="comment">** the current node exceeds INTERIOR_MAX bytes (default 2048).</span>
<a name="l00202"></a>00202 <span class="comment">** INTERIOR_MIN_TERMS (default 7) keeps large terms from monopolizing</span>
<a name="l00203"></a>00203 <span class="comment">** interior nodes and making the tree too skinny.  The interior nodes</span>
<a name="l00204"></a>00204 <span class="comment">** at a given height are naturally tracked by interior nodes at</span>
<a name="l00205"></a>00205 <span class="comment">** height+1, and so on.</span>
<a name="l00206"></a>00206 <span class="comment">**</span>
<a name="l00207"></a>00207 <span class="comment">**</span>
<a name="l00208"></a>00208 <span class="comment">**** Segment directory ****</span>
<a name="l00209"></a>00209 <span class="comment">** The segment directory in table %_segdir stores meta-information for</span>
<a name="l00210"></a>00210 <span class="comment">** merging and deleting segments, and also the root node of the</span>
<a name="l00211"></a>00211 <span class="comment">** segment&apos;s tree.</span>
<a name="l00212"></a>00212 <span class="comment">**</span>
<a name="l00213"></a>00213 <span class="comment">** The root node is the top node of the segment&apos;s tree after encoding</span>
<a name="l00214"></a>00214 <span class="comment">** the entire segment, restricted to ROOT_MAX bytes (default 1024).</span>
<a name="l00215"></a>00215 <span class="comment">** This could be either a leaf node or an interior node.  If the top</span>
<a name="l00216"></a>00216 <span class="comment">** node requires more than ROOT_MAX bytes, it is flushed to %_segments</span>
<a name="l00217"></a>00217 <span class="comment">** and a new root interior node is generated (which should always fit</span>
<a name="l00218"></a>00218 <span class="comment">** within ROOT_MAX because it only needs space for 2 varints, the</span>
<a name="l00219"></a>00219 <span class="comment">** height and the blockid of the previous root).</span>
<a name="l00220"></a>00220 <span class="comment">**</span>
<a name="l00221"></a>00221 <span class="comment">** The meta-information in the segment directory is:</span>
<a name="l00222"></a>00222 <span class="comment">**   level               - segment level (see below)</span>
<a name="l00223"></a>00223 <span class="comment">**   idx                 - index within level</span>
<a name="l00224"></a>00224 <span class="comment">**                       - (level,idx uniquely identify a segment)</span>
<a name="l00225"></a>00225 <span class="comment">**   start_block         - first leaf node</span>
<a name="l00226"></a>00226 <span class="comment">**   leaves_end_block    - last leaf node</span>
<a name="l00227"></a>00227 <span class="comment">**   end_block           - last block (including interior nodes)</span>
<a name="l00228"></a>00228 <span class="comment">**   root                - contents of root node</span>
<a name="l00229"></a>00229 <span class="comment">**</span>
<a name="l00230"></a>00230 <span class="comment">** If the root node is a leaf node, then start_block,</span>
<a name="l00231"></a>00231 <span class="comment">** leaves_end_block, and end_block are all 0.</span>
<a name="l00232"></a>00232 <span class="comment">**</span>
<a name="l00233"></a>00233 <span class="comment">**</span>
<a name="l00234"></a>00234 <span class="comment">**** Segment merging ****</span>
<a name="l00235"></a>00235 <span class="comment">** To amortize update costs, segments are groups into levels and</span>
<a name="l00236"></a>00236 <span class="comment">** merged in matches.  Each increase in level represents exponentially</span>
<a name="l00237"></a>00237 <span class="comment">** more documents.</span>
<a name="l00238"></a>00238 <span class="comment">**</span>
<a name="l00239"></a>00239 <span class="comment">** New documents (actually, document updates) are tokenized and</span>
<a name="l00240"></a>00240 <span class="comment">** written individually (using LeafWriter) to a level 0 segment, with</span>
<a name="l00241"></a>00241 <span class="comment">** incrementing idx.  When idx reaches MERGE_COUNT (default 16), all</span>
<a name="l00242"></a>00242 <span class="comment">** level 0 segments are merged into a single level 1 segment.  Level 1</span>
<a name="l00243"></a>00243 <span class="comment">** is populated like level 0, and eventually MERGE_COUNT level 1</span>
<a name="l00244"></a>00244 <span class="comment">** segments are merged to a single level 2 segment (representing</span>
<a name="l00245"></a>00245 <span class="comment">** MERGE_COUNT^2 updates), and so on.</span>
<a name="l00246"></a>00246 <span class="comment">**</span>
<a name="l00247"></a>00247 <span class="comment">** A segment merge traverses all segments at a given level in</span>
<a name="l00248"></a>00248 <span class="comment">** parallel, performing a straightforward sorted merge.  Since segment</span>
<a name="l00249"></a>00249 <span class="comment">** leaf nodes are written in to the %_segments table in order, this</span>
<a name="l00250"></a>00250 <span class="comment">** merge traverses the underlying sqlite disk structures efficiently.</span>
<a name="l00251"></a>00251 <span class="comment">** After the merge, all segment blocks from the merged level are</span>
<a name="l00252"></a>00252 <span class="comment">** deleted.</span>
<a name="l00253"></a>00253 <span class="comment">**</span>
<a name="l00254"></a>00254 <span class="comment">** MERGE_COUNT controls how often we merge segments.  16 seems to be</span>
<a name="l00255"></a>00255 <span class="comment">** somewhat of a sweet spot for insertion performance.  32 and 64 show</span>
<a name="l00256"></a>00256 <span class="comment">** very similar performance numbers to 16 on insertion, though they&apos;re</span>
<a name="l00257"></a>00257 <span class="comment">** a tiny bit slower (perhaps due to more overhead in merge-time</span>
<a name="l00258"></a>00258 <span class="comment">** sorting).  8 is about 20% slower than 16, 4 about 50% slower than</span>
<a name="l00259"></a>00259 <span class="comment">** 16, 2 about 66% slower than 16.</span>
<a name="l00260"></a>00260 <span class="comment">**</span>
<a name="l00261"></a>00261 <span class="comment">** At query time, high MERGE_COUNT increases the number of segments</span>
<a name="l00262"></a>00262 <span class="comment">** which need to be scanned and merged.  For instance, with 100k docs</span>
<a name="l00263"></a>00263 <span class="comment">** inserted:</span>
<a name="l00264"></a>00264 <span class="comment">**</span>
<a name="l00265"></a>00265 <span class="comment">**    MERGE_COUNT   segments</span>
<a name="l00266"></a>00266 <span class="comment">**       16           25</span>
<a name="l00267"></a>00267 <span class="comment">**        8           12</span>
<a name="l00268"></a>00268 <span class="comment">**        4           10</span>
<a name="l00269"></a>00269 <span class="comment">**        2            6</span>
<a name="l00270"></a>00270 <span class="comment">**</span>
<a name="l00271"></a>00271 <span class="comment">** This appears to have only a moderate impact on queries for very</span>
<a name="l00272"></a>00272 <span class="comment">** frequent terms (which are somewhat dominated by segment merge</span>
<a name="l00273"></a>00273 <span class="comment">** costs), and infrequent and non-existent terms still seem to be fast</span>
<a name="l00274"></a>00274 <span class="comment">** even with many segments.</span>
<a name="l00275"></a>00275 <span class="comment">**</span>
<a name="l00276"></a>00276 <span class="comment">** TODO(shess) That said, it would be nice to have a better query-side</span>
<a name="l00277"></a>00277 <span class="comment">** argument for MERGE_COUNT of 16.  Also, it is possible/likely that</span>
<a name="l00278"></a>00278 <span class="comment">** optimizations to things like doclist merging will swing the sweet</span>
<a name="l00279"></a>00279 <span class="comment">** spot around.</span>
<a name="l00280"></a>00280 <span class="comment">**</span>
<a name="l00281"></a>00281 <span class="comment">**</span>
<a name="l00282"></a>00282 <span class="comment">**</span>
<a name="l00283"></a>00283 <span class="comment">**** Handling of deletions and updates ****</span>
<a name="l00284"></a>00284 <span class="comment">** Since we&apos;re using a segmented structure, with no docid-oriented</span>
<a name="l00285"></a>00285 <span class="comment">** index into the term index, we clearly cannot simply update the term</span>
<a name="l00286"></a>00286 <span class="comment">** index when a document is deleted or updated.  For deletions, we</span>
<a name="l00287"></a>00287 <span class="comment">** write an empty doclist (varint(docid) varint(POS_END)), for updates</span>
<a name="l00288"></a>00288 <span class="comment">** we simply write the new doclist.  Segment merges overwrite older</span>
<a name="l00289"></a>00289 <span class="comment">** data for a particular docid with newer data, so deletes or updates</span>
<a name="l00290"></a>00290 <span class="comment">** will eventually overtake the earlier data and knock it out.  The</span>
<a name="l00291"></a>00291 <span class="comment">** query logic likewise merges doclists so that newer data knocks out</span>
<a name="l00292"></a>00292 <span class="comment">** older data.</span>
<a name="l00293"></a>00293 <span class="comment">**</span>
<a name="l00294"></a>00294 <span class="comment">** TODO(shess) Provide a VACUUM type operation to clear out all</span>
<a name="l00295"></a>00295 <span class="comment">** deletions and duplications.  This would basically be a forced merge</span>
<a name="l00296"></a>00296 <span class="comment">** into a single segment.</span>
<a name="l00297"></a>00297 <span class="comment">*/</span>
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="preprocessor">#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS2)</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>
<a name="l00301"></a>00301 <span class="preprocessor">#if defined(SQLITE_ENABLE_FTS2) &amp;&amp; !defined(SQLITE_CORE)</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span><span class="preprocessor"># define SQLITE_CORE 1</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00304"></a>00304 <span class="preprocessor"></span>
<a name="l00305"></a>00305 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00306"></a>00306 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00307"></a>00307 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00308"></a>00308 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00309"></a>00309 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="preprocessor">#include &quot;<a class="code" href="fts2_8h.html">fts2.h</a>&quot;</span>
<a name="l00312"></a>00312 <span class="preprocessor">#include &quot;<a class="code" href="fts2__hash_8h.html">fts2_hash.h</a>&quot;</span>
<a name="l00313"></a>00313 <span class="preprocessor">#include &quot;<a class="code" href="fts2__tokenizer_8h.html">fts2_tokenizer.h</a>&quot;</span>
<a name="l00314"></a>00314 <span class="preprocessor">#include &quot;<a class="code" href="sqlite3_8h.html">sqlite3.h</a>&quot;</span>
<a name="l00315"></a>00315 <span class="preprocessor">#include &quot;<a class="code" href="sqlite3ext_8h.html">sqlite3ext.h</a>&quot;</span>
<a name="l00316"></a>00316 <a class="code" href="sqlite3ext_8h.html#afff1053b875c905fa8695b458d836b42">SQLITE_EXTENSION_INIT1</a>
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">/* TODO(shess) MAN, this thing needs some refactoring.  At minimum, it</span>
<a name="l00320"></a>00320 <span class="comment">** would be nice to order the file better, perhaps something along the</span>
<a name="l00321"></a>00321 <span class="comment">** lines of:</span>
<a name="l00322"></a>00322 <span class="comment">**</span>
<a name="l00323"></a>00323 <span class="comment">**  - utility functions</span>
<a name="l00324"></a>00324 <span class="comment">**  - table setup functions</span>
<a name="l00325"></a>00325 <span class="comment">**  - table update functions</span>
<a name="l00326"></a>00326 <span class="comment">**  - table query functions</span>
<a name="l00327"></a>00327 <span class="comment">**</span>
<a name="l00328"></a>00328 <span class="comment">** Put the query functions last because they&apos;re likely to reference</span>
<a name="l00329"></a>00329 <span class="comment">** typedefs or functions from the table update section.</span>
<a name="l00330"></a>00330 <span class="comment">*/</span>
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 <span class="preprocessor">#if 0</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span><span class="preprocessor"># define TRACE(A)  printf A; fflush(stdout)</span>
<a name="l00334"></a>00334 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00335"></a><a class="code" href="fts2_8c.html#aeaae6edb1c0c3f3eaf73c0199c25afb3">00335</a> <span class="preprocessor"></span><span class="preprocessor"># define TRACE(A)</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00337"></a>00337 <span class="preprocessor"></span>
<a name="l00338"></a>00338 <span class="comment">/* It is not safe to call isspace(), tolower(), or isalnum() on</span>
<a name="l00339"></a>00339 <span class="comment">** hi-bit-set characters.  This is the same solution used in the</span>
<a name="l00340"></a>00340 <span class="comment">** tokenizer.</span>
<a name="l00341"></a>00341 <span class="comment">*/</span>
<a name="l00342"></a>00342 <span class="comment">/* TODO(shess) The snippet-generation code should be using the</span>
<a name="l00343"></a>00343 <span class="comment">** tokenizer-generated tokens rather than doing its own local</span>
<a name="l00344"></a>00344 <span class="comment">** tokenization.</span>
<a name="l00345"></a>00345 <span class="comment">*/</span>
<a name="l00346"></a>00346 <span class="comment">/* TODO(shess) Is __isascii() a portable version of (c&amp;0x80)==0? */</span>
<a name="l00347"></a><a class="code" href="fts2_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">00347</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(<span class="keywordtype">char</span> c){
<a name="l00348"></a>00348   <span class="keywordflow">return</span> (c&amp;0x80)==0 ? isspace(c) : 0;
<a name="l00349"></a>00349 }
<a name="l00350"></a><a class="code" href="fts2_8c.html#aa13290c27de028c6f1886f82656482fa">00350</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aa13290c27de028c6f1886f82656482fa">safe_tolower</a>(<span class="keywordtype">char</span> c){
<a name="l00351"></a>00351   <span class="keywordflow">return</span> (c&amp;0x80)==0 ? tolower(c) : c;
<a name="l00352"></a>00352 }
<a name="l00353"></a><a class="code" href="fts2_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">00353</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">safe_isalnum</a>(<span class="keywordtype">char</span> c){
<a name="l00354"></a>00354   <span class="keywordflow">return</span> (c&amp;0x80)==0 ? isalnum(c) : 0;
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 
<a name="l00357"></a><a class="code" href="fts2_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">00357</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> {
<a name="l00358"></a><a class="code" href="fts2_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">00358</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>,              <span class="comment">/* docids only */</span>
<a name="l00359"></a><a class="code" href="fts2_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">00359</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a>,           <span class="comment">/* docids + positions */</span>
<a name="l00360"></a><a class="code" href="fts2_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">00360</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a>    <span class="comment">/* docids + positions + offsets */</span>
<a name="l00361"></a>00361 } <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a>;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 <span class="comment">/*</span>
<a name="l00364"></a>00364 <span class="comment">** By default, only positions and not offsets are stored in the doclists.</span>
<a name="l00365"></a>00365 <span class="comment">** To change this so that offsets are stored too, compile with</span>
<a name="l00366"></a>00366 <span class="comment">**</span>
<a name="l00367"></a>00367 <span class="comment">**          -DDL_DEFAULT=DL_POSITIONS_OFFSETS</span>
<a name="l00368"></a>00368 <span class="comment">**</span>
<a name="l00369"></a>00369 <span class="comment">** If DL_DEFAULT is set to DL_DOCIDS, your table can only be inserted</span>
<a name="l00370"></a>00370 <span class="comment">** into (no deletes or updates).</span>
<a name="l00371"></a>00371 <span class="comment">*/</span>
<a name="l00372"></a>00372 <span class="preprocessor">#ifndef DL_DEFAULT</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span><span class="preprocessor"># define DL_DEFAULT DL_POSITIONS</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00375"></a>00375 <span class="preprocessor"></span>
<a name="l00376"></a>00376 <span class="keyword">enum</span> {
<a name="l00377"></a><a class="code" href="fts2_8c.html#a05589fbab0657f08285ebdfe93f5ec9ea99a23817e10baf2a99599ffaa7c36f2b">00377</a>   <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a> = 0,        <span class="comment">/* end of this position list */</span>
<a name="l00378"></a><a class="code" href="fts2_8c.html#a05589fbab0657f08285ebdfe93f5ec9ea72830b71eccc1ce94c57582ad624bea2">00378</a>   <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">POS_COLUMN</a>,         <span class="comment">/* followed by new column number */</span>
<a name="l00379"></a><a class="code" href="fts2_8c.html#a05589fbab0657f08285ebdfe93f5ec9ea97c7ac3d72e7a29547748b3c4f529945">00379</a>   <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a97c7ac3d72e7a29547748b3c4f529945">POS_BASE</a>
<a name="l00380"></a>00380 };
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="comment">/* MERGE_COUNT controls how often we merge segments (see comment at</span>
<a name="l00383"></a>00383 <span class="comment">** top of file).</span>
<a name="l00384"></a>00384 <span class="comment">*/</span>
<a name="l00385"></a><a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">00385</a> <span class="preprocessor">#define MERGE_COUNT 16</span>
<a name="l00386"></a>00386 <span class="preprocessor"></span>
<a name="l00387"></a>00387 <span class="comment">/* utility functions */</span>
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 <span class="comment">/* CLEAR() and SCRAMBLE() abstract memset() on a pointer to a single</span>
<a name="l00390"></a>00390 <span class="comment">** record to prevent errors of the form:</span>
<a name="l00391"></a>00391 <span class="comment">**</span>
<a name="l00392"></a>00392 <span class="comment">** my_function(SomeType *b){</span>
<a name="l00393"></a>00393 <span class="comment">**   memset(b, &apos;\0&apos;, sizeof(b));  // sizeof(b)!=sizeof(*b)</span>
<a name="l00394"></a>00394 <span class="comment">** }</span>
<a name="l00395"></a>00395 <span class="comment">*/</span>
<a name="l00396"></a>00396 <span class="comment">/* TODO(shess) Obvious candidates for a header file. */</span>
<a name="l00397"></a><a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">00397</a> <span class="preprocessor">#define CLEAR(b) memset(b, &apos;\0&apos;, sizeof(*(b)))</span>
<a name="l00398"></a>00398 <span class="preprocessor"></span>
<a name="l00399"></a>00399 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span><span class="preprocessor">#  define SCRAMBLE(b) memset(b, 0x55, sizeof(*(b)))</span>
<a name="l00401"></a>00401 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00402"></a><a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">00402</a> <span class="preprocessor"></span><span class="preprocessor">#  define SCRAMBLE(b)</span>
<a name="l00403"></a>00403 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00404"></a>00404 <span class="preprocessor"></span>
<a name="l00405"></a>00405 <span class="comment">/* We may need up to VARINT_MAX bytes to store an encoded 64-bit integer. */</span>
<a name="l00406"></a><a class="code" href="fts2_8c.html#abdded853f553807df4d7ff2363c313e8">00406</a> <span class="preprocessor">#define VARINT_MAX 10</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>
<a name="l00408"></a>00408 <span class="comment">/* Write a 64-bit variable-length integer to memory starting at p[0].</span>
<a name="l00409"></a>00409 <span class="comment"> * The length of data written will be between 1 and VARINT_MAX bytes.</span>
<a name="l00410"></a>00410 <span class="comment"> * The number of bytes written is returned. */</span>
<a name="l00411"></a><a class="code" href="fts2_8c.html#a67a954d4b47621a14ebae9c22d46a271">00411</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(<span class="keywordtype">char</span> *p, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> v){
<a name="l00412"></a>00412   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *q = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) p;
<a name="l00413"></a>00413   <a class="code" href="sqlite3_8h.html#a127a9c18f6d067a05b994f5d0111ee25">sqlite_uint64</a> vu = v;
<a name="l00414"></a>00414   <span class="keywordflow">do</span>{
<a name="l00415"></a>00415     *q++ = (<span class="keywordtype">unsigned</span> char) ((vu &amp; 0x7f) | 0x80);
<a name="l00416"></a>00416     vu &gt;&gt;= 7;
<a name="l00417"></a>00417   }<span class="keywordflow">while</span>( vu!=0 );
<a name="l00418"></a>00418   q[-1] &amp;= 0x7f;  <span class="comment">/* turn off high bit in final byte */</span>
<a name="l00419"></a>00419   assert( q - (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)p &lt;= <a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a> );
<a name="l00420"></a>00420   <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) (q - (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)p);
<a name="l00421"></a>00421 }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 <span class="comment">/* Read a 64-bit variable-length integer from memory starting at p[0].</span>
<a name="l00424"></a>00424 <span class="comment"> * Return the number of bytes read, or 0 on error.</span>
<a name="l00425"></a>00425 <span class="comment"> * The value is stored in *v. */</span>
<a name="l00426"></a><a class="code" href="fts2_8c.html#a2e94291c61716c6bbb22f0e44cfa2b79">00426</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *p, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *v){
<a name="l00427"></a>00427   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *q = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) p;
<a name="l00428"></a>00428   <a class="code" href="sqlite3_8h.html#a127a9c18f6d067a05b994f5d0111ee25">sqlite_uint64</a> x = 0, y = 1;
<a name="l00429"></a>00429   <span class="keywordflow">while</span>( (*q &amp; 0x80) == 0x80 ){
<a name="l00430"></a>00430     x += y * (*q++ &amp; 0x7f);
<a name="l00431"></a>00431     y &lt;&lt;= 7;
<a name="l00432"></a>00432     <span class="keywordflow">if</span>( q - (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)p &gt;= <a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a> ){  <span class="comment">/* bad data */</span>
<a name="l00433"></a>00433       assert( 0 );
<a name="l00434"></a>00434       <span class="keywordflow">return</span> 0;
<a name="l00435"></a>00435     }
<a name="l00436"></a>00436   }
<a name="l00437"></a>00437   x += y * (*q++);
<a name="l00438"></a>00438   *v = (<a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a>) x;
<a name="l00439"></a>00439   <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) (q - (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)p);
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a><a class="code" href="fts2_8c.html#ae06c82772c657bafa9fd7af259034782">00442</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> *pi){
<a name="l00443"></a>00443  <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> i;
<a name="l00444"></a>00444  <span class="keywordtype">int</span> ret = <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(p, &amp;i);
<a name="l00445"></a>00445  *pi = (int) i;
<a name="l00446"></a>00446  assert( *pi==i );
<a name="l00447"></a>00447  <span class="keywordflow">return</span> ret;
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 <span class="comment">/*******************************************************************/</span>
<a name="l00451"></a>00451 <span class="comment">/* DataBuffer is used to collect data into a buffer in piecemeal</span>
<a name="l00452"></a>00452 <span class="comment">** fashion.  It implements the usual distinction between amount of</span>
<a name="l00453"></a>00453 <span class="comment">** data currently stored (nData) and buffer capacity (nCapacity).</span>
<a name="l00454"></a>00454 <span class="comment">**</span>
<a name="l00455"></a>00455 <span class="comment">** dataBufferInit - create a buffer with given initial capacity.</span>
<a name="l00456"></a>00456 <span class="comment">** dataBufferReset - forget buffer&apos;s data, retaining capacity.</span>
<a name="l00457"></a>00457 <span class="comment">** dataBufferDestroy - free buffer&apos;s data.</span>
<a name="l00458"></a>00458 <span class="comment">** dataBufferSwap - swap contents of two buffers.</span>
<a name="l00459"></a>00459 <span class="comment">** dataBufferExpand - expand capacity without adding data.</span>
<a name="l00460"></a>00460 <span class="comment">** dataBufferAppend - append data.</span>
<a name="l00461"></a>00461 <span class="comment">** dataBufferAppend2 - append two pieces of data at once.</span>
<a name="l00462"></a>00462 <span class="comment">** dataBufferReplace - replace buffer&apos;s data.</span>
<a name="l00463"></a>00463 <span class="comment">*/</span>
<a name="l00464"></a><a class="code" href="structDataBuffer.html">00464</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structDataBuffer.html">DataBuffer</a> {
<a name="l00465"></a><a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">00465</a>   <span class="keywordtype">char</span> *<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>;          <span class="comment">/* Pointer to malloc&apos;ed buffer. */</span>
<a name="l00466"></a><a class="code" href="structDataBuffer.html#a94be96e6647b66004cdc163cd6cd1df4">00466</a>   <span class="keywordtype">int</span> <a class="code" href="structDataBuffer.html#a94be96e6647b66004cdc163cd6cd1df4">nCapacity</a>;        <span class="comment">/* Size of pData buffer. */</span>
<a name="l00467"></a><a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">00467</a>   <span class="keywordtype">int</span> <a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>;            <span class="comment">/* End of data loaded into pData. */</span>
<a name="l00468"></a>00468 } <a class="code" href="structDataBuffer.html">DataBuffer</a>;
<a name="l00469"></a>00469 
<a name="l00470"></a><a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">00470</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffer, <span class="keywordtype">int</span> nCapacity){
<a name="l00471"></a>00471   assert( nCapacity&gt;=0 );
<a name="l00472"></a>00472   pBuffer-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> = 0;
<a name="l00473"></a>00473   pBuffer-&gt;<a class="code" href="structDataBuffer.html#a94be96e6647b66004cdc163cd6cd1df4">nCapacity</a> = nCapacity;
<a name="l00474"></a>00474   pBuffer-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a> = nCapacity==0 ? NULL : <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(nCapacity);
<a name="l00475"></a>00475 }
<a name="l00476"></a><a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">00476</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffer){
<a name="l00477"></a>00477   pBuffer-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> = 0;
<a name="l00478"></a>00478 }
<a name="l00479"></a><a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">00479</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffer){
<a name="l00480"></a>00480   <span class="keywordflow">if</span>( pBuffer-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>!=NULL ) <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pBuffer-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>);
<a name="l00481"></a>00481   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pBuffer);
<a name="l00482"></a>00482 }
<a name="l00483"></a><a class="code" href="fts2_8c.html#aa9ed042d26904ee854cb8a87c6d2d666">00483</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aa9ed042d26904ee854cb8a87c6d2d666">dataBufferSwap</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffer1, <a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffer2){
<a name="l00484"></a>00484   <a class="code" href="structDataBuffer.html">DataBuffer</a> tmp = *pBuffer1;
<a name="l00485"></a>00485   *pBuffer1 = *pBuffer2;
<a name="l00486"></a>00486   *pBuffer2 = tmp;
<a name="l00487"></a>00487 }
<a name="l00488"></a><a class="code" href="fts2_8c.html#adacb3dea03975658c0e31acb2501e49f">00488</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#adacb3dea03975658c0e31acb2501e49f">dataBufferExpand</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffer, <span class="keywordtype">int</span> nAddCapacity){
<a name="l00489"></a>00489   assert( nAddCapacity&gt;0 );
<a name="l00490"></a>00490   <span class="comment">/* TODO(shess) Consider expanding more aggressively.  Note that the</span>
<a name="l00491"></a>00491 <span class="comment">  ** underlying malloc implementation may take care of such things for</span>
<a name="l00492"></a>00492 <span class="comment">  ** us already.</span>
<a name="l00493"></a>00493 <span class="comment">  */</span>
<a name="l00494"></a>00494   <span class="keywordflow">if</span>( pBuffer-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>+nAddCapacity&gt;pBuffer-&gt;<a class="code" href="structDataBuffer.html#a94be96e6647b66004cdc163cd6cd1df4">nCapacity</a> ){
<a name="l00495"></a>00495     pBuffer-&gt;<a class="code" href="structDataBuffer.html#a94be96e6647b66004cdc163cd6cd1df4">nCapacity</a> = pBuffer-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>+nAddCapacity;
<a name="l00496"></a>00496     pBuffer-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a> = <a class="code" href="malloc_8c.html#a478028442c2ce4635eac464d47465c8f">sqlite3_realloc</a>(pBuffer-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, pBuffer-&gt;<a class="code" href="structDataBuffer.html#a94be96e6647b66004cdc163cd6cd1df4">nCapacity</a>);
<a name="l00497"></a>00497   }
<a name="l00498"></a>00498 }
<a name="l00499"></a><a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">00499</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffer,
<a name="l00500"></a>00500                              <span class="keyword">const</span> <span class="keywordtype">char</span> *pSource, <span class="keywordtype">int</span> nSource){
<a name="l00501"></a>00501   assert( nSource&gt;0 &amp;&amp; pSource!=NULL );
<a name="l00502"></a>00502   <a class="code" href="fts2_8c.html#adacb3dea03975658c0e31acb2501e49f">dataBufferExpand</a>(pBuffer, nSource);
<a name="l00503"></a>00503   memcpy(pBuffer-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+pBuffer-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, pSource, nSource);
<a name="l00504"></a>00504   pBuffer-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> += nSource;
<a name="l00505"></a>00505 }
<a name="l00506"></a><a class="code" href="fts2_8c.html#a5cb462adcb518c795ccb9b8d1a44c0a2">00506</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a5cb462adcb518c795ccb9b8d1a44c0a2">dataBufferAppend2</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffer,
<a name="l00507"></a>00507                               <span class="keyword">const</span> <span class="keywordtype">char</span> *pSource1, <span class="keywordtype">int</span> nSource1,
<a name="l00508"></a>00508                               <span class="keyword">const</span> <span class="keywordtype">char</span> *pSource2, <span class="keywordtype">int</span> nSource2){
<a name="l00509"></a>00509   assert( nSource1&gt;0 &amp;&amp; pSource1!=NULL );
<a name="l00510"></a>00510   assert( nSource2&gt;0 &amp;&amp; pSource2!=NULL );
<a name="l00511"></a>00511   <a class="code" href="fts2_8c.html#adacb3dea03975658c0e31acb2501e49f">dataBufferExpand</a>(pBuffer, nSource1+nSource2);
<a name="l00512"></a>00512   memcpy(pBuffer-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+pBuffer-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, pSource1, nSource1);
<a name="l00513"></a>00513   memcpy(pBuffer-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+pBuffer-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>+nSource1, pSource2, nSource2);
<a name="l00514"></a>00514   pBuffer-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> += nSource1+nSource2;
<a name="l00515"></a>00515 }
<a name="l00516"></a><a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">00516</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffer,
<a name="l00517"></a>00517                               <span class="keyword">const</span> <span class="keywordtype">char</span> *pSource, <span class="keywordtype">int</span> nSource){
<a name="l00518"></a>00518   <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(pBuffer);
<a name="l00519"></a>00519   <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pBuffer, pSource, nSource);
<a name="l00520"></a>00520 }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522 <span class="comment">/* StringBuffer is a null-terminated version of DataBuffer. */</span>
<a name="l00523"></a>00523 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structStringBuffer.html">StringBuffer</a> {
<a name="l00524"></a><a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">00524</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>;            <span class="comment">/* Includes null terminator. */</span>
<a name="l00525"></a>00525 } <a class="code" href="structStringBuffer.html">StringBuffer</a>;
<a name="l00526"></a>00526 
<a name="l00527"></a><a class="code" href="fts2_8c.html#af53d41e9c022beb0601be19642881765">00527</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb){
<a name="l00528"></a>00528   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;sb-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>, 100);
<a name="l00529"></a>00529   <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(&amp;sb-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>, <span class="stringliteral">&quot;&quot;</span>, 1);
<a name="l00530"></a>00530 }
<a name="l00531"></a><a class="code" href="fts2_8c.html#a56627c1d8b74dcf698115ca20b7accd8">00531</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a56627c1d8b74dcf698115ca20b7accd8">stringBufferLength</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb){
<a name="l00532"></a>00532   <span class="keywordflow">return</span> sb-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>-1;
<a name="l00533"></a>00533 }
<a name="l00534"></a><a class="code" href="fts2_8c.html#ab18184660d40766ca94505dbf1acaf5f">00534</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#ab18184660d40766ca94505dbf1acaf5f">stringBufferData</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb){
<a name="l00535"></a>00535   <span class="keywordflow">return</span> sb-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>;
<a name="l00536"></a>00536 }
<a name="l00537"></a><a class="code" href="fts2_8c.html#a785a73228d39f5c83891bdd56ced4e35">00537</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a785a73228d39f5c83891bdd56ced4e35">stringBufferDestroy</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb){
<a name="l00538"></a>00538   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;sb-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>);
<a name="l00539"></a>00539 }
<a name="l00540"></a>00540 
<a name="l00541"></a><a class="code" href="fts2_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">00541</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFrom, <span class="keywordtype">int</span> nFrom){
<a name="l00542"></a>00542   assert( sb-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 );
<a name="l00543"></a>00543   <span class="keywordflow">if</span>( nFrom&gt;0 ){
<a name="l00544"></a>00544     sb-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>--;
<a name="l00545"></a>00545     <a class="code" href="fts2_8c.html#a5cb462adcb518c795ccb9b8d1a44c0a2">dataBufferAppend2</a>(&amp;sb-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>, zFrom, nFrom, <span class="stringliteral">&quot;&quot;</span>, 1);
<a name="l00546"></a>00546   }
<a name="l00547"></a>00547 }
<a name="l00548"></a><a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">00548</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFrom){
<a name="l00549"></a>00549   <a class="code" href="fts2_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(sb, zFrom, strlen(zFrom));
<a name="l00550"></a>00550 }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="comment">/* Append a list of strings separated by commas. */</span>
<a name="l00553"></a><a class="code" href="fts2_8c.html#a25815e8e930bcd9e3eabfe5ee1c9412f">00553</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a25815e8e930bcd9e3eabfe5ee1c9412f">appendList</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *sb, <span class="keywordtype">int</span> nString, <span class="keywordtype">char</span> **azString){
<a name="l00554"></a>00554   <span class="keywordtype">int</span> i;
<a name="l00555"></a>00555   <span class="keywordflow">for</span>(i=0; i&lt;nString; ++i){
<a name="l00556"></a>00556     <span class="keywordflow">if</span>( i&gt;0 ) <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(sb, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l00557"></a>00557     <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(sb, azString[i]);
<a name="l00558"></a>00558   }
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 
<a name="l00561"></a><a class="code" href="fts2_8c.html#a00cb2c31920cc0101c52f1c1c2c72492">00561</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a00cb2c31920cc0101c52f1c1c2c72492">endsInWhiteSpace</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *p){
<a name="l00562"></a>00562   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a56627c1d8b74dcf698115ca20b7accd8">stringBufferLength</a>(p)&gt;0 &amp;&amp;
<a name="l00563"></a>00563     <a class="code" href="fts2_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(<a class="code" href="fts2_8c.html#ab18184660d40766ca94505dbf1acaf5f">stringBufferData</a>(p)[<a class="code" href="fts2_8c.html#a56627c1d8b74dcf698115ca20b7accd8">stringBufferLength</a>(p)-1]);
<a name="l00564"></a>00564 }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 <span class="comment">/* If the StringBuffer ends in something other than white space, add a</span>
<a name="l00567"></a>00567 <span class="comment">** single space character to the end.</span>
<a name="l00568"></a>00568 <span class="comment">*/</span>
<a name="l00569"></a><a class="code" href="fts2_8c.html#ad5cddce8600a160495ae0fa2f778fde4">00569</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#ad5cddce8600a160495ae0fa2f778fde4">appendWhiteSpace</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *p){
<a name="l00570"></a>00570   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a56627c1d8b74dcf698115ca20b7accd8">stringBufferLength</a>(p)==0 ) <span class="keywordflow">return</span>;
<a name="l00571"></a>00571   <span class="keywordflow">if</span>( !<a class="code" href="fts2_8c.html#a00cb2c31920cc0101c52f1c1c2c72492">endsInWhiteSpace</a>(p) ) <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(p, <span class="stringliteral">&quot; &quot;</span>);
<a name="l00572"></a>00572 }
<a name="l00573"></a>00573 
<a name="l00574"></a>00574 <span class="comment">/* Remove white space from the end of the StringBuffer */</span>
<a name="l00575"></a><a class="code" href="fts2_8c.html#a5afad57e102ddaa7772992b7a69bc6a6">00575</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a5afad57e102ddaa7772992b7a69bc6a6">trimWhiteSpace</a>(<a class="code" href="structStringBuffer.html">StringBuffer</a> *p){
<a name="l00576"></a>00576   <span class="keywordflow">while</span>( <a class="code" href="fts2_8c.html#a00cb2c31920cc0101c52f1c1c2c72492">endsInWhiteSpace</a>(p) ){
<a name="l00577"></a>00577     p-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>[--p-&gt;<a class="code" href="structStringBuffer.html#a81571d839e40f4fe71db92373efa2324">b</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>-1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00578"></a>00578   }
<a name="l00579"></a>00579 }
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="comment">/*******************************************************************/</span>
<a name="l00582"></a>00582 <span class="comment">/* DLReader is used to read document elements from a doclist.  The</span>
<a name="l00583"></a>00583 <span class="comment">** current docid is cached, so dlrDocid() is fast.  DLReader does not</span>
<a name="l00584"></a>00584 <span class="comment">** own the doclist buffer.</span>
<a name="l00585"></a>00585 <span class="comment">**</span>
<a name="l00586"></a>00586 <span class="comment">** dlrAtEnd - true if there&apos;s no more data to read.</span>
<a name="l00587"></a>00587 <span class="comment">** dlrDocid - docid of current document.</span>
<a name="l00588"></a>00588 <span class="comment">** dlrDocData - doclist data for current document (including docid).</span>
<a name="l00589"></a>00589 <span class="comment">** dlrDocDataBytes - length of same.</span>
<a name="l00590"></a>00590 <span class="comment">** dlrAllDataBytes - length of all remaining data.</span>
<a name="l00591"></a>00591 <span class="comment">** dlrPosData - position data for current document.</span>
<a name="l00592"></a>00592 <span class="comment">** dlrPosDataLen - length of pos data for current document (incl POS_END).</span>
<a name="l00593"></a>00593 <span class="comment">** dlrStep - step to current document.</span>
<a name="l00594"></a>00594 <span class="comment">** dlrInit - initial for doclist of given type against given data.</span>
<a name="l00595"></a>00595 <span class="comment">** dlrDestroy - clean up.</span>
<a name="l00596"></a>00596 <span class="comment">**</span>
<a name="l00597"></a>00597 <span class="comment">** Expected usage is something like:</span>
<a name="l00598"></a>00598 <span class="comment">**</span>
<a name="l00599"></a>00599 <span class="comment">**   DLReader reader;</span>
<a name="l00600"></a>00600 <span class="comment">**   dlrInit(&amp;reader, pData, nData);</span>
<a name="l00601"></a>00601 <span class="comment">**   while( !dlrAtEnd(&amp;reader) ){</span>
<a name="l00602"></a>00602 <span class="comment">**     // calls to dlrDocid() and kin.</span>
<a name="l00603"></a>00603 <span class="comment">**     dlrStep(&amp;reader);</span>
<a name="l00604"></a>00604 <span class="comment">**   }</span>
<a name="l00605"></a>00605 <span class="comment">**   dlrDestroy(&amp;reader);</span>
<a name="l00606"></a>00606 <span class="comment">*/</span>
<a name="l00607"></a><a class="code" href="structDLReader.html">00607</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structDLReader.html">DLReader</a> {
<a name="l00608"></a><a class="code" href="structDLReader.html#a93c2770301c7a3469d9f3055e44e7b64">00608</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> <a class="code" href="structDLReader.html#a93c2770301c7a3469d9f3055e44e7b64">iType</a>;
<a name="l00609"></a><a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">00609</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>;
<a name="l00610"></a><a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">00610</a>   <span class="keywordtype">int</span> <a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">nData</a>;
<a name="l00611"></a>00611 
<a name="l00612"></a><a class="code" href="structDLReader.html#a021896eae6566fa0ecab666719caab44">00612</a>   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="structDLReader.html#a021896eae6566fa0ecab666719caab44">iDocid</a>;
<a name="l00613"></a><a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">00613</a>   <span class="keywordtype">int</span> <a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">nElement</a>;
<a name="l00614"></a>00614 } <a class="code" href="structDLReader.html">DLReader</a>;
<a name="l00615"></a>00615 
<a name="l00616"></a><a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">00616</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00617"></a>00617   assert( pReader-&gt;<a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">nData</a>&gt;=0 );
<a name="l00618"></a>00618   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">nData</a>==0;
<a name="l00619"></a>00619 }
<a name="l00620"></a><a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">00620</a> <span class="keyword">static</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00621"></a>00621   assert( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(pReader) );
<a name="l00622"></a>00622   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structDLReader.html#a021896eae6566fa0ecab666719caab44">iDocid</a>;
<a name="l00623"></a>00623 }
<a name="l00624"></a><a class="code" href="fts2_8c.html#a09a2b06a41a6ec0c8a6003f0e62c87f5">00624</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a09a2b06a41a6ec0c8a6003f0e62c87f5">dlrDocData</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00625"></a>00625   assert( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(pReader) );
<a name="l00626"></a>00626   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>;
<a name="l00627"></a>00627 }
<a name="l00628"></a><a class="code" href="fts2_8c.html#acf7480695ffb31c831ba699530f5e7f5">00628</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#acf7480695ffb31c831ba699530f5e7f5">dlrDocDataBytes</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00629"></a>00629   assert( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(pReader) );
<a name="l00630"></a>00630   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">nElement</a>;
<a name="l00631"></a>00631 }
<a name="l00632"></a><a class="code" href="fts2_8c.html#a1b98de47a53d77a7616bf2da40965c15">00632</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a1b98de47a53d77a7616bf2da40965c15">dlrAllDataBytes</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00633"></a>00633   assert( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(pReader) );
<a name="l00634"></a>00634   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">nData</a>;
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 <span class="comment">/* TODO(shess) Consider adding a field to track iDocid varint length</span>
<a name="l00637"></a>00637 <span class="comment">** to make these two functions faster.  This might matter (a tiny bit)</span>
<a name="l00638"></a>00638 <span class="comment">** for queries.</span>
<a name="l00639"></a>00639 <span class="comment">*/</span>
<a name="l00640"></a><a class="code" href="fts2_8c.html#ab95c0e64c5f3ef1415d7f7c41e2d88ac">00640</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#ab95c0e64c5f3ef1415d7f7c41e2d88ac">dlrPosData</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00641"></a>00641   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDummy;
<a name="l00642"></a>00642   <span class="keywordtype">int</span> n = <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>, &amp;iDummy);
<a name="l00643"></a>00643   assert( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(pReader) );
<a name="l00644"></a>00644   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>+n;
<a name="l00645"></a>00645 }
<a name="l00646"></a><a class="code" href="fts2_8c.html#a795e00c43f7d8135d2757cb91b96d163">00646</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a795e00c43f7d8135d2757cb91b96d163">dlrPosDataLen</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00647"></a>00647   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDummy;
<a name="l00648"></a>00648   <span class="keywordtype">int</span> n = <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>, &amp;iDummy);
<a name="l00649"></a>00649   assert( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(pReader) );
<a name="l00650"></a>00650   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">nElement</a>-n;
<a name="l00651"></a>00651 }
<a name="l00652"></a><a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">00652</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00653"></a>00653   assert( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(pReader) );
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <span class="comment">/* Skip past current doclist element. */</span>
<a name="l00656"></a>00656   assert( pReader-&gt;<a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">nElement</a>&lt;=pReader-&gt;<a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">nData</a> );
<a name="l00657"></a>00657   pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a> += pReader-&gt;<a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">nElement</a>;
<a name="l00658"></a>00658   pReader-&gt;<a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">nData</a> -= pReader-&gt;<a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">nElement</a>;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   <span class="comment">/* If there is more data, read the next doclist element. */</span>
<a name="l00661"></a>00661   <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">nData</a>!=0 ){
<a name="l00662"></a>00662     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocidDelta;
<a name="l00663"></a>00663     <span class="keywordtype">int</span> iDummy, n = <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>, &amp;iDocidDelta);
<a name="l00664"></a>00664     pReader-&gt;<a class="code" href="structDLReader.html#a021896eae6566fa0ecab666719caab44">iDocid</a> += iDocidDelta;
<a name="l00665"></a>00665     <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structDLReader.html#a93c2770301c7a3469d9f3055e44e7b64">iType</a>&gt;=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ){
<a name="l00666"></a>00666       assert( n&lt;pReader-&gt;nData );
<a name="l00667"></a>00667       <span class="keywordflow">while</span>( 1 ){
<a name="l00668"></a>00668         n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>+n, &amp;iDummy);
<a name="l00669"></a>00669         assert( n&lt;=pReader-&gt;nData );
<a name="l00670"></a>00670         <span class="keywordflow">if</span>( iDummy==<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a> ) <span class="keywordflow">break</span>;
<a name="l00671"></a>00671         <span class="keywordflow">if</span>( iDummy==<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">POS_COLUMN</a> ){
<a name="l00672"></a>00672           n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>+n, &amp;iDummy);
<a name="l00673"></a>00673           assert( n&lt;pReader-&gt;nData );
<a name="l00674"></a>00674         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structDLReader.html#a93c2770301c7a3469d9f3055e44e7b64">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a> ){
<a name="l00675"></a>00675           n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>+n, &amp;iDummy);
<a name="l00676"></a>00676           n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a>+n, &amp;iDummy);
<a name="l00677"></a>00677           assert( n&lt;pReader-&gt;nData );
<a name="l00678"></a>00678         }
<a name="l00679"></a>00679       }
<a name="l00680"></a>00680     }
<a name="l00681"></a>00681     pReader-&gt;<a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">nElement</a> = n;
<a name="l00682"></a>00682     assert( pReader-&gt;<a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">nElement</a>&lt;=pReader-&gt;<a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">nData</a> );
<a name="l00683"></a>00683   }
<a name="l00684"></a>00684 }
<a name="l00685"></a><a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">00685</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType,
<a name="l00686"></a>00686                     <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData){
<a name="l00687"></a>00687   assert( pData!=NULL &amp;&amp; nData!=0 );
<a name="l00688"></a>00688   pReader-&gt;<a class="code" href="structDLReader.html#a93c2770301c7a3469d9f3055e44e7b64">iType</a> = iType;
<a name="l00689"></a>00689   pReader-&gt;<a class="code" href="structDLReader.html#a028198c76d0571fa641cf4ce9a5e8c5f">pData</a> = pData;
<a name="l00690"></a>00690   pReader-&gt;<a class="code" href="structDLReader.html#ad76b26f13754892d6dede0e909f12e5d">nData</a> = nData;
<a name="l00691"></a>00691   pReader-&gt;<a class="code" href="structDLReader.html#a6caefe1111466728aebda060e1d21f85">nElement</a> = 0;
<a name="l00692"></a>00692   pReader-&gt;<a class="code" href="structDLReader.html#a021896eae6566fa0ecab666719caab44">iDocid</a> = 0;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   <span class="comment">/* Load the first element&apos;s data.  There must be a first element. */</span>
<a name="l00695"></a>00695   <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(pReader);
<a name="l00696"></a>00696 }
<a name="l00697"></a><a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">00697</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(<a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00698"></a>00698   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pReader);
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00702"></a>00702 <span class="preprocessor"></span><span class="comment">/* Verify that the doclist can be validly decoded.  Also returns the</span>
<a name="l00703"></a>00703 <span class="comment">** last docid found because it is convenient in other assertions for</span>
<a name="l00704"></a>00704 <span class="comment">** DLWriter.</span>
<a name="l00705"></a>00705 <span class="comment">*/</span>
<a name="l00706"></a>00706 <span class="keyword">static</span> <span class="keywordtype">void</span> docListValidate(<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType, <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l00707"></a>00707                             <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *pLastDocid){
<a name="l00708"></a>00708   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iPrevDocid = 0;
<a name="l00709"></a>00709   assert( nData&gt;0 );
<a name="l00710"></a>00710   assert( pData!=0 );
<a name="l00711"></a>00711   assert( pData+nData&gt;pData );
<a name="l00712"></a>00712   <span class="keywordflow">while</span>( nData!=0 ){
<a name="l00713"></a>00713     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocidDelta;
<a name="l00714"></a>00714     <span class="keywordtype">int</span> n = <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pData, &amp;iDocidDelta);
<a name="l00715"></a>00715     iPrevDocid += iDocidDelta;
<a name="l00716"></a>00716     <span class="keywordflow">if</span>( iType&gt;<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a> ){
<a name="l00717"></a>00717       <span class="keywordtype">int</span> iDummy;
<a name="l00718"></a>00718       <span class="keywordflow">while</span>( 1 ){
<a name="l00719"></a>00719         n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData+n, &amp;iDummy);
<a name="l00720"></a>00720         <span class="keywordflow">if</span>( iDummy==<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a> ) <span class="keywordflow">break</span>;
<a name="l00721"></a>00721         <span class="keywordflow">if</span>( iDummy==<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">POS_COLUMN</a> ){
<a name="l00722"></a>00722           n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData+n, &amp;iDummy);
<a name="l00723"></a>00723         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( iType&gt;<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ){
<a name="l00724"></a>00724           n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData+n, &amp;iDummy);
<a name="l00725"></a>00725           n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData+n, &amp;iDummy);
<a name="l00726"></a>00726         }
<a name="l00727"></a>00727         assert( n&lt;=nData );
<a name="l00728"></a>00728       }
<a name="l00729"></a>00729     }
<a name="l00730"></a>00730     assert( n&lt;=nData );
<a name="l00731"></a>00731     pData += n;
<a name="l00732"></a>00732     nData -= n;
<a name="l00733"></a>00733   }
<a name="l00734"></a>00734   <span class="keywordflow">if</span>( pLastDocid ) *pLastDocid = iPrevDocid;
<a name="l00735"></a>00735 }
<a name="l00736"></a>00736 <span class="preprocessor">#define ASSERT_VALID_DOCLIST(i, p, n, o) docListValidate(i, p, n, o)</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00738"></a><a class="code" href="fts2_8c.html#ac0a9fdb841eb19d55fc4ecb511f6b1aa">00738</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_VALID_DOCLIST(i, p, n, o) assert( 1 )</span>
<a name="l00739"></a>00739 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00740"></a>00740 <span class="preprocessor"></span>
<a name="l00741"></a>00741 <span class="comment">/*******************************************************************/</span>
<a name="l00742"></a>00742 <span class="comment">/* DLWriter is used to write doclist data to a DataBuffer.  DLWriter</span>
<a name="l00743"></a>00743 <span class="comment">** always appends to the buffer and does not own it.</span>
<a name="l00744"></a>00744 <span class="comment">**</span>
<a name="l00745"></a>00745 <span class="comment">** dlwInit - initialize to write a given type doclistto a buffer.</span>
<a name="l00746"></a>00746 <span class="comment">** dlwDestroy - clear the writer&apos;s memory.  Does not free buffer.</span>
<a name="l00747"></a>00747 <span class="comment">** dlwAppend - append raw doclist data to buffer.</span>
<a name="l00748"></a>00748 <span class="comment">** dlwCopy - copy next doclist from reader to writer.</span>
<a name="l00749"></a>00749 <span class="comment">** dlwAdd - construct doclist element and append to buffer.</span>
<a name="l00750"></a>00750 <span class="comment">**    Only apply dlwAdd() to DL_DOCIDS doclists (else use PLWriter).</span>
<a name="l00751"></a>00751 <span class="comment">*/</span>
<a name="l00752"></a><a class="code" href="structDLWriter.html">00752</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structDLWriter.html">DLWriter</a> {
<a name="l00753"></a><a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">00753</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType;
<a name="l00754"></a><a class="code" href="structDLWriter.html#a603979f1faf7db85afe575e536258bc5">00754</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> *<a class="code" href="structDLWriter.html#a603979f1faf7db85afe575e536258bc5">b</a>;
<a name="l00755"></a><a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">00755</a>   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iPrevDocid;
<a name="l00756"></a>00756 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00757"></a>00757 <span class="preprocessor"></span>  <span class="keywordtype">int</span> has_iPrevDocid;
<a name="l00758"></a>00758 <span class="preprocessor">#endif</span>
<a name="l00759"></a>00759 <span class="preprocessor"></span>} <a class="code" href="structDLWriter.html">DLWriter</a>;
<a name="l00760"></a>00760 
<a name="l00761"></a><a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">00761</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">dlwInit</a>(<a class="code" href="structDLWriter.html">DLWriter</a> *pWriter, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType, <a class="code" href="structDataBuffer.html">DataBuffer</a> *b){
<a name="l00762"></a>00762   pWriter-&gt;<a class="code" href="structDLWriter.html#a603979f1faf7db85afe575e536258bc5">b</a> = b;
<a name="l00763"></a>00763   pWriter-&gt;<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a> = iType;
<a name="l00764"></a>00764   pWriter-&gt;<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a> = 0;
<a name="l00765"></a>00765 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00766"></a>00766 <span class="preprocessor"></span>  pWriter-&gt;has_iPrevDocid = 0;
<a name="l00767"></a>00767 <span class="preprocessor">#endif</span>
<a name="l00768"></a>00768 <span class="preprocessor"></span>}
<a name="l00769"></a><a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">00769</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">dlwDestroy</a>(<a class="code" href="structDLWriter.html">DLWriter</a> *pWriter){
<a name="l00770"></a>00770   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pWriter);
<a name="l00771"></a>00771 }
<a name="l00772"></a>00772 <span class="comment">/* iFirstDocid is the first docid in the doclist in pData.  It is</span>
<a name="l00773"></a>00773 <span class="comment">** needed because pData may point within a larger doclist, in which</span>
<a name="l00774"></a>00774 <span class="comment">** case the first item would be delta-encoded.</span>
<a name="l00775"></a>00775 <span class="comment">**</span>
<a name="l00776"></a>00776 <span class="comment">** iLastDocid is the final docid in the doclist in pData.  It is</span>
<a name="l00777"></a>00777 <span class="comment">** needed to create the new iPrevDocid for future delta-encoding.  The</span>
<a name="l00778"></a>00778 <span class="comment">** code could decode the passed doclist to recreate iLastDocid, but</span>
<a name="l00779"></a>00779 <span class="comment">** the only current user (docListMerge) already has decoded this</span>
<a name="l00780"></a>00780 <span class="comment">** information.</span>
<a name="l00781"></a>00781 <span class="comment">*/</span>
<a name="l00782"></a>00782 <span class="comment">/* TODO(shess) This has become just a helper for docListMerge.</span>
<a name="l00783"></a>00783 <span class="comment">** Consider a refactor to make this cleaner.</span>
<a name="l00784"></a>00784 <span class="comment">*/</span>
<a name="l00785"></a><a class="code" href="fts2_8c.html#a01590c2119575bfadd678cc54ef10b34">00785</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a01590c2119575bfadd678cc54ef10b34">dlwAppend</a>(<a class="code" href="structDLWriter.html">DLWriter</a> *pWriter,
<a name="l00786"></a>00786                       <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l00787"></a>00787                       <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iFirstDocid, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iLastDocid){
<a name="l00788"></a>00788   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid = 0;
<a name="l00789"></a>00789   <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l00790"></a>00790   <span class="keywordtype">int</span> nFirstOld, nFirstNew;     <span class="comment">/* Old and new varint len of first docid. */</span>
<a name="l00791"></a>00791 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00792"></a>00792 <span class="preprocessor"></span>  <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iLastDocidDelta;
<a name="l00793"></a>00793 <span class="preprocessor">#endif</span>
<a name="l00794"></a>00794 <span class="preprocessor"></span>
<a name="l00795"></a>00795   <span class="comment">/* Recode the initial docid as delta from iPrevDocid. */</span>
<a name="l00796"></a>00796   nFirstOld = <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pData, &amp;iDocid);
<a name="l00797"></a>00797   assert( nFirstOld&lt;nData || (nFirstOld==nData &amp;&amp; pWriter-&gt;<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>) );
<a name="l00798"></a>00798   nFirstNew = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, iFirstDocid-pWriter-&gt;<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a>);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800   <span class="comment">/* Verify that the incoming doclist is valid AND that it ends with</span>
<a name="l00801"></a>00801 <span class="comment">  ** the expected docid.  This is essential because we&apos;ll trust this</span>
<a name="l00802"></a>00802 <span class="comment">  ** docid in future delta-encoding.</span>
<a name="l00803"></a>00803 <span class="comment">  */</span>
<a name="l00804"></a>00804   <a class="code" href="fts2_8c.html#ac0a9fdb841eb19d55fc4ecb511f6b1aa">ASSERT_VALID_DOCLIST</a>(pWriter-&gt;<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a>, pData, nData, &amp;iLastDocidDelta);
<a name="l00805"></a>00805   assert( iLastDocid==iFirstDocid-iDocid+iLastDocidDelta );
<a name="l00806"></a>00806 
<a name="l00807"></a>00807   <span class="comment">/* Append recoded initial docid and everything else.  Rest of docids</span>
<a name="l00808"></a>00808 <span class="comment">  ** should have been delta-encoded from previous initial docid.</span>
<a name="l00809"></a>00809 <span class="comment">  */</span>
<a name="l00810"></a>00810   <span class="keywordflow">if</span>( nFirstOld&lt;nData ){
<a name="l00811"></a>00811     <a class="code" href="fts2_8c.html#a5cb462adcb518c795ccb9b8d1a44c0a2">dataBufferAppend2</a>(pWriter-&gt;<a class="code" href="structDLWriter.html#a603979f1faf7db85afe575e536258bc5">b</a>, c, nFirstNew,
<a name="l00812"></a>00812                       pData+nFirstOld, nData-nFirstOld);
<a name="l00813"></a>00813   }<span class="keywordflow">else</span>{
<a name="l00814"></a>00814     <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pWriter-&gt;<a class="code" href="structDLWriter.html#a603979f1faf7db85afe575e536258bc5">b</a>, c, nFirstNew);
<a name="l00815"></a>00815   }
<a name="l00816"></a>00816   pWriter-&gt;<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a> = iLastDocid;
<a name="l00817"></a>00817 }
<a name="l00818"></a><a class="code" href="fts2_8c.html#ae947473b08c66e08165ad4697f4183a5">00818</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#ae947473b08c66e08165ad4697f4183a5">dlwCopy</a>(<a class="code" href="structDLWriter.html">DLWriter</a> *pWriter, <a class="code" href="structDLReader.html">DLReader</a> *pReader){
<a name="l00819"></a>00819   <a class="code" href="fts2_8c.html#a01590c2119575bfadd678cc54ef10b34">dlwAppend</a>(pWriter, <a class="code" href="fts2_8c.html#a09a2b06a41a6ec0c8a6003f0e62c87f5">dlrDocData</a>(pReader), <a class="code" href="fts2_8c.html#acf7480695ffb31c831ba699530f5e7f5">dlrDocDataBytes</a>(pReader),
<a name="l00820"></a>00820             <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(pReader), <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(pReader));
<a name="l00821"></a>00821 }
<a name="l00822"></a><a class="code" href="fts2_8c.html#a33a58b23659c4120b32966362c9bb36c">00822</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a33a58b23659c4120b32966362c9bb36c">dlwAdd</a>(<a class="code" href="structDLWriter.html">DLWriter</a> *pWriter, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid){
<a name="l00823"></a>00823   <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l00824"></a>00824   <span class="keywordtype">int</span> n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, iDocid-pWriter-&gt;<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a>);
<a name="l00825"></a>00825 
<a name="l00826"></a>00826   <span class="comment">/* Docids must ascend. */</span>
<a name="l00827"></a>00827   assert( !pWriter-&gt;has_iPrevDocid || iDocid&gt;pWriter-&gt;<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a> );
<a name="l00828"></a>00828   assert( pWriter-&gt;<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a> );
<a name="l00829"></a>00829 
<a name="l00830"></a>00830   <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pWriter-&gt;<a class="code" href="structDLWriter.html#a603979f1faf7db85afe575e536258bc5">b</a>, c, n);
<a name="l00831"></a>00831   pWriter-&gt;<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a> = iDocid;
<a name="l00832"></a>00832 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00833"></a>00833 <span class="preprocessor"></span>  pWriter-&gt;has_iPrevDocid = 1;
<a name="l00834"></a>00834 <span class="preprocessor">#endif</span>
<a name="l00835"></a>00835 <span class="preprocessor"></span>}
<a name="l00836"></a>00836 
<a name="l00837"></a>00837 <span class="comment">/*******************************************************************/</span>
<a name="l00838"></a>00838 <span class="comment">/* PLReader is used to read data from a document&apos;s position list.  As</span>
<a name="l00839"></a>00839 <span class="comment">** the caller steps through the list, data is cached so that varints</span>
<a name="l00840"></a>00840 <span class="comment">** only need to be decoded once.</span>
<a name="l00841"></a>00841 <span class="comment">**</span>
<a name="l00842"></a>00842 <span class="comment">** plrInit, plrDestroy - create/destroy a reader.</span>
<a name="l00843"></a>00843 <span class="comment">** plrColumn, plrPosition, plrStartOffset, plrEndOffset - accessors</span>
<a name="l00844"></a>00844 <span class="comment">** plrAtEnd - at end of stream, only call plrDestroy once true.</span>
<a name="l00845"></a>00845 <span class="comment">** plrStep - step to the next element.</span>
<a name="l00846"></a>00846 <span class="comment">*/</span>
<a name="l00847"></a><a class="code" href="structPLReader.html">00847</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structPLReader.html">PLReader</a> {
<a name="l00848"></a>00848   <span class="comment">/* These refer to the next position&apos;s data.  nData will reach 0 when</span>
<a name="l00849"></a>00849 <span class="comment">  ** reading the last position, so plrStep() signals EOF by setting</span>
<a name="l00850"></a>00850 <span class="comment">  ** pData to NULL.</span>
<a name="l00851"></a>00851 <span class="comment">  */</span>
<a name="l00852"></a><a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">00852</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *pData;
<a name="l00853"></a><a class="code" href="structPLReader.html#acbc35ea8afeb878a612a0cf9d5a9983c">00853</a>   <span class="keywordtype">int</span> nData;
<a name="l00854"></a>00854 
<a name="l00855"></a><a class="code" href="structPLReader.html#a3b51af3309621caa31482eed19623684">00855</a>   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType;
<a name="l00856"></a><a class="code" href="structPLReader.html#ae76cf21f6df0771b127e1580c7a7a8d4">00856</a>   <span class="keywordtype">int</span> <a class="code" href="structPLReader.html#ae76cf21f6df0771b127e1580c7a7a8d4">iColumn</a>;         <span class="comment">/* the last column read */</span>
<a name="l00857"></a><a class="code" href="structPLReader.html#a09986279c3a88d2cbf802ef295431e8d">00857</a>   <span class="keywordtype">int</span> <a class="code" href="structPLReader.html#a09986279c3a88d2cbf802ef295431e8d">iPosition</a>;       <span class="comment">/* the last position read */</span>
<a name="l00858"></a><a class="code" href="structPLReader.html#a0f90b3bb2c96d70ce23c2ba303bc092e">00858</a>   <span class="keywordtype">int</span> <a class="code" href="structPLReader.html#a0f90b3bb2c96d70ce23c2ba303bc092e">iStartOffset</a>;    <span class="comment">/* the last start offset read */</span>
<a name="l00859"></a><a class="code" href="structPLReader.html#a11d0bd9e1a42db55836e9f26b67fbc61">00859</a>   <span class="keywordtype">int</span> <a class="code" href="structPLReader.html#a11d0bd9e1a42db55836e9f26b67fbc61">iEndOffset</a>;      <span class="comment">/* the last end offset read */</span>
<a name="l00860"></a>00860 } <a class="code" href="structPLReader.html">PLReader</a>;
<a name="l00861"></a>00861 
<a name="l00862"></a><a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">00862</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(<a class="code" href="structPLReader.html">PLReader</a> *pReader){
<a name="l00863"></a>00863   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a>==NULL;
<a name="l00864"></a>00864 }
<a name="l00865"></a><a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">00865</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(<a class="code" href="structPLReader.html">PLReader</a> *pReader){
<a name="l00866"></a>00866   assert( !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(pReader) );
<a name="l00867"></a>00867   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structPLReader.html#ae76cf21f6df0771b127e1580c7a7a8d4">iColumn</a>;
<a name="l00868"></a>00868 }
<a name="l00869"></a><a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">00869</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(<a class="code" href="structPLReader.html">PLReader</a> *pReader){
<a name="l00870"></a>00870   assert( !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(pReader) );
<a name="l00871"></a>00871   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structPLReader.html#a09986279c3a88d2cbf802ef295431e8d">iPosition</a>;
<a name="l00872"></a>00872 }
<a name="l00873"></a><a class="code" href="fts2_8c.html#a53f94db5ee5ec2bbb60962eb9d1c292a">00873</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a53f94db5ee5ec2bbb60962eb9d1c292a">plrStartOffset</a>(<a class="code" href="structPLReader.html">PLReader</a> *pReader){
<a name="l00874"></a>00874   assert( !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(pReader) );
<a name="l00875"></a>00875   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structPLReader.html#a0f90b3bb2c96d70ce23c2ba303bc092e">iStartOffset</a>;
<a name="l00876"></a>00876 }
<a name="l00877"></a><a class="code" href="fts2_8c.html#a41ebd653df431023f9c89b13ac282e37">00877</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a41ebd653df431023f9c89b13ac282e37">plrEndOffset</a>(<a class="code" href="structPLReader.html">PLReader</a> *pReader){
<a name="l00878"></a>00878   assert( !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(pReader) );
<a name="l00879"></a>00879   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structPLReader.html#a11d0bd9e1a42db55836e9f26b67fbc61">iEndOffset</a>;
<a name="l00880"></a>00880 }
<a name="l00881"></a><a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">00881</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(<a class="code" href="structPLReader.html">PLReader</a> *pReader){
<a name="l00882"></a>00882   <span class="keywordtype">int</span> i, n;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884   assert( !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(pReader) );
<a name="l00885"></a>00885 
<a name="l00886"></a>00886   <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structPLReader.html#acbc35ea8afeb878a612a0cf9d5a9983c">nData</a>==0 ){
<a name="l00887"></a>00887     pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a> = NULL;
<a name="l00888"></a>00888     <span class="keywordflow">return</span>;
<a name="l00889"></a>00889   }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891   n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a>, &amp;i);
<a name="l00892"></a>00892   <span class="keywordflow">if</span>( i==<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">POS_COLUMN</a> ){
<a name="l00893"></a>00893     n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a>+n, &amp;pReader-&gt;<a class="code" href="structPLReader.html#ae76cf21f6df0771b127e1580c7a7a8d4">iColumn</a>);
<a name="l00894"></a>00894     pReader-&gt;<a class="code" href="structPLReader.html#a09986279c3a88d2cbf802ef295431e8d">iPosition</a> = 0;
<a name="l00895"></a>00895     pReader-&gt;<a class="code" href="structPLReader.html#a0f90b3bb2c96d70ce23c2ba303bc092e">iStartOffset</a> = 0;
<a name="l00896"></a>00896     n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a>+n, &amp;i);
<a name="l00897"></a>00897   }
<a name="l00898"></a>00898   <span class="comment">/* Should never see adjacent column changes. */</span>
<a name="l00899"></a>00899   assert( i!=<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">POS_COLUMN</a> );
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   <span class="keywordflow">if</span>( i==<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a> ){
<a name="l00902"></a>00902     pReader-&gt;<a class="code" href="structPLReader.html#acbc35ea8afeb878a612a0cf9d5a9983c">nData</a> = 0;
<a name="l00903"></a>00903     pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a> = NULL;
<a name="l00904"></a>00904     <span class="keywordflow">return</span>;
<a name="l00905"></a>00905   }
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   pReader-&gt;<a class="code" href="structPLReader.html#a09986279c3a88d2cbf802ef295431e8d">iPosition</a> += i-<a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a97c7ac3d72e7a29547748b3c4f529945">POS_BASE</a>;
<a name="l00908"></a>00908   <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structPLReader.html#a3b51af3309621caa31482eed19623684">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a> ){
<a name="l00909"></a>00909     n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a>+n, &amp;i);
<a name="l00910"></a>00910     pReader-&gt;<a class="code" href="structPLReader.html#a0f90b3bb2c96d70ce23c2ba303bc092e">iStartOffset</a> += i;
<a name="l00911"></a>00911     n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a>+n, &amp;i);
<a name="l00912"></a>00912     pReader-&gt;<a class="code" href="structPLReader.html#a11d0bd9e1a42db55836e9f26b67fbc61">iEndOffset</a> = pReader-&gt;<a class="code" href="structPLReader.html#a0f90b3bb2c96d70ce23c2ba303bc092e">iStartOffset</a>+i;
<a name="l00913"></a>00913   }
<a name="l00914"></a>00914   assert( n&lt;=pReader-&gt;nData );
<a name="l00915"></a>00915   pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a> += n;
<a name="l00916"></a>00916   pReader-&gt;<a class="code" href="structPLReader.html#acbc35ea8afeb878a612a0cf9d5a9983c">nData</a> -= n;
<a name="l00917"></a>00917 }
<a name="l00918"></a>00918 
<a name="l00919"></a><a class="code" href="fts2_8c.html#ac211994cb69d057e6e933363854b92b0">00919</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#ac211994cb69d057e6e933363854b92b0">plrInit</a>(<a class="code" href="structPLReader.html">PLReader</a> *pReader, <a class="code" href="structDLReader.html">DLReader</a> *pDLReader){
<a name="l00920"></a>00920   pReader-&gt;<a class="code" href="structPLReader.html#a83c2b54558282e1f6a03f316b2e78d30">pData</a> = <a class="code" href="fts2_8c.html#ab95c0e64c5f3ef1415d7f7c41e2d88ac">dlrPosData</a>(pDLReader);
<a name="l00921"></a>00921   pReader-&gt;<a class="code" href="structPLReader.html#acbc35ea8afeb878a612a0cf9d5a9983c">nData</a> = <a class="code" href="fts2_8c.html#a795e00c43f7d8135d2757cb91b96d163">dlrPosDataLen</a>(pDLReader);
<a name="l00922"></a>00922   pReader-&gt;<a class="code" href="structPLReader.html#a3b51af3309621caa31482eed19623684">iType</a> = pDLReader-&gt;<a class="code" href="structDLReader.html#a93c2770301c7a3469d9f3055e44e7b64">iType</a>;
<a name="l00923"></a>00923   pReader-&gt;<a class="code" href="structPLReader.html#ae76cf21f6df0771b127e1580c7a7a8d4">iColumn</a> = 0;
<a name="l00924"></a>00924   pReader-&gt;<a class="code" href="structPLReader.html#a09986279c3a88d2cbf802ef295431e8d">iPosition</a> = 0;
<a name="l00925"></a>00925   pReader-&gt;<a class="code" href="structPLReader.html#a0f90b3bb2c96d70ce23c2ba303bc092e">iStartOffset</a> = 0;
<a name="l00926"></a>00926   pReader-&gt;<a class="code" href="structPLReader.html#a11d0bd9e1a42db55836e9f26b67fbc61">iEndOffset</a> = 0;
<a name="l00927"></a>00927   <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(pReader);
<a name="l00928"></a>00928 }
<a name="l00929"></a><a class="code" href="fts2_8c.html#a4f4258f283f5c91fbb885c1726e16455">00929</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a4f4258f283f5c91fbb885c1726e16455">plrDestroy</a>(<a class="code" href="structPLReader.html">PLReader</a> *pReader){
<a name="l00930"></a>00930   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pReader);
<a name="l00931"></a>00931 }
<a name="l00932"></a>00932 
<a name="l00933"></a>00933 <span class="comment">/*******************************************************************/</span>
<a name="l00934"></a>00934 <span class="comment">/* PLWriter is used in constructing a document&apos;s position list.  As a</span>
<a name="l00935"></a>00935 <span class="comment">** convenience, if iType is DL_DOCIDS, PLWriter becomes a no-op.</span>
<a name="l00936"></a>00936 <span class="comment">** PLWriter writes to the associated DLWriter&apos;s buffer.</span>
<a name="l00937"></a>00937 <span class="comment">**</span>
<a name="l00938"></a>00938 <span class="comment">** plwInit - init for writing a document&apos;s poslist.</span>
<a name="l00939"></a>00939 <span class="comment">** plwDestroy - clear a writer.</span>
<a name="l00940"></a>00940 <span class="comment">** plwAdd - append position and offset information.</span>
<a name="l00941"></a>00941 <span class="comment">** plwCopy - copy next position&apos;s data from reader to writer.</span>
<a name="l00942"></a>00942 <span class="comment">** plwTerminate - add any necessary doclist terminator.</span>
<a name="l00943"></a>00943 <span class="comment">**</span>
<a name="l00944"></a>00944 <span class="comment">** Calling plwAdd() after plwTerminate() may result in a corrupt</span>
<a name="l00945"></a>00945 <span class="comment">** doclist.</span>
<a name="l00946"></a>00946 <span class="comment">*/</span>
<a name="l00947"></a>00947 <span class="comment">/* TODO(shess) Until we&apos;ve written the second item, we can cache the</span>
<a name="l00948"></a>00948 <span class="comment">** first item&apos;s information.  Then we&apos;d have three states:</span>
<a name="l00949"></a>00949 <span class="comment">**</span>
<a name="l00950"></a>00950 <span class="comment">** - initialized with docid, no positions.</span>
<a name="l00951"></a>00951 <span class="comment">** - docid and one position.</span>
<a name="l00952"></a>00952 <span class="comment">** - docid and multiple positions.</span>
<a name="l00953"></a>00953 <span class="comment">**</span>
<a name="l00954"></a>00954 <span class="comment">** Only the last state needs to actually write to dlw-&gt;b, which would</span>
<a name="l00955"></a>00955 <span class="comment">** be an improvement in the DLCollector case.</span>
<a name="l00956"></a>00956 <span class="comment">*/</span>
<a name="l00957"></a><a class="code" href="structPLWriter.html">00957</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structPLWriter.html">PLWriter</a> {
<a name="l00958"></a><a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">00958</a>   <a class="code" href="structDLWriter.html">DLWriter</a> *<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>;
<a name="l00959"></a>00959 
<a name="l00960"></a><a class="code" href="structPLWriter.html#ad74f2c2de7ee36f73b2b5375f1116ba7">00960</a>   <span class="keywordtype">int</span> <a class="code" href="structPLWriter.html#ad74f2c2de7ee36f73b2b5375f1116ba7">iColumn</a>;    <span class="comment">/* the last column written */</span>
<a name="l00961"></a><a class="code" href="structPLWriter.html#a2d58448d7e9fb141b25396895045303a">00961</a>   <span class="keywordtype">int</span> <a class="code" href="structPLWriter.html#a2d58448d7e9fb141b25396895045303a">iPos</a>;       <span class="comment">/* the last position written */</span>
<a name="l00962"></a><a class="code" href="structPLWriter.html#a548d1553a53e10865dbe497093ff972f">00962</a>   <span class="keywordtype">int</span> <a class="code" href="structPLWriter.html#a548d1553a53e10865dbe497093ff972f">iOffset</a>;    <span class="comment">/* the last start offset written */</span>
<a name="l00963"></a>00963 } <a class="code" href="structPLWriter.html">PLWriter</a>;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="comment">/* TODO(shess) In the case where the parent is reading these values</span>
<a name="l00966"></a>00966 <span class="comment">** from a PLReader, we could optimize to a copy if that PLReader has</span>
<a name="l00967"></a>00967 <span class="comment">** the same type as pWriter.</span>
<a name="l00968"></a>00968 <span class="comment">*/</span>
<a name="l00969"></a><a class="code" href="fts2_8c.html#a98cd872fb23c47d87519cd900c589a0f">00969</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a98cd872fb23c47d87519cd900c589a0f">plwAdd</a>(<a class="code" href="structPLWriter.html">PLWriter</a> *pWriter, <span class="keywordtype">int</span> iColumn, <span class="keywordtype">int</span> iPos,
<a name="l00970"></a>00970                    <span class="keywordtype">int</span> iStartOffset, <span class="keywordtype">int</span> iEndOffset){
<a name="l00971"></a>00971   <span class="comment">/* Worst-case space for POS_COLUMN, iColumn, iPosDelta,</span>
<a name="l00972"></a>00972 <span class="comment">  ** iStartOffsetDelta, and iEndOffsetDelta.</span>
<a name="l00973"></a>00973 <span class="comment">  */</span>
<a name="l00974"></a>00974   <span class="keywordtype">char</span> c[5*<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l00975"></a>00975   <span class="keywordtype">int</span> n = 0;
<a name="l00976"></a>00976 
<a name="l00977"></a>00977   <span class="comment">/* Ban plwAdd() after plwTerminate(). */</span>
<a name="l00978"></a>00978   assert( pWriter-&gt;<a class="code" href="structPLWriter.html#a2d58448d7e9fb141b25396895045303a">iPos</a>!=-1 );
<a name="l00979"></a>00979 
<a name="l00980"></a>00980   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a> ) <span class="keywordflow">return</span>;
<a name="l00981"></a>00981 
<a name="l00982"></a>00982   <span class="keywordflow">if</span>( iColumn!=pWriter-&gt;<a class="code" href="structPLWriter.html#ad74f2c2de7ee36f73b2b5375f1116ba7">iColumn</a> ){
<a name="l00983"></a>00983     n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a72830b71eccc1ce94c57582ad624bea2">POS_COLUMN</a>);
<a name="l00984"></a>00984     n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, iColumn);
<a name="l00985"></a>00985     pWriter-&gt;<a class="code" href="structPLWriter.html#ad74f2c2de7ee36f73b2b5375f1116ba7">iColumn</a> = iColumn;
<a name="l00986"></a>00986     pWriter-&gt;<a class="code" href="structPLWriter.html#a2d58448d7e9fb141b25396895045303a">iPos</a> = 0;
<a name="l00987"></a>00987     pWriter-&gt;<a class="code" href="structPLWriter.html#a548d1553a53e10865dbe497093ff972f">iOffset</a> = 0;
<a name="l00988"></a>00988   }
<a name="l00989"></a>00989   assert( iPos&gt;=pWriter-&gt;<a class="code" href="structPLWriter.html#a2d58448d7e9fb141b25396895045303a">iPos</a> );
<a name="l00990"></a>00990   n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a97c7ac3d72e7a29547748b3c4f529945">POS_BASE</a>+(iPos-pWriter-&gt;<a class="code" href="structPLWriter.html#a2d58448d7e9fb141b25396895045303a">iPos</a>));
<a name="l00991"></a>00991   pWriter-&gt;<a class="code" href="structPLWriter.html#a2d58448d7e9fb141b25396895045303a">iPos</a> = iPos;
<a name="l00992"></a>00992   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a> ){
<a name="l00993"></a>00993     assert( iStartOffset&gt;=pWriter-&gt;<a class="code" href="structPLWriter.html#a548d1553a53e10865dbe497093ff972f">iOffset</a> );
<a name="l00994"></a>00994     n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, iStartOffset-pWriter-&gt;<a class="code" href="structPLWriter.html#a548d1553a53e10865dbe497093ff972f">iOffset</a>);
<a name="l00995"></a>00995     pWriter-&gt;<a class="code" href="structPLWriter.html#a548d1553a53e10865dbe497093ff972f">iOffset</a> = iStartOffset;
<a name="l00996"></a>00996     assert( iEndOffset&gt;=iStartOffset );
<a name="l00997"></a>00997     n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, iEndOffset-iStartOffset);
<a name="l00998"></a>00998   }
<a name="l00999"></a>00999   <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;<a class="code" href="structDLWriter.html#a603979f1faf7db85afe575e536258bc5">b</a>, c, n);
<a name="l01000"></a>01000 }
<a name="l01001"></a><a class="code" href="fts2_8c.html#aae61ae5509a522de001fef98aaf6ed86">01001</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aae61ae5509a522de001fef98aaf6ed86">plwCopy</a>(<a class="code" href="structPLWriter.html">PLWriter</a> *pWriter, <a class="code" href="structPLReader.html">PLReader</a> *pReader){
<a name="l01002"></a>01002   <a class="code" href="fts2_8c.html#a98cd872fb23c47d87519cd900c589a0f">plwAdd</a>(pWriter, <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(pReader), <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(pReader),
<a name="l01003"></a>01003          <a class="code" href="fts2_8c.html#a53f94db5ee5ec2bbb60962eb9d1c292a">plrStartOffset</a>(pReader), <a class="code" href="fts2_8c.html#a41ebd653df431023f9c89b13ac282e37">plrEndOffset</a>(pReader));
<a name="l01004"></a>01004 }
<a name="l01005"></a><a class="code" href="fts2_8c.html#acfd18578dc8616ad20d4c3844a8ff168">01005</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#acfd18578dc8616ad20d4c3844a8ff168">plwInit</a>(<a class="code" href="structPLWriter.html">PLWriter</a> *pWriter, <a class="code" href="structDLWriter.html">DLWriter</a> *dlw, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid){
<a name="l01006"></a>01006   <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l01007"></a>01007   <span class="keywordtype">int</span> n;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009   pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a> = dlw;
<a name="l01010"></a>01010 
<a name="l01011"></a>01011   <span class="comment">/* Docids must ascend. */</span>
<a name="l01012"></a>01012   assert( !pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;has_iPrevDocid || iDocid&gt;pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a> );
<a name="l01013"></a>01013   n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, iDocid-pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a>);
<a name="l01014"></a>01014   <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;<a class="code" href="structDLWriter.html#a603979f1faf7db85afe575e536258bc5">b</a>, c, n);
<a name="l01015"></a>01015   pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a> = iDocid;
<a name="l01016"></a>01016 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01017"></a>01017 <span class="preprocessor"></span>  pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;has_iPrevDocid = 1;
<a name="l01018"></a>01018 <span class="preprocessor">#endif</span>
<a name="l01019"></a>01019 <span class="preprocessor"></span>
<a name="l01020"></a>01020   pWriter-&gt;<a class="code" href="structPLWriter.html#ad74f2c2de7ee36f73b2b5375f1116ba7">iColumn</a> = 0;
<a name="l01021"></a>01021   pWriter-&gt;<a class="code" href="structPLWriter.html#a2d58448d7e9fb141b25396895045303a">iPos</a> = 0;
<a name="l01022"></a>01022   pWriter-&gt;<a class="code" href="structPLWriter.html#a548d1553a53e10865dbe497093ff972f">iOffset</a> = 0;
<a name="l01023"></a>01023 }
<a name="l01024"></a>01024 <span class="comment">/* TODO(shess) Should plwDestroy() also terminate the doclist?  But</span>
<a name="l01025"></a>01025 <span class="comment">** then plwDestroy() would no longer be just a destructor, it would</span>
<a name="l01026"></a>01026 <span class="comment">** also be doing work, which isn&apos;t consistent with the overall idiom.</span>
<a name="l01027"></a>01027 <span class="comment">** Another option would be for plwAdd() to always append any necessary</span>
<a name="l01028"></a>01028 <span class="comment">** terminator, so that the output is always correct.  But that would</span>
<a name="l01029"></a>01029 <span class="comment">** add incremental work to the common case with the only benefit being</span>
<a name="l01030"></a>01030 <span class="comment">** API elegance.  Punt for now.</span>
<a name="l01031"></a>01031 <span class="comment">*/</span>
<a name="l01032"></a><a class="code" href="fts2_8c.html#a2db69170e94c0c3fa5eac814302930c6">01032</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a2db69170e94c0c3fa5eac814302930c6">plwTerminate</a>(<a class="code" href="structPLWriter.html">PLWriter</a> *pWriter){
<a name="l01033"></a>01033   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a>&gt;<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a> ){
<a name="l01034"></a>01034     <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l01035"></a>01035     <span class="keywordtype">int</span> n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a>);
<a name="l01036"></a>01036     <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pWriter-&gt;<a class="code" href="structPLWriter.html#a43192a3d445b317fbdc03ca3eaa16406">dlw</a>-&gt;<a class="code" href="structDLWriter.html#a603979f1faf7db85afe575e536258bc5">b</a>, c, n);
<a name="l01037"></a>01037   }
<a name="l01038"></a>01038 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01039"></a>01039 <span class="preprocessor"></span>  <span class="comment">/* Mark as terminated for assert in plwAdd(). */</span>
<a name="l01040"></a>01040   pWriter-&gt;<a class="code" href="structPLWriter.html#a2d58448d7e9fb141b25396895045303a">iPos</a> = -1;
<a name="l01041"></a>01041 <span class="preprocessor">#endif</span>
<a name="l01042"></a>01042 <span class="preprocessor"></span>}
<a name="l01043"></a><a class="code" href="fts2_8c.html#abe80ec683531714ccb69cb6181498e48">01043</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#abe80ec683531714ccb69cb6181498e48">plwDestroy</a>(<a class="code" href="structPLWriter.html">PLWriter</a> *pWriter){
<a name="l01044"></a>01044   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pWriter);
<a name="l01045"></a>01045 }
<a name="l01046"></a>01046 
<a name="l01047"></a>01047 <span class="comment">/*******************************************************************/</span>
<a name="l01048"></a>01048 <span class="comment">/* DLCollector wraps PLWriter and DLWriter to provide a</span>
<a name="l01049"></a>01049 <span class="comment">** dynamically-allocated doclist area to use during tokenization.</span>
<a name="l01050"></a>01050 <span class="comment">**</span>
<a name="l01051"></a>01051 <span class="comment">** dlcNew - malloc up and initialize a collector.</span>
<a name="l01052"></a>01052 <span class="comment">** dlcDelete - destroy a collector and all contained items.</span>
<a name="l01053"></a>01053 <span class="comment">** dlcAddPos - append position and offset information.</span>
<a name="l01054"></a>01054 <span class="comment">** dlcAddDoclist - add the collected doclist to the given buffer.</span>
<a name="l01055"></a>01055 <span class="comment">** dlcNext - terminate the current document and open another.</span>
<a name="l01056"></a>01056 <span class="comment">*/</span>
<a name="l01057"></a><a class="code" href="structDLCollector.html">01057</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structDLCollector.html">DLCollector</a> {
<a name="l01058"></a><a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">01058</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>;
<a name="l01059"></a><a class="code" href="structDLCollector.html#a8f6f670899344bcb2a45d223ac751b19">01059</a>   <a class="code" href="structDLWriter.html">DLWriter</a> <a class="code" href="structDLCollector.html#a8f6f670899344bcb2a45d223ac751b19">dlw</a>;
<a name="l01060"></a><a class="code" href="structDLCollector.html#a7ff1ed96881423ca0ee93cd98291c948">01060</a>   <a class="code" href="structPLWriter.html">PLWriter</a> <a class="code" href="structDLCollector.html#a7ff1ed96881423ca0ee93cd98291c948">plw</a>;
<a name="l01061"></a>01061 } <a class="code" href="structDLCollector.html">DLCollector</a>;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063 <span class="comment">/* TODO(shess) This could also be done by calling plwTerminate() and</span>
<a name="l01064"></a>01064 <span class="comment">** dataBufferAppend().  I tried that, expecting nominal performance</span>
<a name="l01065"></a>01065 <span class="comment">** differences, but it seemed to pretty reliably be worth 1% to code</span>
<a name="l01066"></a>01066 <span class="comment">** it this way.  I suspect it is the incremental malloc overhead (some</span>
<a name="l01067"></a>01067 <span class="comment">** percentage of the plwTerminate() calls will cause a realloc), so</span>
<a name="l01068"></a>01068 <span class="comment">** this might be worth revisiting if the DataBuffer implementation</span>
<a name="l01069"></a>01069 <span class="comment">** changes.</span>
<a name="l01070"></a>01070 <span class="comment">*/</span>
<a name="l01071"></a><a class="code" href="fts2_8c.html#a205a5a118cd3fd98dee5ba95a666a6cb">01071</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a205a5a118cd3fd98dee5ba95a666a6cb">dlcAddDoclist</a>(<a class="code" href="structDLCollector.html">DLCollector</a> *pCollector, <a class="code" href="structDataBuffer.html">DataBuffer</a> *b){
<a name="l01072"></a>01072   <span class="keywordflow">if</span>( pCollector-&gt;<a class="code" href="structDLCollector.html#a8f6f670899344bcb2a45d223ac751b19">dlw</a>.<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a>&gt;<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a> ){
<a name="l01073"></a>01073     <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l01074"></a>01074     <span class="keywordtype">int</span> n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, <a class="code" href="fts1_8c.html#ac36f475ca5b446f4fde4c9b90bec77c8a99a23817e10baf2a99599ffaa7c36f2b">POS_END</a>);
<a name="l01075"></a>01075     <a class="code" href="fts2_8c.html#a5cb462adcb518c795ccb9b8d1a44c0a2">dataBufferAppend2</a>(b, pCollector-&gt;<a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, pCollector-&gt;<a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, c, n);
<a name="l01076"></a>01076   }<span class="keywordflow">else</span>{
<a name="l01077"></a>01077     <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(b, pCollector-&gt;<a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, pCollector-&gt;<a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l01078"></a>01078   }
<a name="l01079"></a>01079 }
<a name="l01080"></a><a class="code" href="fts2_8c.html#a522aa1434803358cb62a953195f8cc98">01080</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a522aa1434803358cb62a953195f8cc98">dlcNext</a>(<a class="code" href="structDLCollector.html">DLCollector</a> *pCollector, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid){
<a name="l01081"></a>01081   <a class="code" href="fts2_8c.html#a2db69170e94c0c3fa5eac814302930c6">plwTerminate</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a7ff1ed96881423ca0ee93cd98291c948">plw</a>);
<a name="l01082"></a>01082   <a class="code" href="fts2_8c.html#abe80ec683531714ccb69cb6181498e48">plwDestroy</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a7ff1ed96881423ca0ee93cd98291c948">plw</a>);
<a name="l01083"></a>01083   <a class="code" href="fts2_8c.html#acfd18578dc8616ad20d4c3844a8ff168">plwInit</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a7ff1ed96881423ca0ee93cd98291c948">plw</a>, &amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a8f6f670899344bcb2a45d223ac751b19">dlw</a>, iDocid);
<a name="l01084"></a>01084 }
<a name="l01085"></a><a class="code" href="fts2_8c.html#aa5a392b124ae323b9b9752101858e837">01085</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aa5a392b124ae323b9b9752101858e837">dlcAddPos</a>(<a class="code" href="structDLCollector.html">DLCollector</a> *pCollector, <span class="keywordtype">int</span> iColumn, <span class="keywordtype">int</span> iPos,
<a name="l01086"></a>01086                       <span class="keywordtype">int</span> iStartOffset, <span class="keywordtype">int</span> iEndOffset){
<a name="l01087"></a>01087   <a class="code" href="fts2_8c.html#a98cd872fb23c47d87519cd900c589a0f">plwAdd</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a7ff1ed96881423ca0ee93cd98291c948">plw</a>, iColumn, iPos, iStartOffset, iEndOffset);
<a name="l01088"></a>01088 }
<a name="l01089"></a>01089 
<a name="l01090"></a><a class="code" href="fts2_8c.html#a746ed40e8e7435d8e752ad7a72b95c9f">01090</a> <span class="keyword">static</span> <a class="code" href="structDLCollector.html">DLCollector</a> *<a class="code" href="fts2_8c.html#a746ed40e8e7435d8e752ad7a72b95c9f">dlcNew</a>(<a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType){
<a name="l01091"></a>01091   <a class="code" href="structDLCollector.html">DLCollector</a> *pCollector = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="structDLCollector.html">DLCollector</a>));
<a name="l01092"></a>01092   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>, 0);
<a name="l01093"></a>01093   <a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">dlwInit</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a8f6f670899344bcb2a45d223ac751b19">dlw</a>, iType, &amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>);
<a name="l01094"></a>01094   <a class="code" href="fts2_8c.html#acfd18578dc8616ad20d4c3844a8ff168">plwInit</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a7ff1ed96881423ca0ee93cd98291c948">plw</a>, &amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a8f6f670899344bcb2a45d223ac751b19">dlw</a>, iDocid);
<a name="l01095"></a>01095   <span class="keywordflow">return</span> pCollector;
<a name="l01096"></a>01096 }
<a name="l01097"></a><a class="code" href="fts2_8c.html#aacb9c17923676be8a13c887bdcdcf18a">01097</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aacb9c17923676be8a13c887bdcdcf18a">dlcDelete</a>(<a class="code" href="structDLCollector.html">DLCollector</a> *pCollector){
<a name="l01098"></a>01098   <a class="code" href="fts2_8c.html#abe80ec683531714ccb69cb6181498e48">plwDestroy</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a7ff1ed96881423ca0ee93cd98291c948">plw</a>);
<a name="l01099"></a>01099   <a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">dlwDestroy</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a8f6f670899344bcb2a45d223ac751b19">dlw</a>);
<a name="l01100"></a>01100   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;pCollector-&gt;<a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>);
<a name="l01101"></a>01101   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pCollector);
<a name="l01102"></a>01102   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pCollector);
<a name="l01103"></a>01103 }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 <span class="comment">/* Copy the doclist data of iType in pData/nData into *out, trimming</span>
<a name="l01107"></a>01107 <span class="comment">** unnecessary data as we go.  Only columns matching iColumn are</span>
<a name="l01108"></a>01108 <span class="comment">** copied, all columns copied if iColumn is -1.  Elements with no</span>
<a name="l01109"></a>01109 <span class="comment">** matching columns are dropped.  The output is an iOutType doclist.</span>
<a name="l01110"></a>01110 <span class="comment">*/</span>
<a name="l01111"></a>01111 <span class="comment">/* NOTE(shess) This code is only valid after all doclists are merged.</span>
<a name="l01112"></a>01112 <span class="comment">** If this is run before merges, then doclist items which represent</span>
<a name="l01113"></a>01113 <span class="comment">** deletion will be trimmed, and will thus not effect a deletion</span>
<a name="l01114"></a>01114 <span class="comment">** during the merge.</span>
<a name="l01115"></a>01115 <span class="comment">*/</span>
<a name="l01116"></a><a class="code" href="fts2_8c.html#a2b1eafafb5e270c5d938362c43da3e15">01116</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a2b1eafafb5e270c5d938362c43da3e15">docListTrim</a>(<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType, <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l01117"></a>01117                         <span class="keywordtype">int</span> iColumn, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iOutType, <a class="code" href="structDataBuffer.html">DataBuffer</a> *out){
<a name="l01118"></a>01118   <a class="code" href="structDLReader.html">DLReader</a> dlReader;
<a name="l01119"></a>01119   <a class="code" href="structDLWriter.html">DLWriter</a> dlWriter;
<a name="l01120"></a>01120 
<a name="l01121"></a>01121   assert( iOutType&lt;=iType );
<a name="l01122"></a>01122 
<a name="l01123"></a>01123   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;dlReader, iType, pData, nData);
<a name="l01124"></a>01124   <a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">dlwInit</a>(&amp;dlWriter, iOutType, out);
<a name="l01125"></a>01125 
<a name="l01126"></a>01126   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;dlReader) ){
<a name="l01127"></a>01127     <a class="code" href="structPLReader.html">PLReader</a> plReader;
<a name="l01128"></a>01128     <a class="code" href="structPLWriter.html">PLWriter</a> plWriter;
<a name="l01129"></a>01129     <span class="keywordtype">int</span> <a class="code" href="lstrlib_8c.html#a52a45835b75e5d31ec66421456bbb728">match</a> = 0;
<a name="l01130"></a>01130 
<a name="l01131"></a>01131     <a class="code" href="fts2_8c.html#ac211994cb69d057e6e933363854b92b0">plrInit</a>(&amp;plReader, &amp;dlReader);
<a name="l01132"></a>01132 
<a name="l01133"></a>01133     <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(&amp;plReader) ){
<a name="l01134"></a>01134       <span class="keywordflow">if</span>( iColumn==-1 || <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;plReader)==iColumn ){
<a name="l01135"></a>01135         <span class="keywordflow">if</span>( !match ){
<a name="l01136"></a>01136           <a class="code" href="fts2_8c.html#acfd18578dc8616ad20d4c3844a8ff168">plwInit</a>(&amp;plWriter, &amp;dlWriter, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;dlReader));
<a name="l01137"></a>01137           match = 1;
<a name="l01138"></a>01138         }
<a name="l01139"></a>01139         <a class="code" href="fts2_8c.html#a98cd872fb23c47d87519cd900c589a0f">plwAdd</a>(&amp;plWriter, <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;plReader), <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(&amp;plReader),
<a name="l01140"></a>01140                <a class="code" href="fts2_8c.html#a53f94db5ee5ec2bbb60962eb9d1c292a">plrStartOffset</a>(&amp;plReader), <a class="code" href="fts2_8c.html#a41ebd653df431023f9c89b13ac282e37">plrEndOffset</a>(&amp;plReader));
<a name="l01141"></a>01141       }
<a name="l01142"></a>01142       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;plReader);
<a name="l01143"></a>01143     }
<a name="l01144"></a>01144     <span class="keywordflow">if</span>( match ){
<a name="l01145"></a>01145       <a class="code" href="fts2_8c.html#a2db69170e94c0c3fa5eac814302930c6">plwTerminate</a>(&amp;plWriter);
<a name="l01146"></a>01146       <a class="code" href="fts2_8c.html#abe80ec683531714ccb69cb6181498e48">plwDestroy</a>(&amp;plWriter);
<a name="l01147"></a>01147     }
<a name="l01148"></a>01148 
<a name="l01149"></a>01149     <a class="code" href="fts2_8c.html#a4f4258f283f5c91fbb885c1726e16455">plrDestroy</a>(&amp;plReader);
<a name="l01150"></a>01150     <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;dlReader);
<a name="l01151"></a>01151   }
<a name="l01152"></a>01152   <a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">dlwDestroy</a>(&amp;dlWriter);
<a name="l01153"></a>01153   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;dlReader);
<a name="l01154"></a>01154 }
<a name="l01155"></a>01155 
<a name="l01156"></a>01156 <span class="comment">/* Used by docListMerge() to keep doclists in the ascending order by</span>
<a name="l01157"></a>01157 <span class="comment">** docid, then ascending order by age (so the newest comes first).</span>
<a name="l01158"></a>01158 <span class="comment">*/</span>
<a name="l01159"></a><a class="code" href="structOrderedDLReader.html">01159</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structOrderedDLReader.html">OrderedDLReader</a> {
<a name="l01160"></a><a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">01160</a>   <a class="code" href="structDLReader.html">DLReader</a> *<a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">pReader</a>;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162   <span class="comment">/* TODO(shess) If we assume that docListMerge pReaders is ordered by</span>
<a name="l01163"></a>01163 <span class="comment">  ** age (which we do), then we could use pReader comparisons to break</span>
<a name="l01164"></a>01164 <span class="comment">  ** ties.</span>
<a name="l01165"></a>01165 <span class="comment">  */</span>
<a name="l01166"></a><a class="code" href="structOrderedDLReader.html#a4874d131ac5cafaa90b93db6584ef354">01166</a>   <span class="keywordtype">int</span> <a class="code" href="structOrderedDLReader.html#a4874d131ac5cafaa90b93db6584ef354">idx</a>;
<a name="l01167"></a>01167 } <a class="code" href="structOrderedDLReader.html">OrderedDLReader</a>;
<a name="l01168"></a>01168 
<a name="l01169"></a>01169 <span class="comment">/* Order eof to end, then by docid asc, idx desc. */</span>
<a name="l01170"></a><a class="code" href="fts2_8c.html#a20d181dae5fd5997e6ffd0be07099c48">01170</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a20d181dae5fd5997e6ffd0be07099c48">orderedDLReaderCmp</a>(<a class="code" href="structOrderedDLReader.html">OrderedDLReader</a> *r1, <a class="code" href="structOrderedDLReader.html">OrderedDLReader</a> *r2){
<a name="l01171"></a>01171   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(r1-&gt;<a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">pReader</a>) ){
<a name="l01172"></a>01172     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(r2-&gt;<a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">pReader</a>) ) <span class="keywordflow">return</span> 0;  <span class="comment">/* Both atEnd(). */</span>
<a name="l01173"></a>01173     <span class="keywordflow">return</span> 1;                              <span class="comment">/* Only r1 atEnd(). */</span>
<a name="l01174"></a>01174   }
<a name="l01175"></a>01175   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(r2-&gt;<a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">pReader</a>) ) <span class="keywordflow">return</span> -1;   <span class="comment">/* Only r2 atEnd(). */</span>
<a name="l01176"></a>01176 
<a name="l01177"></a>01177   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(r1-&gt;<a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">pReader</a>)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(r2-&gt;<a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">pReader</a>) ) <span class="keywordflow">return</span> -1;
<a name="l01178"></a>01178   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(r1-&gt;<a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">pReader</a>)&gt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(r2-&gt;<a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">pReader</a>) ) <span class="keywordflow">return</span> 1;
<a name="l01179"></a>01179 
<a name="l01180"></a>01180   <span class="comment">/* Descending on idx. */</span>
<a name="l01181"></a>01181   <span class="keywordflow">return</span> r2-&gt;<a class="code" href="structOrderedDLReader.html#a4874d131ac5cafaa90b93db6584ef354">idx</a>-r1-&gt;<a class="code" href="structOrderedDLReader.html#a4874d131ac5cafaa90b93db6584ef354">idx</a>;
<a name="l01182"></a>01182 }
<a name="l01183"></a>01183 
<a name="l01184"></a>01184 <span class="comment">/* Bubble p[0] to appropriate place in p[1..n-1].  Assumes that</span>
<a name="l01185"></a>01185 <span class="comment">** p[1..n-1] is already sorted.</span>
<a name="l01186"></a>01186 <span class="comment">*/</span>
<a name="l01187"></a>01187 <span class="comment">/* TODO(shess) Is this frequent enough to warrant a binary search?</span>
<a name="l01188"></a>01188 <span class="comment">** Before implementing that, instrument the code to check.  In most</span>
<a name="l01189"></a>01189 <span class="comment">** current usage, I expect that p[0] will be less than p[1] a very</span>
<a name="l01190"></a>01190 <span class="comment">** high proportion of the time.</span>
<a name="l01191"></a>01191 <span class="comment">*/</span>
<a name="l01192"></a><a class="code" href="fts2_8c.html#a7e05e36e9ff2d0edbfbb4b9c3b587313">01192</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a7e05e36e9ff2d0edbfbb4b9c3b587313">orderedDLReaderReorder</a>(<a class="code" href="structOrderedDLReader.html">OrderedDLReader</a> *p, <span class="keywordtype">int</span> n){
<a name="l01193"></a>01193   <span class="keywordflow">while</span>( n&gt;1 &amp;&amp; <a class="code" href="fts2_8c.html#a20d181dae5fd5997e6ffd0be07099c48">orderedDLReaderCmp</a>(p, p+1)&gt;0 ){
<a name="l01194"></a>01194     <a class="code" href="structOrderedDLReader.html">OrderedDLReader</a> tmp = p[0];
<a name="l01195"></a>01195     p[0] = p[1];
<a name="l01196"></a>01196     p[1] = tmp;
<a name="l01197"></a>01197     n--;
<a name="l01198"></a>01198     p++;
<a name="l01199"></a>01199   }
<a name="l01200"></a>01200 }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202 <span class="comment">/* Given an array of doclist readers, merge their doclist elements</span>
<a name="l01203"></a>01203 <span class="comment">** into out in sorted order (by docid), dropping elements from older</span>
<a name="l01204"></a>01204 <span class="comment">** readers when there is a duplicate docid.  pReaders is assumed to be</span>
<a name="l01205"></a>01205 <span class="comment">** ordered by age, oldest first.</span>
<a name="l01206"></a>01206 <span class="comment">*/</span>
<a name="l01207"></a>01207 <span class="comment">/* TODO(shess) nReaders must be &lt;= MERGE_COUNT.  This should probably</span>
<a name="l01208"></a>01208 <span class="comment">** be fixed.</span>
<a name="l01209"></a>01209 <span class="comment">*/</span>
<a name="l01210"></a><a class="code" href="fts2_8c.html#aa204589d71a5ad4842500f76af21e2b9">01210</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aa204589d71a5ad4842500f76af21e2b9">docListMerge</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *out,
<a name="l01211"></a>01211                          <a class="code" href="structDLReader.html">DLReader</a> *pReaders, <span class="keywordtype">int</span> nReaders){
<a name="l01212"></a>01212   <a class="code" href="structOrderedDLReader.html">OrderedDLReader</a> readers[<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>];
<a name="l01213"></a>01213   <a class="code" href="structDLWriter.html">DLWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l01214"></a>01214   <span class="keywordtype">int</span> i, n;
<a name="l01215"></a>01215   <span class="keyword">const</span> <span class="keywordtype">char</span> *pStart = 0;
<a name="l01216"></a>01216   <span class="keywordtype">int</span> nStart = 0;
<a name="l01217"></a>01217   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iFirstDocid = 0, iLastDocid = 0;
<a name="l01218"></a>01218 
<a name="l01219"></a>01219   assert( nReaders&gt;0 );
<a name="l01220"></a>01220   <span class="keywordflow">if</span>( nReaders==1 ){
<a name="l01221"></a>01221     <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(out, <a class="code" href="fts2_8c.html#a09a2b06a41a6ec0c8a6003f0e62c87f5">dlrDocData</a>(pReaders), <a class="code" href="fts2_8c.html#a1b98de47a53d77a7616bf2da40965c15">dlrAllDataBytes</a>(pReaders));
<a name="l01222"></a>01222     <span class="keywordflow">return</span>;
<a name="l01223"></a>01223   }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225   assert( nReaders&lt;=<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a> );
<a name="l01226"></a>01226   n = 0;
<a name="l01227"></a>01227   <span class="keywordflow">for</span>(i=0; i&lt;nReaders; i++){
<a name="l01228"></a>01228     assert( pReaders[i].iType==pReaders[0].iType );
<a name="l01229"></a>01229     readers[i].<a class="code" href="structOrderedDLReader.html#a121046e6f80756fb080a0d3110605e82">pReader</a> = pReaders+i;
<a name="l01230"></a>01230     readers[i].<a class="code" href="structOrderedDLReader.html#a4874d131ac5cafaa90b93db6584ef354">idx</a> = i;
<a name="l01231"></a>01231     n += <a class="code" href="fts2_8c.html#a1b98de47a53d77a7616bf2da40965c15">dlrAllDataBytes</a>(&amp;pReaders[i]);
<a name="l01232"></a>01232   }
<a name="l01233"></a>01233   <span class="comment">/* Conservatively size output to sum of inputs.  Output should end</span>
<a name="l01234"></a>01234 <span class="comment">  ** up strictly smaller than input.</span>
<a name="l01235"></a>01235 <span class="comment">  */</span>
<a name="l01236"></a>01236   <a class="code" href="fts2_8c.html#adacb3dea03975658c0e31acb2501e49f">dataBufferExpand</a>(out, n);
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   <span class="comment">/* Get the readers into sorted order. */</span>
<a name="l01239"></a>01239   <span class="keywordflow">while</span>( i--&gt;0 ){
<a name="l01240"></a>01240     <a class="code" href="fts2_8c.html#a7e05e36e9ff2d0edbfbb4b9c3b587313">orderedDLReaderReorder</a>(readers+i, nReaders-i);
<a name="l01241"></a>01241   }
<a name="l01242"></a>01242 
<a name="l01243"></a>01243   <a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">dlwInit</a>(&amp;writer, pReaders[0].iType, out);
<a name="l01244"></a>01244   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(readers[0].pReader) ){
<a name="l01245"></a>01245     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid = <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(readers[0].pReader);
<a name="l01246"></a>01246 
<a name="l01247"></a>01247     <span class="comment">/* If this is a continuation of the current buffer to copy, extend</span>
<a name="l01248"></a>01248 <span class="comment">    ** that buffer.  memcpy() seems to be more efficient if it has a</span>
<a name="l01249"></a>01249 <span class="comment">    ** lots of data to copy.</span>
<a name="l01250"></a>01250 <span class="comment">    */</span>
<a name="l01251"></a>01251     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a09a2b06a41a6ec0c8a6003f0e62c87f5">dlrDocData</a>(readers[0].pReader)==pStart+nStart ){
<a name="l01252"></a>01252       nStart += <a class="code" href="fts2_8c.html#acf7480695ffb31c831ba699530f5e7f5">dlrDocDataBytes</a>(readers[0].pReader);
<a name="l01253"></a>01253     }<span class="keywordflow">else</span>{
<a name="l01254"></a>01254       <span class="keywordflow">if</span>( pStart!=0 ){
<a name="l01255"></a>01255         <a class="code" href="fts2_8c.html#a01590c2119575bfadd678cc54ef10b34">dlwAppend</a>(&amp;writer, pStart, nStart, iFirstDocid, iLastDocid);
<a name="l01256"></a>01256       }
<a name="l01257"></a>01257       pStart = <a class="code" href="fts2_8c.html#a09a2b06a41a6ec0c8a6003f0e62c87f5">dlrDocData</a>(readers[0].pReader);
<a name="l01258"></a>01258       nStart = <a class="code" href="fts2_8c.html#acf7480695ffb31c831ba699530f5e7f5">dlrDocDataBytes</a>(readers[0].pReader);
<a name="l01259"></a>01259       iFirstDocid = iDocid;
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261     iLastDocid = iDocid;
<a name="l01262"></a>01262     <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(readers[0].pReader);
<a name="l01263"></a>01263 
<a name="l01264"></a>01264     <span class="comment">/* Drop all of the older elements with the same docid. */</span>
<a name="l01265"></a>01265     <span class="keywordflow">for</span>(i=1; i&lt;nReaders &amp;&amp;
<a name="l01266"></a>01266              !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(readers[i].pReader) &amp;&amp;
<a name="l01267"></a>01267              <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(readers[i].pReader)==iDocid; i++){
<a name="l01268"></a>01268       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(readers[i].pReader);
<a name="l01269"></a>01269     }
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     <span class="comment">/* Get the readers back into order. */</span>
<a name="l01272"></a>01272     <span class="keywordflow">while</span>( i--&gt;0 ){
<a name="l01273"></a>01273       <a class="code" href="fts2_8c.html#a7e05e36e9ff2d0edbfbb4b9c3b587313">orderedDLReaderReorder</a>(readers+i, nReaders-i);
<a name="l01274"></a>01274     }
<a name="l01275"></a>01275   }
<a name="l01276"></a>01276 
<a name="l01277"></a>01277   <span class="comment">/* Copy over any remaining elements. */</span>
<a name="l01278"></a>01278   <span class="keywordflow">if</span>( nStart&gt;0 ) <a class="code" href="fts2_8c.html#a01590c2119575bfadd678cc54ef10b34">dlwAppend</a>(&amp;writer, pStart, nStart, iFirstDocid, iLastDocid);
<a name="l01279"></a>01279   <a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">dlwDestroy</a>(&amp;writer);
<a name="l01280"></a>01280 }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 <span class="comment">/* Helper function for posListUnion().  Compares the current position</span>
<a name="l01283"></a>01283 <span class="comment">** between left and right, returning as standard C idiom of &lt;0 if</span>
<a name="l01284"></a>01284 <span class="comment">** left&lt;right, &gt;0 if left&gt;right, and 0 if left==right.  &quot;End&quot; always</span>
<a name="l01285"></a>01285 <span class="comment">** compares greater.</span>
<a name="l01286"></a>01286 <span class="comment">*/</span>
<a name="l01287"></a><a class="code" href="fts2_8c.html#acdea285e639800f8d732bc1a23b40010">01287</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#acdea285e639800f8d732bc1a23b40010">posListCmp</a>(<a class="code" href="structPLReader.html">PLReader</a> *pLeft, <a class="code" href="structPLReader.html">PLReader</a> *pRight){
<a name="l01288"></a>01288   assert( pLeft-&gt;<a class="code" href="structPLReader.html#a3b51af3309621caa31482eed19623684">iType</a>==pRight-&gt;<a class="code" href="structPLReader.html#a3b51af3309621caa31482eed19623684">iType</a> );
<a name="l01289"></a>01289   <span class="keywordflow">if</span>( pLeft-&gt;<a class="code" href="structPLReader.html#a3b51af3309621caa31482eed19623684">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a> ) <span class="keywordflow">return</span> 0;
<a name="l01290"></a>01290 
<a name="l01291"></a>01291   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(pLeft) ) <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(pRight) ? 0 : 1;
<a name="l01292"></a>01292   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(pRight) ) <span class="keywordflow">return</span> -1;
<a name="l01293"></a>01293 
<a name="l01294"></a>01294   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(pLeft)&lt;<a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(pRight) ) <span class="keywordflow">return</span> -1;
<a name="l01295"></a>01295   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(pLeft)&gt;<a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(pRight) ) <span class="keywordflow">return</span> 1;
<a name="l01296"></a>01296 
<a name="l01297"></a>01297   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(pLeft)&lt;<a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(pRight) ) <span class="keywordflow">return</span> -1;
<a name="l01298"></a>01298   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(pLeft)&gt;<a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(pRight) ) <span class="keywordflow">return</span> 1;
<a name="l01299"></a>01299   <span class="keywordflow">if</span>( pLeft-&gt;<a class="code" href="structPLReader.html#a3b51af3309621caa31482eed19623684">iType</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ) <span class="keywordflow">return</span> 0;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a53f94db5ee5ec2bbb60962eb9d1c292a">plrStartOffset</a>(pLeft)&lt;<a class="code" href="fts2_8c.html#a53f94db5ee5ec2bbb60962eb9d1c292a">plrStartOffset</a>(pRight) ) <span class="keywordflow">return</span> -1;
<a name="l01302"></a>01302   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a53f94db5ee5ec2bbb60962eb9d1c292a">plrStartOffset</a>(pLeft)&gt;<a class="code" href="fts2_8c.html#a53f94db5ee5ec2bbb60962eb9d1c292a">plrStartOffset</a>(pRight) ) <span class="keywordflow">return</span> 1;
<a name="l01303"></a>01303 
<a name="l01304"></a>01304   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a41ebd653df431023f9c89b13ac282e37">plrEndOffset</a>(pLeft)&lt;<a class="code" href="fts2_8c.html#a41ebd653df431023f9c89b13ac282e37">plrEndOffset</a>(pRight) ) <span class="keywordflow">return</span> -1;
<a name="l01305"></a>01305   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a41ebd653df431023f9c89b13ac282e37">plrEndOffset</a>(pLeft)&gt;<a class="code" href="fts2_8c.html#a41ebd653df431023f9c89b13ac282e37">plrEndOffset</a>(pRight) ) <span class="keywordflow">return</span> 1;
<a name="l01306"></a>01306 
<a name="l01307"></a>01307   <span class="keywordflow">return</span> 0;
<a name="l01308"></a>01308 }
<a name="l01309"></a>01309 
<a name="l01310"></a>01310 <span class="comment">/* Write the union of position lists in pLeft and pRight to pOut.</span>
<a name="l01311"></a>01311 <span class="comment">** &quot;Union&quot; in this case meaning &quot;All unique position tuples&quot;.  Should</span>
<a name="l01312"></a>01312 <span class="comment">** work with any doclist type, though both inputs and the output</span>
<a name="l01313"></a>01313 <span class="comment">** should be the same type.</span>
<a name="l01314"></a>01314 <span class="comment">*/</span>
<a name="l01315"></a><a class="code" href="fts2_8c.html#a9e2357955a79d2b830afd3bbf03e8ed5">01315</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a9e2357955a79d2b830afd3bbf03e8ed5">posListUnion</a>(<a class="code" href="structDLReader.html">DLReader</a> *pLeft, <a class="code" href="structDLReader.html">DLReader</a> *pRight, <a class="code" href="structDLWriter.html">DLWriter</a> *pOut){
<a name="l01316"></a>01316   <a class="code" href="structPLReader.html">PLReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l01317"></a>01317   <a class="code" href="structPLWriter.html">PLWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l01318"></a>01318 
<a name="l01319"></a>01319   assert( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(pLeft)==<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(pRight) );
<a name="l01320"></a>01320   assert( pLeft-&gt;<a class="code" href="structDLReader.html#a93c2770301c7a3469d9f3055e44e7b64">iType</a>==pRight-&gt;<a class="code" href="structDLReader.html#a93c2770301c7a3469d9f3055e44e7b64">iType</a> );
<a name="l01321"></a>01321   assert( pLeft-&gt;<a class="code" href="structDLReader.html#a93c2770301c7a3469d9f3055e44e7b64">iType</a>==pOut-&gt;<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a> );
<a name="l01322"></a>01322 
<a name="l01323"></a>01323   <a class="code" href="fts2_8c.html#ac211994cb69d057e6e933363854b92b0">plrInit</a>(&amp;left, pLeft);
<a name="l01324"></a>01324   <a class="code" href="fts2_8c.html#ac211994cb69d057e6e933363854b92b0">plrInit</a>(&amp;right, pRight);
<a name="l01325"></a>01325   <a class="code" href="fts2_8c.html#acfd18578dc8616ad20d4c3844a8ff168">plwInit</a>(&amp;writer, pOut, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(pLeft));
<a name="l01326"></a>01326 
<a name="l01327"></a>01327   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(&amp;left) || !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(&amp;right) ){
<a name="l01328"></a>01328     <span class="keywordtype">int</span> c = <a class="code" href="fts2_8c.html#acdea285e639800f8d732bc1a23b40010">posListCmp</a>(&amp;left, &amp;right);
<a name="l01329"></a>01329     <span class="keywordflow">if</span>( c&lt;0 ){
<a name="l01330"></a>01330       <a class="code" href="fts2_8c.html#aae61ae5509a522de001fef98aaf6ed86">plwCopy</a>(&amp;writer, &amp;left);
<a name="l01331"></a>01331       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;left);
<a name="l01332"></a>01332     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( c&gt;0 ){
<a name="l01333"></a>01333       <a class="code" href="fts2_8c.html#aae61ae5509a522de001fef98aaf6ed86">plwCopy</a>(&amp;writer, &amp;right);
<a name="l01334"></a>01334       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;right);
<a name="l01335"></a>01335     }<span class="keywordflow">else</span>{
<a name="l01336"></a>01336       <a class="code" href="fts2_8c.html#aae61ae5509a522de001fef98aaf6ed86">plwCopy</a>(&amp;writer, &amp;left);
<a name="l01337"></a>01337       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;left);
<a name="l01338"></a>01338       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;right);
<a name="l01339"></a>01339     }
<a name="l01340"></a>01340   }
<a name="l01341"></a>01341 
<a name="l01342"></a>01342   <a class="code" href="fts2_8c.html#a2db69170e94c0c3fa5eac814302930c6">plwTerminate</a>(&amp;writer);
<a name="l01343"></a>01343   <a class="code" href="fts2_8c.html#abe80ec683531714ccb69cb6181498e48">plwDestroy</a>(&amp;writer);
<a name="l01344"></a>01344   <a class="code" href="fts2_8c.html#a4f4258f283f5c91fbb885c1726e16455">plrDestroy</a>(&amp;left);
<a name="l01345"></a>01345   <a class="code" href="fts2_8c.html#a4f4258f283f5c91fbb885c1726e16455">plrDestroy</a>(&amp;right);
<a name="l01346"></a>01346 }
<a name="l01347"></a>01347 
<a name="l01348"></a>01348 <span class="comment">/* Write the union of doclists in pLeft and pRight to pOut.  For</span>
<a name="l01349"></a>01349 <span class="comment">** docids in common between the inputs, the union of the position</span>
<a name="l01350"></a>01350 <span class="comment">** lists is written.  Inputs and outputs are always type DL_DEFAULT.</span>
<a name="l01351"></a>01351 <span class="comment">*/</span>
<a name="l01352"></a><a class="code" href="fts2_8c.html#a1378255319ef7fb8ca0763a7fef50619">01352</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a1378255319ef7fb8ca0763a7fef50619">docListUnion</a>(
<a name="l01353"></a>01353   <span class="keyword">const</span> <span class="keywordtype">char</span> *pLeft, <span class="keywordtype">int</span> nLeft,
<a name="l01354"></a>01354   <span class="keyword">const</span> <span class="keywordtype">char</span> *pRight, <span class="keywordtype">int</span> nRight,
<a name="l01355"></a>01355   <a class="code" href="structDataBuffer.html">DataBuffer</a> *pOut      <span class="comment">/* Write the combined doclist here */</span>
<a name="l01356"></a>01356 ){
<a name="l01357"></a>01357   <a class="code" href="structDLReader.html">DLReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l01358"></a>01358   <a class="code" href="structDLWriter.html">DLWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l01359"></a>01359 
<a name="l01360"></a>01360   <span class="keywordflow">if</span>( nLeft==0 ){
<a name="l01361"></a>01361     <span class="keywordflow">if</span>( nRight!=0) <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pOut, pRight, nRight);
<a name="l01362"></a>01362     <span class="keywordflow">return</span>;
<a name="l01363"></a>01363   }
<a name="l01364"></a>01364   <span class="keywordflow">if</span>( nRight==0 ){
<a name="l01365"></a>01365     <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pOut, pLeft, nLeft);
<a name="l01366"></a>01366     <span class="keywordflow">return</span>;
<a name="l01367"></a>01367   }
<a name="l01368"></a>01368 
<a name="l01369"></a>01369   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;left, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, pLeft, nLeft);
<a name="l01370"></a>01370   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;right, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, pRight, nRight);
<a name="l01371"></a>01371   <a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">dlwInit</a>(&amp;writer, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, pOut);
<a name="l01372"></a>01372 
<a name="l01373"></a>01373   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;left) || !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;right) ){
<a name="l01374"></a>01374     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;right) ){
<a name="l01375"></a>01375       <a class="code" href="fts2_8c.html#ae947473b08c66e08165ad4697f4183a5">dlwCopy</a>(&amp;writer, &amp;left);
<a name="l01376"></a>01376       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01377"></a>01377     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;left) ){
<a name="l01378"></a>01378       <a class="code" href="fts2_8c.html#ae947473b08c66e08165ad4697f4183a5">dlwCopy</a>(&amp;writer, &amp;right);
<a name="l01379"></a>01379       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01380"></a>01380     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right) ){
<a name="l01381"></a>01381       <a class="code" href="fts2_8c.html#ae947473b08c66e08165ad4697f4183a5">dlwCopy</a>(&amp;writer, &amp;left);
<a name="l01382"></a>01382       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01383"></a>01383     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left)&gt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right) ){
<a name="l01384"></a>01384       <a class="code" href="fts2_8c.html#ae947473b08c66e08165ad4697f4183a5">dlwCopy</a>(&amp;writer, &amp;right);
<a name="l01385"></a>01385       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01386"></a>01386     }<span class="keywordflow">else</span>{
<a name="l01387"></a>01387       <a class="code" href="fts2_8c.html#a9e2357955a79d2b830afd3bbf03e8ed5">posListUnion</a>(&amp;left, &amp;right, &amp;writer);
<a name="l01388"></a>01388       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01389"></a>01389       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01390"></a>01390     }
<a name="l01391"></a>01391   }
<a name="l01392"></a>01392 
<a name="l01393"></a>01393   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;left);
<a name="l01394"></a>01394   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;right);
<a name="l01395"></a>01395   <a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">dlwDestroy</a>(&amp;writer);
<a name="l01396"></a>01396 }
<a name="l01397"></a>01397 
<a name="l01398"></a>01398 <span class="comment">/* pLeft and pRight are DLReaders positioned to the same docid.</span>
<a name="l01399"></a>01399 <span class="comment">**</span>
<a name="l01400"></a>01400 <span class="comment">** If there are no instances in pLeft or pRight where the position</span>
<a name="l01401"></a>01401 <span class="comment">** of pLeft is one less than the position of pRight, then this</span>
<a name="l01402"></a>01402 <span class="comment">** routine adds nothing to pOut.</span>
<a name="l01403"></a>01403 <span class="comment">**</span>
<a name="l01404"></a>01404 <span class="comment">** If there are one or more instances where positions from pLeft</span>
<a name="l01405"></a>01405 <span class="comment">** are exactly one less than positions from pRight, then add a new</span>
<a name="l01406"></a>01406 <span class="comment">** document record to pOut.  If pOut wants to hold positions, then</span>
<a name="l01407"></a>01407 <span class="comment">** include the positions from pRight that are one more than a</span>
<a name="l01408"></a>01408 <span class="comment">** position in pLeft.  In other words:  pRight.iPos==pLeft.iPos+1.</span>
<a name="l01409"></a>01409 <span class="comment">*/</span>
<a name="l01410"></a><a class="code" href="fts2_8c.html#a43911eafb9b9c98059cf927adee8e477">01410</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a43911eafb9b9c98059cf927adee8e477">posListPhraseMerge</a>(<a class="code" href="structDLReader.html">DLReader</a> *pLeft, <a class="code" href="structDLReader.html">DLReader</a> *pRight,
<a name="l01411"></a>01411                                <a class="code" href="structDLWriter.html">DLWriter</a> *pOut){
<a name="l01412"></a>01412   <a class="code" href="structPLReader.html">PLReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l01413"></a>01413   <a class="code" href="structPLWriter.html">PLWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l01414"></a>01414   <span class="keywordtype">int</span> <a class="code" href="lstrlib_8c.html#a52a45835b75e5d31ec66421456bbb728">match</a> = 0;
<a name="l01415"></a>01415 
<a name="l01416"></a>01416   assert( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(pLeft)==<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(pRight) );
<a name="l01417"></a>01417   assert( pOut-&gt;<a class="code" href="structDLWriter.html#acb82cd5850c9418010d85f654bf881ff">iType</a>!=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a> );
<a name="l01418"></a>01418 
<a name="l01419"></a>01419   <a class="code" href="fts2_8c.html#ac211994cb69d057e6e933363854b92b0">plrInit</a>(&amp;left, pLeft);
<a name="l01420"></a>01420   <a class="code" href="fts2_8c.html#ac211994cb69d057e6e933363854b92b0">plrInit</a>(&amp;right, pRight);
<a name="l01421"></a>01421 
<a name="l01422"></a>01422   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(&amp;left) &amp;&amp; !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(&amp;right) ){
<a name="l01423"></a>01423     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;left)&lt;<a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;right) ){
<a name="l01424"></a>01424       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;left);
<a name="l01425"></a>01425     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;left)&gt;<a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;right) ){
<a name="l01426"></a>01426       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;right);
<a name="l01427"></a>01427     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(&amp;left)+1&lt;<a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(&amp;right) ){
<a name="l01428"></a>01428       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;left);
<a name="l01429"></a>01429     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(&amp;left)+1&gt;<a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(&amp;right) ){
<a name="l01430"></a>01430       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;right);
<a name="l01431"></a>01431     }<span class="keywordflow">else</span>{
<a name="l01432"></a>01432       <span class="keywordflow">if</span>( !match ){
<a name="l01433"></a>01433         <a class="code" href="fts2_8c.html#acfd18578dc8616ad20d4c3844a8ff168">plwInit</a>(&amp;writer, pOut, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(pLeft));
<a name="l01434"></a>01434         match = 1;
<a name="l01435"></a>01435       }
<a name="l01436"></a>01436       <a class="code" href="fts2_8c.html#a98cd872fb23c47d87519cd900c589a0f">plwAdd</a>(&amp;writer, <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;right), <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(&amp;right), 0, 0);
<a name="l01437"></a>01437       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;left);
<a name="l01438"></a>01438       <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;right);
<a name="l01439"></a>01439     }
<a name="l01440"></a>01440   }
<a name="l01441"></a>01441 
<a name="l01442"></a>01442   <span class="keywordflow">if</span>( match ){
<a name="l01443"></a>01443     <a class="code" href="fts2_8c.html#a2db69170e94c0c3fa5eac814302930c6">plwTerminate</a>(&amp;writer);
<a name="l01444"></a>01444     <a class="code" href="fts2_8c.html#abe80ec683531714ccb69cb6181498e48">plwDestroy</a>(&amp;writer);
<a name="l01445"></a>01445   }
<a name="l01446"></a>01446 
<a name="l01447"></a>01447   <a class="code" href="fts2_8c.html#a4f4258f283f5c91fbb885c1726e16455">plrDestroy</a>(&amp;left);
<a name="l01448"></a>01448   <a class="code" href="fts2_8c.html#a4f4258f283f5c91fbb885c1726e16455">plrDestroy</a>(&amp;right);
<a name="l01449"></a>01449 }
<a name="l01450"></a>01450 
<a name="l01451"></a>01451 <span class="comment">/* We have two doclists with positions:  pLeft and pRight.</span>
<a name="l01452"></a>01452 <span class="comment">** Write the phrase intersection of these two doclists into pOut.</span>
<a name="l01453"></a>01453 <span class="comment">**</span>
<a name="l01454"></a>01454 <span class="comment">** A phrase intersection means that two documents only match</span>
<a name="l01455"></a>01455 <span class="comment">** if pLeft.iPos+1==pRight.iPos.</span>
<a name="l01456"></a>01456 <span class="comment">**</span>
<a name="l01457"></a>01457 <span class="comment">** iType controls the type of data written to pOut.  If iType is</span>
<a name="l01458"></a>01458 <span class="comment">** DL_POSITIONS, the positions are those from pRight.</span>
<a name="l01459"></a>01459 <span class="comment">*/</span>
<a name="l01460"></a><a class="code" href="fts2_8c.html#a1c69fcaac7f3a472f2c6bd8cb700b3c2">01460</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a1c69fcaac7f3a472f2c6bd8cb700b3c2">docListPhraseMerge</a>(
<a name="l01461"></a>01461   <span class="keyword">const</span> <span class="keywordtype">char</span> *pLeft, <span class="keywordtype">int</span> nLeft,
<a name="l01462"></a>01462   <span class="keyword">const</span> <span class="keywordtype">char</span> *pRight, <span class="keywordtype">int</span> nRight,
<a name="l01463"></a>01463   <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType,
<a name="l01464"></a>01464   <a class="code" href="structDataBuffer.html">DataBuffer</a> *pOut      <span class="comment">/* Write the combined doclist here */</span>
<a name="l01465"></a>01465 ){
<a name="l01466"></a>01466   <a class="code" href="structDLReader.html">DLReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l01467"></a>01467   <a class="code" href="structDLWriter.html">DLWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l01468"></a>01468 
<a name="l01469"></a>01469   <span class="keywordflow">if</span>( nLeft==0 || nRight==0 ) <span class="keywordflow">return</span>;
<a name="l01470"></a>01470 
<a name="l01471"></a>01471   assert( iType!=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a> );
<a name="l01472"></a>01472 
<a name="l01473"></a>01473   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;left, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a>, pLeft, nLeft);
<a name="l01474"></a>01474   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;right, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a>, pRight, nRight);
<a name="l01475"></a>01475   <a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">dlwInit</a>(&amp;writer, iType, pOut);
<a name="l01476"></a>01476 
<a name="l01477"></a>01477   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;left) &amp;&amp; !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;right) ){
<a name="l01478"></a>01478     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right) ){
<a name="l01479"></a>01479       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01480"></a>01480     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left) ){
<a name="l01481"></a>01481       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01482"></a>01482     }<span class="keywordflow">else</span>{
<a name="l01483"></a>01483       <a class="code" href="fts2_8c.html#a43911eafb9b9c98059cf927adee8e477">posListPhraseMerge</a>(&amp;left, &amp;right, &amp;writer);
<a name="l01484"></a>01484       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01485"></a>01485       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487   }
<a name="l01488"></a>01488 
<a name="l01489"></a>01489   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;left);
<a name="l01490"></a>01490   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;right);
<a name="l01491"></a>01491   <a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">dlwDestroy</a>(&amp;writer);
<a name="l01492"></a>01492 }
<a name="l01493"></a>01493 
<a name="l01494"></a>01494 <span class="comment">/* We have two DL_DOCIDS doclists:  pLeft and pRight.</span>
<a name="l01495"></a>01495 <span class="comment">** Write the intersection of these two doclists into pOut as a</span>
<a name="l01496"></a>01496 <span class="comment">** DL_DOCIDS doclist.</span>
<a name="l01497"></a>01497 <span class="comment">*/</span>
<a name="l01498"></a><a class="code" href="fts2_8c.html#a15c61ce33f9c52f09efdbca0d45bd5d7">01498</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a15c61ce33f9c52f09efdbca0d45bd5d7">docListAndMerge</a>(
<a name="l01499"></a>01499   <span class="keyword">const</span> <span class="keywordtype">char</span> *pLeft, <span class="keywordtype">int</span> nLeft,
<a name="l01500"></a>01500   <span class="keyword">const</span> <span class="keywordtype">char</span> *pRight, <span class="keywordtype">int</span> nRight,
<a name="l01501"></a>01501   <a class="code" href="structDataBuffer.html">DataBuffer</a> *pOut      <span class="comment">/* Write the combined doclist here */</span>
<a name="l01502"></a>01502 ){
<a name="l01503"></a>01503   <a class="code" href="structDLReader.html">DLReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l01504"></a>01504   <a class="code" href="structDLWriter.html">DLWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l01505"></a>01505 
<a name="l01506"></a>01506   <span class="keywordflow">if</span>( nLeft==0 || nRight==0 ) <span class="keywordflow">return</span>;
<a name="l01507"></a>01507 
<a name="l01508"></a>01508   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;left, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, pLeft, nLeft);
<a name="l01509"></a>01509   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;right, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, pRight, nRight);
<a name="l01510"></a>01510   <a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">dlwInit</a>(&amp;writer, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, pOut);
<a name="l01511"></a>01511 
<a name="l01512"></a>01512   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;left) &amp;&amp; !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;right) ){
<a name="l01513"></a>01513     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right) ){
<a name="l01514"></a>01514       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01515"></a>01515     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left) ){
<a name="l01516"></a>01516       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01517"></a>01517     }<span class="keywordflow">else</span>{
<a name="l01518"></a>01518       <a class="code" href="fts2_8c.html#a33a58b23659c4120b32966362c9bb36c">dlwAdd</a>(&amp;writer, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left));
<a name="l01519"></a>01519       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01520"></a>01520       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01521"></a>01521     }
<a name="l01522"></a>01522   }
<a name="l01523"></a>01523 
<a name="l01524"></a>01524   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;left);
<a name="l01525"></a>01525   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;right);
<a name="l01526"></a>01526   <a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">dlwDestroy</a>(&amp;writer);
<a name="l01527"></a>01527 }
<a name="l01528"></a>01528 
<a name="l01529"></a>01529 <span class="comment">/* We have two DL_DOCIDS doclists:  pLeft and pRight.</span>
<a name="l01530"></a>01530 <span class="comment">** Write the union of these two doclists into pOut as a</span>
<a name="l01531"></a>01531 <span class="comment">** DL_DOCIDS doclist.</span>
<a name="l01532"></a>01532 <span class="comment">*/</span>
<a name="l01533"></a><a class="code" href="fts2_8c.html#a7103f3714d4b2bfaebdb0d475dea8279">01533</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a7103f3714d4b2bfaebdb0d475dea8279">docListOrMerge</a>(
<a name="l01534"></a>01534   <span class="keyword">const</span> <span class="keywordtype">char</span> *pLeft, <span class="keywordtype">int</span> nLeft,
<a name="l01535"></a>01535   <span class="keyword">const</span> <span class="keywordtype">char</span> *pRight, <span class="keywordtype">int</span> nRight,
<a name="l01536"></a>01536   <a class="code" href="structDataBuffer.html">DataBuffer</a> *pOut      <span class="comment">/* Write the combined doclist here */</span>
<a name="l01537"></a>01537 ){
<a name="l01538"></a>01538   <a class="code" href="structDLReader.html">DLReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l01539"></a>01539   <a class="code" href="structDLWriter.html">DLWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l01540"></a>01540 
<a name="l01541"></a>01541   <span class="keywordflow">if</span>( nLeft==0 ){
<a name="l01542"></a>01542     <span class="keywordflow">if</span>( nRight!=0 ) <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pOut, pRight, nRight);
<a name="l01543"></a>01543     <span class="keywordflow">return</span>;
<a name="l01544"></a>01544   }
<a name="l01545"></a>01545   <span class="keywordflow">if</span>( nRight==0 ){
<a name="l01546"></a>01546     <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pOut, pLeft, nLeft);
<a name="l01547"></a>01547     <span class="keywordflow">return</span>;
<a name="l01548"></a>01548   }
<a name="l01549"></a>01549 
<a name="l01550"></a>01550   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;left, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, pLeft, nLeft);
<a name="l01551"></a>01551   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;right, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, pRight, nRight);
<a name="l01552"></a>01552   <a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">dlwInit</a>(&amp;writer, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, pOut);
<a name="l01553"></a>01553 
<a name="l01554"></a>01554   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;left) || !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;right) ){
<a name="l01555"></a>01555     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;right) ){
<a name="l01556"></a>01556       <a class="code" href="fts2_8c.html#a33a58b23659c4120b32966362c9bb36c">dlwAdd</a>(&amp;writer, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left));
<a name="l01557"></a>01557       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01558"></a>01558     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;left) ){
<a name="l01559"></a>01559       <a class="code" href="fts2_8c.html#a33a58b23659c4120b32966362c9bb36c">dlwAdd</a>(&amp;writer, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right));
<a name="l01560"></a>01560       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01561"></a>01561     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right) ){
<a name="l01562"></a>01562       <a class="code" href="fts2_8c.html#a33a58b23659c4120b32966362c9bb36c">dlwAdd</a>(&amp;writer, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left));
<a name="l01563"></a>01563       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01564"></a>01564     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left) ){
<a name="l01565"></a>01565       <a class="code" href="fts2_8c.html#a33a58b23659c4120b32966362c9bb36c">dlwAdd</a>(&amp;writer, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right));
<a name="l01566"></a>01566       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01567"></a>01567     }<span class="keywordflow">else</span>{
<a name="l01568"></a>01568       <a class="code" href="fts2_8c.html#a33a58b23659c4120b32966362c9bb36c">dlwAdd</a>(&amp;writer, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left));
<a name="l01569"></a>01569       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01570"></a>01570       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01571"></a>01571     }
<a name="l01572"></a>01572   }
<a name="l01573"></a>01573 
<a name="l01574"></a>01574   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;left);
<a name="l01575"></a>01575   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;right);
<a name="l01576"></a>01576   <a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">dlwDestroy</a>(&amp;writer);
<a name="l01577"></a>01577 }
<a name="l01578"></a>01578 
<a name="l01579"></a>01579 <span class="comment">/* We have two DL_DOCIDS doclists:  pLeft and pRight.</span>
<a name="l01580"></a>01580 <span class="comment">** Write into pOut as DL_DOCIDS doclist containing all documents that</span>
<a name="l01581"></a>01581 <span class="comment">** occur in pLeft but not in pRight.</span>
<a name="l01582"></a>01582 <span class="comment">*/</span>
<a name="l01583"></a><a class="code" href="fts2_8c.html#a14543ab3eeff9421574583330c1a3839">01583</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a14543ab3eeff9421574583330c1a3839">docListExceptMerge</a>(
<a name="l01584"></a>01584   <span class="keyword">const</span> <span class="keywordtype">char</span> *pLeft, <span class="keywordtype">int</span> nLeft,
<a name="l01585"></a>01585   <span class="keyword">const</span> <span class="keywordtype">char</span> *pRight, <span class="keywordtype">int</span> nRight,
<a name="l01586"></a>01586   <a class="code" href="structDataBuffer.html">DataBuffer</a> *pOut      <span class="comment">/* Write the combined doclist here */</span>
<a name="l01587"></a>01587 ){
<a name="l01588"></a>01588   <a class="code" href="structDLReader.html">DLReader</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>;
<a name="l01589"></a>01589   <a class="code" href="structDLWriter.html">DLWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l01590"></a>01590 
<a name="l01591"></a>01591   <span class="keywordflow">if</span>( nLeft==0 ) <span class="keywordflow">return</span>;
<a name="l01592"></a>01592   <span class="keywordflow">if</span>( nRight==0 ){
<a name="l01593"></a>01593     <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(pOut, pLeft, nLeft);
<a name="l01594"></a>01594     <span class="keywordflow">return</span>;
<a name="l01595"></a>01595   }
<a name="l01596"></a>01596 
<a name="l01597"></a>01597   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;left, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, pLeft, nLeft);
<a name="l01598"></a>01598   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;right, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, pRight, nRight);
<a name="l01599"></a>01599   <a class="code" href="fts2_8c.html#ae2cd905efd2eaa5648828e2adf8af9ee">dlwInit</a>(&amp;writer, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, pOut);
<a name="l01600"></a>01600 
<a name="l01601"></a>01601   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;left) ){
<a name="l01602"></a>01602     <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;right) &amp;&amp; <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left) ){
<a name="l01603"></a>01603       <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;right);
<a name="l01604"></a>01604     }
<a name="l01605"></a>01605     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;right) || <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left)&lt;<a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;right) ){
<a name="l01606"></a>01606       <a class="code" href="fts2_8c.html#a33a58b23659c4120b32966362c9bb36c">dlwAdd</a>(&amp;writer, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;left));
<a name="l01607"></a>01607     }
<a name="l01608"></a>01608     <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;left);
<a name="l01609"></a>01609   }
<a name="l01610"></a>01610 
<a name="l01611"></a>01611   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;left);
<a name="l01612"></a>01612   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;right);
<a name="l01613"></a>01613   <a class="code" href="fts2_8c.html#a11c289cd389f0f2c5c573d64e1e3432e">dlwDestroy</a>(&amp;writer);
<a name="l01614"></a>01614 }
<a name="l01615"></a>01615 
<a name="l01616"></a><a class="code" href="fts2_8c.html#a1bd93cdd9e47ca6e2aeb514b515c221b">01616</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a1bd93cdd9e47ca6e2aeb514b515c221b">string_dup_n</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> n){
<a name="l01617"></a>01617   <span class="keywordtype">char</span> *str = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(n + 1);
<a name="l01618"></a>01618   memcpy(str, s, n);
<a name="l01619"></a>01619   str[n] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01620"></a>01620   <span class="keywordflow">return</span> str;
<a name="l01621"></a>01621 }
<a name="l01622"></a>01622 
<a name="l01623"></a>01623 <span class="comment">/* Duplicate a string; the caller must free() the returned string.</span>
<a name="l01624"></a>01624 <span class="comment"> * (We don&apos;t use strdup() since it is not part of the standard C library and</span>
<a name="l01625"></a>01625 <span class="comment"> * may not be available everywhere.) */</span>
<a name="l01626"></a><a class="code" href="fts2_8c.html#a7a1ca6e7e7b15d27e59df8a9da195d77">01626</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a7a1ca6e7e7b15d27e59df8a9da195d77">string_dup</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s){
<a name="l01627"></a>01627   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a1bd93cdd9e47ca6e2aeb514b515c221b">string_dup_n</a>(s, strlen(s));
<a name="l01628"></a>01628 }
<a name="l01629"></a>01629 
<a name="l01630"></a>01630 <span class="comment">/* Format a string, replacing each occurrence of the % character with</span>
<a name="l01631"></a>01631 <span class="comment"> * zDb.zName.  This may be more convenient than sqlite_mprintf()</span>
<a name="l01632"></a>01632 <span class="comment"> * when one string is used repeatedly in a format string.</span>
<a name="l01633"></a>01633 <span class="comment"> * The caller must free() the returned string. */</span>
<a name="l01634"></a><a class="code" href="fts2_8c.html#ae30be3db8b2e8e3fc7675a0683646676">01634</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#ae30be3db8b2e8e3fc7675a0683646676">string_format</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat,
<a name="l01635"></a>01635                            <span class="keyword">const</span> <span class="keywordtype">char</span> *zDb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zName){
<a name="l01636"></a>01636   <span class="keyword">const</span> <span class="keywordtype">char</span> *p;
<a name="l01637"></a>01637   <span class="keywordtype">size_t</span> len = 0;
<a name="l01638"></a>01638   <span class="keywordtype">size_t</span> nDb = strlen(zDb);
<a name="l01639"></a>01639   <span class="keywordtype">size_t</span> nName = strlen(zName);
<a name="l01640"></a>01640   <span class="keywordtype">size_t</span> nFullTableName = nDb+1+nName;
<a name="l01641"></a>01641   <span class="keywordtype">char</span> *result;
<a name="l01642"></a>01642   <span class="keywordtype">char</span> *r;
<a name="l01643"></a>01643 
<a name="l01644"></a>01644   <span class="comment">/* first compute length needed */</span>
<a name="l01645"></a>01645   <span class="keywordflow">for</span>(p = zFormat ; *p ; ++p){
<a name="l01646"></a>01646     len += (*p==<span class="charliteral">&apos;%&apos;</span> ? nFullTableName : 1);
<a name="l01647"></a>01647   }
<a name="l01648"></a>01648   len += 1;  <span class="comment">/* for null terminator */</span>
<a name="l01649"></a>01649 
<a name="l01650"></a>01650   r = result = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(len);
<a name="l01651"></a>01651   <span class="keywordflow">for</span>(p = zFormat; *p; ++p){
<a name="l01652"></a>01652     <span class="keywordflow">if</span>( *p==<span class="charliteral">&apos;%&apos;</span> ){
<a name="l01653"></a>01653       memcpy(r, zDb, nDb);
<a name="l01654"></a>01654       r += nDb;
<a name="l01655"></a>01655       *r++ = <span class="charliteral">&apos;.&apos;</span>;
<a name="l01656"></a>01656       memcpy(r, zName, nName);
<a name="l01657"></a>01657       r += nName;
<a name="l01658"></a>01658     } <span class="keywordflow">else</span> {
<a name="l01659"></a>01659       *r++ = *p;
<a name="l01660"></a>01660     }
<a name="l01661"></a>01661   }
<a name="l01662"></a>01662   *r++ = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01663"></a>01663   assert( r == result + len );
<a name="l01664"></a>01664   <span class="keywordflow">return</span> result;
<a name="l01665"></a>01665 }
<a name="l01666"></a>01666 
<a name="l01667"></a><a class="code" href="fts2_8c.html#a39d956ab682bbd568f87016368f26aee">01667</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a39d956ab682bbd568f87016368f26aee">sql_exec</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *zDb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,
<a name="l01668"></a>01668                     <span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat){
<a name="l01669"></a>01669   <span class="keywordtype">char</span> *zCommand = <a class="code" href="fts2_8c.html#ae30be3db8b2e8e3fc7675a0683646676">string_format</a>(zFormat, zDb, zName);
<a name="l01670"></a>01670   <span class="keywordtype">int</span> rc;
<a name="l01671"></a>01671   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 sql: %s\n&quot;</span>, zCommand));
<a name="l01672"></a>01672   rc = <a class="code" href="legacy_8c.html#ada787486cf95a994521cfd0c64e853e4">sqlite3_exec</a>(db, zCommand, NULL, 0, NULL);
<a name="l01673"></a>01673   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zCommand);
<a name="l01674"></a>01674   <span class="keywordflow">return</span> rc;
<a name="l01675"></a>01675 }
<a name="l01676"></a>01676 
<a name="l01677"></a><a class="code" href="fts2_8c.html#a90c49c1625eff6f726a4ce28200e24d4">01677</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a90c49c1625eff6f726a4ce28200e24d4">sql_prepare</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *zDb, <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,
<a name="l01678"></a>01678                        <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> **ppStmt, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat){
<a name="l01679"></a>01679   <span class="keywordtype">char</span> *zCommand = <a class="code" href="fts2_8c.html#ae30be3db8b2e8e3fc7675a0683646676">string_format</a>(zFormat, zDb, zName);
<a name="l01680"></a>01680   <span class="keywordtype">int</span> rc;
<a name="l01681"></a>01681   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 prepare: %s\n&quot;</span>, zCommand));
<a name="l01682"></a>01682   rc = <a class="code" href="prepare_8c.html#a2798d2a1d90446bee6e9fa880fc659c1">sqlite3_prepare_v2</a>(db, zCommand, -1, ppStmt, NULL);
<a name="l01683"></a>01683   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zCommand);
<a name="l01684"></a>01684   <span class="keywordflow">return</span> rc;
<a name="l01685"></a>01685 }
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 <span class="comment">/* end utility functions */</span>
<a name="l01688"></a>01688 
<a name="l01689"></a>01689 <span class="comment">/* Forward reference */</span>
<a name="l01690"></a><a class="code" href="fts2_8c.html#a51038c9c7231d3309a70de308e15f6dc">01690</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a>;
<a name="l01691"></a>01691 
<a name="l01692"></a>01692 <span class="comment">/* A single term in a query is represented by an instances of</span>
<a name="l01693"></a>01693 <span class="comment">** the following structure.</span>
<a name="l01694"></a>01694 <span class="comment">*/</span>
<a name="l01695"></a>01695 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structQueryTerm.html">QueryTerm</a> {
<a name="l01696"></a>01696   <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a>; <span class="comment">/* How many following terms are part of the same phrase */</span>
<a name="l01697"></a>01697   <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structQueryTerm.html#abea35c7535689b4425baad079834a74c">iPhrase</a>; <span class="comment">/* This is the i-th term of a phrase. */</span>
<a name="l01698"></a>01698   <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structQueryTerm.html#a71a4c3b5b3246a6e2e7347d0d71edf2c">iColumn</a>; <span class="comment">/* Column of the index that must match this term */</span>
<a name="l01699"></a>01699   <span class="keywordtype">signed</span> <span class="keywordtype">char</span> <a class="code" href="structQueryTerm.html#af7018292d462a2b11f4acd1dd440bf03">isOr</a>;  <span class="comment">/* this term is preceded by &quot;OR&quot; */</span>
<a name="l01700"></a>01700   <span class="keywordtype">signed</span> <span class="keywordtype">char</span> <a class="code" href="structQueryTerm.html#a173e6f424ffb75f22ac977b041511361">isNot</a>; <span class="comment">/* this term is preceded by &quot;-&quot; */</span>
<a name="l01701"></a><a class="code" href="structQueryTerm.html#a93193d71d1732930b838cb26601ee89e">01701</a>   <span class="keywordtype">signed</span> <span class="keywordtype">char</span> <a class="code" href="structQueryTerm.html#a93193d71d1732930b838cb26601ee89e">isPrefix</a>; <span class="comment">/* this term is followed by &quot;*&quot; */</span>
<a name="l01702"></a>01702   <span class="keywordtype">char</span> *<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>;       <span class="comment">/* text of the term.  &apos;\000&apos; terminated.  malloced */</span>
<a name="l01703"></a>01703   <span class="keywordtype">int</span> <a class="code" href="structQueryTerm.html#aeeb3d5a5c0c62dc9d0966204c8cae819">nTerm</a>;         <span class="comment">/* Number of bytes in pTerm[] */</span>
<a name="l01704"></a>01704 } <a class="code" href="structQueryTerm.html">QueryTerm</a>;
<a name="l01705"></a>01705 
<a name="l01706"></a>01706 
<a name="l01707"></a>01707 <span class="comment">/* A query string is parsed into a Query structure.</span>
<a name="l01708"></a>01708 <span class="comment"> *</span>
<a name="l01709"></a>01709 <span class="comment"> * We could, in theory, allow query strings to be complicated</span>
<a name="l01710"></a>01710 <span class="comment"> * nested expressions with precedence determined by parentheses.</span>
<a name="l01711"></a>01711 <span class="comment"> * But none of the major search engines do this.  (Perhaps the</span>
<a name="l01712"></a>01712 <span class="comment"> * feeling is that an parenthesized expression is two complex of</span>
<a name="l01713"></a>01713 <span class="comment"> * an idea for the average user to grasp.)  Taking our lead from</span>
<a name="l01714"></a>01714 <span class="comment"> * the major search engines, we will allow queries to be a list</span>
<a name="l01715"></a>01715 <span class="comment"> * of terms (with an implied AND operator) or phrases in double-quotes,</span>
<a name="l01716"></a>01716 <span class="comment"> * with a single optional &quot;-&quot; before each non-phrase term to designate</span>
<a name="l01717"></a>01717 <span class="comment"> * negation and an optional OR connector.</span>
<a name="l01718"></a>01718 <span class="comment"> *</span>
<a name="l01719"></a>01719 <span class="comment"> * OR binds more tightly than the implied AND, which is what the</span>
<a name="l01720"></a>01720 <span class="comment"> * major search engines seem to do.  So, for example:</span>
<a name="l01721"></a>01721 <span class="comment"> * </span>
<a name="l01722"></a>01722 <span class="comment"> *    [one two OR three]     ==&gt;    one AND (two OR three)</span>
<a name="l01723"></a>01723 <span class="comment"> *    [one OR two three]     ==&gt;    (one OR two) AND three</span>
<a name="l01724"></a>01724 <span class="comment"> *</span>
<a name="l01725"></a>01725 <span class="comment"> * A &quot;-&quot; before a term matches all entries that lack that term.</span>
<a name="l01726"></a>01726 <span class="comment"> * The &quot;-&quot; must occur immediately before the term with in intervening</span>
<a name="l01727"></a>01727 <span class="comment"> * space.  This is how the search engines do it.</span>
<a name="l01728"></a>01728 <span class="comment"> *</span>
<a name="l01729"></a>01729 <span class="comment"> * A NOT term cannot be the right-hand operand of an OR.  If this</span>
<a name="l01730"></a>01730 <span class="comment"> * occurs in the query string, the NOT is ignored:</span>
<a name="l01731"></a>01731 <span class="comment"> *</span>
<a name="l01732"></a>01732 <span class="comment"> *    [one OR -two]          ==&gt;    one OR two</span>
<a name="l01733"></a>01733 <span class="comment"> *</span>
<a name="l01734"></a>01734 <span class="comment"> */</span>
<a name="l01735"></a>01735 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structQuery.html">Query</a> {
<a name="l01736"></a>01736   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a>;  <span class="comment">/* The full text index */</span>
<a name="l01737"></a>01737   <span class="keywordtype">int</span> <a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;           <span class="comment">/* Number of terms in the query */</span>
<a name="l01738"></a>01738   <a class="code" href="structQueryTerm.html">QueryTerm</a> *<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>;    <span class="comment">/* Array of terms.  Space obtained from malloc() */</span>
<a name="l01739"></a>01739   <span class="keywordtype">int</span> <a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a>;         <span class="comment">/* Set the isOr flag on the next inserted term */</span>
<a name="l01740"></a>01740   <span class="keywordtype">int</span> <a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a>;       <span class="comment">/* Next word parsed must be in this column */</span>
<a name="l01741"></a>01741   <span class="keywordtype">int</span> <a class="code" href="structQuery.html#af4b5b552a7646059a60c1eace4d2a020">dfltColumn</a>;       <span class="comment">/* The default column */</span>
<a name="l01742"></a>01742 } <a class="code" href="structQuery.html">Query</a>;
<a name="l01743"></a>01743 
<a name="l01744"></a>01744 
<a name="l01745"></a>01745 <span class="comment">/*</span>
<a name="l01746"></a>01746 <span class="comment">** An instance of the following structure keeps track of generated</span>
<a name="l01747"></a>01747 <span class="comment">** matching-word offset information and snippets.</span>
<a name="l01748"></a>01748 <span class="comment">*/</span>
<a name="l01749"></a>01749 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structSnippet.html">Snippet</a> {
<a name="l01750"></a>01750   <span class="keywordtype">int</span> <a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>;     <span class="comment">/* Total number of matches */</span>
<a name="l01751"></a>01751   <span class="keywordtype">int</span> <a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a>;     <span class="comment">/* Space allocated for aMatch[] */</span>
<a name="l01752"></a>01752   <span class="keyword">struct </span>snippetMatch { <span class="comment">/* One entry for each matching term */</span>
<a name="l01753"></a>01753     <span class="keywordtype">char</span> <a class="code" href="structSnippet_1_1snippetMatch.html#ac598af81a9803bc14821f25c793b0b71">snStatus</a>;       <span class="comment">/* Status flag for use while constructing snippets */</span>
<a name="l01754"></a>01754     <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structSnippet_1_1snippetMatch.html#aaf3b1781a511ec1a2e459d49ff805538">iCol</a>;      <span class="comment">/* The column that contains the match */</span>
<a name="l01755"></a>01755     <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structSnippet_1_1snippetMatch.html#a0741681e81d0310741da5745ccca9976">iTerm</a>;     <span class="comment">/* The index in Query.pTerms[] of the matching term */</span>
<a name="l01756"></a>01756     <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="structSnippet_1_1snippetMatch.html#a6b5e06d6f74d8c8467ffec2f0ccff571">nByte</a>;     <span class="comment">/* Number of bytes in the term */</span>
<a name="l01757"></a>01757     <span class="keywordtype">int</span> <a class="code" href="structSnippet_1_1snippetMatch.html#aaeeac51c4caa2b18402547755de70894">iStart</a>;          <span class="comment">/* The offset to the first character of the term */</span>
<a name="l01758"></a>01758   } *<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>;      <span class="comment">/* Points to space obtained from malloc */</span>
<a name="l01759"></a>01759   <span class="keywordtype">char</span> *<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a>;  <span class="comment">/* Text rendering of aMatch[] */</span>
<a name="l01760"></a>01760   <span class="keywordtype">int</span> <a class="code" href="structSnippet.html#a68aacd704960f6ab1c8f7de23a5d0730">nOffset</a>;    <span class="comment">/* strlen(zOffset) */</span>
<a name="l01761"></a>01761   <span class="keywordtype">char</span> *<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a>; <span class="comment">/* Snippet text */</span>
<a name="l01762"></a>01762   <span class="keywordtype">int</span> <a class="code" href="structSnippet.html#a467392bb026bc056ab7c5466873f8f11">nSnippet</a>;   <span class="comment">/* strlen(zSnippet) */</span>
<a name="l01763"></a>01763 } <a class="code" href="structSnippet.html">Snippet</a>;
<a name="l01764"></a>01764 
<a name="l01765"></a>01765 
<a name="l01766"></a><a class="code" href="fts2_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ec">01766</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ec">QueryType</a> {
<a name="l01767"></a><a class="code" href="fts2_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">01767</a>   <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">QUERY_GENERIC</a>,   <span class="comment">/* table scan */</span>
<a name="l01768"></a><a class="code" href="fts2_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ecadfa9dc6cb33447260116307a64a3c657">01768</a>   <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ecadfa9dc6cb33447260116307a64a3c657">QUERY_ROWID</a>,     <span class="comment">/* lookup by rowid */</span>
<a name="l01769"></a><a class="code" href="fts2_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">01769</a>   <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a>   <span class="comment">/* QUERY_FULLTEXT + [i] is a full-text search for column i*/</span>
<a name="l01770"></a>01770 } <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ec">QueryType</a>;
<a name="l01771"></a>01771 
<a name="l01772"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">01772</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">fulltext_statement</a> {
<a name="l01773"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ae800de40a0ad0185ff0335c967411a84">01773</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ae800de40a0ad0185ff0335c967411a84">CONTENT_INSERT_STMT</a>,
<a name="l01774"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abfdc634e15bbc89a90bdaf76034fe478">01774</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abfdc634e15bbc89a90bdaf76034fe478">CONTENT_SELECT_STMT</a>,
<a name="l01775"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a016651ce129880970fb699b09f85576c">01775</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a016651ce129880970fb699b09f85576c">CONTENT_UPDATE_STMT</a>,
<a name="l01776"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789acdb161caf82c5437390779f9e886d62e">01776</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789acdb161caf82c5437390779f9e886d62e">CONTENT_DELETE_STMT</a>,
<a name="l01777"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3ea2d2a142e2ef3cc5d19d2ca6129e56">01777</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3ea2d2a142e2ef3cc5d19d2ca6129e56">CONTENT_EXISTS_STMT</a>,
<a name="l01778"></a>01778 
<a name="l01779"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a772711d87dc79880aa0dcdf16ceba405">01779</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a772711d87dc79880aa0dcdf16ceba405">BLOCK_INSERT_STMT</a>,
<a name="l01780"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a098557abf15da2ebb1ff53f662254240">01780</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a098557abf15da2ebb1ff53f662254240">BLOCK_SELECT_STMT</a>,
<a name="l01781"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3a372ccafc30b8cc56feb976bbe55e9c">01781</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3a372ccafc30b8cc56feb976bbe55e9c">BLOCK_DELETE_STMT</a>,
<a name="l01782"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abe51aa0578de628e38ca56cd272a7966">01782</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abe51aa0578de628e38ca56cd272a7966">BLOCK_DELETE_ALL_STMT</a>,
<a name="l01783"></a>01783 
<a name="l01784"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a9e8b2c67f838ab2279a2417af4baed61">01784</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a9e8b2c67f838ab2279a2417af4baed61">SEGDIR_MAX_INDEX_STMT</a>,
<a name="l01785"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abeeeed0cd977354eaf567e05f153b890">01785</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abeeeed0cd977354eaf567e05f153b890">SEGDIR_SET_STMT</a>,
<a name="l01786"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a6189c67dce3ec517210faabb4e4651f4">01786</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a6189c67dce3ec517210faabb4e4651f4">SEGDIR_SELECT_LEVEL_STMT</a>,
<a name="l01787"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a78c1f6dbdc2c212ec09aaa1e05a8388c">01787</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a78c1f6dbdc2c212ec09aaa1e05a8388c">SEGDIR_SPAN_STMT</a>,
<a name="l01788"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ad0155bf348fa2cc6e28af7191914a4b4">01788</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ad0155bf348fa2cc6e28af7191914a4b4">SEGDIR_DELETE_STMT</a>,
<a name="l01789"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3756eca57cdc28e500ada182a256ac41">01789</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3756eca57cdc28e500ada182a256ac41">SEGDIR_SELECT_SEGMENT_STMT</a>,
<a name="l01790"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a81b342bd8dbd7d6ef31c6e8357c12b89">01790</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a81b342bd8dbd7d6ef31c6e8357c12b89">SEGDIR_SELECT_ALL_STMT</a>,
<a name="l01791"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a03eb0e5ed1f84367d55273421d7a3848">01791</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a03eb0e5ed1f84367d55273421d7a3848">SEGDIR_DELETE_ALL_STMT</a>,
<a name="l01792"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3c3f6d06e7ea78978e303b43e50ae31f">01792</a>   <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3c3f6d06e7ea78978e303b43e50ae31f">SEGDIR_COUNT_STMT</a>,
<a name="l01793"></a>01793 
<a name="l01794"></a><a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">01794</a>   <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a>                     <span class="comment">/* Always at end! */</span>
<a name="l01795"></a>01795 } <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">fulltext_statement</a>;
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 <span class="comment">/* These must exactly match the enum above. */</span>
<a name="l01798"></a>01798 <span class="comment">/* TODO(shess): Is there some risk that a statement will be used in two</span>
<a name="l01799"></a>01799 <span class="comment">** cursors at once, e.g.  if a query joins a virtual table to itself?</span>
<a name="l01800"></a>01800 <span class="comment">** If so perhaps we should move some of these to the cursor object.</span>
<a name="l01801"></a>01801 <span class="comment">*/</span>
<a name="l01802"></a><a class="code" href="fts2_8c.html#aa858a7ad9f41049729d556509e08aaf0">01802</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> <a class="code" href="fts2_8c.html#aa858a7ad9f41049729d556509e08aaf0">fulltext_zStatement</a>[<a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a>] = {
<a name="l01803"></a>01803   <span class="comment">/* CONTENT_INSERT */</span> NULL,  <span class="comment">/* generated in contentInsertStatement() */</span>
<a name="l01804"></a>01804   <span class="comment">/* CONTENT_SELECT */</span> <span class="stringliteral">&quot;select * from %_content where rowid = ?&quot;</span>,
<a name="l01805"></a>01805   <span class="comment">/* CONTENT_UPDATE */</span> NULL,  <span class="comment">/* generated in contentUpdateStatement() */</span>
<a name="l01806"></a>01806   <span class="comment">/* CONTENT_DELETE */</span> <span class="stringliteral">&quot;delete from %_content where rowid = ?&quot;</span>,
<a name="l01807"></a>01807   <span class="comment">/* CONTENT_EXISTS */</span> <span class="stringliteral">&quot;select rowid from %_content limit 1&quot;</span>,
<a name="l01808"></a>01808 
<a name="l01809"></a>01809   <span class="comment">/* BLOCK_INSERT */</span> <span class="stringliteral">&quot;insert into %_segments values (?)&quot;</span>,
<a name="l01810"></a>01810   <span class="comment">/* BLOCK_SELECT */</span> <span class="stringliteral">&quot;select block from %_segments where rowid = ?&quot;</span>,
<a name="l01811"></a>01811   <span class="comment">/* BLOCK_DELETE */</span> <span class="stringliteral">&quot;delete from %_segments where rowid between ? and ?&quot;</span>,
<a name="l01812"></a>01812   <span class="comment">/* BLOCK_DELETE_ALL */</span> <span class="stringliteral">&quot;delete from %_segments&quot;</span>,
<a name="l01813"></a>01813 
<a name="l01814"></a>01814   <span class="comment">/* SEGDIR_MAX_INDEX */</span> <span class="stringliteral">&quot;select max(idx) from %_segdir where level = ?&quot;</span>,
<a name="l01815"></a>01815   <span class="comment">/* SEGDIR_SET */</span> <span class="stringliteral">&quot;insert into %_segdir values (?, ?, ?, ?, ?, ?)&quot;</span>,
<a name="l01816"></a>01816   <span class="comment">/* SEGDIR_SELECT_LEVEL */</span>
<a name="l01817"></a>01817   <span class="stringliteral">&quot;select start_block, leaves_end_block, root from %_segdir &quot;</span>
<a name="l01818"></a>01818   <span class="stringliteral">&quot; where level = ? order by idx&quot;</span>,
<a name="l01819"></a>01819   <span class="comment">/* SEGDIR_SPAN */</span>
<a name="l01820"></a>01820   <span class="stringliteral">&quot;select min(start_block), max(end_block) from %_segdir &quot;</span>
<a name="l01821"></a>01821   <span class="stringliteral">&quot; where level = ? and start_block &lt;&gt; 0&quot;</span>,
<a name="l01822"></a>01822   <span class="comment">/* SEGDIR_DELETE */</span> <span class="stringliteral">&quot;delete from %_segdir where level = ?&quot;</span>,
<a name="l01823"></a>01823 
<a name="l01824"></a>01824   <span class="comment">/* NOTE(shess): The first three results of the following two</span>
<a name="l01825"></a>01825 <span class="comment">  ** statements must match.</span>
<a name="l01826"></a>01826 <span class="comment">  */</span>
<a name="l01827"></a>01827   <span class="comment">/* SEGDIR_SELECT_SEGMENT */</span>
<a name="l01828"></a>01828   <span class="stringliteral">&quot;select start_block, leaves_end_block, root from %_segdir &quot;</span>
<a name="l01829"></a>01829   <span class="stringliteral">&quot; where level = ? and idx = ?&quot;</span>,
<a name="l01830"></a>01830   <span class="comment">/* SEGDIR_SELECT_ALL */</span>
<a name="l01831"></a>01831   <span class="stringliteral">&quot;select start_block, leaves_end_block, root from %_segdir &quot;</span>
<a name="l01832"></a>01832   <span class="stringliteral">&quot; order by level desc, idx asc&quot;</span>,
<a name="l01833"></a>01833   <span class="comment">/* SEGDIR_DELETE_ALL */</span> <span class="stringliteral">&quot;delete from %_segdir&quot;</span>,
<a name="l01834"></a>01834   <span class="comment">/* SEGDIR_COUNT */</span> <span class="stringliteral">&quot;select count(*), ifnull(max(level),0) from %_segdir&quot;</span>,
<a name="l01835"></a>01835 };
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 <span class="comment">/*</span>
<a name="l01838"></a>01838 <span class="comment">** A connection to a fulltext index is an instance of the following</span>
<a name="l01839"></a>01839 <span class="comment">** structure.  The xCreate and xConnect methods create an instance</span>
<a name="l01840"></a>01840 <span class="comment">** of this structure and xDestroy and xDisconnect free that instance.</span>
<a name="l01841"></a>01841 <span class="comment">** All other methods receive a pointer to the structure as one of their</span>
<a name="l01842"></a>01842 <span class="comment">** arguments.</span>
<a name="l01843"></a>01843 <span class="comment">*/</span>
<a name="l01844"></a>01844 <span class="keyword">struct </span><a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> {
<a name="l01845"></a>01845   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> <a class="code" href="structfulltext__vtab.html#a8e711ebd8423f2581ac15dd3a25f4353">base</a>;               <span class="comment">/* Base class used by SQLite core */</span>
<a name="l01846"></a>01846   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>;                     <span class="comment">/* The database connection */</span>
<a name="l01847"></a>01847   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>;                 <span class="comment">/* logical database name */</span>
<a name="l01848"></a>01848   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>;               <span class="comment">/* virtual table name */</span>
<a name="l01849"></a>01849   <span class="keywordtype">int</span> <a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>;                     <span class="comment">/* number of columns in virtual table */</span>
<a name="l01850"></a>01850   <span class="keywordtype">char</span> **<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>;                 <span class="comment">/* column names.  malloced */</span>
<a name="l01851"></a>01851   <span class="keywordtype">char</span> **<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>;          <span class="comment">/* column names in content table; malloced */</span>
<a name="l01852"></a>01852   <a class="code" href="structsqlite3__tokenizer.html">sqlite3_tokenizer</a> *<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>;   <span class="comment">/* tokenizer for inserts and queries */</span>
<a name="l01853"></a>01853 
<a name="l01854"></a>01854   <span class="comment">/* Precompiled statements which we keep as long as the table is</span>
<a name="l01855"></a>01855 <span class="comment">  ** open.</span>
<a name="l01856"></a>01856 <span class="comment">  */</span>
<a name="l01857"></a>01857   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[<a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a>];
<a name="l01858"></a>01858 
<a name="l01859"></a>01859   <span class="comment">/* Precompiled statements used for segment merges.  We run a</span>
<a name="l01860"></a>01860 <span class="comment">  ** separate select across the leaf level of each tree being merged.</span>
<a name="l01861"></a>01861 <span class="comment">  */</span>
<a name="l01862"></a><a class="code" href="structfulltext__vtab.html#aeca83e8a610e7001293dea1eac91d83d">01862</a>   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *<a class="code" href="structfulltext__vtab.html#aeca83e8a610e7001293dea1eac91d83d">pLeafSelectStmts</a>[<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>];
<a name="l01863"></a>01863   <span class="comment">/* The statement used to prepare pLeafSelectStmts. */</span>
<a name="l01864"></a><a class="code" href="fts2_8c.html#ace45db2002affdd533cf8cf7d0657a63">01864</a> <span class="preprocessor">#define LEAF_SELECT \</span>
<a name="l01865"></a>01865 <span class="preprocessor">  &quot;select block from %_segments where rowid between ? and ? order by rowid&quot;</span>
<a name="l01866"></a>01866 <span class="preprocessor"></span>
<a name="l01867"></a>01867   <span class="comment">/* These buffer pending index updates during transactions.</span>
<a name="l01868"></a>01868 <span class="comment">  ** nPendingData estimates the memory size of the pending data.  It</span>
<a name="l01869"></a>01869 <span class="comment">  ** doesn&apos;t include the hash-bucket overhead, nor any malloc</span>
<a name="l01870"></a>01870 <span class="comment">  ** overhead.  When nPendingData exceeds kPendingThreshold, the</span>
<a name="l01871"></a>01871 <span class="comment">  ** buffer is flushed even before the transaction closes.</span>
<a name="l01872"></a>01872 <span class="comment">  ** pendingTerms stores the data, and is only valid when nPendingData</span>
<a name="l01873"></a>01873 <span class="comment">  ** is &gt;=0 (nPendingData&lt;0 means pendingTerms has not been</span>
<a name="l01874"></a>01874 <span class="comment">  ** initialized).  iPrevDocid is the last docid written, used to make</span>
<a name="l01875"></a>01875 <span class="comment">  ** certain we&apos;re inserting in sorted order.</span>
<a name="l01876"></a>01876 <span class="comment">  */</span>
<a name="l01877"></a><a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">01877</a>   <span class="keywordtype">int</span> <a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>;
<a name="l01878"></a><a class="code" href="fts2_8c.html#a27c3c050492b57112b6f6d4dd7bf1120">01878</a> <span class="preprocessor">#define kPendingThreshold (1*1024*1024)</span>
<a name="l01879"></a><a class="code" href="structfulltext__vtab.html#ac2af915a8f5f2957c8f73e4419d0bbee">01879</a> <span class="preprocessor"></span>  <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iPrevDocid;
<a name="l01880"></a><a class="code" href="structfulltext__vtab.html#af7cc40710088b48f62de7c47e5e822c2">01880</a>   <a class="code" href="structfts2Hash.html">fts2Hash</a> <a class="code" href="structfulltext__vtab.html#af7cc40710088b48f62de7c47e5e822c2">pendingTerms</a>;
<a name="l01881"></a>01881 };
<a name="l01882"></a>01882 
<a name="l01883"></a>01883 <span class="comment">/*</span>
<a name="l01884"></a>01884 <span class="comment">** When the core wants to do a query, it create a cursor using a</span>
<a name="l01885"></a>01885 <span class="comment">** call to xOpen.  This structure is an instance of a cursor.  It</span>
<a name="l01886"></a>01886 <span class="comment">** is destroyed by xClose.</span>
<a name="l01887"></a>01887 <span class="comment">*/</span>
<a name="l01888"></a>01888 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> {
<a name="l01889"></a>01889   <a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> <a class="code" href="structfulltext__cursor.html#a81a33bdfcda3fbe7a0170224d8442a5c">base</a>;        <span class="comment">/* Base class used by SQLite core */</span>
<a name="l01890"></a>01890   <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ec">QueryType</a> <a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a>;           <span class="comment">/* Copy of sqlite3_index_info.idxNum */</span>
<a name="l01891"></a>01891   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>;             <span class="comment">/* Prepared statement in use by the cursor */</span>
<a name="l01892"></a>01892   <span class="keywordtype">int</span> <a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a>;                         <span class="comment">/* True if at End Of Results */</span>
<a name="l01893"></a>01893   <a class="code" href="structQuery.html">Query</a> <a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>;                         <span class="comment">/* Parsed query string */</span>
<a name="l01894"></a>01894   <a class="code" href="structSnippet.html">Snippet</a> <a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>;                 <span class="comment">/* Cached snippet for the current row */</span>
<a name="l01895"></a>01895   <span class="keywordtype">int</span> <a class="code" href="structfulltext__cursor.html#a1f988ebd94b599b84d18e224f90f110d">iColumn</a>;                     <span class="comment">/* Column being searched */</span>
<a name="l01896"></a><a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">01896</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>;               <span class="comment">/* Doclist results from fulltextQuery */</span>
<a name="l01897"></a><a class="code" href="structfulltext__cursor.html#ad364061ebd037f7228b3599ead044d15">01897</a>   <a class="code" href="structDLReader.html">DLReader</a> <a class="code" href="structfulltext__cursor.html#ad364061ebd037f7228b3599ead044d15">reader</a>;                 <span class="comment">/* Result reader if result not empty */</span>
<a name="l01898"></a>01898 } <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a>;
<a name="l01899"></a>01899 
<a name="l01900"></a><a class="code" href="fts2_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">01900</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *<a class="code" href="fts2_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">cursor_vtab</a>(<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c){
<a name="l01901"></a>01901   <span class="keywordflow">return</span> (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *) c-&gt;<a class="code" href="structfulltext__cursor.html#a81a33bdfcda3fbe7a0170224d8442a5c">base</a>.<a class="code" href="structsqlite3__vtab__cursor.html#a2989d9f84a35506c3ef9fe9e9ecd3365">pVtab</a>;
<a name="l01902"></a>01902 }
<a name="l01903"></a>01903 
<a name="l01904"></a><a class="code" href="fts2_8c.html#a5531c28f6a29f1cf2001d055e9d05feb">01904</a> <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> <a class="code" href="fts2_8c.html#a5531c28f6a29f1cf2001d055e9d05feb">fts2Module</a>;   <span class="comment">/* forward declaration */</span>
<a name="l01905"></a>01905 
<a name="l01906"></a>01906 <span class="comment">/* Return a dynamically generated statement of the form</span>
<a name="l01907"></a>01907 <span class="comment"> *   insert into %_content (rowid, ...) values (?, ...)</span>
<a name="l01908"></a>01908 <span class="comment"> */</span>
<a name="l01909"></a><a class="code" href="fts2_8c.html#a64d2e6d573a9a737fcf9fd5578d8b400">01909</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a64d2e6d573a9a737fcf9fd5578d8b400">contentInsertStatement</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l01910"></a>01910   <a class="code" href="structStringBuffer.html">StringBuffer</a> sb;
<a name="l01911"></a>01911   <span class="keywordtype">int</span> i;
<a name="l01912"></a>01912 
<a name="l01913"></a>01913   <a class="code" href="fts2_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;sb);
<a name="l01914"></a>01914   <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;insert into %_content (rowid, &quot;</span>);
<a name="l01915"></a>01915   <a class="code" href="fts2_8c.html#a25815e8e930bcd9e3eabfe5ee1c9412f">appendList</a>(&amp;sb, v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>);
<a name="l01916"></a>01916   <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;) values (?&quot;</span>);
<a name="l01917"></a>01917   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i)
<a name="l01918"></a>01918     <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;, ?&quot;</span>);
<a name="l01919"></a>01919   <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;)&quot;</span>);
<a name="l01920"></a>01920   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#ab18184660d40766ca94505dbf1acaf5f">stringBufferData</a>(&amp;sb);
<a name="l01921"></a>01921 }
<a name="l01922"></a>01922 
<a name="l01923"></a>01923 <span class="comment">/* Return a dynamically generated statement of the form</span>
<a name="l01924"></a>01924 <span class="comment"> *   update %_content set [col_0] = ?, [col_1] = ?, ...</span>
<a name="l01925"></a>01925 <span class="comment"> *                    where rowid = ?</span>
<a name="l01926"></a>01926 <span class="comment"> */</span>
<a name="l01927"></a><a class="code" href="fts2_8c.html#af131b6e23b7bd297c4c502da7fd88c97">01927</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#af131b6e23b7bd297c4c502da7fd88c97">contentUpdateStatement</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l01928"></a>01928   <a class="code" href="structStringBuffer.html">StringBuffer</a> sb;
<a name="l01929"></a>01929   <span class="keywordtype">int</span> i;
<a name="l01930"></a>01930 
<a name="l01931"></a>01931   <a class="code" href="fts2_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;sb);
<a name="l01932"></a>01932   <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;update %_content set &quot;</span>);
<a name="l01933"></a>01933   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i) {
<a name="l01934"></a>01934     <span class="keywordflow">if</span>( i&gt;0 ){
<a name="l01935"></a>01935       <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l01936"></a>01936     }
<a name="l01937"></a>01937     <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>[i]);
<a name="l01938"></a>01938     <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot; = ?&quot;</span>);
<a name="l01939"></a>01939   }
<a name="l01940"></a>01940   <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, <span class="stringliteral">&quot; where rowid = ?&quot;</span>);
<a name="l01941"></a>01941   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#ab18184660d40766ca94505dbf1acaf5f">stringBufferData</a>(&amp;sb);
<a name="l01942"></a>01942 }
<a name="l01943"></a>01943 
<a name="l01944"></a>01944 <span class="comment">/* Puts a freshly-prepared statement determined by iStmt in *ppStmt.</span>
<a name="l01945"></a>01945 <span class="comment">** If the indicated statement has never been prepared, it is prepared</span>
<a name="l01946"></a>01946 <span class="comment">** and cached, otherwise the cached version is reset.</span>
<a name="l01947"></a>01947 <span class="comment">*/</span>
<a name="l01948"></a><a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">01948</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789">fulltext_statement</a> iStmt,
<a name="l01949"></a>01949                              <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> **ppStmt){
<a name="l01950"></a>01950   assert( iStmt&lt;<a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a> );
<a name="l01951"></a>01951   <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt]==NULL ){
<a name="l01952"></a>01952     <span class="keyword">const</span> <span class="keywordtype">char</span> *zStmt;
<a name="l01953"></a>01953     <span class="keywordtype">int</span> rc;
<a name="l01954"></a>01954     <span class="keywordflow">switch</span>( iStmt ){
<a name="l01955"></a>01955       <span class="keywordflow">case</span> <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ae800de40a0ad0185ff0335c967411a84">CONTENT_INSERT_STMT</a>:
<a name="l01956"></a>01956         zStmt = <a class="code" href="fts2_8c.html#a64d2e6d573a9a737fcf9fd5578d8b400">contentInsertStatement</a>(v); <span class="keywordflow">break</span>;
<a name="l01957"></a>01957       <span class="keywordflow">case</span> <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a016651ce129880970fb699b09f85576c">CONTENT_UPDATE_STMT</a>:
<a name="l01958"></a>01958         zStmt = <a class="code" href="fts2_8c.html#af131b6e23b7bd297c4c502da7fd88c97">contentUpdateStatement</a>(v); <span class="keywordflow">break</span>;
<a name="l01959"></a>01959       <span class="keywordflow">default</span>:
<a name="l01960"></a>01960         zStmt = fulltext_zStatement[iStmt];
<a name="l01961"></a>01961     }
<a name="l01962"></a>01962     rc = <a class="code" href="fts2_8c.html#a90c49c1625eff6f726a4ce28200e24d4">sql_prepare</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt],
<a name="l01963"></a>01963                          zStmt);
<a name="l01964"></a>01964     <span class="keywordflow">if</span>( zStmt != fulltext_zStatement[iStmt]) <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>((<span class="keywordtype">void</span> *) zStmt);
<a name="l01965"></a>01965     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01966"></a>01966   } <span class="keywordflow">else</span> {
<a name="l01967"></a>01967     <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt]);
<a name="l01968"></a>01968     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01969"></a>01969   }
<a name="l01970"></a>01970 
<a name="l01971"></a>01971   *ppStmt = v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt];
<a name="l01972"></a>01972   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01973"></a>01973 }
<a name="l01974"></a>01974 
<a name="l01975"></a>01975 <span class="comment">/* Like sqlite3_step(), but convert SQLITE_DONE to SQLITE_OK and</span>
<a name="l01976"></a>01976 <span class="comment">** SQLITE_ROW to SQLITE_ERROR.  Useful for statements like UPDATE,</span>
<a name="l01977"></a>01977 <span class="comment">** where we expect no results.</span>
<a name="l01978"></a>01978 <span class="comment">*/</span>
<a name="l01979"></a><a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">01979</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">sql_single_step</a>(<a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s){
<a name="l01980"></a>01980   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l01981"></a>01981   <span class="keywordflow">return</span> (rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>) ? <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> : rc;
<a name="l01982"></a>01982 }
<a name="l01983"></a>01983 
<a name="l01984"></a>01984 <span class="comment">/* Like sql_get_statement(), but for special replicated LEAF_SELECT</span>
<a name="l01985"></a>01985 <span class="comment">** statements.  idx -1 is a special case for an uncached version of</span>
<a name="l01986"></a>01986 <span class="comment">** the statement (used in the optimize implementation).</span>
<a name="l01987"></a>01987 <span class="comment">*/</span>
<a name="l01988"></a>01988 <span class="comment">/* TODO(shess) Write version for generic statements and then share</span>
<a name="l01989"></a>01989 <span class="comment">** that between the cached-statement functions.</span>
<a name="l01990"></a>01990 <span class="comment">*/</span>
<a name="l01991"></a><a class="code" href="fts2_8c.html#af6f50d47986ffc800da3bf8c6176615f">01991</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#af6f50d47986ffc800da3bf8c6176615f">sql_get_leaf_statement</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> idx,
<a name="l01992"></a>01992                                   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> **ppStmt){
<a name="l01993"></a>01993   assert( idx&gt;=-1 &amp;&amp; idx&lt;<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a> );
<a name="l01994"></a>01994   <span class="keywordflow">if</span>( idx==-1 ){
<a name="l01995"></a>01995     <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a90c49c1625eff6f726a4ce28200e24d4">sql_prepare</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, ppStmt, <a class="code" href="fts2_8c.html#ace45db2002affdd533cf8cf7d0657a63">LEAF_SELECT</a>);
<a name="l01996"></a>01996   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#aeca83e8a610e7001293dea1eac91d83d">pLeafSelectStmts</a>[idx]==NULL ){
<a name="l01997"></a>01997     <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a90c49c1625eff6f726a4ce28200e24d4">sql_prepare</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#aeca83e8a610e7001293dea1eac91d83d">pLeafSelectStmts</a>[idx],
<a name="l01998"></a>01998                          <a class="code" href="fts2_8c.html#ace45db2002affdd533cf8cf7d0657a63">LEAF_SELECT</a>);
<a name="l01999"></a>01999     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02000"></a>02000   }<span class="keywordflow">else</span>{
<a name="l02001"></a>02001     <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#aeca83e8a610e7001293dea1eac91d83d">pLeafSelectStmts</a>[idx]);
<a name="l02002"></a>02002     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02003"></a>02003   }
<a name="l02004"></a>02004 
<a name="l02005"></a>02005   *ppStmt = v-&gt;<a class="code" href="structfulltext__vtab.html#aeca83e8a610e7001293dea1eac91d83d">pLeafSelectStmts</a>[idx];
<a name="l02006"></a>02006   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02007"></a>02007 }
<a name="l02008"></a>02008 
<a name="l02009"></a>02009 <span class="comment">/* insert into %_content (rowid, ...) values ([rowid], [pValues]) */</span>
<a name="l02010"></a><a class="code" href="fts2_8c.html#a97f61f9291ab35fbfe2c39993ec56796">02010</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a97f61f9291ab35fbfe2c39993ec56796">content_insert</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structMem.html">sqlite3_value</a> *rowid,
<a name="l02011"></a>02011                           <a class="code" href="structMem.html">sqlite3_value</a> **pValues){
<a name="l02012"></a>02012   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02013"></a>02013   <span class="keywordtype">int</span> i;
<a name="l02014"></a>02014   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ae800de40a0ad0185ff0335c967411a84">CONTENT_INSERT_STMT</a>, &amp;s);
<a name="l02015"></a>02015   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02016"></a>02016 
<a name="l02017"></a>02017   rc = <a class="code" href="sqlite3_8h.html#ae2de595a4a816aa57435c9247839d86a">sqlite3_bind_value</a>(s, 1, rowid);
<a name="l02018"></a>02018   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02019"></a>02019 
<a name="l02020"></a>02020   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i){
<a name="l02021"></a>02021     rc = <a class="code" href="sqlite3_8h.html#ae2de595a4a816aa57435c9247839d86a">sqlite3_bind_value</a>(s, 2+i, pValues[i]);
<a name="l02022"></a>02022     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02023"></a>02023   }
<a name="l02024"></a>02024 
<a name="l02025"></a>02025   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">sql_single_step</a>(s);
<a name="l02026"></a>02026 }
<a name="l02027"></a>02027 
<a name="l02028"></a>02028 <span class="comment">/* update %_content set col0 = pValues[0], col1 = pValues[1], ...</span>
<a name="l02029"></a>02029 <span class="comment"> *                  where rowid = [iRowid] */</span>
<a name="l02030"></a><a class="code" href="fts2_8c.html#aff98794eedf8ff43e623a00e0634c566">02030</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aff98794eedf8ff43e623a00e0634c566">content_update</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structMem.html">sqlite3_value</a> **pValues,
<a name="l02031"></a>02031                           <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRowid){
<a name="l02032"></a>02032   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02033"></a>02033   <span class="keywordtype">int</span> i;
<a name="l02034"></a>02034   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a016651ce129880970fb699b09f85576c">CONTENT_UPDATE_STMT</a>, &amp;s);
<a name="l02035"></a>02035   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02036"></a>02036 
<a name="l02037"></a>02037   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i){
<a name="l02038"></a>02038     rc = <a class="code" href="sqlite3_8h.html#ae2de595a4a816aa57435c9247839d86a">sqlite3_bind_value</a>(s, 1+i, pValues[i]);
<a name="l02039"></a>02039     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02040"></a>02040   }
<a name="l02041"></a>02041 
<a name="l02042"></a>02042   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1+v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, iRowid);
<a name="l02043"></a>02043   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02044"></a>02044 
<a name="l02045"></a>02045   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">sql_single_step</a>(s);
<a name="l02046"></a>02046 }
<a name="l02047"></a>02047 
<a name="l02048"></a><a class="code" href="fts2_8c.html#a217321df065d27f4580f1affa711f23b">02048</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a217321df065d27f4580f1affa711f23b">freeStringArray</a>(<span class="keywordtype">int</span> nString, <span class="keyword">const</span> <span class="keywordtype">char</span> **pString){
<a name="l02049"></a>02049   <span class="keywordtype">int</span> i;
<a name="l02050"></a>02050 
<a name="l02051"></a>02051   <span class="keywordflow">for</span> (i=0 ; i &lt; nString ; ++i) {
<a name="l02052"></a>02052     <span class="keywordflow">if</span>( pString[i]!=NULL ) <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>((<span class="keywordtype">void</span> *) pString[i]);
<a name="l02053"></a>02053   }
<a name="l02054"></a>02054   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>((<span class="keywordtype">void</span> *) pString);
<a name="l02055"></a>02055 }
<a name="l02056"></a>02056 
<a name="l02057"></a>02057 <span class="comment">/* select * from %_content where rowid = [iRow]</span>
<a name="l02058"></a>02058 <span class="comment"> * The caller must delete the returned array and all strings in it.</span>
<a name="l02059"></a>02059 <span class="comment"> * null fields will be NULL in the returned array.</span>
<a name="l02060"></a>02060 <span class="comment"> *</span>
<a name="l02061"></a>02061 <span class="comment"> * TODO: Perhaps we should return pointer/length strings here for consistency</span>
<a name="l02062"></a>02062 <span class="comment"> * with other code which uses pointer/length. */</span>
<a name="l02063"></a><a class="code" href="fts2_8c.html#a45b9abe0a1f6a081cab0c2eeda68794d">02063</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a45b9abe0a1f6a081cab0c2eeda68794d">content_select</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRow,
<a name="l02064"></a>02064                           <span class="keyword">const</span> <span class="keywordtype">char</span> ***pValues){
<a name="l02065"></a>02065   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02066"></a>02066   <span class="keyword">const</span> <span class="keywordtype">char</span> **values;
<a name="l02067"></a>02067   <span class="keywordtype">int</span> i;
<a name="l02068"></a>02068   <span class="keywordtype">int</span> rc;
<a name="l02069"></a>02069 
<a name="l02070"></a>02070   *pValues = NULL;
<a name="l02071"></a>02071 
<a name="l02072"></a>02072   rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abfdc634e15bbc89a90bdaf76034fe478">CONTENT_SELECT_STMT</a>, &amp;s);
<a name="l02073"></a>02073   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02074"></a>02074 
<a name="l02075"></a>02075   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, iRow);
<a name="l02076"></a>02076   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02077"></a>02077 
<a name="l02078"></a>02078   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02079"></a>02079   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> rc;
<a name="l02080"></a>02080 
<a name="l02081"></a>02081   values = (<span class="keyword">const</span> <span class="keywordtype">char</span> **) <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a> * <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *));
<a name="l02082"></a>02082   <span class="keywordflow">for</span>(i=0; i&lt;v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i){
<a name="l02083"></a>02083     <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a7e076f91f53b4936cd6f2ce4b078bcc1">sqlite3_column_type</a>(s, i)==<a class="code" href="sqlite3_8h.html#afd180931f2d06d6c245791d187da5802">SQLITE_NULL</a> ){
<a name="l02084"></a>02084       values[i] = NULL;
<a name="l02085"></a>02085     }<span class="keywordflow">else</span>{
<a name="l02086"></a>02086       values[i] = <a class="code" href="fts2_8c.html#a7a1ca6e7e7b15d27e59df8a9da195d77">string_dup</a>((<span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#adebe4cf494727dd2e9c0d22c2a629d2f">sqlite3_column_text</a>(s, i));
<a name="l02087"></a>02087     }
<a name="l02088"></a>02088   }
<a name="l02089"></a>02089 
<a name="l02090"></a>02090   <span class="comment">/* We expect only one row.  We must execute another sqlite3_step()</span>
<a name="l02091"></a>02091 <span class="comment">   * to complete the iteration; otherwise the table will remain locked. */</span>
<a name="l02092"></a>02092   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02093"></a>02093   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l02094"></a>02094     *pValues = values;
<a name="l02095"></a>02095     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02096"></a>02096   }
<a name="l02097"></a>02097 
<a name="l02098"></a>02098   <a class="code" href="fts2_8c.html#a217321df065d27f4580f1affa711f23b">freeStringArray</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, values);
<a name="l02099"></a>02099   <span class="keywordflow">return</span> rc;
<a name="l02100"></a>02100 }
<a name="l02101"></a>02101 
<a name="l02102"></a>02102 <span class="comment">/* delete from %_content where rowid = [iRow ] */</span>
<a name="l02103"></a><a class="code" href="fts2_8c.html#a8d2f433ca2290904b916ff1972b921c3">02103</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a8d2f433ca2290904b916ff1972b921c3">content_delete</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRow){
<a name="l02104"></a>02104   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02105"></a>02105   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789acdb161caf82c5437390779f9e886d62e">CONTENT_DELETE_STMT</a>, &amp;s);
<a name="l02106"></a>02106   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02107"></a>02107 
<a name="l02108"></a>02108   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, iRow);
<a name="l02109"></a>02109   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02110"></a>02110 
<a name="l02111"></a>02111   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">sql_single_step</a>(s);
<a name="l02112"></a>02112 }
<a name="l02113"></a>02113 
<a name="l02114"></a>02114 <span class="comment">/* Returns SQLITE_ROW if any rows exist in %_content, SQLITE_DONE if</span>
<a name="l02115"></a>02115 <span class="comment">** no rows exist, and any error in case of failure.</span>
<a name="l02116"></a>02116 <span class="comment">*/</span>
<a name="l02117"></a><a class="code" href="fts2_8c.html#a151618fa123f92b062b1a98a6ebeefac">02117</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a151618fa123f92b062b1a98a6ebeefac">content_exists</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l02118"></a>02118   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02119"></a>02119   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3ea2d2a142e2ef3cc5d19d2ca6129e56">CONTENT_EXISTS_STMT</a>, &amp;s);
<a name="l02120"></a>02120   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02121"></a>02121 
<a name="l02122"></a>02122   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02123"></a>02123   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> rc;
<a name="l02124"></a>02124 
<a name="l02125"></a>02125   <span class="comment">/* We expect only one row.  We must execute another sqlite3_step()</span>
<a name="l02126"></a>02126 <span class="comment">   * to complete the iteration; otherwise the table will remain locked. */</span>
<a name="l02127"></a>02127   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02128"></a>02128   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a>;
<a name="l02129"></a>02129   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02130"></a>02130   <span class="keywordflow">return</span> rc;
<a name="l02131"></a>02131 }
<a name="l02132"></a>02132 
<a name="l02133"></a>02133 <span class="comment">/* insert into %_segments values ([pData])</span>
<a name="l02134"></a>02134 <span class="comment">**   returns assigned rowid in *piBlockid</span>
<a name="l02135"></a>02135 <span class="comment">*/</span>
<a name="l02136"></a><a class="code" href="fts2_8c.html#abaeb71e066db78e51476730392b1f28c">02136</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#abaeb71e066db78e51476730392b1f28c">block_insert</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l02137"></a>02137                         <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piBlockid){
<a name="l02138"></a>02138   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02139"></a>02139   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a772711d87dc79880aa0dcdf16ceba405">BLOCK_INSERT_STMT</a>, &amp;s);
<a name="l02140"></a>02140   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02141"></a>02141 
<a name="l02142"></a>02142   rc = <a class="code" href="sqlite3_8h.html#a31729e3159ba77c17d7fb51a7f468e8e">sqlite3_bind_blob</a>(s, 1, pData, nData, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l02143"></a>02143   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02144"></a>02144 
<a name="l02145"></a>02145   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02146"></a>02146   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02147"></a>02147   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> rc;
<a name="l02148"></a>02148 
<a name="l02149"></a>02149   *piBlockid = <a class="code" href="main_8c.html#ac09d49376c77414ba143635184b7ee10">sqlite3_last_insert_rowid</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>);
<a name="l02150"></a>02150   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02151"></a>02151 }
<a name="l02152"></a>02152 
<a name="l02153"></a>02153 <span class="comment">/* delete from %_segments</span>
<a name="l02154"></a>02154 <span class="comment">**   where rowid between [iStartBlockid] and [iEndBlockid]</span>
<a name="l02155"></a>02155 <span class="comment">**</span>
<a name="l02156"></a>02156 <span class="comment">** Deletes the range of blocks, inclusive, used to delete the blocks</span>
<a name="l02157"></a>02157 <span class="comment">** which form a segment.</span>
<a name="l02158"></a>02158 <span class="comment">*/</span>
<a name="l02159"></a><a class="code" href="fts2_8c.html#a6d7c0edf48b4def30e64085789171ac6">02159</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a6d7c0edf48b4def30e64085789171ac6">block_delete</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,
<a name="l02160"></a>02160                         <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iStartBlockid, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iEndBlockid){
<a name="l02161"></a>02161   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02162"></a>02162   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3a372ccafc30b8cc56feb976bbe55e9c">BLOCK_DELETE_STMT</a>, &amp;s);
<a name="l02163"></a>02163   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02164"></a>02164 
<a name="l02165"></a>02165   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, iStartBlockid);
<a name="l02166"></a>02166   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02167"></a>02167 
<a name="l02168"></a>02168   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 2, iEndBlockid);
<a name="l02169"></a>02169   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02170"></a>02170 
<a name="l02171"></a>02171   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">sql_single_step</a>(s);
<a name="l02172"></a>02172 }
<a name="l02173"></a>02173 
<a name="l02174"></a>02174 <span class="comment">/* Returns SQLITE_ROW with *pidx set to the maximum segment idx found</span>
<a name="l02175"></a>02175 <span class="comment">** at iLevel.  Returns SQLITE_DONE if there are no segments at</span>
<a name="l02176"></a>02176 <span class="comment">** iLevel.  Otherwise returns an error.</span>
<a name="l02177"></a>02177 <span class="comment">*/</span>
<a name="l02178"></a><a class="code" href="fts2_8c.html#a6fb5e7757b149795cb2f3eb774368db2">02178</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a6fb5e7757b149795cb2f3eb774368db2">segdir_max_index</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iLevel, <span class="keywordtype">int</span> *pidx){
<a name="l02179"></a>02179   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02180"></a>02180   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a9e8b2c67f838ab2279a2417af4baed61">SEGDIR_MAX_INDEX_STMT</a>, &amp;s);
<a name="l02181"></a>02181   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02182"></a>02182 
<a name="l02183"></a>02183   rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 1, iLevel);
<a name="l02184"></a>02184   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02185"></a>02185 
<a name="l02186"></a>02186   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02187"></a>02187   <span class="comment">/* Should always get at least one row due to how max() works. */</span>
<a name="l02188"></a>02188   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>;
<a name="l02189"></a>02189   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> rc;
<a name="l02190"></a>02190 
<a name="l02191"></a>02191   <span class="comment">/* NULL means that there were no inputs to max(). */</span>
<a name="l02192"></a>02192   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#afd180931f2d06d6c245791d187da5802">SQLITE_NULL</a>==<a class="code" href="sqlite3_8h.html#a7e076f91f53b4936cd6f2ce4b078bcc1">sqlite3_column_type</a>(s, 0) ){
<a name="l02193"></a>02193     rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02194"></a>02194     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02195"></a>02195     <span class="keywordflow">return</span> rc;
<a name="l02196"></a>02196   }
<a name="l02197"></a>02197 
<a name="l02198"></a>02198   *pidx = <a class="code" href="sqlite3_8h.html#a2fb75f411c508be8480074c2b5528b5f">sqlite3_column_int</a>(s, 0);
<a name="l02199"></a>02199 
<a name="l02200"></a>02200   <span class="comment">/* We expect only one row.  We must execute another sqlite3_step()</span>
<a name="l02201"></a>02201 <span class="comment">   * to complete the iteration; otherwise the table will remain locked. */</span>
<a name="l02202"></a>02202   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02203"></a>02203   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02204"></a>02204   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> rc;
<a name="l02205"></a>02205   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a>;
<a name="l02206"></a>02206 }
<a name="l02207"></a>02207 
<a name="l02208"></a>02208 <span class="comment">/* insert into %_segdir values (</span>
<a name="l02209"></a>02209 <span class="comment">**   [iLevel], [idx],</span>
<a name="l02210"></a>02210 <span class="comment">**   [iStartBlockid], [iLeavesEndBlockid], [iEndBlockid],</span>
<a name="l02211"></a>02211 <span class="comment">**   [pRootData]</span>
<a name="l02212"></a>02212 <span class="comment">** )</span>
<a name="l02213"></a>02213 <span class="comment">*/</span>
<a name="l02214"></a><a class="code" href="fts2_8c.html#a1180b1a1722443432cf152bd68b38bbd">02214</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a1180b1a1722443432cf152bd68b38bbd">segdir_set</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iLevel, <span class="keywordtype">int</span> idx,
<a name="l02215"></a>02215                       <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iStartBlockid,
<a name="l02216"></a>02216                       <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iLeavesEndBlockid,
<a name="l02217"></a>02217                       <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iEndBlockid,
<a name="l02218"></a>02218                       <span class="keyword">const</span> <span class="keywordtype">char</span> *pRootData, <span class="keywordtype">int</span> nRootData){
<a name="l02219"></a>02219   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02220"></a>02220   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abeeeed0cd977354eaf567e05f153b890">SEGDIR_SET_STMT</a>, &amp;s);
<a name="l02221"></a>02221   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02222"></a>02222 
<a name="l02223"></a>02223   rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 1, iLevel);
<a name="l02224"></a>02224   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02225"></a>02225 
<a name="l02226"></a>02226   rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 2, idx);
<a name="l02227"></a>02227   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02228"></a>02228 
<a name="l02229"></a>02229   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 3, iStartBlockid);
<a name="l02230"></a>02230   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02231"></a>02231 
<a name="l02232"></a>02232   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 4, iLeavesEndBlockid);
<a name="l02233"></a>02233   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02234"></a>02234 
<a name="l02235"></a>02235   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 5, iEndBlockid);
<a name="l02236"></a>02236   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02237"></a>02237 
<a name="l02238"></a>02238   rc = <a class="code" href="sqlite3_8h.html#a31729e3159ba77c17d7fb51a7f468e8e">sqlite3_bind_blob</a>(s, 6, pRootData, nRootData, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l02239"></a>02239   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02240"></a>02240 
<a name="l02241"></a>02241   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">sql_single_step</a>(s);
<a name="l02242"></a>02242 }
<a name="l02243"></a>02243 
<a name="l02244"></a>02244 <span class="comment">/* Queries %_segdir for the block span of the segments in level</span>
<a name="l02245"></a>02245 <span class="comment">** iLevel.  Returns SQLITE_DONE if there are no blocks for iLevel,</span>
<a name="l02246"></a>02246 <span class="comment">** SQLITE_ROW if there are blocks, else an error.</span>
<a name="l02247"></a>02247 <span class="comment">*/</span>
<a name="l02248"></a><a class="code" href="fts2_8c.html#a39937982fef952aa4f18f4b0eda9b54a">02248</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a39937982fef952aa4f18f4b0eda9b54a">segdir_span</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iLevel,
<a name="l02249"></a>02249                        <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piStartBlockid,
<a name="l02250"></a>02250                        <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piEndBlockid){
<a name="l02251"></a>02251   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02252"></a>02252   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a78c1f6dbdc2c212ec09aaa1e05a8388c">SEGDIR_SPAN_STMT</a>, &amp;s);
<a name="l02253"></a>02253   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02254"></a>02254 
<a name="l02255"></a>02255   rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 1, iLevel);
<a name="l02256"></a>02256   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02257"></a>02257 
<a name="l02258"></a>02258   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02259"></a>02259   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>;  <span class="comment">/* Should never happen */</span>
<a name="l02260"></a>02260   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> rc;
<a name="l02261"></a>02261 
<a name="l02262"></a>02262   <span class="comment">/* This happens if all segments at this level are entirely inline. */</span>
<a name="l02263"></a>02263   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#afd180931f2d06d6c245791d187da5802">SQLITE_NULL</a>==<a class="code" href="sqlite3_8h.html#a7e076f91f53b4936cd6f2ce4b078bcc1">sqlite3_column_type</a>(s, 0) ){
<a name="l02264"></a>02264     <span class="comment">/* We expect only one row.  We must execute another sqlite3_step()</span>
<a name="l02265"></a>02265 <span class="comment">     * to complete the iteration; otherwise the table will remain locked. */</span>
<a name="l02266"></a>02266     <span class="keywordtype">int</span> rc2 = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02267"></a>02267     <span class="keywordflow">if</span>( rc2==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02268"></a>02268     <span class="keywordflow">return</span> rc2;
<a name="l02269"></a>02269   }
<a name="l02270"></a>02270 
<a name="l02271"></a>02271   *piStartBlockid = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 0);
<a name="l02272"></a>02272   *piEndBlockid = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 1);
<a name="l02273"></a>02273 
<a name="l02274"></a>02274   <span class="comment">/* We expect only one row.  We must execute another sqlite3_step()</span>
<a name="l02275"></a>02275 <span class="comment">   * to complete the iteration; otherwise the table will remain locked. */</span>
<a name="l02276"></a>02276   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02277"></a>02277   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02278"></a>02278   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> rc;
<a name="l02279"></a>02279   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a>;
<a name="l02280"></a>02280 }
<a name="l02281"></a>02281 
<a name="l02282"></a>02282 <span class="comment">/* Delete the segment blocks and segment directory records for all</span>
<a name="l02283"></a>02283 <span class="comment">** segments at iLevel.</span>
<a name="l02284"></a>02284 <span class="comment">*/</span>
<a name="l02285"></a><a class="code" href="fts2_8c.html#a4f5564997dda64601c2138e86b85a96a">02285</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a4f5564997dda64601c2138e86b85a96a">segdir_delete</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iLevel){
<a name="l02286"></a>02286   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02287"></a>02287   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iStartBlockid, iEndBlockid;
<a name="l02288"></a>02288   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a39937982fef952aa4f18f4b0eda9b54a">segdir_span</a>(v, iLevel, &amp;iStartBlockid, &amp;iEndBlockid);
<a name="l02289"></a>02289   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> &amp;&amp; rc!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> rc;
<a name="l02290"></a>02290 
<a name="l02291"></a>02291   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l02292"></a>02292     rc = <a class="code" href="fts2_8c.html#a6d7c0edf48b4def30e64085789171ac6">block_delete</a>(v, iStartBlockid, iEndBlockid);
<a name="l02293"></a>02293     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02294"></a>02294   }
<a name="l02295"></a>02295 
<a name="l02296"></a>02296   <span class="comment">/* Delete the segment directory itself. */</span>
<a name="l02297"></a>02297   rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789ad0155bf348fa2cc6e28af7191914a4b4">SEGDIR_DELETE_STMT</a>, &amp;s);
<a name="l02298"></a>02298   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02299"></a>02299 
<a name="l02300"></a>02300   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, iLevel);
<a name="l02301"></a>02301   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02302"></a>02302 
<a name="l02303"></a>02303   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">sql_single_step</a>(s);
<a name="l02304"></a>02304 }
<a name="l02305"></a>02305 
<a name="l02306"></a>02306 <span class="comment">/* Delete entire fts index, SQLITE_OK on success, relevant error on</span>
<a name="l02307"></a>02307 <span class="comment">** failure.</span>
<a name="l02308"></a>02308 <span class="comment">*/</span>
<a name="l02309"></a><a class="code" href="fts2_8c.html#a96b31172512ccbfbdf69e7bd70419ae2">02309</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a96b31172512ccbfbdf69e7bd70419ae2">segdir_delete_all</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l02310"></a>02310   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02311"></a>02311   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a03eb0e5ed1f84367d55273421d7a3848">SEGDIR_DELETE_ALL_STMT</a>, &amp;s);
<a name="l02312"></a>02312   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02313"></a>02313 
<a name="l02314"></a>02314   rc = <a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">sql_single_step</a>(s);
<a name="l02315"></a>02315   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02316"></a>02316 
<a name="l02317"></a>02317   rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789abe51aa0578de628e38ca56cd272a7966">BLOCK_DELETE_ALL_STMT</a>, &amp;s);
<a name="l02318"></a>02318   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02319"></a>02319 
<a name="l02320"></a>02320   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a7614536bae53e788658d177bc677cc20">sql_single_step</a>(s);
<a name="l02321"></a>02321 }
<a name="l02322"></a>02322 
<a name="l02323"></a>02323 <span class="comment">/* Returns SQLITE_OK with *pnSegments set to the number of entries in</span>
<a name="l02324"></a>02324 <span class="comment">** %_segdir and *piMaxLevel set to the highest level which has a</span>
<a name="l02325"></a>02325 <span class="comment">** segment.  Otherwise returns the SQLite error which caused failure.</span>
<a name="l02326"></a>02326 <span class="comment">*/</span>
<a name="l02327"></a><a class="code" href="fts2_8c.html#a8952407493e082f2740936253854c9c9">02327</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a8952407493e082f2740936253854c9c9">segdir_count</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> *pnSegments, <span class="keywordtype">int</span> *piMaxLevel){
<a name="l02328"></a>02328   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l02329"></a>02329   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3c3f6d06e7ea78978e303b43e50ae31f">SEGDIR_COUNT_STMT</a>, &amp;s);
<a name="l02330"></a>02330   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02331"></a>02331 
<a name="l02332"></a>02332   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02333"></a>02333   <span class="comment">/* TODO(shess): This case should not be possible?  Should stronger</span>
<a name="l02334"></a>02334 <span class="comment">  ** measures be taken if it happens?</span>
<a name="l02335"></a>02335 <span class="comment">  */</span>
<a name="l02336"></a>02336   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l02337"></a>02337     *pnSegments = 0;
<a name="l02338"></a>02338     *piMaxLevel = 0;
<a name="l02339"></a>02339     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02340"></a>02340   }
<a name="l02341"></a>02341   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> rc;
<a name="l02342"></a>02342 
<a name="l02343"></a>02343   *pnSegments = <a class="code" href="sqlite3_8h.html#a2fb75f411c508be8480074c2b5528b5f">sqlite3_column_int</a>(s, 0);
<a name="l02344"></a>02344   *piMaxLevel = <a class="code" href="sqlite3_8h.html#a2fb75f411c508be8480074c2b5528b5f">sqlite3_column_int</a>(s, 1);
<a name="l02345"></a>02345 
<a name="l02346"></a>02346   <span class="comment">/* We expect only one row.  We must execute another sqlite3_step()</span>
<a name="l02347"></a>02347 <span class="comment">   * to complete the iteration; otherwise the table will remain locked. */</span>
<a name="l02348"></a>02348   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l02349"></a>02349   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02350"></a>02350   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02351"></a>02351   <span class="keywordflow">return</span> rc;
<a name="l02352"></a>02352 }
<a name="l02353"></a>02353 
<a name="l02354"></a>02354 <span class="comment">/* TODO(shess) clearPendingTerms() is far down the file because</span>
<a name="l02355"></a>02355 <span class="comment">** writeZeroSegment() is far down the file because LeafWriter is far</span>
<a name="l02356"></a>02356 <span class="comment">** down the file.  Consider refactoring the code to move the non-vtab</span>
<a name="l02357"></a>02357 <span class="comment">** code above the vtab code so that we don&apos;t need this forward</span>
<a name="l02358"></a>02358 <span class="comment">** reference.</span>
<a name="l02359"></a>02359 <span class="comment">*/</span>
<a name="l02360"></a>02360 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a6e35ee9ad89ff36849eee74a55a0cc65">clearPendingTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v);
<a name="l02361"></a>02361 
<a name="l02362"></a>02362 <span class="comment">/*</span>
<a name="l02363"></a>02363 <span class="comment">** Free the memory used to contain a fulltext_vtab structure.</span>
<a name="l02364"></a>02364 <span class="comment">*/</span>
<a name="l02365"></a><a class="code" href="fts2_8c.html#aec311e3893b552f3ae7b70311bb70280">02365</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aec311e3893b552f3ae7b70311bb70280">fulltext_vtab_destroy</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l02366"></a>02366   <span class="keywordtype">int</span> iStmt, i;
<a name="l02367"></a>02367 
<a name="l02368"></a>02368   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Destroy %p\n&quot;</span>, v));
<a name="l02369"></a>02369   <span class="keywordflow">for</span>( iStmt=0; iStmt&lt;<a class="code" href="fts1_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a1fb812abbfbee9be362d76e9faeb5cf8">MAX_STMT</a>; iStmt++ ){
<a name="l02370"></a>02370     <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt]!=NULL ){
<a name="l02371"></a>02371       <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt]);
<a name="l02372"></a>02372       v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>[iStmt] = NULL;
<a name="l02373"></a>02373     }
<a name="l02374"></a>02374   }
<a name="l02375"></a>02375 
<a name="l02376"></a>02376   <span class="keywordflow">for</span>( i=0; i&lt;<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>; i++ ){
<a name="l02377"></a>02377     <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#aeca83e8a610e7001293dea1eac91d83d">pLeafSelectStmts</a>[i]!=NULL ){
<a name="l02378"></a>02378       <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#aeca83e8a610e7001293dea1eac91d83d">pLeafSelectStmts</a>[i]);
<a name="l02379"></a>02379       v-&gt;<a class="code" href="structfulltext__vtab.html#aeca83e8a610e7001293dea1eac91d83d">pLeafSelectStmts</a>[i] = NULL;
<a name="l02380"></a>02380     }
<a name="l02381"></a>02381   }
<a name="l02382"></a>02382 
<a name="l02383"></a>02383   <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>!=NULL ){
<a name="l02384"></a>02384     v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#ab9b545740a7dbd6528ba294e6b456f7d">xDestroy</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>);
<a name="l02385"></a>02385     v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a> = NULL;
<a name="l02386"></a>02386   }
<a name="l02387"></a>02387 
<a name="l02388"></a>02388   <a class="code" href="fts2_8c.html#a6e35ee9ad89ff36849eee74a55a0cc65">clearPendingTerms</a>(v);
<a name="l02389"></a>02389 
<a name="l02390"></a>02390   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>);
<a name="l02391"></a>02391   <span class="keywordflow">for</span>(i = 0; i &lt; v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i) {
<a name="l02392"></a>02392     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>[i]);
<a name="l02393"></a>02393   }
<a name="l02394"></a>02394   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a>);
<a name="l02395"></a>02395   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(v);
<a name="l02396"></a>02396 }
<a name="l02397"></a>02397 
<a name="l02398"></a>02398 <span class="comment">/*</span>
<a name="l02399"></a>02399 <span class="comment">** Token types for parsing the arguments to xConnect or xCreate.</span>
<a name="l02400"></a>02400 <span class="comment">*/</span>
<a name="l02401"></a><a class="code" href="fts2_8c.html#af447f39a147c39c7304edbc1e2794405">02401</a> <span class="preprocessor">#define TOKEN_EOF         0    </span><span class="comment">/* End of file */</span>
<a name="l02402"></a><a class="code" href="fts2_8c.html#a353479c59d2069c4456ac5561d255a5d">02402</a> <span class="preprocessor">#define TOKEN_SPACE       1    </span><span class="comment">/* Any kind of whitespace */</span>
<a name="l02403"></a><a class="code" href="fts2_8c.html#a404b774530b3e491cd6afffa0caebc7a">02403</a> <span class="preprocessor">#define TOKEN_ID          2    </span><span class="comment">/* An identifier */</span>
<a name="l02404"></a><a class="code" href="fts2_8c.html#a7c4ffd4f88cfd9c44737230ad6e34e35">02404</a> <span class="preprocessor">#define TOKEN_STRING      3    </span><span class="comment">/* A string literal */</span>
<a name="l02405"></a><a class="code" href="fts2_8c.html#a1831e10448b8343472b14186f534519a">02405</a> <span class="preprocessor">#define TOKEN_PUNCT       4    </span><span class="comment">/* A single punctuation character */</span>
<a name="l02406"></a>02406 
<a name="l02407"></a>02407 <span class="comment">/*</span>
<a name="l02408"></a>02408 <span class="comment">** If X is a character that can be used in an identifier then</span>
<a name="l02409"></a>02409 <span class="comment">** IdChar(X) will be true.  Otherwise it is false.</span>
<a name="l02410"></a>02410 <span class="comment">**</span>
<a name="l02411"></a>02411 <span class="comment">** For ASCII, any character with the high-order bit set is</span>
<a name="l02412"></a>02412 <span class="comment">** allowed in an identifier.  For 7-bit characters, </span>
<a name="l02413"></a>02413 <span class="comment">** sqlite3IsIdChar[X] must be 1.</span>
<a name="l02414"></a>02414 <span class="comment">**</span>
<a name="l02415"></a>02415 <span class="comment">** Ticket #1066.  the SQL standard does not allow &apos;$&apos; in the</span>
<a name="l02416"></a>02416 <span class="comment">** middle of identfiers.  But many SQL implementations do. </span>
<a name="l02417"></a>02417 <span class="comment">** SQLite will allow &apos;$&apos; in identifiers for compatibility.</span>
<a name="l02418"></a>02418 <span class="comment">** But the feature is undocumented.</span>
<a name="l02419"></a>02419 <span class="comment">*/</span>
<a name="l02420"></a><a class="code" href="fts2_8c.html#aa72da15488fa2850cc0a2fccd83fc61f">02420</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="fts2_8c.html#aa72da15488fa2850cc0a2fccd83fc61f">isIdChar</a>[] = {
<a name="l02421"></a>02421 <span class="comment">/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */</span>
<a name="l02422"></a>02422     0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  <span class="comment">/* 2x */</span>
<a name="l02423"></a>02423     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  <span class="comment">/* 3x */</span>
<a name="l02424"></a>02424     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  <span class="comment">/* 4x */</span>
<a name="l02425"></a>02425     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  <span class="comment">/* 5x */</span>
<a name="l02426"></a>02426     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  <span class="comment">/* 6x */</span>
<a name="l02427"></a>02427     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  <span class="comment">/* 7x */</span>
<a name="l02428"></a>02428 };
<a name="l02429"></a><a class="code" href="fts2_8c.html#a26191b553b179817d928443be24f2dab">02429</a> <span class="preprocessor">#define IdChar(C)  (((c=C)&amp;0x80)!=0 || (c&gt;0x1f &amp;&amp; isIdChar[c-0x20]))</span>
<a name="l02430"></a>02430 <span class="preprocessor"></span>
<a name="l02431"></a>02431 
<a name="l02432"></a>02432 <span class="comment">/*</span>
<a name="l02433"></a>02433 <span class="comment">** Return the length of the token that begins at z[0]. </span>
<a name="l02434"></a>02434 <span class="comment">** Store the token type in *tokenType before returning.</span>
<a name="l02435"></a>02435 <span class="comment">*/</span>
<a name="l02436"></a><a class="code" href="fts2_8c.html#a81bf14af50f9d8908ce332aa32761ef4">02436</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a81bf14af50f9d8908ce332aa32761ef4">getToken</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *z, <span class="keywordtype">int</span> *tokenType){
<a name="l02437"></a>02437   <span class="keywordtype">int</span> i, c;
<a name="l02438"></a>02438   <span class="keywordflow">switch</span>( *z ){
<a name="l02439"></a>02439     <span class="keywordflow">case</span> 0: {
<a name="l02440"></a>02440       *tokenType = <a class="code" href="fts1_8c.html#af447f39a147c39c7304edbc1e2794405">TOKEN_EOF</a>;
<a name="l02441"></a>02441       <span class="keywordflow">return</span> 0;
<a name="l02442"></a>02442     }
<a name="l02443"></a>02443     <span class="keywordflow">case</span> <span class="charliteral">&apos; &apos;</span>: <span class="keywordflow">case</span> <span class="charliteral">&apos;\t&apos;</span>: <span class="keywordflow">case</span> <span class="charliteral">&apos;\n&apos;</span>: <span class="keywordflow">case</span> <span class="charliteral">&apos;\f&apos;</span>: <span class="keywordflow">case</span> <span class="charliteral">&apos;\r&apos;</span>: {
<a name="l02444"></a>02444       <span class="keywordflow">for</span>(i=1; <a class="code" href="fts2_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(z[i]); i++){}
<a name="l02445"></a>02445       *tokenType = <a class="code" href="fts1_8c.html#a353479c59d2069c4456ac5561d255a5d">TOKEN_SPACE</a>;
<a name="l02446"></a>02446       <span class="keywordflow">return</span> i;
<a name="l02447"></a>02447     }
<a name="l02448"></a>02448     <span class="keywordflow">case</span> <span class="charliteral">&apos;`&apos;</span>:
<a name="l02449"></a>02449     <span class="keywordflow">case</span> <span class="charliteral">&apos;\&apos;&apos;</span>:
<a name="l02450"></a>02450     <span class="keywordflow">case</span> <span class="charliteral">&apos;&quot;&apos;</span>: {
<a name="l02451"></a>02451       <span class="keywordtype">int</span> delim = z[0];
<a name="l02452"></a>02452       <span class="keywordflow">for</span>(i=1; (c=z[i])!=0; i++){
<a name="l02453"></a>02453         <span class="keywordflow">if</span>( c==delim ){
<a name="l02454"></a>02454           <span class="keywordflow">if</span>( z[i+1]==delim ){
<a name="l02455"></a>02455             i++;
<a name="l02456"></a>02456           }<span class="keywordflow">else</span>{
<a name="l02457"></a>02457             <span class="keywordflow">break</span>;
<a name="l02458"></a>02458           }
<a name="l02459"></a>02459         }
<a name="l02460"></a>02460       }
<a name="l02461"></a>02461       *tokenType = <a class="code" href="fts1_8c.html#a7c4ffd4f88cfd9c44737230ad6e34e35">TOKEN_STRING</a>;
<a name="l02462"></a>02462       <span class="keywordflow">return</span> i + (c!=0);
<a name="l02463"></a>02463     }
<a name="l02464"></a>02464     <span class="keywordflow">case</span> <span class="charliteral">&apos;[&apos;</span>: {
<a name="l02465"></a>02465       <span class="keywordflow">for</span>(i=1, c=z[0]; c!=<span class="charliteral">&apos;]&apos;</span> &amp;&amp; (c=z[i])!=0; i++){}
<a name="l02466"></a>02466       *tokenType = <a class="code" href="fts1_8c.html#a404b774530b3e491cd6afffa0caebc7a">TOKEN_ID</a>;
<a name="l02467"></a>02467       <span class="keywordflow">return</span> i;
<a name="l02468"></a>02468     }
<a name="l02469"></a>02469     <span class="keywordflow">default</span>: {
<a name="l02470"></a>02470       <span class="keywordflow">if</span>( !<a class="code" href="fts1_8c.html#a26191b553b179817d928443be24f2dab">IdChar</a>(*z) ){
<a name="l02471"></a>02471         <span class="keywordflow">break</span>;
<a name="l02472"></a>02472       }
<a name="l02473"></a>02473       <span class="keywordflow">for</span>(i=1; <a class="code" href="fts1_8c.html#a26191b553b179817d928443be24f2dab">IdChar</a>(z[i]); i++){}
<a name="l02474"></a>02474       *tokenType = <a class="code" href="fts1_8c.html#a404b774530b3e491cd6afffa0caebc7a">TOKEN_ID</a>;
<a name="l02475"></a>02475       <span class="keywordflow">return</span> i;
<a name="l02476"></a>02476     }
<a name="l02477"></a>02477   }
<a name="l02478"></a>02478   *tokenType = <a class="code" href="fts1_8c.html#a1831e10448b8343472b14186f534519a">TOKEN_PUNCT</a>;
<a name="l02479"></a>02479   <span class="keywordflow">return</span> 1;
<a name="l02480"></a>02480 }
<a name="l02481"></a>02481 
<a name="l02482"></a>02482 <span class="comment">/*</span>
<a name="l02483"></a>02483 <span class="comment">** A token extracted from a string is an instance of the following</span>
<a name="l02484"></a>02484 <span class="comment">** structure.</span>
<a name="l02485"></a>02485 <span class="comment">*/</span>
<a name="l02486"></a>02486 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structToken.html">Token</a> {
<a name="l02487"></a>02487   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>;       <span class="comment">/* Pointer to token text.  Not &apos;\000&apos; terminated */</span>
<a name="l02488"></a>02488   <span class="keywordtype">short</span> <span class="keywordtype">int</span> n;         <span class="comment">/* Length of the token text in bytes. */</span>
<a name="l02489"></a>02489 } <a class="code" href="structToken.html">Token</a>;
<a name="l02490"></a>02490 
<a name="l02491"></a>02491 <span class="comment">/*</span>
<a name="l02492"></a>02492 <span class="comment">** Given a input string (which is really one of the argv[] parameters</span>
<a name="l02493"></a>02493 <span class="comment">** passed into xConnect or xCreate) split the string up into tokens.</span>
<a name="l02494"></a>02494 <span class="comment">** Return an array of pointers to &apos;\000&apos; terminated strings, one string</span>
<a name="l02495"></a>02495 <span class="comment">** for each non-whitespace token.</span>
<a name="l02496"></a>02496 <span class="comment">**</span>
<a name="l02497"></a>02497 <span class="comment">** The returned array is terminated by a single NULL pointer.</span>
<a name="l02498"></a>02498 <span class="comment">**</span>
<a name="l02499"></a>02499 <span class="comment">** Space to hold the returned array is obtained from a single</span>
<a name="l02500"></a>02500 <span class="comment">** malloc and should be freed by passing the return value to free().</span>
<a name="l02501"></a>02501 <span class="comment">** The individual strings within the token list are all a part of</span>
<a name="l02502"></a>02502 <span class="comment">** the single memory allocation and will all be freed at once.</span>
<a name="l02503"></a>02503 <span class="comment">*/</span>
<a name="l02504"></a><a class="code" href="fts2_8c.html#a3ea56dae76c51349cbdef32a7215bcbb">02504</a> <span class="keyword">static</span> <span class="keywordtype">char</span> **<a class="code" href="fts2_8c.html#a3ea56dae76c51349cbdef32a7215bcbb">tokenizeString</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *z, <span class="keywordtype">int</span> *pnToken){
<a name="l02505"></a>02505   <span class="keywordtype">int</span> nToken = 0;
<a name="l02506"></a>02506   <a class="code" href="structToken.html">Token</a> *aToken = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>( strlen(z) * <span class="keyword">sizeof</span>(aToken[0]) );
<a name="l02507"></a>02507   <span class="keywordtype">int</span> n = 1;
<a name="l02508"></a>02508   <span class="keywordtype">int</span> e, i;
<a name="l02509"></a>02509   <span class="keywordtype">int</span> totalSize = 0;
<a name="l02510"></a>02510   <span class="keywordtype">char</span> **azToken;
<a name="l02511"></a>02511   <span class="keywordtype">char</span> *zCopy;
<a name="l02512"></a>02512   <span class="keywordflow">while</span>( n&gt;0 ){
<a name="l02513"></a>02513     n = <a class="code" href="fts2_8c.html#a81bf14af50f9d8908ce332aa32761ef4">getToken</a>(z, &amp;e);
<a name="l02514"></a>02514     <span class="keywordflow">if</span>( e!=<a class="code" href="fts1_8c.html#a353479c59d2069c4456ac5561d255a5d">TOKEN_SPACE</a> ){
<a name="l02515"></a>02515       aToken[nToken].<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> = z;
<a name="l02516"></a>02516       aToken[nToken].<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> = n;
<a name="l02517"></a>02517       nToken++;
<a name="l02518"></a>02518       totalSize += n+1;
<a name="l02519"></a>02519     }
<a name="l02520"></a>02520     z += n;
<a name="l02521"></a>02521   }
<a name="l02522"></a>02522   azToken = (<span class="keywordtype">char</span>**)<a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>( nToken*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*) + totalSize );
<a name="l02523"></a>02523   zCopy = (<span class="keywordtype">char</span>*)&amp;azToken[nToken];
<a name="l02524"></a>02524   nToken--;
<a name="l02525"></a>02525   <span class="keywordflow">for</span>(i=0; i&lt;nToken; i++){
<a name="l02526"></a>02526     azToken[i] = zCopy;
<a name="l02527"></a>02527     n = aToken[i].<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a>;
<a name="l02528"></a>02528     memcpy(zCopy, aToken[i].z, n);
<a name="l02529"></a>02529     zCopy[n] = 0;
<a name="l02530"></a>02530     zCopy += n+1;
<a name="l02531"></a>02531   }
<a name="l02532"></a>02532   azToken[nToken] = 0;
<a name="l02533"></a>02533   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(aToken);
<a name="l02534"></a>02534   *pnToken = nToken;
<a name="l02535"></a>02535   <span class="keywordflow">return</span> azToken;
<a name="l02536"></a>02536 }
<a name="l02537"></a>02537 
<a name="l02538"></a>02538 <span class="comment">/*</span>
<a name="l02539"></a>02539 <span class="comment">** Convert an SQL-style quoted string into a normal string by removing</span>
<a name="l02540"></a>02540 <span class="comment">** the quote characters.  The conversion is done in-place.  If the</span>
<a name="l02541"></a>02541 <span class="comment">** input does not begin with a quote character, then this routine</span>
<a name="l02542"></a>02542 <span class="comment">** is a no-op.</span>
<a name="l02543"></a>02543 <span class="comment">**</span>
<a name="l02544"></a>02544 <span class="comment">** Examples:</span>
<a name="l02545"></a>02545 <span class="comment">**</span>
<a name="l02546"></a>02546 <span class="comment">**     &quot;abc&quot;   becomes   abc</span>
<a name="l02547"></a>02547 <span class="comment">**     &apos;xyz&apos;   becomes   xyz</span>
<a name="l02548"></a>02548 <span class="comment">**     [pqr]   becomes   pqr</span>
<a name="l02549"></a>02549 <span class="comment">**     `mno`   becomes   mno</span>
<a name="l02550"></a>02550 <span class="comment">*/</span>
<a name="l02551"></a><a class="code" href="fts2_8c.html#a407801ec85fdd038cfa6789058685d80">02551</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a407801ec85fdd038cfa6789058685d80">dequoteString</a>(<span class="keywordtype">char</span> *z){
<a name="l02552"></a>02552   <span class="keywordtype">int</span> quote;
<a name="l02553"></a>02553   <span class="keywordtype">int</span> i, j;
<a name="l02554"></a>02554   <span class="keywordflow">if</span>( z==0 ) <span class="keywordflow">return</span>;
<a name="l02555"></a>02555   quote = z[0];
<a name="l02556"></a>02556   <span class="keywordflow">switch</span>( quote ){
<a name="l02557"></a>02557     <span class="keywordflow">case</span> <span class="charliteral">&apos;\&apos;&apos;</span>:  <span class="keywordflow">break</span>;
<a name="l02558"></a>02558     <span class="keywordflow">case</span> <span class="charliteral">&apos;&quot;&apos;</span>:   <span class="keywordflow">break</span>;
<a name="l02559"></a>02559     <span class="keywordflow">case</span> <span class="charliteral">&apos;`&apos;</span>:   <span class="keywordflow">break</span>;                <span class="comment">/* For MySQL compatibility */</span>
<a name="l02560"></a>02560     <span class="keywordflow">case</span> <span class="charliteral">&apos;[&apos;</span>:   quote = <span class="charliteral">&apos;]&apos;</span>;  <span class="keywordflow">break</span>;  <span class="comment">/* For MS SqlServer compatibility */</span>
<a name="l02561"></a>02561     <span class="keywordflow">default</span>:    <span class="keywordflow">return</span>;
<a name="l02562"></a>02562   }
<a name="l02563"></a>02563   <span class="keywordflow">for</span>(i=1, j=0; z[i]; i++){
<a name="l02564"></a>02564     <span class="keywordflow">if</span>( z[i]==quote ){
<a name="l02565"></a>02565       <span class="keywordflow">if</span>( z[i+1]==quote ){
<a name="l02566"></a>02566         z[j++] = quote;
<a name="l02567"></a>02567         i++;
<a name="l02568"></a>02568       }<span class="keywordflow">else</span>{
<a name="l02569"></a>02569         z[j++] = 0;
<a name="l02570"></a>02570         <span class="keywordflow">break</span>;
<a name="l02571"></a>02571       }
<a name="l02572"></a>02572     }<span class="keywordflow">else</span>{
<a name="l02573"></a>02573       z[j++] = z[i];
<a name="l02574"></a>02574     }
<a name="l02575"></a>02575   }
<a name="l02576"></a>02576 }
<a name="l02577"></a>02577 
<a name="l02578"></a>02578 <span class="comment">/*</span>
<a name="l02579"></a>02579 <span class="comment">** The input azIn is a NULL-terminated list of tokens.  Remove the first</span>
<a name="l02580"></a>02580 <span class="comment">** token and all punctuation tokens.  Remove the quotes from</span>
<a name="l02581"></a>02581 <span class="comment">** around string literal tokens.</span>
<a name="l02582"></a>02582 <span class="comment">**</span>
<a name="l02583"></a>02583 <span class="comment">** Example:</span>
<a name="l02584"></a>02584 <span class="comment">**</span>
<a name="l02585"></a>02585 <span class="comment">**     input:      tokenize chinese ( &apos;simplifed&apos; , &apos;mixed&apos; )</span>
<a name="l02586"></a>02586 <span class="comment">**     output:     chinese simplifed mixed</span>
<a name="l02587"></a>02587 <span class="comment">**</span>
<a name="l02588"></a>02588 <span class="comment">** Another example:</span>
<a name="l02589"></a>02589 <span class="comment">**</span>
<a name="l02590"></a>02590 <span class="comment">**     input:      delimiters ( &apos;[&apos; , &apos;]&apos; , &apos;...&apos; )</span>
<a name="l02591"></a>02591 <span class="comment">**     output:     [ ] ...</span>
<a name="l02592"></a>02592 <span class="comment">*/</span>
<a name="l02593"></a><a class="code" href="fts2_8c.html#aa1202d8ce261dc098a68360d002b7420">02593</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aa1202d8ce261dc098a68360d002b7420">tokenListToIdList</a>(<span class="keywordtype">char</span> **azIn){
<a name="l02594"></a>02594   <span class="keywordtype">int</span> i, j;
<a name="l02595"></a>02595   <span class="keywordflow">if</span>( azIn ){
<a name="l02596"></a>02596     <span class="keywordflow">for</span>(i=0, j=-1; azIn[i]; i++){
<a name="l02597"></a>02597       <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">safe_isalnum</a>(azIn[i][0]) || azIn[i][1] ){
<a name="l02598"></a>02598         <a class="code" href="fts2_8c.html#a407801ec85fdd038cfa6789058685d80">dequoteString</a>(azIn[i]);
<a name="l02599"></a>02599         <span class="keywordflow">if</span>( j&gt;=0 ){
<a name="l02600"></a>02600           azIn[j] = azIn[i];
<a name="l02601"></a>02601         }
<a name="l02602"></a>02602         j++;
<a name="l02603"></a>02603       }
<a name="l02604"></a>02604     }
<a name="l02605"></a>02605     azIn[j] = 0;
<a name="l02606"></a>02606   }
<a name="l02607"></a>02607 }
<a name="l02608"></a>02608 
<a name="l02609"></a>02609 
<a name="l02610"></a>02610 <span class="comment">/*</span>
<a name="l02611"></a>02611 <span class="comment">** Find the first alphanumeric token in the string zIn.  Null-terminate</span>
<a name="l02612"></a>02612 <span class="comment">** this token.  Remove any quotation marks.  And return a pointer to</span>
<a name="l02613"></a>02613 <span class="comment">** the result.</span>
<a name="l02614"></a>02614 <span class="comment">*/</span>
<a name="l02615"></a><a class="code" href="fts2_8c.html#a3948d23d2ee53a6cbcc9a546734acb38">02615</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a3948d23d2ee53a6cbcc9a546734acb38">firstToken</a>(<span class="keywordtype">char</span> *zIn, <span class="keywordtype">char</span> **pzTail){
<a name="l02616"></a>02616   <span class="keywordtype">int</span> n, <a class="code" href="lobject_8h.html#acd205ab396b96fba48e1f758c17a2cf3">ttype</a>;
<a name="l02617"></a>02617   <span class="keywordflow">while</span>(1){
<a name="l02618"></a>02618     n = <a class="code" href="fts2_8c.html#a81bf14af50f9d8908ce332aa32761ef4">getToken</a>(zIn, &amp;ttype);
<a name="l02619"></a>02619     <span class="keywordflow">if</span>( ttype==<a class="code" href="fts1_8c.html#a353479c59d2069c4456ac5561d255a5d">TOKEN_SPACE</a> ){
<a name="l02620"></a>02620       zIn += n;
<a name="l02621"></a>02621     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( ttype==<a class="code" href="fts1_8c.html#af447f39a147c39c7304edbc1e2794405">TOKEN_EOF</a> ){
<a name="l02622"></a>02622       *pzTail = zIn;
<a name="l02623"></a>02623       <span class="keywordflow">return</span> 0;
<a name="l02624"></a>02624     }<span class="keywordflow">else</span>{
<a name="l02625"></a>02625       zIn[n] = 0;
<a name="l02626"></a>02626       *pzTail = &amp;zIn[1];
<a name="l02627"></a>02627       <a class="code" href="fts2_8c.html#a407801ec85fdd038cfa6789058685d80">dequoteString</a>(zIn);
<a name="l02628"></a>02628       <span class="keywordflow">return</span> zIn;
<a name="l02629"></a>02629     }
<a name="l02630"></a>02630   }
<a name="l02631"></a>02631   <span class="comment">/*NOTREACHED*/</span>
<a name="l02632"></a>02632 }
<a name="l02633"></a>02633 
<a name="l02634"></a>02634 <span class="comment">/* Return true if...</span>
<a name="l02635"></a>02635 <span class="comment">**</span>
<a name="l02636"></a>02636 <span class="comment">**   *  s begins with the string t, ignoring case</span>
<a name="l02637"></a>02637 <span class="comment">**   *  s is longer than t</span>
<a name="l02638"></a>02638 <span class="comment">**   *  The first character of s beyond t is not a alphanumeric</span>
<a name="l02639"></a>02639 <span class="comment">** </span>
<a name="l02640"></a>02640 <span class="comment">** Ignore leading space in *s.</span>
<a name="l02641"></a>02641 <span class="comment">**</span>
<a name="l02642"></a>02642 <span class="comment">** To put it another way, return true if the first token of</span>
<a name="l02643"></a>02643 <span class="comment">** s[] is t[].</span>
<a name="l02644"></a>02644 <span class="comment">*/</span>
<a name="l02645"></a><a class="code" href="fts2_8c.html#ae6de35868033307bf1b589708be561c3">02645</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ae6de35868033307bf1b589708be561c3">startsWith</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *t){
<a name="l02646"></a>02646   <span class="keywordflow">while</span>( <a class="code" href="fts2_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(*s) ){ s++; }
<a name="l02647"></a>02647   <span class="keywordflow">while</span>( *t ){
<a name="l02648"></a>02648     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#aa13290c27de028c6f1886f82656482fa">safe_tolower</a>(*s++)!=<a class="code" href="fts2_8c.html#aa13290c27de028c6f1886f82656482fa">safe_tolower</a>(*t++) ) <span class="keywordflow">return</span> 0;
<a name="l02649"></a>02649   }
<a name="l02650"></a>02650   <span class="keywordflow">return</span> *s!=<span class="charliteral">&apos;_&apos;</span> &amp;&amp; !<a class="code" href="fts2_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">safe_isalnum</a>(*s);
<a name="l02651"></a>02651 }
<a name="l02652"></a>02652 
<a name="l02653"></a>02653 <span class="comment">/*</span>
<a name="l02654"></a>02654 <span class="comment">** An instance of this structure defines the &quot;spec&quot; of a</span>
<a name="l02655"></a>02655 <span class="comment">** full text index.  This structure is populated by parseSpec</span>
<a name="l02656"></a>02656 <span class="comment">** and use by fulltextConnect and fulltextCreate.</span>
<a name="l02657"></a>02657 <span class="comment">*/</span>
<a name="l02658"></a>02658 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structTableSpec.html">TableSpec</a> {
<a name="l02659"></a>02659   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a>;         <span class="comment">/* Logical database name */</span>
<a name="l02660"></a>02660   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>;       <span class="comment">/* Name of the full-text index */</span>
<a name="l02661"></a>02661   <span class="keywordtype">int</span> <a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>;             <span class="comment">/* Number of columns to be indexed */</span>
<a name="l02662"></a>02662   <span class="keywordtype">char</span> **<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a>;         <span class="comment">/* Original names of columns to be indexed */</span>
<a name="l02663"></a>02663   <span class="keywordtype">char</span> **<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>;  <span class="comment">/* Column names for %_content */</span>
<a name="l02664"></a>02664   <span class="keywordtype">char</span> **<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>;      <span class="comment">/* Name of tokenizer and its arguments */</span>
<a name="l02665"></a>02665 } <a class="code" href="structTableSpec.html">TableSpec</a>;
<a name="l02666"></a>02666 
<a name="l02667"></a>02667 <span class="comment">/*</span>
<a name="l02668"></a>02668 <span class="comment">** Reclaim all of the memory used by a TableSpec</span>
<a name="l02669"></a>02669 <span class="comment">*/</span>
<a name="l02670"></a><a class="code" href="fts2_8c.html#a558f389157af9866b165a9f1138d077d">02670</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a558f389157af9866b165a9f1138d077d">clearTableSpec</a>(<a class="code" href="structTableSpec.html">TableSpec</a> *p) {
<a name="l02671"></a>02671   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p-&gt;<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a>);
<a name="l02672"></a>02672   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>);
<a name="l02673"></a>02673   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>);
<a name="l02674"></a>02674 }
<a name="l02675"></a>02675 
<a name="l02676"></a>02676 <span class="comment">/* Parse a CREATE VIRTUAL TABLE statement, which looks like this:</span>
<a name="l02677"></a>02677 <span class="comment"> *</span>
<a name="l02678"></a>02678 <span class="comment"> * CREATE VIRTUAL TABLE email</span>
<a name="l02679"></a>02679 <span class="comment"> *        USING fts2(subject, body, tokenize mytokenizer(myarg))</span>
<a name="l02680"></a>02680 <span class="comment"> *</span>
<a name="l02681"></a>02681 <span class="comment"> * We return parsed information in a TableSpec structure.</span>
<a name="l02682"></a>02682 <span class="comment"> * </span>
<a name="l02683"></a>02683 <span class="comment"> */</span>
<a name="l02684"></a><a class="code" href="fts2_8c.html#ab2b3c8fa2bbe697f78bc3a84b61ef0ce">02684</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ab2b3c8fa2bbe697f78bc3a84b61ef0ce">parseSpec</a>(<a class="code" href="structTableSpec.html">TableSpec</a> *pSpec, <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span>*argv,
<a name="l02685"></a>02685                      <span class="keywordtype">char</span>**pzErr){
<a name="l02686"></a>02686   <span class="keywordtype">int</span> i, n;
<a name="l02687"></a>02687   <span class="keywordtype">char</span> *z, *zDummy;
<a name="l02688"></a>02688   <span class="keywordtype">char</span> **azArg;
<a name="l02689"></a>02689   <span class="keyword">const</span> <span class="keywordtype">char</span> *zTokenizer = 0;    <span class="comment">/* argv[] entry describing the tokenizer */</span>
<a name="l02690"></a>02690 
<a name="l02691"></a>02691   assert( argc&gt;=3 );
<a name="l02692"></a>02692   <span class="comment">/* Current interface:</span>
<a name="l02693"></a>02693 <span class="comment">  ** argv[0] - module name</span>
<a name="l02694"></a>02694 <span class="comment">  ** argv[1] - database name</span>
<a name="l02695"></a>02695 <span class="comment">  ** argv[2] - table name</span>
<a name="l02696"></a>02696 <span class="comment">  ** argv[3..] - columns, optionally followed by tokenizer specification</span>
<a name="l02697"></a>02697 <span class="comment">  **             and snippet delimiters specification.</span>
<a name="l02698"></a>02698 <span class="comment">  */</span>
<a name="l02699"></a>02699 
<a name="l02700"></a>02700   <span class="comment">/* Make a copy of the complete argv[][] array in a single allocation.</span>
<a name="l02701"></a>02701 <span class="comment">  ** The argv[][] array is read-only and transient.  We can write to the</span>
<a name="l02702"></a>02702 <span class="comment">  ** copy in order to modify things and the copy is persistent.</span>
<a name="l02703"></a>02703 <span class="comment">  */</span>
<a name="l02704"></a>02704   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(pSpec);
<a name="l02705"></a>02705   <span class="keywordflow">for</span>(i=n=0; i&lt;argc; i++){
<a name="l02706"></a>02706     n += strlen(argv[i]) + 1;
<a name="l02707"></a>02707   }
<a name="l02708"></a>02708   azArg = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>( <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*)*argc + n );
<a name="l02709"></a>02709   <span class="keywordflow">if</span>( azArg==0 ){
<a name="l02710"></a>02710     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l02711"></a>02711   }
<a name="l02712"></a>02712   z = (<span class="keywordtype">char</span>*)&amp;azArg[argc];
<a name="l02713"></a>02713   <span class="keywordflow">for</span>(i=0; i&lt;argc; i++){
<a name="l02714"></a>02714     azArg[i] = z;
<a name="l02715"></a>02715     strcpy(z, argv[i]);
<a name="l02716"></a>02716     z += strlen(z)+1;
<a name="l02717"></a>02717   }
<a name="l02718"></a>02718 
<a name="l02719"></a>02719   <span class="comment">/* Identify the column names and the tokenizer and delimiter arguments</span>
<a name="l02720"></a>02720 <span class="comment">  ** in the argv[][] array.</span>
<a name="l02721"></a>02721 <span class="comment">  */</span>
<a name="l02722"></a>02722   pSpec-&gt;<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a> = azArg[1];
<a name="l02723"></a>02723   pSpec-&gt;<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a> = azArg[2];
<a name="l02724"></a>02724   pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a> = 0;
<a name="l02725"></a>02725   pSpec-&gt;<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a> = azArg;
<a name="l02726"></a>02726   zTokenizer = <span class="stringliteral">&quot;tokenize simple&quot;</span>;
<a name="l02727"></a>02727   <span class="keywordflow">for</span>(i=3; i&lt;argc; ++i){
<a name="l02728"></a>02728     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ae6de35868033307bf1b589708be561c3">startsWith</a>(azArg[i],<span class="stringliteral">&quot;tokenize&quot;</span>) ){
<a name="l02729"></a>02729       zTokenizer = azArg[i];
<a name="l02730"></a>02730     }<span class="keywordflow">else</span>{
<a name="l02731"></a>02731       z = azArg[pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>] = <a class="code" href="fts2_8c.html#a3948d23d2ee53a6cbcc9a546734acb38">firstToken</a>(azArg[i], &amp;zDummy);
<a name="l02732"></a>02732       pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>++;
<a name="l02733"></a>02733     }
<a name="l02734"></a>02734   }
<a name="l02735"></a>02735   <span class="keywordflow">if</span>( pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>==0 ){
<a name="l02736"></a>02736     azArg[0] = <span class="stringliteral">&quot;content&quot;</span>;
<a name="l02737"></a>02737     pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a> = 1;
<a name="l02738"></a>02738   }
<a name="l02739"></a>02739 
<a name="l02740"></a>02740   <span class="comment">/*</span>
<a name="l02741"></a>02741 <span class="comment">  ** Construct the list of content column names.</span>
<a name="l02742"></a>02742 <span class="comment">  **</span>
<a name="l02743"></a>02743 <span class="comment">  ** Each content column name will be of the form cNNAAAA</span>
<a name="l02744"></a>02744 <span class="comment">  ** where NN is the column number and AAAA is the sanitized</span>
<a name="l02745"></a>02745 <span class="comment">  ** column name.  &quot;sanitized&quot; means that special characters are</span>
<a name="l02746"></a>02746 <span class="comment">  ** converted to &quot;_&quot;.  The cNN prefix guarantees that all column</span>
<a name="l02747"></a>02747 <span class="comment">  ** names are unique.</span>
<a name="l02748"></a>02748 <span class="comment">  **</span>
<a name="l02749"></a>02749 <span class="comment">  ** The AAAA suffix is not strictly necessary.  It is included</span>
<a name="l02750"></a>02750 <span class="comment">  ** for the convenience of people who might examine the generated</span>
<a name="l02751"></a>02751 <span class="comment">  ** %_content table and wonder what the columns are used for.</span>
<a name="l02752"></a>02752 <span class="comment">  */</span>
<a name="l02753"></a>02753   pSpec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a> = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>( pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *) );
<a name="l02754"></a>02754   <span class="keywordflow">if</span>( pSpec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>==0 ){
<a name="l02755"></a>02755     <a class="code" href="fts2_8c.html#a558f389157af9866b165a9f1138d077d">clearTableSpec</a>(pSpec);
<a name="l02756"></a>02756     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l02757"></a>02757   }
<a name="l02758"></a>02758   <span class="keywordflow">for</span>(i=0; i&lt;pSpec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>; i++){
<a name="l02759"></a>02759     <span class="keywordtype">char</span> *p;
<a name="l02760"></a>02760     pSpec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>[i] = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;c%d%s&quot;</span>, i, azArg[i]);
<a name="l02761"></a>02761     <span class="keywordflow">for</span> (p = pSpec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>[i]; *p ; ++p) {
<a name="l02762"></a>02762       <span class="keywordflow">if</span>( !<a class="code" href="fts2_8c.html#ae6578e6f091fcde2bb2d4ffcfba346fb">safe_isalnum</a>(*p) ) *p = <span class="charliteral">&apos;_&apos;</span>;
<a name="l02763"></a>02763     }
<a name="l02764"></a>02764   }
<a name="l02765"></a>02765 
<a name="l02766"></a>02766   <span class="comment">/*</span>
<a name="l02767"></a>02767 <span class="comment">  ** Parse the tokenizer specification string.</span>
<a name="l02768"></a>02768 <span class="comment">  */</span>
<a name="l02769"></a>02769   pSpec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a> = <a class="code" href="fts2_8c.html#a3ea56dae76c51349cbdef32a7215bcbb">tokenizeString</a>(zTokenizer, &amp;n);
<a name="l02770"></a>02770   <a class="code" href="fts2_8c.html#aa1202d8ce261dc098a68360d002b7420">tokenListToIdList</a>(pSpec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>);
<a name="l02771"></a>02771 
<a name="l02772"></a>02772   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02773"></a>02773 }
<a name="l02774"></a>02774 
<a name="l02775"></a>02775 <span class="comment">/*</span>
<a name="l02776"></a>02776 <span class="comment">** Generate a CREATE TABLE statement that describes the schema of</span>
<a name="l02777"></a>02777 <span class="comment">** the virtual table.  Return a pointer to this schema string.</span>
<a name="l02778"></a>02778 <span class="comment">**</span>
<a name="l02779"></a>02779 <span class="comment">** Space is obtained from sqlite3_mprintf() and should be freed</span>
<a name="l02780"></a>02780 <span class="comment">** using sqlite3_free().</span>
<a name="l02781"></a>02781 <span class="comment">*/</span>
<a name="l02782"></a><a class="code" href="fts2_8c.html#a679cfcb66f0cbef9c8af06fb107b93ae">02782</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a679cfcb66f0cbef9c8af06fb107b93ae">fulltextSchema</a>(
<a name="l02783"></a>02783   <span class="keywordtype">int</span> nColumn,                  <span class="comment">/* Number of columns */</span>
<a name="l02784"></a>02784   <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span>* azColumn,  <span class="comment">/* List of columns */</span>
<a name="l02785"></a>02785   <span class="keyword">const</span> <span class="keywordtype">char</span> *zTableName        <span class="comment">/* Name of the table */</span>
<a name="l02786"></a>02786 ){
<a name="l02787"></a>02787   <span class="keywordtype">int</span> i;
<a name="l02788"></a>02788   <span class="keywordtype">char</span> *zSchema, *zNext;
<a name="l02789"></a>02789   <span class="keyword">const</span> <span class="keywordtype">char</span> *zSep = <span class="stringliteral">&quot;(&quot;</span>;
<a name="l02790"></a>02790   zSchema = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;CREATE TABLE x&quot;</span>);
<a name="l02791"></a>02791   <span class="keywordflow">for</span>(i=0; i&lt;nColumn; i++){
<a name="l02792"></a>02792     zNext = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;%s%s%Q&quot;</span>, zSchema, zSep, azColumn[i]);
<a name="l02793"></a>02793     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zSchema);
<a name="l02794"></a>02794     zSchema = zNext;
<a name="l02795"></a>02795     zSep = <span class="stringliteral">&quot;,&quot;</span>;
<a name="l02796"></a>02796   }
<a name="l02797"></a>02797   zNext = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;%s,%Q)&quot;</span>, zSchema, zTableName);
<a name="l02798"></a>02798   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zSchema);
<a name="l02799"></a>02799   <span class="keywordflow">return</span> zNext;
<a name="l02800"></a>02800 }
<a name="l02801"></a>02801 
<a name="l02802"></a>02802 <span class="comment">/*</span>
<a name="l02803"></a>02803 <span class="comment">** Build a new sqlite3_vtab structure that will describe the</span>
<a name="l02804"></a>02804 <span class="comment">** fulltext index defined by spec.</span>
<a name="l02805"></a>02805 <span class="comment">*/</span>
<a name="l02806"></a><a class="code" href="fts2_8c.html#a63df5907f7754ab312551a2408434a79">02806</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a63df5907f7754ab312551a2408434a79">constructVtab</a>(
<a name="l02807"></a>02807   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>,              <span class="comment">/* The SQLite database connection */</span>
<a name="l02808"></a>02808   <a class="code" href="structfts2Hash.html">fts2Hash</a> *pHash,          <span class="comment">/* Hash table containing tokenizers */</span>
<a name="l02809"></a>02809   <a class="code" href="structTableSpec.html">TableSpec</a> *spec,          <span class="comment">/* Parsed spec information from parseSpec() */</span>
<a name="l02810"></a>02810   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> **ppVTab,    <span class="comment">/* Write the resulting vtab structure here */</span>
<a name="l02811"></a>02811   <span class="keywordtype">char</span> **pzErr              <span class="comment">/* Write any error message here */</span>
<a name="l02812"></a>02812 ){
<a name="l02813"></a>02813   <span class="keywordtype">int</span> rc;
<a name="l02814"></a>02814   <span class="keywordtype">int</span> n;
<a name="l02815"></a>02815   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = 0;
<a name="l02816"></a>02816   <span class="keyword">const</span> <a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *m = NULL;
<a name="l02817"></a>02817   <span class="keywordtype">char</span> *schema;
<a name="l02818"></a>02818 
<a name="l02819"></a>02819   <span class="keywordtype">char</span> <span class="keyword">const</span> *zTok;         <span class="comment">/* Name of tokenizer to use for this fts table */</span>
<a name="l02820"></a>02820   <span class="keywordtype">int</span> nTok;                 <span class="comment">/* Length of zTok, including nul terminator */</span>
<a name="l02821"></a>02821 
<a name="l02822"></a>02822   v = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *) <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a>));
<a name="l02823"></a>02823   <span class="keywordflow">if</span>( v==0 ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l02824"></a>02824   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(v);
<a name="l02825"></a>02825   <span class="comment">/* sqlite will initialize v-&gt;base */</span>
<a name="l02826"></a>02826   v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a> = db;
<a name="l02827"></a>02827   v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a> = spec-&gt;<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a>;       <span class="comment">/* Freed when azColumn is freed */</span>
<a name="l02828"></a>02828   v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a> = spec-&gt;<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>;   <span class="comment">/* Freed when azColumn is freed */</span>
<a name="l02829"></a>02829   v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a> = spec-&gt;<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>;
<a name="l02830"></a>02830   v-&gt;<a class="code" href="structfulltext__vtab.html#a7d7fb8f55a26bf7fafb3ad50e13ef07c">azContentColumn</a> = spec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>;
<a name="l02831"></a>02831   spec-&gt;<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a> = 0;
<a name="l02832"></a>02832   v-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a> = spec-&gt;<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a>;
<a name="l02833"></a>02833   spec-&gt;<a class="code" href="structTableSpec.html#aa276ff789a51b7e14402795fb610907c">azColumn</a> = 0;
<a name="l02834"></a>02834 
<a name="l02835"></a>02835   <span class="keywordflow">if</span>( spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>==0 ){
<a name="l02836"></a>02836     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l02837"></a>02837   }
<a name="l02838"></a>02838 
<a name="l02839"></a>02839   zTok = spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[0]; 
<a name="l02840"></a>02840   <span class="keywordflow">if</span>( !zTok ){
<a name="l02841"></a>02841     zTok = <span class="stringliteral">&quot;simple&quot;</span>;
<a name="l02842"></a>02842   }
<a name="l02843"></a>02843   nTok = strlen(zTok)+1;
<a name="l02844"></a>02844 
<a name="l02845"></a>02845   m = (<a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *)<a class="code" href="fts2__hash_8c.html#a14439ab02f3df4a2a00056e440b4eb6a">sqlite3Fts2HashFind</a>(pHash, zTok, nTok);
<a name="l02846"></a>02846   <span class="keywordflow">if</span>( !m ){
<a name="l02847"></a>02847     *pzErr = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;unknown tokenizer: %s&quot;</span>, spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[0]);
<a name="l02848"></a>02848     rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02849"></a>02849     <span class="keywordflow">goto</span> err;
<a name="l02850"></a>02850   }
<a name="l02851"></a>02851 
<a name="l02852"></a>02852   <span class="keywordflow">for</span>(n=0; spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[n]; n++){}
<a name="l02853"></a>02853   <span class="keywordflow">if</span>( n ){
<a name="l02854"></a>02854     rc = m-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#af23cec0bb84594e9c28c6892e2bb917a">xCreate</a>(n-1, (<span class="keyword">const</span> <span class="keywordtype">char</span>*<span class="keyword">const</span>*)&amp;spec-&gt;<a class="code" href="structTableSpec.html#a838e9389c071ac698ea9493c2ebd36fa">azTokenizer</a>[1],
<a name="l02855"></a>02855                     &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>);
<a name="l02856"></a>02856   }<span class="keywordflow">else</span>{
<a name="l02857"></a>02857     rc = m-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#af23cec0bb84594e9c28c6892e2bb917a">xCreate</a>(0, 0, &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>);
<a name="l02858"></a>02858   }
<a name="l02859"></a>02859   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l02860"></a>02860   v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a> = m;
<a name="l02861"></a>02861 
<a name="l02862"></a>02862   <span class="comment">/* TODO: verify the existence of backing tables foo_content, foo_term */</span>
<a name="l02863"></a>02863 
<a name="l02864"></a>02864   schema = <a class="code" href="fts2_8c.html#a679cfcb66f0cbef9c8af06fb107b93ae">fulltextSchema</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*<span class="keyword">const</span>*)v-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>,
<a name="l02865"></a>02865                           spec-&gt;<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>);
<a name="l02866"></a>02866   rc = <a class="code" href="sqlite3_8h.html#aefa1dcc35bfd08140af3073d08e20029">sqlite3_declare_vtab</a>(db, schema);
<a name="l02867"></a>02867   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(schema);
<a name="l02868"></a>02868   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l02869"></a>02869 
<a name="l02870"></a>02870   memset(v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>, 0, <span class="keyword">sizeof</span>(v-&gt;<a class="code" href="structfulltext__vtab.html#a074f9c93c16deb9e0350f227c87b8934">pFulltextStatements</a>));
<a name="l02871"></a>02871 
<a name="l02872"></a>02872   <span class="comment">/* Indicate that the buffer is not live. */</span>
<a name="l02873"></a>02873   v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a> = -1;
<a name="l02874"></a>02874 
<a name="l02875"></a>02875   *ppVTab = &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#a8e711ebd8423f2581ac15dd3a25f4353">base</a>;
<a name="l02876"></a>02876   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Connect %p\n&quot;</span>, v));
<a name="l02877"></a>02877 
<a name="l02878"></a>02878   <span class="keywordflow">return</span> rc;
<a name="l02879"></a>02879 
<a name="l02880"></a>02880 err:
<a name="l02881"></a>02881   <a class="code" href="fts2_8c.html#aec311e3893b552f3ae7b70311bb70280">fulltext_vtab_destroy</a>(v);
<a name="l02882"></a>02882   <span class="keywordflow">return</span> rc;
<a name="l02883"></a>02883 }
<a name="l02884"></a>02884 
<a name="l02885"></a><a class="code" href="fts2_8c.html#a42d060bb429eb8ae7a86e9042b4fb232">02885</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a42d060bb429eb8ae7a86e9042b4fb232">fulltextConnect</a>(
<a name="l02886"></a>02886   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>,
<a name="l02887"></a>02887   <span class="keywordtype">void</span> *pAux,
<a name="l02888"></a>02888   <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span>*argv,
<a name="l02889"></a>02889   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> **ppVTab,
<a name="l02890"></a>02890   <span class="keywordtype">char</span> **pzErr
<a name="l02891"></a>02891 ){
<a name="l02892"></a>02892   <a class="code" href="structTableSpec.html">TableSpec</a> spec;
<a name="l02893"></a>02893   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#ab2b3c8fa2bbe697f78bc3a84b61ef0ce">parseSpec</a>(&amp;spec, argc, argv, pzErr);
<a name="l02894"></a>02894   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02895"></a>02895 
<a name="l02896"></a>02896   rc = <a class="code" href="fts2_8c.html#a63df5907f7754ab312551a2408434a79">constructVtab</a>(db, (<a class="code" href="structfts2Hash.html">fts2Hash</a> *)pAux, &amp;spec, ppVTab, pzErr);
<a name="l02897"></a>02897   <a class="code" href="fts2_8c.html#a558f389157af9866b165a9f1138d077d">clearTableSpec</a>(&amp;spec);
<a name="l02898"></a>02898   <span class="keywordflow">return</span> rc;
<a name="l02899"></a>02899 }
<a name="l02900"></a>02900 
<a name="l02901"></a>02901 <span class="comment">/* The %_content table holds the text of each document, with</span>
<a name="l02902"></a>02902 <span class="comment">** the rowid used as the docid.</span>
<a name="l02903"></a>02903 <span class="comment">*/</span>
<a name="l02904"></a>02904 <span class="comment">/* TODO(shess) This comment needs elaboration to match the updated</span>
<a name="l02905"></a>02905 <span class="comment">** code.  Work it into the top-of-file comment at that time.</span>
<a name="l02906"></a>02906 <span class="comment">*/</span>
<a name="l02907"></a><a class="code" href="fts2_8c.html#a0d5b27c0376561066f14ab3a59d8b6a2">02907</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a0d5b27c0376561066f14ab3a59d8b6a2">fulltextCreate</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <span class="keywordtype">void</span> *pAux,
<a name="l02908"></a>02908                           <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> *argv,
<a name="l02909"></a>02909                           <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> **ppVTab, <span class="keywordtype">char</span> **pzErr){
<a name="l02910"></a>02910   <span class="keywordtype">int</span> rc;
<a name="l02911"></a>02911   <a class="code" href="structTableSpec.html">TableSpec</a> spec;
<a name="l02912"></a>02912   <a class="code" href="structStringBuffer.html">StringBuffer</a> schema;
<a name="l02913"></a>02913   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Create\n&quot;</span>));
<a name="l02914"></a>02914 
<a name="l02915"></a>02915   rc = <a class="code" href="fts2_8c.html#ab2b3c8fa2bbe697f78bc3a84b61ef0ce">parseSpec</a>(&amp;spec, argc, argv, pzErr);
<a name="l02916"></a>02916   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l02917"></a>02917 
<a name="l02918"></a>02918   <a class="code" href="fts2_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;schema);
<a name="l02919"></a>02919   <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;schema, <span class="stringliteral">&quot;CREATE TABLE %_content(&quot;</span>);
<a name="l02920"></a>02920   <a class="code" href="fts2_8c.html#a25815e8e930bcd9e3eabfe5ee1c9412f">appendList</a>(&amp;schema, spec.<a class="code" href="structTableSpec.html#a23e0ef8f47f517d45482765038646975">nColumn</a>, spec.<a class="code" href="structTableSpec.html#addd54e64803788d94c0c11531d56ca28">azContentColumn</a>);
<a name="l02921"></a>02921   <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;schema, <span class="stringliteral">&quot;)&quot;</span>);
<a name="l02922"></a>02922   rc = <a class="code" href="fts2_8c.html#a39d956ab682bbd568f87016368f26aee">sql_exec</a>(db, spec.<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a>, spec.<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>, <a class="code" href="fts2_8c.html#ab18184660d40766ca94505dbf1acaf5f">stringBufferData</a>(&amp;schema));
<a name="l02923"></a>02923   <a class="code" href="fts2_8c.html#a785a73228d39f5c83891bdd56ced4e35">stringBufferDestroy</a>(&amp;schema);
<a name="l02924"></a>02924   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> out;
<a name="l02925"></a>02925 
<a name="l02926"></a>02926   rc = <a class="code" href="fts2_8c.html#a39d956ab682bbd568f87016368f26aee">sql_exec</a>(db, spec.<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a>, spec.<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>,
<a name="l02927"></a>02927                 <span class="stringliteral">&quot;create table %_segments(block blob);&quot;</span>);
<a name="l02928"></a>02928   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> out;
<a name="l02929"></a>02929 
<a name="l02930"></a>02930   rc = <a class="code" href="fts2_8c.html#a39d956ab682bbd568f87016368f26aee">sql_exec</a>(db, spec.<a class="code" href="structTableSpec.html#ad0c1fcfe50d62b2197758f8563fddac7">zDb</a>, spec.<a class="code" href="structTableSpec.html#a93fc65591b3ad418e167022560b105bf">zName</a>,
<a name="l02931"></a>02931                 <span class="stringliteral">&quot;create table %_segdir(&quot;</span>
<a name="l02932"></a>02932                 <span class="stringliteral">&quot;  level integer,&quot;</span>
<a name="l02933"></a>02933                 <span class="stringliteral">&quot;  idx integer,&quot;</span>
<a name="l02934"></a>02934                 <span class="stringliteral">&quot;  start_block integer,&quot;</span>
<a name="l02935"></a>02935                 <span class="stringliteral">&quot;  leaves_end_block integer,&quot;</span>
<a name="l02936"></a>02936                 <span class="stringliteral">&quot;  end_block integer,&quot;</span>
<a name="l02937"></a>02937                 <span class="stringliteral">&quot;  root blob,&quot;</span>
<a name="l02938"></a>02938                 <span class="stringliteral">&quot;  primary key(level, idx)&quot;</span>
<a name="l02939"></a>02939                 <span class="stringliteral">&quot;);&quot;</span>);
<a name="l02940"></a>02940   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> out;
<a name="l02941"></a>02941 
<a name="l02942"></a>02942   rc = <a class="code" href="fts2_8c.html#a63df5907f7754ab312551a2408434a79">constructVtab</a>(db, (<a class="code" href="structfts2Hash.html">fts2Hash</a> *)pAux, &amp;spec, ppVTab, pzErr);
<a name="l02943"></a>02943 
<a name="l02944"></a>02944 out:
<a name="l02945"></a>02945   <a class="code" href="fts2_8c.html#a558f389157af9866b165a9f1138d077d">clearTableSpec</a>(&amp;spec);
<a name="l02946"></a>02946   <span class="keywordflow">return</span> rc;
<a name="l02947"></a>02947 }
<a name="l02948"></a>02948 
<a name="l02949"></a>02949 <span class="comment">/* Decide how to handle an SQL query. */</span>
<a name="l02950"></a><a class="code" href="fts2_8c.html#abf18e0da44ece3b370a714c8e95e2de6">02950</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#abf18e0da44ece3b370a714c8e95e2de6">fulltextBestIndex</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVTab, <a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> *pInfo){
<a name="l02951"></a>02951   <span class="keywordtype">int</span> i;
<a name="l02952"></a>02952   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 BestIndex\n&quot;</span>));
<a name="l02953"></a>02953 
<a name="l02954"></a>02954   <span class="keywordflow">for</span>(i=0; i&lt;pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#ae861993a30ce914a5214eab2579d935a">nConstraint</a>; ++i){
<a name="l02955"></a>02955     <span class="keyword">const</span> <span class="keyword">struct </span>sqlite3_index_constraint *pConstraint;
<a name="l02956"></a>02956     pConstraint = &amp;pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a>[i];
<a name="l02957"></a>02957     <span class="keywordflow">if</span>( pConstraint-&gt;usable ) {
<a name="l02958"></a>02958       <span class="keywordflow">if</span>( pConstraint-&gt;iColumn==-1 &amp;&amp;
<a name="l02959"></a>02959           pConstraint-&gt;op==<a class="code" href="sqlite3_8h.html#a82727c6d3191174cb4e900a70a3434a4">SQLITE_INDEX_CONSTRAINT_EQ</a> ){
<a name="l02960"></a>02960         pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a> = <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ecadfa9dc6cb33447260116307a64a3c657">QUERY_ROWID</a>;      <span class="comment">/* lookup by rowid */</span>
<a name="l02961"></a>02961         <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 QUERY_ROWID\n&quot;</span>));
<a name="l02962"></a>02962       } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pConstraint-&gt;iColumn&gt;=0 &amp;&amp;
<a name="l02963"></a>02963                  pConstraint-&gt;op==<a class="code" href="sqlite3_8h.html#a5f5c5144477960f96f6d49bce0598e9a">SQLITE_INDEX_CONSTRAINT_MATCH</a> ){
<a name="l02964"></a>02964         <span class="comment">/* full-text search */</span>
<a name="l02965"></a>02965         pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a> = <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a> + pConstraint-&gt;iColumn;
<a name="l02966"></a>02966         <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 QUERY_FULLTEXT %d\n&quot;</span>, pConstraint-&gt;iColumn));
<a name="l02967"></a>02967       } <span class="keywordflow">else</span> <span class="keywordflow">continue</span>;
<a name="l02968"></a>02968 
<a name="l02969"></a>02969       pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a79b8a969dd7d582fc2ea3c0fbc5adb56">aConstraintUsage</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint__usage.html#a2cbf680033c2937b3de226e091743a94">argvIndex</a> = 1;
<a name="l02970"></a>02970       pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a79b8a969dd7d582fc2ea3c0fbc5adb56">aConstraintUsage</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint__usage.html#ad07fa17d30e4fb3abe23ceaf84edf0ef">omit</a> = 1;
<a name="l02971"></a>02971 
<a name="l02972"></a>02972       <span class="comment">/* An arbitrary value for now.</span>
<a name="l02973"></a>02973 <span class="comment">       * TODO: Perhaps rowid matches should be considered cheaper than</span>
<a name="l02974"></a>02974 <span class="comment">       * full-text searches. */</span>
<a name="l02975"></a>02975       pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#aa8b4fe1d2ee38aab57ba5e1da00d7830">estimatedCost</a> = 1.0;   
<a name="l02976"></a>02976 
<a name="l02977"></a>02977       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02978"></a>02978     }
<a name="l02979"></a>02979   }
<a name="l02980"></a>02980   pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a> = <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">QUERY_GENERIC</a>;
<a name="l02981"></a>02981   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02982"></a>02982 }
<a name="l02983"></a>02983 
<a name="l02984"></a><a class="code" href="fts2_8c.html#a8314ee27dd1e598b803db35bf1aa393d">02984</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a8314ee27dd1e598b803db35bf1aa393d">fulltextDisconnect</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVTab){
<a name="l02985"></a>02985   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Disconnect %p\n&quot;</span>, pVTab));
<a name="l02986"></a>02986   <a class="code" href="fts2_8c.html#aec311e3893b552f3ae7b70311bb70280">fulltext_vtab_destroy</a>((<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVTab);
<a name="l02987"></a>02987   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02988"></a>02988 }
<a name="l02989"></a>02989 
<a name="l02990"></a><a class="code" href="fts2_8c.html#ace0e89f70928f42ce6dc7769c8309ba6">02990</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ace0e89f70928f42ce6dc7769c8309ba6">fulltextDestroy</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVTab){
<a name="l02991"></a>02991   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVTab;
<a name="l02992"></a>02992   <span class="keywordtype">int</span> rc;
<a name="l02993"></a>02993 
<a name="l02994"></a>02994   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Destroy %p\n&quot;</span>, pVTab));
<a name="l02995"></a>02995   rc = <a class="code" href="fts2_8c.html#a39d956ab682bbd568f87016368f26aee">sql_exec</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>,
<a name="l02996"></a>02996                 <span class="stringliteral">&quot;drop table if exists %_content;&quot;</span>
<a name="l02997"></a>02997                 <span class="stringliteral">&quot;drop table if exists %_segments;&quot;</span>
<a name="l02998"></a>02998                 <span class="stringliteral">&quot;drop table if exists %_segdir;&quot;</span>
<a name="l02999"></a>02999                 );
<a name="l03000"></a>03000   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03001"></a>03001 
<a name="l03002"></a>03002   <a class="code" href="fts2_8c.html#aec311e3893b552f3ae7b70311bb70280">fulltext_vtab_destroy</a>((<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVTab);
<a name="l03003"></a>03003   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03004"></a>03004 }
<a name="l03005"></a>03005 
<a name="l03006"></a><a class="code" href="fts2_8c.html#a124d1580023f422308936a6fad63ce4f">03006</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a124d1580023f422308936a6fad63ce4f">fulltextOpen</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVTab, <a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> **ppCursor){
<a name="l03007"></a>03007   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c;
<a name="l03008"></a>03008 
<a name="l03009"></a>03009   c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a>));
<a name="l03010"></a>03010   <span class="keywordflow">if</span>( c ){
<a name="l03011"></a>03011     memset(c, 0, <span class="keyword">sizeof</span>(<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a>));
<a name="l03012"></a>03012     <span class="comment">/* sqlite will initialize c-&gt;base */</span>
<a name="l03013"></a>03013     *ppCursor = &amp;c-&gt;<a class="code" href="structfulltext__cursor.html#a81a33bdfcda3fbe7a0170224d8442a5c">base</a>;
<a name="l03014"></a>03014     <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Open %p: %p\n&quot;</span>, pVTab, c));
<a name="l03015"></a>03015     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03016"></a>03016   }<span class="keywordflow">else</span>{
<a name="l03017"></a>03017     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l03018"></a>03018   }
<a name="l03019"></a>03019 }
<a name="l03020"></a>03020 
<a name="l03021"></a>03021 
<a name="l03022"></a>03022 <span class="comment">/* Free all of the dynamically allocated memory held by *q</span>
<a name="l03023"></a>03023 <span class="comment">*/</span>
<a name="l03024"></a><a class="code" href="fts2_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">03024</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(<a class="code" href="structQuery.html">Query</a> *q){
<a name="l03025"></a>03025   <span class="keywordtype">int</span> i;
<a name="l03026"></a>03026   <span class="keywordflow">for</span>(i = 0; i &lt; q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>; ++i){
<a name="l03027"></a>03027     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[i].<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>);
<a name="l03028"></a>03028   }
<a name="l03029"></a>03029   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>);
<a name="l03030"></a>03030   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(q);
<a name="l03031"></a>03031 }
<a name="l03032"></a>03032 
<a name="l03033"></a>03033 <span class="comment">/* Free all of the dynamically allocated memory held by the</span>
<a name="l03034"></a>03034 <span class="comment">** Snippet</span>
<a name="l03035"></a>03035 <span class="comment">*/</span>
<a name="l03036"></a><a class="code" href="fts2_8c.html#ac4854671b9ca8b41ca0f7bd78f090eee">03036</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#ac4854671b9ca8b41ca0f7bd78f090eee">snippetClear</a>(<a class="code" href="structSnippet.html">Snippet</a> *p){
<a name="l03037"></a>03037   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>);
<a name="l03038"></a>03038   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p-&gt;<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a>);
<a name="l03039"></a>03039   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p-&gt;<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a>);
<a name="l03040"></a>03040   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(p);
<a name="l03041"></a>03041 }
<a name="l03042"></a>03042 <span class="comment">/*</span>
<a name="l03043"></a>03043 <span class="comment">** Append a single entry to the p-&gt;aMatch[] log.</span>
<a name="l03044"></a>03044 <span class="comment">*/</span>
<a name="l03045"></a><a class="code" href="fts2_8c.html#a656691e1d431166d866f0ce903aa7dd0">03045</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a656691e1d431166d866f0ce903aa7dd0">snippetAppendMatch</a>(
<a name="l03046"></a>03046   <a class="code" href="structSnippet.html">Snippet</a> *p,               <span class="comment">/* Append the entry to this snippet */</span>
<a name="l03047"></a>03047   <span class="keywordtype">int</span> iCol, <span class="keywordtype">int</span> iTerm,      <span class="comment">/* The column and query term */</span>
<a name="l03048"></a>03048   <span class="keywordtype">int</span> iStart, <span class="keywordtype">int</span> nByte     <span class="comment">/* Offset and size of the match */</span>
<a name="l03049"></a>03049 ){
<a name="l03050"></a>03050   <span class="keywordtype">int</span> i;
<a name="l03051"></a>03051   <span class="keyword">struct </span>snippetMatch *pMatch;
<a name="l03052"></a>03052   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>+1&gt;=p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a> ){
<a name="l03053"></a>03053     p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a> = p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a>*2 + 10;
<a name="l03054"></a>03054     p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a> = <a class="code" href="malloc_8c.html#a478028442c2ce4635eac464d47465c8f">sqlite3_realloc</a>(p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>, p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a>*<span class="keyword">sizeof</span>(p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>[0]) );
<a name="l03055"></a>03055     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>==0 ){
<a name="l03056"></a>03056       p-&gt;<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a> = 0;
<a name="l03057"></a>03057       p-&gt;<a class="code" href="structSnippet.html#a8bc06d28ac5243d2919b1b8e9e7fa3d6">nAlloc</a> = 0;
<a name="l03058"></a>03058       <span class="keywordflow">return</span>;
<a name="l03059"></a>03059     }
<a name="l03060"></a>03060   }
<a name="l03061"></a>03061   i = p-&gt;<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>++;
<a name="l03062"></a>03062   pMatch = &amp;p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>[i];
<a name="l03063"></a>03063   pMatch-&gt;iCol = iCol;
<a name="l03064"></a>03064   pMatch-&gt;iTerm = iTerm;
<a name="l03065"></a>03065   pMatch-&gt;iStart = iStart;
<a name="l03066"></a>03066   pMatch-&gt;nByte = nByte;
<a name="l03067"></a>03067 }
<a name="l03068"></a>03068 
<a name="l03069"></a>03069 <span class="comment">/*</span>
<a name="l03070"></a>03070 <span class="comment">** Sizing information for the circular buffer used in snippetOffsetsOfColumn()</span>
<a name="l03071"></a>03071 <span class="comment">*/</span>
<a name="l03072"></a><a class="code" href="fts2_8c.html#a20cf8dab9e5fb243cdfea7fb858f15aa">03072</a> <span class="preprocessor">#define FTS2_ROTOR_SZ   (32)</span>
<a name="l03073"></a><a class="code" href="fts2_8c.html#a2abb7f522ffa7a6a88fe38c371f641cd">03073</a> <span class="preprocessor"></span><span class="preprocessor">#define FTS2_ROTOR_MASK (FTS2_ROTOR_SZ-1)</span>
<a name="l03074"></a>03074 <span class="preprocessor"></span>
<a name="l03075"></a>03075 <span class="comment">/*</span>
<a name="l03076"></a>03076 <span class="comment">** Add entries to pSnippet-&gt;aMatch[] for every match that occurs against</span>
<a name="l03077"></a>03077 <span class="comment">** document zDoc[0..nDoc-1] which is stored in column iColumn.</span>
<a name="l03078"></a>03078 <span class="comment">*/</span>
<a name="l03079"></a><a class="code" href="fts2_8c.html#af987482c53c99bf0c1222b650f7ad533">03079</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#af987482c53c99bf0c1222b650f7ad533">snippetOffsetsOfColumn</a>(
<a name="l03080"></a>03080   <a class="code" href="structQuery.html">Query</a> *pQuery,
<a name="l03081"></a>03081   <a class="code" href="structSnippet.html">Snippet</a> *pSnippet,
<a name="l03082"></a>03082   <span class="keywordtype">int</span> iColumn,
<a name="l03083"></a>03083   <span class="keyword">const</span> <span class="keywordtype">char</span> *zDoc,
<a name="l03084"></a>03084   <span class="keywordtype">int</span> nDoc
<a name="l03085"></a>03085 ){
<a name="l03086"></a>03086   <span class="keyword">const</span> <a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *pTModule;  <span class="comment">/* The tokenizer module */</span>
<a name="l03087"></a>03087   <a class="code" href="structsqlite3__tokenizer.html">sqlite3_tokenizer</a> *pTokenizer;             <span class="comment">/* The specific tokenizer */</span>
<a name="l03088"></a>03088   <a class="code" href="structsqlite3__tokenizer__cursor.html">sqlite3_tokenizer_cursor</a> *pTCursor;        <span class="comment">/* Tokenizer cursor */</span>
<a name="l03089"></a>03089   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *pVtab;                <span class="comment">/* The full text index */</span>
<a name="l03090"></a>03090   <span class="keywordtype">int</span> nColumn;                         <span class="comment">/* Number of columns in the index */</span>
<a name="l03091"></a>03091   <span class="keyword">const</span> <a class="code" href="structQueryTerm.html">QueryTerm</a> *aTerm;              <span class="comment">/* Query string terms */</span>
<a name="l03092"></a>03092   <span class="keywordtype">int</span> nTerm;                           <span class="comment">/* Number of query string terms */</span>  
<a name="l03093"></a>03093   <span class="keywordtype">int</span> i, j;                            <span class="comment">/* Loop counters */</span>
<a name="l03094"></a>03094   <span class="keywordtype">int</span> rc;                              <span class="comment">/* Return code */</span>
<a name="l03095"></a>03095   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="lstrlib_8c.html#a52a45835b75e5d31ec66421456bbb728">match</a>, prevMatch;       <span class="comment">/* Phrase search bitmasks */</span>
<a name="l03096"></a>03096   <span class="keyword">const</span> <span class="keywordtype">char</span> *zToken;                  <span class="comment">/* Next token from the tokenizer */</span>
<a name="l03097"></a>03097   <span class="keywordtype">int</span> nToken;                          <span class="comment">/* Size of zToken */</span>
<a name="l03098"></a>03098   <span class="keywordtype">int</span> iBegin, iEnd, iPos;              <span class="comment">/* Offsets of beginning and end */</span>
<a name="l03099"></a>03099 
<a name="l03100"></a>03100   <span class="comment">/* The following variables keep a circular buffer of the last</span>
<a name="l03101"></a>03101 <span class="comment">  ** few tokens */</span>
<a name="l03102"></a>03102   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iRotor = 0;             <span class="comment">/* Index of current token */</span>
<a name="l03103"></a>03103   <span class="keywordtype">int</span> iRotorBegin[<a class="code" href="fts2_8c.html#a20cf8dab9e5fb243cdfea7fb858f15aa">FTS2_ROTOR_SZ</a>];      <span class="comment">/* Beginning offset of token */</span>
<a name="l03104"></a>03104   <span class="keywordtype">int</span> iRotorLen[<a class="code" href="fts2_8c.html#a20cf8dab9e5fb243cdfea7fb858f15aa">FTS2_ROTOR_SZ</a>];        <span class="comment">/* Length of token */</span>
<a name="l03105"></a>03105 
<a name="l03106"></a>03106   pVtab = pQuery-&gt;<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a>;
<a name="l03107"></a>03107   nColumn = pVtab-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>;
<a name="l03108"></a>03108   pTokenizer = pVtab-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>;
<a name="l03109"></a>03109   pTModule = pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>;
<a name="l03110"></a>03110   rc = pTModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a44ab0f8ad43cd5900d5ab59f899f6acd">xOpen</a>(pTokenizer, zDoc, nDoc, &amp;pTCursor);
<a name="l03111"></a>03111   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span>;
<a name="l03112"></a>03112   pTCursor-&gt;<a class="code" href="structsqlite3__tokenizer__cursor.html#aa0ec54f843cb47b54daa4e8c8c6013c0">pTokenizer</a> = pTokenizer;
<a name="l03113"></a>03113   aTerm = pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>;
<a name="l03114"></a>03114   nTerm = pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;
<a name="l03115"></a>03115   <span class="keywordflow">if</span>( nTerm&gt;=<a class="code" href="fts2_8c.html#a20cf8dab9e5fb243cdfea7fb858f15aa">FTS2_ROTOR_SZ</a> ){
<a name="l03116"></a>03116     nTerm = <a class="code" href="fts2_8c.html#a20cf8dab9e5fb243cdfea7fb858f15aa">FTS2_ROTOR_SZ</a> - 1;
<a name="l03117"></a>03117   }
<a name="l03118"></a>03118   prevMatch = 0;
<a name="l03119"></a>03119   <span class="keywordflow">while</span>(1){
<a name="l03120"></a>03120     rc = pTModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a13443eb8fac89e3031f601a38564e2cc">xNext</a>(pTCursor, &amp;zToken, &amp;nToken, &amp;iBegin, &amp;iEnd, &amp;iPos);
<a name="l03121"></a>03121     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">break</span>;
<a name="l03122"></a>03122     iRotorBegin[iRotor&amp;<a class="code" href="fts2_8c.html#a2abb7f522ffa7a6a88fe38c371f641cd">FTS2_ROTOR_MASK</a>] = iBegin;
<a name="l03123"></a>03123     iRotorLen[iRotor&amp;<a class="code" href="fts2_8c.html#a2abb7f522ffa7a6a88fe38c371f641cd">FTS2_ROTOR_MASK</a>] = iEnd-iBegin;
<a name="l03124"></a>03124     match = 0;
<a name="l03125"></a>03125     <span class="keywordflow">for</span>(i=0; i&lt;nTerm; i++){
<a name="l03126"></a>03126       <span class="keywordtype">int</span> iCol;
<a name="l03127"></a>03127       iCol = aTerm[i].<a class="code" href="structQueryTerm.html#a71a4c3b5b3246a6e2e7347d0d71edf2c">iColumn</a>;
<a name="l03128"></a>03128       <span class="keywordflow">if</span>( iCol&gt;=0 &amp;&amp; iCol&lt;nColumn &amp;&amp; iCol!=iColumn ) <span class="keywordflow">continue</span>;
<a name="l03129"></a>03129       <span class="keywordflow">if</span>( aTerm[i].nTerm&gt;nToken ) <span class="keywordflow">continue</span>;
<a name="l03130"></a>03130       <span class="keywordflow">if</span>( !aTerm[i].isPrefix &amp;&amp; aTerm[i].nTerm&lt;nToken ) <span class="keywordflow">continue</span>;
<a name="l03131"></a>03131       assert( aTerm[i].nTerm&lt;=nToken );
<a name="l03132"></a>03132       <span class="keywordflow">if</span>( memcmp(aTerm[i].pTerm, zToken, aTerm[i].nTerm) ) <span class="keywordflow">continue</span>;
<a name="l03133"></a>03133       <span class="keywordflow">if</span>( aTerm[i].iPhrase&gt;1 &amp;&amp; (prevMatch &amp; (1&lt;&lt;i))==0 ) <span class="keywordflow">continue</span>;
<a name="l03134"></a>03134       match |= 1&lt;&lt;i;
<a name="l03135"></a>03135       <span class="keywordflow">if</span>( i==nTerm-1 || aTerm[i+1].iPhrase==1 ){
<a name="l03136"></a>03136         <span class="keywordflow">for</span>(j=aTerm[i].iPhrase-1; j&gt;=0; j--){
<a name="l03137"></a>03137           <span class="keywordtype">int</span> k = (iRotor-j) &amp; <a class="code" href="fts2_8c.html#a2abb7f522ffa7a6a88fe38c371f641cd">FTS2_ROTOR_MASK</a>;
<a name="l03138"></a>03138           <a class="code" href="fts2_8c.html#a656691e1d431166d866f0ce903aa7dd0">snippetAppendMatch</a>(pSnippet, iColumn, i-j,
<a name="l03139"></a>03139                 iRotorBegin[k], iRotorLen[k]);
<a name="l03140"></a>03140         }
<a name="l03141"></a>03141       }
<a name="l03142"></a>03142     }
<a name="l03143"></a>03143     prevMatch = match&lt;&lt;1;
<a name="l03144"></a>03144     iRotor++;
<a name="l03145"></a>03145   }
<a name="l03146"></a>03146   pTModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#ad8bb92424245a38583cbaf36b509efd6">xClose</a>(pTCursor);  
<a name="l03147"></a>03147 }
<a name="l03148"></a>03148 
<a name="l03149"></a>03149 
<a name="l03150"></a>03150 <span class="comment">/*</span>
<a name="l03151"></a>03151 <span class="comment">** Compute all offsets for the current row of the query.  </span>
<a name="l03152"></a>03152 <span class="comment">** If the offsets have already been computed, this routine is a no-op.</span>
<a name="l03153"></a>03153 <span class="comment">*/</span>
<a name="l03154"></a><a class="code" href="fts2_8c.html#a59f88d7e78ca82c2ded0ad6d0dc761cf">03154</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a59f88d7e78ca82c2ded0ad6d0dc761cf">snippetAllOffsets</a>(<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *p){
<a name="l03155"></a>03155   <span class="keywordtype">int</span> nColumn;
<a name="l03156"></a>03156   <span class="keywordtype">int</span> iColumn, i;
<a name="l03157"></a>03157   <span class="keywordtype">int</span> iFirst, iLast;
<a name="l03158"></a>03158   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *pFts;
<a name="l03159"></a>03159 
<a name="l03160"></a>03160   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a> ) <span class="keywordflow">return</span>;
<a name="l03161"></a>03161   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>.<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>==0 ) <span class="keywordflow">return</span>;
<a name="l03162"></a>03162   pFts = p-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>.<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a>;
<a name="l03163"></a>03163   nColumn = pFts-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>;
<a name="l03164"></a>03164   iColumn = (p-&gt;<a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a> - <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a>);
<a name="l03165"></a>03165   <span class="keywordflow">if</span>( iColumn&lt;0 || iColumn&gt;=nColumn ){
<a name="l03166"></a>03166     iFirst = 0;
<a name="l03167"></a>03167     iLast = nColumn-1;
<a name="l03168"></a>03168   }<span class="keywordflow">else</span>{
<a name="l03169"></a>03169     iFirst = iColumn;
<a name="l03170"></a>03170     iLast = iColumn;
<a name="l03171"></a>03171   }
<a name="l03172"></a>03172   <span class="keywordflow">for</span>(i=iFirst; i&lt;=iLast; i++){
<a name="l03173"></a>03173     <span class="keyword">const</span> <span class="keywordtype">char</span> *zDoc;
<a name="l03174"></a>03174     <span class="keywordtype">int</span> nDoc;
<a name="l03175"></a>03175     zDoc = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#adebe4cf494727dd2e9c0d22c2a629d2f">sqlite3_column_text</a>(p-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, i+1);
<a name="l03176"></a>03176     nDoc = <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(p-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, i+1);
<a name="l03177"></a>03177     <a class="code" href="fts2_8c.html#af987482c53c99bf0c1222b650f7ad533">snippetOffsetsOfColumn</a>(&amp;p-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>, &amp;p-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>, i, zDoc, nDoc);
<a name="l03178"></a>03178   }
<a name="l03179"></a>03179 }
<a name="l03180"></a>03180 
<a name="l03181"></a>03181 <span class="comment">/*</span>
<a name="l03182"></a>03182 <span class="comment">** Convert the information in the aMatch[] array of the snippet</span>
<a name="l03183"></a>03183 <span class="comment">** into the string zOffset[0..nOffset-1].</span>
<a name="l03184"></a>03184 <span class="comment">*/</span>
<a name="l03185"></a><a class="code" href="fts2_8c.html#a0be87d3def9290916cff3b6cb84f04bc">03185</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a0be87d3def9290916cff3b6cb84f04bc">snippetOffsetText</a>(<a class="code" href="structSnippet.html">Snippet</a> *p){
<a name="l03186"></a>03186   <span class="keywordtype">int</span> i;
<a name="l03187"></a>03187   <span class="keywordtype">int</span> cnt = 0;
<a name="l03188"></a>03188   <a class="code" href="structStringBuffer.html">StringBuffer</a> sb;
<a name="l03189"></a>03189   <span class="keywordtype">char</span> zBuf[200];
<a name="l03190"></a>03190   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a> ) <span class="keywordflow">return</span>;
<a name="l03191"></a>03191   <a class="code" href="fts2_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;sb);
<a name="l03192"></a>03192   <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>; i++){
<a name="l03193"></a>03193     <span class="keyword">struct </span>snippetMatch *pMatch = &amp;p-&gt;<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>[i];
<a name="l03194"></a>03194     zBuf[0] = <span class="charliteral">&apos; &apos;</span>;
<a name="l03195"></a>03195     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zBuf)-1, &amp;zBuf[cnt&gt;0], <span class="stringliteral">&quot;%d %d %d %d&quot;</span>,
<a name="l03196"></a>03196         pMatch-&gt;iCol, pMatch-&gt;iTerm, pMatch-&gt;iStart, pMatch-&gt;nByte);
<a name="l03197"></a>03197     <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zBuf);
<a name="l03198"></a>03198     cnt++;
<a name="l03199"></a>03199   }
<a name="l03200"></a>03200   p-&gt;<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a> = <a class="code" href="fts2_8c.html#ab18184660d40766ca94505dbf1acaf5f">stringBufferData</a>(&amp;sb);
<a name="l03201"></a>03201   p-&gt;<a class="code" href="structSnippet.html#a68aacd704960f6ab1c8f7de23a5d0730">nOffset</a> = <a class="code" href="fts2_8c.html#a56627c1d8b74dcf698115ca20b7accd8">stringBufferLength</a>(&amp;sb);
<a name="l03202"></a>03202 }
<a name="l03203"></a>03203 
<a name="l03204"></a>03204 <span class="comment">/*</span>
<a name="l03205"></a>03205 <span class="comment">** zDoc[0..nDoc-1] is phrase of text.  aMatch[0..nMatch-1] are a set</span>
<a name="l03206"></a>03206 <span class="comment">** of matching words some of which might be in zDoc.  zDoc is column</span>
<a name="l03207"></a>03207 <span class="comment">** number iCol.</span>
<a name="l03208"></a>03208 <span class="comment">**</span>
<a name="l03209"></a>03209 <span class="comment">** iBreak is suggested spot in zDoc where we could begin or end an</span>
<a name="l03210"></a>03210 <span class="comment">** excerpt.  Return a value similar to iBreak but possibly adjusted</span>
<a name="l03211"></a>03211 <span class="comment">** to be a little left or right so that the break point is better.</span>
<a name="l03212"></a>03212 <span class="comment">*/</span>
<a name="l03213"></a><a class="code" href="fts2_8c.html#adf761f2ec01d20bb458fa8f2f04b2246">03213</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#adf761f2ec01d20bb458fa8f2f04b2246">wordBoundary</a>(
<a name="l03214"></a>03214   <span class="keywordtype">int</span> iBreak,                   <span class="comment">/* The suggested break point */</span>
<a name="l03215"></a>03215   <span class="keyword">const</span> <span class="keywordtype">char</span> *zDoc,             <span class="comment">/* Document text */</span>
<a name="l03216"></a>03216   <span class="keywordtype">int</span> nDoc,                     <span class="comment">/* Number of bytes in zDoc[] */</span>
<a name="l03217"></a>03217   <span class="keyword">struct</span> snippetMatch *aMatch,  <span class="comment">/* Matching words */</span>
<a name="l03218"></a>03218   <span class="keywordtype">int</span> nMatch,                   <span class="comment">/* Number of entries in aMatch[] */</span>
<a name="l03219"></a>03219   <span class="keywordtype">int</span> iCol                      <span class="comment">/* The column number for zDoc[] */</span>
<a name="l03220"></a>03220 ){
<a name="l03221"></a>03221   <span class="keywordtype">int</span> i;
<a name="l03222"></a>03222   <span class="keywordflow">if</span>( iBreak&lt;=10 ){
<a name="l03223"></a>03223     <span class="keywordflow">return</span> 0;
<a name="l03224"></a>03224   }
<a name="l03225"></a>03225   <span class="keywordflow">if</span>( iBreak&gt;=nDoc-10 ){
<a name="l03226"></a>03226     <span class="keywordflow">return</span> nDoc;
<a name="l03227"></a>03227   }
<a name="l03228"></a>03228   <span class="keywordflow">for</span>(i=0; i&lt;nMatch &amp;&amp; aMatch[i].iCol&lt;iCol; i++){}
<a name="l03229"></a>03229   <span class="keywordflow">while</span>( i&lt;nMatch &amp;&amp; aMatch[i].iStart+aMatch[i].nByte&lt;iBreak ){ i++; }
<a name="l03230"></a>03230   <span class="keywordflow">if</span>( i&lt;nMatch ){
<a name="l03231"></a>03231     <span class="keywordflow">if</span>( aMatch[i].iStart&lt;iBreak+10 ){
<a name="l03232"></a>03232       <span class="keywordflow">return</span> aMatch[i].iStart;
<a name="l03233"></a>03233     }
<a name="l03234"></a>03234     <span class="keywordflow">if</span>( i&gt;0 &amp;&amp; aMatch[i-1].iStart+aMatch[i-1].nByte&gt;=iBreak ){
<a name="l03235"></a>03235       <span class="keywordflow">return</span> aMatch[i-1].iStart;
<a name="l03236"></a>03236     }
<a name="l03237"></a>03237   }
<a name="l03238"></a>03238   <span class="keywordflow">for</span>(i=1; i&lt;=10; i++){
<a name="l03239"></a>03239     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(zDoc[iBreak-i]) ){
<a name="l03240"></a>03240       <span class="keywordflow">return</span> iBreak - i + 1;
<a name="l03241"></a>03241     }
<a name="l03242"></a>03242     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a0e5b3fb0c51e133d16fcacd45f4a5539">safe_isspace</a>(zDoc[iBreak+i]) ){
<a name="l03243"></a>03243       <span class="keywordflow">return</span> iBreak + i + 1;
<a name="l03244"></a>03244     }
<a name="l03245"></a>03245   }
<a name="l03246"></a>03246   <span class="keywordflow">return</span> iBreak;
<a name="l03247"></a>03247 }
<a name="l03248"></a>03248 
<a name="l03249"></a>03249 
<a name="l03250"></a>03250 
<a name="l03251"></a>03251 <span class="comment">/*</span>
<a name="l03252"></a>03252 <span class="comment">** Allowed values for Snippet.aMatch[].snStatus</span>
<a name="l03253"></a>03253 <span class="comment">*/</span>
<a name="l03254"></a><a class="code" href="fts2_8c.html#af1ddee38ad072b0e25eded90ed70b4ff">03254</a> <span class="preprocessor">#define SNIPPET_IGNORE  0   </span><span class="comment">/* It is ok to omit this match from the snippet */</span>
<a name="l03255"></a><a class="code" href="fts2_8c.html#a102500074009acfa3810201ce27c0e15">03255</a> <span class="preprocessor">#define SNIPPET_DESIRED 1   </span><span class="comment">/* We want to include this match in the snippet */</span>
<a name="l03256"></a>03256 
<a name="l03257"></a>03257 <span class="comment">/*</span>
<a name="l03258"></a>03258 <span class="comment">** Generate the text of a snippet.</span>
<a name="l03259"></a>03259 <span class="comment">*/</span>
<a name="l03260"></a><a class="code" href="fts2_8c.html#a27d12dfb6aab92e44fc0af3dc2a72ad7">03260</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a27d12dfb6aab92e44fc0af3dc2a72ad7">snippetText</a>(
<a name="l03261"></a>03261   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *pCursor,   <span class="comment">/* The cursor we need the snippet for */</span>
<a name="l03262"></a>03262   <span class="keyword">const</span> <span class="keywordtype">char</span> *zStartMark,     <span class="comment">/* Markup to appear before each match */</span>
<a name="l03263"></a>03263   <span class="keyword">const</span> <span class="keywordtype">char</span> *zEndMark,       <span class="comment">/* Markup to appear after each match */</span>
<a name="l03264"></a>03264   <span class="keyword">const</span> <span class="keywordtype">char</span> *zEllipsis       <span class="comment">/* Ellipsis mark */</span>
<a name="l03265"></a>03265 ){
<a name="l03266"></a>03266   <span class="keywordtype">int</span> i, j;
<a name="l03267"></a>03267   <span class="keyword">struct </span>snippetMatch *aMatch;
<a name="l03268"></a>03268   <span class="keywordtype">int</span> nMatch;
<a name="l03269"></a>03269   <span class="keywordtype">int</span> nDesired;
<a name="l03270"></a>03270   <a class="code" href="structStringBuffer.html">StringBuffer</a> sb;
<a name="l03271"></a>03271   <span class="keywordtype">int</span> tailCol;
<a name="l03272"></a>03272   <span class="keywordtype">int</span> tailOffset;
<a name="l03273"></a>03273   <span class="keywordtype">int</span> iCol;
<a name="l03274"></a>03274   <span class="keywordtype">int</span> nDoc;
<a name="l03275"></a>03275   <span class="keyword">const</span> <span class="keywordtype">char</span> *zDoc;
<a name="l03276"></a>03276   <span class="keywordtype">int</span> iStart, iEnd;
<a name="l03277"></a>03277   <span class="keywordtype">int</span> tailEllipsis = 0;
<a name="l03278"></a>03278   <span class="keywordtype">int</span> iMatch;
<a name="l03279"></a>03279   
<a name="l03280"></a>03280 
<a name="l03281"></a>03281   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a>);
<a name="l03282"></a>03282   pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a> = 0;
<a name="l03283"></a>03283   aMatch = pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a7e545c9636fb12cc46310c000bc8fef0">aMatch</a>;
<a name="l03284"></a>03284   nMatch = pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a42c217ffb0b5868c93aa976201192e42">nMatch</a>;
<a name="l03285"></a>03285   <a class="code" href="fts2_8c.html#af53d41e9c022beb0601be19642881765">initStringBuffer</a>(&amp;sb);
<a name="l03286"></a>03286 
<a name="l03287"></a>03287   <span class="keywordflow">for</span>(i=0; i&lt;nMatch; i++){
<a name="l03288"></a>03288     aMatch[i].snStatus = <a class="code" href="fts1_8c.html#af1ddee38ad072b0e25eded90ed70b4ff">SNIPPET_IGNORE</a>;
<a name="l03289"></a>03289   }
<a name="l03290"></a>03290   nDesired = 0;
<a name="l03291"></a>03291   <span class="keywordflow">for</span>(i=0; i&lt;pCursor-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>.<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>; i++){
<a name="l03292"></a>03292     <span class="keywordflow">for</span>(j=0; j&lt;nMatch; j++){
<a name="l03293"></a>03293       <span class="keywordflow">if</span>( aMatch[j].iTerm==i ){
<a name="l03294"></a>03294         aMatch[j].snStatus = <a class="code" href="fts1_8c.html#a102500074009acfa3810201ce27c0e15">SNIPPET_DESIRED</a>;
<a name="l03295"></a>03295         nDesired++;
<a name="l03296"></a>03296         <span class="keywordflow">break</span>;
<a name="l03297"></a>03297       }
<a name="l03298"></a>03298     }
<a name="l03299"></a>03299   }
<a name="l03300"></a>03300 
<a name="l03301"></a>03301   iMatch = 0;
<a name="l03302"></a>03302   tailCol = -1;
<a name="l03303"></a>03303   tailOffset = 0;
<a name="l03304"></a>03304   <span class="keywordflow">for</span>(i=0; i&lt;nMatch &amp;&amp; nDesired&gt;0; i++){
<a name="l03305"></a>03305     <span class="keywordflow">if</span>( aMatch[i].snStatus!=<a class="code" href="fts1_8c.html#a102500074009acfa3810201ce27c0e15">SNIPPET_DESIRED</a> ) <span class="keywordflow">continue</span>;
<a name="l03306"></a>03306     nDesired--;
<a name="l03307"></a>03307     iCol = aMatch[i].iCol;
<a name="l03308"></a>03308     zDoc = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#adebe4cf494727dd2e9c0d22c2a629d2f">sqlite3_column_text</a>(pCursor-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, iCol+1);
<a name="l03309"></a>03309     nDoc = <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(pCursor-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, iCol+1);
<a name="l03310"></a>03310     iStart = aMatch[i].iStart - 40;
<a name="l03311"></a>03311     iStart = <a class="code" href="fts2_8c.html#adf761f2ec01d20bb458fa8f2f04b2246">wordBoundary</a>(iStart, zDoc, nDoc, aMatch, nMatch, iCol);
<a name="l03312"></a>03312     <span class="keywordflow">if</span>( iStart&lt;=10 ){
<a name="l03313"></a>03313       iStart = 0;
<a name="l03314"></a>03314     }
<a name="l03315"></a>03315     <span class="keywordflow">if</span>( iCol==tailCol &amp;&amp; iStart&lt;=tailOffset+20 ){
<a name="l03316"></a>03316       iStart = tailOffset;
<a name="l03317"></a>03317     }
<a name="l03318"></a>03318     <span class="keywordflow">if</span>( (iCol!=tailCol &amp;&amp; tailCol&gt;=0) || iStart!=tailOffset ){
<a name="l03319"></a>03319       <a class="code" href="fts2_8c.html#a5afad57e102ddaa7772992b7a69bc6a6">trimWhiteSpace</a>(&amp;sb);
<a name="l03320"></a>03320       <a class="code" href="fts2_8c.html#ad5cddce8600a160495ae0fa2f778fde4">appendWhiteSpace</a>(&amp;sb);
<a name="l03321"></a>03321       <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zEllipsis);
<a name="l03322"></a>03322       <a class="code" href="fts2_8c.html#ad5cddce8600a160495ae0fa2f778fde4">appendWhiteSpace</a>(&amp;sb);
<a name="l03323"></a>03323     }
<a name="l03324"></a>03324     iEnd = aMatch[i].iStart + aMatch[i].nByte + 40;
<a name="l03325"></a>03325     iEnd = <a class="code" href="fts2_8c.html#adf761f2ec01d20bb458fa8f2f04b2246">wordBoundary</a>(iEnd, zDoc, nDoc, aMatch, nMatch, iCol);
<a name="l03326"></a>03326     <span class="keywordflow">if</span>( iEnd&gt;=nDoc-10 ){
<a name="l03327"></a>03327       iEnd = nDoc;
<a name="l03328"></a>03328       tailEllipsis = 0;
<a name="l03329"></a>03329     }<span class="keywordflow">else</span>{
<a name="l03330"></a>03330       tailEllipsis = 1;
<a name="l03331"></a>03331     }
<a name="l03332"></a>03332     <span class="keywordflow">while</span>( iMatch&lt;nMatch &amp;&amp; aMatch[iMatch].iCol&lt;iCol ){ iMatch++; }
<a name="l03333"></a>03333     <span class="keywordflow">while</span>( iStart&lt;iEnd ){
<a name="l03334"></a>03334       <span class="keywordflow">while</span>( iMatch&lt;nMatch &amp;&amp; aMatch[iMatch].iStart&lt;iStart
<a name="l03335"></a>03335              &amp;&amp; aMatch[iMatch].iCol&lt;=iCol ){
<a name="l03336"></a>03336         iMatch++;
<a name="l03337"></a>03337       }
<a name="l03338"></a>03338       <span class="keywordflow">if</span>( iMatch&lt;nMatch &amp;&amp; aMatch[iMatch].iStart&lt;iEnd
<a name="l03339"></a>03339              &amp;&amp; aMatch[iMatch].iCol==iCol ){
<a name="l03340"></a>03340         <a class="code" href="fts2_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(&amp;sb, &amp;zDoc[iStart], aMatch[iMatch].iStart - iStart);
<a name="l03341"></a>03341         iStart = aMatch[iMatch].iStart;
<a name="l03342"></a>03342         <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zStartMark);
<a name="l03343"></a>03343         <a class="code" href="fts2_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(&amp;sb, &amp;zDoc[iStart], aMatch[iMatch].nByte);
<a name="l03344"></a>03344         <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zEndMark);
<a name="l03345"></a>03345         iStart += aMatch[iMatch].nByte;
<a name="l03346"></a>03346         <span class="keywordflow">for</span>(j=iMatch+1; j&lt;nMatch; j++){
<a name="l03347"></a>03347           <span class="keywordflow">if</span>( aMatch[j].iTerm==aMatch[iMatch].iTerm
<a name="l03348"></a>03348               &amp;&amp; aMatch[j].snStatus==<a class="code" href="fts1_8c.html#a102500074009acfa3810201ce27c0e15">SNIPPET_DESIRED</a> ){
<a name="l03349"></a>03349             nDesired--;
<a name="l03350"></a>03350             aMatch[j].snStatus = <a class="code" href="fts1_8c.html#af1ddee38ad072b0e25eded90ed70b4ff">SNIPPET_IGNORE</a>;
<a name="l03351"></a>03351           }
<a name="l03352"></a>03352         }
<a name="l03353"></a>03353       }<span class="keywordflow">else</span>{
<a name="l03354"></a>03354         <a class="code" href="fts2_8c.html#a6a5a5371f5dce9a6e1219644f8352f4a">nappend</a>(&amp;sb, &amp;zDoc[iStart], iEnd - iStart);
<a name="l03355"></a>03355         iStart = iEnd;
<a name="l03356"></a>03356       }
<a name="l03357"></a>03357     }
<a name="l03358"></a>03358     tailCol = iCol;
<a name="l03359"></a>03359     tailOffset = iEnd;
<a name="l03360"></a>03360   }
<a name="l03361"></a>03361   <a class="code" href="fts2_8c.html#a5afad57e102ddaa7772992b7a69bc6a6">trimWhiteSpace</a>(&amp;sb);
<a name="l03362"></a>03362   <span class="keywordflow">if</span>( tailEllipsis ){
<a name="l03363"></a>03363     <a class="code" href="fts2_8c.html#ad5cddce8600a160495ae0fa2f778fde4">appendWhiteSpace</a>(&amp;sb);
<a name="l03364"></a>03364     <a class="code" href="fts2_8c.html#af6508a23b62f69c4a407e2f609a051b1">append</a>(&amp;sb, zEllipsis);
<a name="l03365"></a>03365   }
<a name="l03366"></a>03366   pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a> = <a class="code" href="fts2_8c.html#ab18184660d40766ca94505dbf1acaf5f">stringBufferData</a>(&amp;sb);
<a name="l03367"></a>03367   pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a467392bb026bc056ab7c5466873f8f11">nSnippet</a> = <a class="code" href="fts2_8c.html#a56627c1d8b74dcf698115ca20b7accd8">stringBufferLength</a>(&amp;sb);
<a name="l03368"></a>03368 }
<a name="l03369"></a>03369 
<a name="l03370"></a>03370 
<a name="l03371"></a>03371 <span class="comment">/*</span>
<a name="l03372"></a>03372 <span class="comment">** Close the cursor.  For additional information see the documentation</span>
<a name="l03373"></a>03373 <span class="comment">** on the xClose method of the virtual table interface.</span>
<a name="l03374"></a>03374 <span class="comment">*/</span>
<a name="l03375"></a><a class="code" href="fts2_8c.html#ae78b3ae93fcfb9b8b2e8b4dc9a380ad7">03375</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ae78b3ae93fcfb9b8b2e8b4dc9a380ad7">fulltextClose</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor){
<a name="l03376"></a>03376   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l03377"></a>03377   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Close %p\n&quot;</span>, c));
<a name="l03378"></a>03378   <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l03379"></a>03379   <a class="code" href="fts2_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>);
<a name="l03380"></a>03380   <a class="code" href="fts2_8c.html#ac4854671b9ca8b41ca0f7bd78f090eee">snippetClear</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>);
<a name="l03381"></a>03381   <span class="keywordflow">if</span>( c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.nData!=0 ) <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ad364061ebd037f7228b3599ead044d15">reader</a>);
<a name="l03382"></a>03382   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>);
<a name="l03383"></a>03383   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(c);
<a name="l03384"></a>03384   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03385"></a>03385 }
<a name="l03386"></a>03386 
<a name="l03387"></a><a class="code" href="fts2_8c.html#a27014ab01a3b771ad685bf0a66ae0f74">03387</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a27014ab01a3b771ad685bf0a66ae0f74">fulltextNext</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor){
<a name="l03388"></a>03388   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l03389"></a>03389   <span class="keywordtype">int</span> rc;
<a name="l03390"></a>03390 
<a name="l03391"></a>03391   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Next %p\n&quot;</span>, pCursor));
<a name="l03392"></a>03392   <a class="code" href="fts2_8c.html#ac4854671b9ca8b41ca0f7bd78f090eee">snippetClear</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>);
<a name="l03393"></a>03393   <span class="keywordflow">if</span>( c-&gt;<a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a> &lt; <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a> ){
<a name="l03394"></a>03394     <span class="comment">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</span>
<a name="l03395"></a>03395     rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l03396"></a>03396     <span class="keywordflow">switch</span>( rc ){
<a name="l03397"></a>03397       <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a>:
<a name="l03398"></a>03398         c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 0;
<a name="l03399"></a>03399         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03400"></a>03400       <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>:
<a name="l03401"></a>03401         c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 1;
<a name="l03402"></a>03402         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03403"></a>03403       <span class="keywordflow">default</span>:
<a name="l03404"></a>03404         c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 1;
<a name="l03405"></a>03405         <span class="keywordflow">return</span> rc;
<a name="l03406"></a>03406     }
<a name="l03407"></a>03407   } <span class="keywordflow">else</span> {  <span class="comment">/* full-text query */</span>
<a name="l03408"></a>03408     rc = <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l03409"></a>03409     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03410"></a>03410 
<a name="l03411"></a>03411     <span class="keywordflow">if</span>( c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.nData==0 || <a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ad364061ebd037f7228b3599ead044d15">reader</a>) ){
<a name="l03412"></a>03412       c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 1;
<a name="l03413"></a>03413       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03414"></a>03414     }
<a name="l03415"></a>03415     rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, 1, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ad364061ebd037f7228b3599ead044d15">reader</a>));
<a name="l03416"></a>03416     <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ad364061ebd037f7228b3599ead044d15">reader</a>);
<a name="l03417"></a>03417     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03418"></a>03418     <span class="comment">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</span>
<a name="l03419"></a>03419     rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l03420"></a>03420     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){   <span class="comment">/* the case we expect */</span>
<a name="l03421"></a>03421       c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a> = 0;
<a name="l03422"></a>03422       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03423"></a>03423     }
<a name="l03424"></a>03424     <span class="comment">/* an error occurred; abort */</span>
<a name="l03425"></a>03425     <span class="keywordflow">return</span> rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ? <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a> : rc;
<a name="l03426"></a>03426   }
<a name="l03427"></a>03427 }
<a name="l03428"></a>03428 
<a name="l03429"></a>03429 
<a name="l03430"></a>03430 <span class="comment">/* TODO(shess) If we pushed LeafReader to the top of the file, or to</span>
<a name="l03431"></a>03431 <span class="comment">** another file, term_select() could be pushed above</span>
<a name="l03432"></a>03432 <span class="comment">** docListOfTerm().</span>
<a name="l03433"></a>03433 <span class="comment">*/</span>
<a name="l03434"></a>03434 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aa6bae5d86dd40972de224e7986a9450d">termSelect</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iColumn,
<a name="l03435"></a>03435                       <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix,
<a name="l03436"></a>03436                       <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType, <a class="code" href="structDataBuffer.html">DataBuffer</a> *out);
<a name="l03437"></a>03437 
<a name="l03438"></a>03438 <span class="comment">/* Return a DocList corresponding to the query term *pTerm.  If *pTerm</span>
<a name="l03439"></a>03439 <span class="comment">** is the first term of a phrase query, go ahead and evaluate the phrase</span>
<a name="l03440"></a>03440 <span class="comment">** query and return the doclist for the entire phrase query.</span>
<a name="l03441"></a>03441 <span class="comment">**</span>
<a name="l03442"></a>03442 <span class="comment">** The resulting DL_DOCIDS doclist is stored in pResult, which is</span>
<a name="l03443"></a>03443 <span class="comment">** overwritten.</span>
<a name="l03444"></a>03444 <span class="comment">*/</span>
<a name="l03445"></a><a class="code" href="fts2_8c.html#aa3a3b694e3e3abe6692fde268ec49cd3">03445</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aa3a3b694e3e3abe6692fde268ec49cd3">docListOfTerm</a>(
<a name="l03446"></a>03446   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,   <span class="comment">/* The full text index */</span>
<a name="l03447"></a>03447   <span class="keywordtype">int</span> iColumn,        <span class="comment">/* column to restrict to.  No restriction if &gt;=nColumn */</span>
<a name="l03448"></a>03448   <a class="code" href="structQueryTerm.html">QueryTerm</a> *pQTerm,  <span class="comment">/* Term we are looking for, or 1st term of a phrase */</span>
<a name="l03449"></a>03449   <a class="code" href="structDataBuffer.html">DataBuffer</a> *pResult <span class="comment">/* Write the result here */</span>
<a name="l03450"></a>03450 ){
<a name="l03451"></a>03451   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>, <span class="keyword">new</span>;
<a name="l03452"></a>03452   <span class="keywordtype">int</span> i, rc;
<a name="l03453"></a>03453 
<a name="l03454"></a>03454   <span class="comment">/* No phrase search if no position info. */</span>
<a name="l03455"></a>03455   assert( pQTerm-&gt;<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a>==0 || <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>!=<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a> );
<a name="l03456"></a>03456 
<a name="l03457"></a>03457   <span class="comment">/* This code should never be called with buffered updates. */</span>
<a name="l03458"></a>03458   assert( v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>&lt;0 );
<a name="l03459"></a>03459 
<a name="l03460"></a>03460   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;left, 0);
<a name="l03461"></a>03461   rc = <a class="code" href="fts2_8c.html#aa6bae5d86dd40972de224e7986a9450d">termSelect</a>(v, iColumn, pQTerm-&gt;<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>, pQTerm-&gt;<a class="code" href="structQueryTerm.html#aeeb3d5a5c0c62dc9d0966204c8cae819">nTerm</a>, pQTerm-&gt;<a class="code" href="structQueryTerm.html#a93193d71d1732930b838cb26601ee89e">isPrefix</a>,
<a name="l03462"></a>03462                   0&lt;pQTerm-&gt;<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> ? <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> : <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, &amp;left);
<a name="l03463"></a>03463   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l03464"></a>03464   <span class="keywordflow">for</span>(i=1; i&lt;=pQTerm-&gt;<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> &amp;&amp; left.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0; i++){
<a name="l03465"></a>03465     <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;right, 0);
<a name="l03466"></a>03466     rc = <a class="code" href="fts2_8c.html#aa6bae5d86dd40972de224e7986a9450d">termSelect</a>(v, iColumn, pQTerm[i].pTerm, pQTerm[i].nTerm,
<a name="l03467"></a>03467                     pQTerm[i].isPrefix, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a>, &amp;right);
<a name="l03468"></a>03468     <span class="keywordflow">if</span>( rc ){
<a name="l03469"></a>03469       <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;left);
<a name="l03470"></a>03470       <span class="keywordflow">return</span> rc;
<a name="l03471"></a>03471     }
<a name="l03472"></a>03472     <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;<span class="keyword">new</span>, 0);
<a name="l03473"></a>03473     <a class="code" href="fts2_8c.html#a1c69fcaac7f3a472f2c6bd8cb700b3c2">docListPhraseMerge</a>(left.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, left.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, right.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, right.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>,
<a name="l03474"></a>03474                        i&lt;pQTerm-&gt;nPhrase ? <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> : DL_DOCIDS, &amp;<span class="keyword">new</span>);
<a name="l03475"></a>03475     <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;left);
<a name="l03476"></a>03476     <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;right);
<a name="l03477"></a>03477     left = <span class="keyword">new</span>;
<a name="l03478"></a>03478   }
<a name="l03479"></a>03479   *pResult = left;
<a name="l03480"></a>03480   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03481"></a>03481 }
<a name="l03482"></a>03482 
<a name="l03483"></a>03483 <span class="comment">/* Add a new term pTerm[0..nTerm-1] to the query *q.</span>
<a name="l03484"></a>03484 <span class="comment">*/</span>
<a name="l03485"></a><a class="code" href="fts2_8c.html#a7ccacb0137b581bffc5942a4074f78d7">03485</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a7ccacb0137b581bffc5942a4074f78d7">queryAdd</a>(<a class="code" href="structQuery.html">Query</a> *q, <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm){
<a name="l03486"></a>03486   <a class="code" href="structQueryTerm.html">QueryTerm</a> *t;
<a name="l03487"></a>03487   ++q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;
<a name="l03488"></a>03488   q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a> = <a class="code" href="malloc_8c.html#a478028442c2ce4635eac464d47465c8f">sqlite3_realloc</a>(q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>, q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> * <span class="keyword">sizeof</span>(q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[0]));
<a name="l03489"></a>03489   <span class="keywordflow">if</span>( q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>==0 ){
<a name="l03490"></a>03490     q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> = 0;
<a name="l03491"></a>03491     <span class="keywordflow">return</span>;
<a name="l03492"></a>03492   }
<a name="l03493"></a>03493   t = &amp;q-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[q-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> - 1];
<a name="l03494"></a>03494   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(t);
<a name="l03495"></a>03495   t-&gt;<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a> = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(nTerm+1);
<a name="l03496"></a>03496   memcpy(t-&gt;<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>, pTerm, nTerm);
<a name="l03497"></a>03497   t-&gt;<a class="code" href="structQueryTerm.html#a76c6603b2ac899a1ed1e4dd38f03c24e">pTerm</a>[nTerm] = 0;
<a name="l03498"></a>03498   t-&gt;<a class="code" href="structQueryTerm.html#aeeb3d5a5c0c62dc9d0966204c8cae819">nTerm</a> = nTerm;
<a name="l03499"></a>03499   t-&gt;<a class="code" href="structQueryTerm.html#af7018292d462a2b11f4acd1dd440bf03">isOr</a> = q-&gt;<a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a>;
<a name="l03500"></a>03500   t-&gt;<a class="code" href="structQueryTerm.html#a93193d71d1732930b838cb26601ee89e">isPrefix</a> = 0;
<a name="l03501"></a>03501   q-&gt;<a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a> = 0;
<a name="l03502"></a>03502   t-&gt;<a class="code" href="structQueryTerm.html#a71a4c3b5b3246a6e2e7347d0d71edf2c">iColumn</a> = q-&gt;<a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a>;
<a name="l03503"></a>03503   q-&gt;<a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a> = q-&gt;<a class="code" href="structQuery.html#af4b5b552a7646059a60c1eace4d2a020">dfltColumn</a>;
<a name="l03504"></a>03504 }
<a name="l03505"></a>03505 
<a name="l03506"></a>03506 <span class="comment">/*</span>
<a name="l03507"></a>03507 <span class="comment">** Check to see if the string zToken[0...nToken-1] matches any</span>
<a name="l03508"></a>03508 <span class="comment">** column name in the virtual table.   If it does,</span>
<a name="l03509"></a>03509 <span class="comment">** return the zero-indexed column number.  If not, return -1.</span>
<a name="l03510"></a>03510 <span class="comment">*/</span>
<a name="l03511"></a><a class="code" href="fts2_8c.html#ab010222acbfa0974c8b91832c5530dd5">03511</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ab010222acbfa0974c8b91832c5530dd5">checkColumnSpecifier</a>(
<a name="l03512"></a>03512   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *pVtab,    <span class="comment">/* The virtual table */</span>
<a name="l03513"></a>03513   <span class="keyword">const</span> <span class="keywordtype">char</span> *zToken,      <span class="comment">/* Text of the token */</span>
<a name="l03514"></a>03514   <span class="keywordtype">int</span> nToken               <span class="comment">/* Number of characters in the token */</span>
<a name="l03515"></a>03515 ){
<a name="l03516"></a>03516   <span class="keywordtype">int</span> i;
<a name="l03517"></a>03517   <span class="keywordflow">for</span>(i=0; i&lt;pVtab-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; i++){
<a name="l03518"></a>03518     <span class="keywordflow">if</span>( memcmp(pVtab-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>[i], zToken, nToken)==0
<a name="l03519"></a>03519         &amp;&amp; pVtab-&gt;<a class="code" href="structfulltext__vtab.html#a31e0d287326146f297373c9cc2a2ce93">azColumn</a>[i][nToken]==0 ){
<a name="l03520"></a>03520       <span class="keywordflow">return</span> i;
<a name="l03521"></a>03521     }
<a name="l03522"></a>03522   }
<a name="l03523"></a>03523   <span class="keywordflow">return</span> -1;
<a name="l03524"></a>03524 }
<a name="l03525"></a>03525 
<a name="l03526"></a>03526 <span class="comment">/*</span>
<a name="l03527"></a>03527 <span class="comment">** Parse the text at pSegment[0..nSegment-1].  Add additional terms</span>
<a name="l03528"></a>03528 <span class="comment">** to the query being assemblied in pQuery.</span>
<a name="l03529"></a>03529 <span class="comment">**</span>
<a name="l03530"></a>03530 <span class="comment">** inPhrase is true if pSegment[0..nSegement-1] is contained within</span>
<a name="l03531"></a>03531 <span class="comment">** double-quotes.  If inPhrase is true, then the first term</span>
<a name="l03532"></a>03532 <span class="comment">** is marked with the number of terms in the phrase less one and</span>
<a name="l03533"></a>03533 <span class="comment">** OR and &quot;-&quot; syntax is ignored.  If inPhrase is false, then every</span>
<a name="l03534"></a>03534 <span class="comment">** term found is marked with nPhrase=0 and OR and &quot;-&quot; syntax is significant.</span>
<a name="l03535"></a>03535 <span class="comment">*/</span>
<a name="l03536"></a><a class="code" href="fts2_8c.html#a2b3fe867e6a4a792af87698942f40a4a">03536</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a2b3fe867e6a4a792af87698942f40a4a">tokenizeSegment</a>(
<a name="l03537"></a>03537   <a class="code" href="structsqlite3__tokenizer.html">sqlite3_tokenizer</a> *pTokenizer,          <span class="comment">/* The tokenizer to use */</span>
<a name="l03538"></a>03538   <span class="keyword">const</span> <span class="keywordtype">char</span> *pSegment, <span class="keywordtype">int</span> nSegment,     <span class="comment">/* Query expression being parsed */</span>
<a name="l03539"></a>03539   <span class="keywordtype">int</span> inPhrase,                           <span class="comment">/* True if within &quot;...&quot; */</span>
<a name="l03540"></a>03540   <a class="code" href="structQuery.html">Query</a> *pQuery                           <span class="comment">/* Append results here */</span>
<a name="l03541"></a>03541 ){
<a name="l03542"></a>03542   <span class="keyword">const</span> <a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *pModule = pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>;
<a name="l03543"></a>03543   <a class="code" href="structsqlite3__tokenizer__cursor.html">sqlite3_tokenizer_cursor</a> *pCursor;
<a name="l03544"></a>03544   <span class="keywordtype">int</span> firstIndex = pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;
<a name="l03545"></a>03545   <span class="keywordtype">int</span> iCol;
<a name="l03546"></a>03546   <span class="keywordtype">int</span> nTerm = 1;
<a name="l03547"></a>03547   
<a name="l03548"></a>03548   <span class="keywordtype">int</span> rc = pModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a44ab0f8ad43cd5900d5ab59f899f6acd">xOpen</a>(pTokenizer, pSegment, nSegment, &amp;pCursor);
<a name="l03549"></a>03549   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03550"></a>03550   pCursor-&gt;<a class="code" href="structsqlite3__tokenizer__cursor.html#aa0ec54f843cb47b54daa4e8c8c6013c0">pTokenizer</a> = pTokenizer;
<a name="l03551"></a>03551 
<a name="l03552"></a>03552   <span class="keywordflow">while</span>( 1 ){
<a name="l03553"></a>03553     <span class="keyword">const</span> <span class="keywordtype">char</span> *pToken;
<a name="l03554"></a>03554     <span class="keywordtype">int</span> nToken, iBegin, iEnd, iPos;
<a name="l03555"></a>03555 
<a name="l03556"></a>03556     rc = pModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a13443eb8fac89e3031f601a38564e2cc">xNext</a>(pCursor,
<a name="l03557"></a>03557                         &amp;pToken, &amp;nToken,
<a name="l03558"></a>03558                         &amp;iBegin, &amp;iEnd, &amp;iPos);
<a name="l03559"></a>03559     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">break</span>;
<a name="l03560"></a>03560     <span class="keywordflow">if</span>( !inPhrase &amp;&amp;
<a name="l03561"></a>03561         pSegment[iEnd]==<span class="charliteral">&apos;:&apos;</span> &amp;&amp;
<a name="l03562"></a>03562          (iCol = <a class="code" href="fts2_8c.html#ab010222acbfa0974c8b91832c5530dd5">checkColumnSpecifier</a>(pQuery-&gt;<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a>, pToken, nToken))&gt;=0 ){
<a name="l03563"></a>03563       pQuery-&gt;<a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a> = iCol;
<a name="l03564"></a>03564       <span class="keywordflow">continue</span>;
<a name="l03565"></a>03565     }
<a name="l03566"></a>03566     <span class="keywordflow">if</span>( !inPhrase &amp;&amp; pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>&gt;0 &amp;&amp; nToken==2
<a name="l03567"></a>03567          &amp;&amp; pSegment[iBegin]==<span class="charliteral">&apos;O&apos;</span> &amp;&amp; pSegment[iBegin+1]==<span class="charliteral">&apos;R&apos;</span> ){
<a name="l03568"></a>03568       pQuery-&gt;<a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a> = 1;
<a name="l03569"></a>03569       <span class="keywordflow">continue</span>;
<a name="l03570"></a>03570     }
<a name="l03571"></a>03571     <a class="code" href="fts2_8c.html#a7ccacb0137b581bffc5942a4074f78d7">queryAdd</a>(pQuery, pToken, nToken);
<a name="l03572"></a>03572     <span class="keywordflow">if</span>( !inPhrase &amp;&amp; iBegin&gt;0 &amp;&amp; pSegment[iBegin-1]==<span class="charliteral">&apos;-&apos;</span> ){
<a name="l03573"></a>03573       pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>-1].<a class="code" href="structQueryTerm.html#a173e6f424ffb75f22ac977b041511361">isNot</a> = 1;
<a name="l03574"></a>03574     }
<a name="l03575"></a>03575     <span class="keywordflow">if</span>( iEnd&lt;nSegment &amp;&amp; pSegment[iEnd]==<span class="charliteral">&apos;*&apos;</span> ){
<a name="l03576"></a>03576       pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>-1].<a class="code" href="structQueryTerm.html#a93193d71d1732930b838cb26601ee89e">isPrefix</a> = 1;
<a name="l03577"></a>03577     }
<a name="l03578"></a>03578     pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>-1].<a class="code" href="structQueryTerm.html#abea35c7535689b4425baad079834a74c">iPhrase</a> = nTerm;
<a name="l03579"></a>03579     <span class="keywordflow">if</span>( inPhrase ){
<a name="l03580"></a>03580       nTerm++;
<a name="l03581"></a>03581     }
<a name="l03582"></a>03582   }
<a name="l03583"></a>03583 
<a name="l03584"></a>03584   <span class="keywordflow">if</span>( inPhrase &amp;&amp; pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>&gt;firstIndex ){
<a name="l03585"></a>03585     pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>[firstIndex].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> = pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> - firstIndex - 1;
<a name="l03586"></a>03586   }
<a name="l03587"></a>03587 
<a name="l03588"></a>03588   <span class="keywordflow">return</span> pModule-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#ad8bb92424245a38583cbaf36b509efd6">xClose</a>(pCursor);
<a name="l03589"></a>03589 }
<a name="l03590"></a>03590 
<a name="l03591"></a>03591 <span class="comment">/* Parse a query string, yielding a Query object pQuery.</span>
<a name="l03592"></a>03592 <span class="comment">**</span>
<a name="l03593"></a>03593 <span class="comment">** The calling function will need to queryClear() to clean up</span>
<a name="l03594"></a>03594 <span class="comment">** the dynamically allocated memory held by pQuery.</span>
<a name="l03595"></a>03595 <span class="comment">*/</span>
<a name="l03596"></a><a class="code" href="fts2_8c.html#a28b0578ebe0882fe104d34ddf4d9208c">03596</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a28b0578ebe0882fe104d34ddf4d9208c">parseQuery</a>(
<a name="l03597"></a>03597   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,        <span class="comment">/* The fulltext index */</span>
<a name="l03598"></a>03598   <span class="keyword">const</span> <span class="keywordtype">char</span> *zInput,      <span class="comment">/* Input text of the query string */</span>
<a name="l03599"></a>03599   <span class="keywordtype">int</span> nInput,              <span class="comment">/* Size of the input text */</span>
<a name="l03600"></a>03600   <span class="keywordtype">int</span> dfltColumn,          <span class="comment">/* Default column of the index to match against */</span>
<a name="l03601"></a>03601   <a class="code" href="structQuery.html">Query</a> *pQuery            <span class="comment">/* Write the parse results here. */</span>
<a name="l03602"></a>03602 ){
<a name="l03603"></a>03603   <span class="keywordtype">int</span> iInput, inPhrase = 0;
<a name="l03604"></a>03604 
<a name="l03605"></a>03605   <span class="keywordflow">if</span>( zInput==0 ) nInput = 0;
<a name="l03606"></a>03606   <span class="keywordflow">if</span>( nInput&lt;0 ) nInput = strlen(zInput);
<a name="l03607"></a>03607   pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> = 0;
<a name="l03608"></a>03608   pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a> = NULL;
<a name="l03609"></a>03609   pQuery-&gt;<a class="code" href="structQuery.html#a8da9219e59ddad3196d13bf21e1ca250">nextIsOr</a> = 0;
<a name="l03610"></a>03610   pQuery-&gt;<a class="code" href="structQuery.html#a5ac085f72aa0818885ab628d0401634c">nextColumn</a> = dfltColumn;
<a name="l03611"></a>03611   pQuery-&gt;<a class="code" href="structQuery.html#af4b5b552a7646059a60c1eace4d2a020">dfltColumn</a> = dfltColumn;
<a name="l03612"></a>03612   pQuery-&gt;<a class="code" href="structQuery.html#ae9d88261063a54996537ece9a82bb2ea">pFts</a> = v;
<a name="l03613"></a>03613 
<a name="l03614"></a>03614   <span class="keywordflow">for</span>(iInput=0; iInput&lt;nInput; ++iInput){
<a name="l03615"></a>03615     <span class="keywordtype">int</span> i;
<a name="l03616"></a>03616     <span class="keywordflow">for</span>(i=iInput; i&lt;nInput &amp;&amp; zInput[i]!=<span class="charliteral">&apos;&quot;&apos;</span>; ++i){}
<a name="l03617"></a>03617     <span class="keywordflow">if</span>( i&gt;iInput ){
<a name="l03618"></a>03618       <a class="code" href="fts2_8c.html#a2b3fe867e6a4a792af87698942f40a4a">tokenizeSegment</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>, zInput+iInput, i-iInput, inPhrase,
<a name="l03619"></a>03619                        pQuery);
<a name="l03620"></a>03620     }
<a name="l03621"></a>03621     iInput = i;
<a name="l03622"></a>03622     <span class="keywordflow">if</span>( i&lt;nInput ){
<a name="l03623"></a>03623       assert( zInput[i]==<span class="charliteral">&apos;&quot;&apos;</span> );
<a name="l03624"></a>03624       inPhrase = !inPhrase;
<a name="l03625"></a>03625     }
<a name="l03626"></a>03626   }
<a name="l03627"></a>03627 
<a name="l03628"></a>03628   <span class="keywordflow">if</span>( inPhrase ){
<a name="l03629"></a>03629     <span class="comment">/* unmatched quote */</span>
<a name="l03630"></a>03630     <a class="code" href="fts2_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(pQuery);
<a name="l03631"></a>03631     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l03632"></a>03632   }
<a name="l03633"></a>03633   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03634"></a>03634 }
<a name="l03635"></a>03635 
<a name="l03636"></a>03636 <span class="comment">/* TODO(shess) Refactor the code to remove this forward decl. */</span>
<a name="l03637"></a>03637 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a7562cdf287e12b6322a65b44f508d177">flushPendingTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v);
<a name="l03638"></a>03638 
<a name="l03639"></a>03639 <span class="comment">/* Perform a full-text query using the search expression in</span>
<a name="l03640"></a>03640 <span class="comment">** zInput[0..nInput-1].  Return a list of matching documents</span>
<a name="l03641"></a>03641 <span class="comment">** in pResult.</span>
<a name="l03642"></a>03642 <span class="comment">**</span>
<a name="l03643"></a>03643 <span class="comment">** Queries must match column iColumn.  Or if iColumn&gt;=nColumn</span>
<a name="l03644"></a>03644 <span class="comment">** they are allowed to match against any column.</span>
<a name="l03645"></a>03645 <span class="comment">*/</span>
<a name="l03646"></a><a class="code" href="fts2_8c.html#a9c2e162b4a18492ccc944bd6eccf1dc1">03646</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a9c2e162b4a18492ccc944bd6eccf1dc1">fulltextQuery</a>(
<a name="l03647"></a>03647   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,      <span class="comment">/* The full text index */</span>
<a name="l03648"></a>03648   <span class="keywordtype">int</span> iColumn,           <span class="comment">/* Match against this column by default */</span>
<a name="l03649"></a>03649   <span class="keyword">const</span> <span class="keywordtype">char</span> *zInput,    <span class="comment">/* The query string */</span>
<a name="l03650"></a>03650   <span class="keywordtype">int</span> nInput,            <span class="comment">/* Number of bytes in zInput[] */</span>
<a name="l03651"></a>03651   <a class="code" href="structDataBuffer.html">DataBuffer</a> *pResult,   <span class="comment">/* Write the result doclist here */</span>
<a name="l03652"></a>03652   <a class="code" href="structQuery.html">Query</a> *pQuery          <span class="comment">/* Put parsed query string here */</span>
<a name="l03653"></a>03653 ){
<a name="l03654"></a>03654   <span class="keywordtype">int</span> i, iNext, rc;
<a name="l03655"></a>03655   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="lparser_8c.html#a3584754acc5e91c03d6fc91359eefd78">left</a>, <a class="code" href="lparser_8c.html#a34b07942956eb7acd9d02c5b75177ae6">right</a>, or, <span class="keyword">new</span>;
<a name="l03656"></a>03656   <span class="keywordtype">int</span> nNot = 0;
<a name="l03657"></a>03657   <a class="code" href="structQueryTerm.html">QueryTerm</a> *aTerm;
<a name="l03658"></a>03658 
<a name="l03659"></a>03659   <span class="comment">/* TODO(shess) Instead of flushing pendingTerms, we could query for</span>
<a name="l03660"></a>03660 <span class="comment">  ** the relevant term and merge the doclist into what we receive from</span>
<a name="l03661"></a>03661 <span class="comment">  ** the database.  Wait and see if this is a common issue, first.</span>
<a name="l03662"></a>03662 <span class="comment">  **</span>
<a name="l03663"></a>03663 <span class="comment">  ** A good reason not to flush is to not generate update-related</span>
<a name="l03664"></a>03664 <span class="comment">  ** error codes from here.</span>
<a name="l03665"></a>03665 <span class="comment">  */</span>
<a name="l03666"></a>03666 
<a name="l03667"></a>03667   <span class="comment">/* Flush any buffered updates before executing the query. */</span>
<a name="l03668"></a>03668   rc = <a class="code" href="fts2_8c.html#a7562cdf287e12b6322a65b44f508d177">flushPendingTerms</a>(v);
<a name="l03669"></a>03669   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03670"></a>03670 
<a name="l03671"></a>03671   <span class="comment">/* TODO(shess) I think that the queryClear() calls below are not</span>
<a name="l03672"></a>03672 <span class="comment">  ** necessary, because fulltextClose() already clears the query.</span>
<a name="l03673"></a>03673 <span class="comment">  */</span>
<a name="l03674"></a>03674   rc = <a class="code" href="fts2_8c.html#a28b0578ebe0882fe104d34ddf4d9208c">parseQuery</a>(v, zInput, nInput, iColumn, pQuery);
<a name="l03675"></a>03675   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03676"></a>03676 
<a name="l03677"></a>03677   <span class="comment">/* Empty or NULL queries return no results. */</span>
<a name="l03678"></a>03678   <span class="keywordflow">if</span>( pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>==0 ){
<a name="l03679"></a>03679     <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(pResult, 0);
<a name="l03680"></a>03680     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03681"></a>03681   }
<a name="l03682"></a>03682 
<a name="l03683"></a>03683   <span class="comment">/* Merge AND terms. */</span>
<a name="l03684"></a>03684   <span class="comment">/* TODO(shess) I think we can early-exit if( i&gt;nNot &amp;&amp; left.nData==0 ). */</span>
<a name="l03685"></a>03685   aTerm = pQuery-&gt;<a class="code" href="structQuery.html#a4c5736b5a69ea38d1f1e580ef8bfd639">pTerms</a>;
<a name="l03686"></a>03686   <span class="keywordflow">for</span>(i = 0; i&lt;pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>; i=iNext){
<a name="l03687"></a>03687     <span class="keywordflow">if</span>( aTerm[i].isNot ){
<a name="l03688"></a>03688       <span class="comment">/* Handle all NOT terms in a separate pass */</span>
<a name="l03689"></a>03689       nNot++;
<a name="l03690"></a>03690       iNext = i + aTerm[i].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a>+1;
<a name="l03691"></a>03691       <span class="keywordflow">continue</span>;
<a name="l03692"></a>03692     }
<a name="l03693"></a>03693     iNext = i + aTerm[i].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> + 1;
<a name="l03694"></a>03694     rc = <a class="code" href="fts2_8c.html#aa3a3b694e3e3abe6692fde268ec49cd3">docListOfTerm</a>(v, aTerm[i].iColumn, &amp;aTerm[i], &amp;right);
<a name="l03695"></a>03695     <span class="keywordflow">if</span>( rc ){
<a name="l03696"></a>03696       <span class="keywordflow">if</span>( i!=nNot ) <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;left);
<a name="l03697"></a>03697       <a class="code" href="fts2_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(pQuery);
<a name="l03698"></a>03698       <span class="keywordflow">return</span> rc;
<a name="l03699"></a>03699     }
<a name="l03700"></a>03700     <span class="keywordflow">while</span>( iNext&lt;pQuery-&gt;nTerms &amp;&amp; aTerm[iNext].isOr ){
<a name="l03701"></a>03701       rc = <a class="code" href="fts2_8c.html#aa3a3b694e3e3abe6692fde268ec49cd3">docListOfTerm</a>(v, aTerm[iNext].iColumn, &amp;aTerm[iNext], &amp;or);
<a name="l03702"></a>03702       iNext += aTerm[iNext].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> + 1;
<a name="l03703"></a>03703       <span class="keywordflow">if</span>( rc ){
<a name="l03704"></a>03704         <span class="keywordflow">if</span>( i!=nNot ) <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;left);
<a name="l03705"></a>03705         <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;right);
<a name="l03706"></a>03706         <a class="code" href="fts2_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(pQuery);
<a name="l03707"></a>03707         <span class="keywordflow">return</span> rc;
<a name="l03708"></a>03708       }
<a name="l03709"></a>03709       <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;<span class="keyword">new</span>, 0);
<a name="l03710"></a>03710       <a class="code" href="fts2_8c.html#a7103f3714d4b2bfaebdb0d475dea8279">docListOrMerge</a>(right.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, right.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, or.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, or.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, &amp;<span class="keyword">new</span>);
<a name="l03711"></a>03711       <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;right);
<a name="l03712"></a>03712       <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;or);
<a name="l03713"></a>03713       right = <span class="keyword">new</span>;
<a name="l03714"></a>03714     }
<a name="l03715"></a>03715     <span class="keywordflow">if</span>( i==nNot ){           <span class="comment">/* first term processed. */</span>
<a name="l03716"></a>03716       left = right;
<a name="l03717"></a>03717     }<span class="keywordflow">else</span>{
<a name="l03718"></a>03718       <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;<span class="keyword">new</span>, 0);
<a name="l03719"></a>03719       <a class="code" href="fts2_8c.html#a15c61ce33f9c52f09efdbca0d45bd5d7">docListAndMerge</a>(left.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, left.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, right.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, right.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, &amp;<span class="keyword">new</span>);
<a name="l03720"></a>03720       <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;right);
<a name="l03721"></a>03721       <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;left);
<a name="l03722"></a>03722       left = <span class="keyword">new</span>;
<a name="l03723"></a>03723     }
<a name="l03724"></a>03724   }
<a name="l03725"></a>03725 
<a name="l03726"></a>03726   <span class="keywordflow">if</span>( nNot==pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a> ){
<a name="l03727"></a>03727     <span class="comment">/* We do not yet know how to handle a query of only NOT terms */</span>
<a name="l03728"></a>03728     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l03729"></a>03729   }
<a name="l03730"></a>03730 
<a name="l03731"></a>03731   <span class="comment">/* Do the EXCEPT terms */</span>
<a name="l03732"></a>03732   <span class="keywordflow">for</span>(i=0; i&lt;pQuery-&gt;<a class="code" href="structQuery.html#a7714b27048da5f9f6dba1f32513ceade">nTerms</a>;  i += aTerm[i].<a class="code" href="structQueryTerm.html#a181ade7597ff4d1df7fa2a2419eba933">nPhrase</a> + 1){
<a name="l03733"></a>03733     <span class="keywordflow">if</span>( !aTerm[i].isNot ) <span class="keywordflow">continue</span>;
<a name="l03734"></a>03734     rc = <a class="code" href="fts2_8c.html#aa3a3b694e3e3abe6692fde268ec49cd3">docListOfTerm</a>(v, aTerm[i].iColumn, &amp;aTerm[i], &amp;right);
<a name="l03735"></a>03735     <span class="keywordflow">if</span>( rc ){
<a name="l03736"></a>03736       <a class="code" href="fts2_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(pQuery);
<a name="l03737"></a>03737       <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;left);
<a name="l03738"></a>03738       <span class="keywordflow">return</span> rc;
<a name="l03739"></a>03739     }
<a name="l03740"></a>03740     <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;<span class="keyword">new</span>, 0);
<a name="l03741"></a>03741     <a class="code" href="fts2_8c.html#a14543ab3eeff9421574583330c1a3839">docListExceptMerge</a>(left.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, left.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, right.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, right.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, &amp;<span class="keyword">new</span>);
<a name="l03742"></a>03742     <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;right);
<a name="l03743"></a>03743     <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;left);
<a name="l03744"></a>03744     left = <span class="keyword">new</span>;
<a name="l03745"></a>03745   }
<a name="l03746"></a>03746 
<a name="l03747"></a>03747   *pResult = left;
<a name="l03748"></a>03748   <span class="keywordflow">return</span> rc;
<a name="l03749"></a>03749 }
<a name="l03750"></a>03750 
<a name="l03751"></a>03751 <span class="comment">/*</span>
<a name="l03752"></a>03752 <span class="comment">** This is the xFilter interface for the virtual table.  See</span>
<a name="l03753"></a>03753 <span class="comment">** the virtual table xFilter method documentation for additional</span>
<a name="l03754"></a>03754 <span class="comment">** information.</span>
<a name="l03755"></a>03755 <span class="comment">**</span>
<a name="l03756"></a>03756 <span class="comment">** If idxNum==QUERY_GENERIC then do a full table scan against</span>
<a name="l03757"></a>03757 <span class="comment">** the %_content table.</span>
<a name="l03758"></a>03758 <span class="comment">**</span>
<a name="l03759"></a>03759 <span class="comment">** If idxNum==QUERY_ROWID then do a rowid lookup for a single entry</span>
<a name="l03760"></a>03760 <span class="comment">** in the %_content table.</span>
<a name="l03761"></a>03761 <span class="comment">**</span>
<a name="l03762"></a>03762 <span class="comment">** If idxNum&gt;=QUERY_FULLTEXT then use the full text index.  The</span>
<a name="l03763"></a>03763 <span class="comment">** column on the left-hand side of the MATCH operator is column</span>
<a name="l03764"></a>03764 <span class="comment">** number idxNum-QUERY_FULLTEXT, 0 indexed.  argv[0] is the right-hand</span>
<a name="l03765"></a>03765 <span class="comment">** side of the MATCH operator.</span>
<a name="l03766"></a>03766 <span class="comment">*/</span>
<a name="l03767"></a>03767 <span class="comment">/* TODO(shess) Upgrade the cursor initialization and destruction to</span>
<a name="l03768"></a>03768 <span class="comment">** account for fulltextFilter() being called multiple times on the</span>
<a name="l03769"></a>03769 <span class="comment">** same cursor.  The current solution is very fragile.  Apply fix to</span>
<a name="l03770"></a>03770 <span class="comment">** fts2 as appropriate.</span>
<a name="l03771"></a>03771 <span class="comment">*/</span>
<a name="l03772"></a><a class="code" href="fts2_8c.html#a77f0a9cad4b0dcb1a60143d08036b466">03772</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a77f0a9cad4b0dcb1a60143d08036b466">fulltextFilter</a>(
<a name="l03773"></a>03773   <a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor,     <span class="comment">/* The cursor used for this query */</span>
<a name="l03774"></a>03774   <span class="keywordtype">int</span> idxNum, <span class="keyword">const</span> <span class="keywordtype">char</span> *idxStr,   <span class="comment">/* Which indexing scheme to use */</span>
<a name="l03775"></a>03775   <span class="keywordtype">int</span> argc, <a class="code" href="structMem.html">sqlite3_value</a> **argv    <span class="comment">/* Arguments for the indexing scheme */</span>
<a name="l03776"></a>03776 ){
<a name="l03777"></a>03777   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l03778"></a>03778   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = <a class="code" href="fts2_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">cursor_vtab</a>(c);
<a name="l03779"></a>03779   <span class="keywordtype">int</span> rc;
<a name="l03780"></a>03780 
<a name="l03781"></a>03781   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Filter %p\n&quot;</span>,pCursor));
<a name="l03782"></a>03782 
<a name="l03783"></a>03783   <span class="comment">/* If the cursor has a statement that was not prepared according to</span>
<a name="l03784"></a>03784 <span class="comment">  ** idxNum, clear it.  I believe all calls to fulltextFilter with a</span>
<a name="l03785"></a>03785 <span class="comment">  ** given cursor will have the same idxNum , but in this case it&apos;s</span>
<a name="l03786"></a>03786 <span class="comment">  ** easy to be safe.</span>
<a name="l03787"></a>03787 <span class="comment">  */</span>
<a name="l03788"></a>03788   <span class="keywordflow">if</span>( c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a> &amp;&amp; c-&gt;<a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a>!=idxNum ){
<a name="l03789"></a>03789     <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l03790"></a>03790     c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a> = NULL;
<a name="l03791"></a>03791   }
<a name="l03792"></a>03792 
<a name="l03793"></a>03793   <span class="comment">/* Get a fresh statement appropriate to idxNum. */</span>
<a name="l03794"></a>03794   <span class="comment">/* TODO(shess): Add a prepared-statement cache in the vt structure.</span>
<a name="l03795"></a>03795 <span class="comment">  ** The cache must handle multiple open cursors.  Easier to cache the</span>
<a name="l03796"></a>03796 <span class="comment">  ** statement variants at the vt to reduce malloc/realloc/free here.</span>
<a name="l03797"></a>03797 <span class="comment">  ** Or we could have a StringBuffer variant which allowed stack</span>
<a name="l03798"></a>03798 <span class="comment">  ** construction for small values.</span>
<a name="l03799"></a>03799 <span class="comment">  */</span>
<a name="l03800"></a>03800   <span class="keywordflow">if</span>( !c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a> ){
<a name="l03801"></a>03801     <span class="keywordtype">char</span> *zSql = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(<span class="stringliteral">&quot;select rowid, * from %%_content %s&quot;</span>,
<a name="l03802"></a>03802                                  idxNum==<a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">QUERY_GENERIC</a> ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;where rowid=?&quot;</span>);
<a name="l03803"></a>03803     rc = <a class="code" href="fts2_8c.html#a90c49c1625eff6f726a4ce28200e24d4">sql_prepare</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, v-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, &amp;c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, zSql);
<a name="l03804"></a>03804     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zSql);
<a name="l03805"></a>03805     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03806"></a>03806     c-&gt;<a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a> = idxNum;
<a name="l03807"></a>03807   }<span class="keywordflow">else</span>{
<a name="l03808"></a>03808     <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>);
<a name="l03809"></a>03809     assert( c-&gt;<a class="code" href="structfulltext__cursor.html#a114798540366ba5751912485b0247c5a">iCursorType</a>==idxNum );
<a name="l03810"></a>03810   }
<a name="l03811"></a>03811 
<a name="l03812"></a>03812   <span class="keywordflow">switch</span>( idxNum ){
<a name="l03813"></a>03813     <span class="keywordflow">case</span> <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca2e3f2d68a806d072fbbd750932c16b18">QUERY_GENERIC</a>:
<a name="l03814"></a>03814       <span class="keywordflow">break</span>;
<a name="l03815"></a>03815 
<a name="l03816"></a>03816     <span class="keywordflow">case</span> <a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9ecadfa9dc6cb33447260116307a64a3c657">QUERY_ROWID</a>:
<a name="l03817"></a>03817       rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, 1, <a class="code" href="sqlite3_8h.html#a8e6a9f5cda11dec1ca742f58695feded">sqlite3_value_int64</a>(argv[0]));
<a name="l03818"></a>03818       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03819"></a>03819       <span class="keywordflow">break</span>;
<a name="l03820"></a>03820 
<a name="l03821"></a>03821     <span class="keywordflow">default</span>:   <span class="comment">/* full-text search */</span>
<a name="l03822"></a>03822     {
<a name="l03823"></a>03823       <span class="keyword">const</span> <span class="keywordtype">char</span> *zQuery = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[0]);
<a name="l03824"></a>03824       assert( idxNum&lt;=QUERY_FULLTEXT+v-&gt;nColumn);
<a name="l03825"></a>03825       assert( argc==1 );
<a name="l03826"></a>03826       <a class="code" href="fts2_8c.html#a8c133ecdf5b6410783825a3ac7cff95b">queryClear</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>);
<a name="l03827"></a>03827       <span class="keywordflow">if</span>( c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.nData!=0 ){
<a name="l03828"></a>03828         <span class="comment">/* This case happens if the same cursor is used repeatedly. */</span>
<a name="l03829"></a>03829         <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ad364061ebd037f7228b3599ead044d15">reader</a>);
<a name="l03830"></a>03830         <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>);
<a name="l03831"></a>03831       }<span class="keywordflow">else</span>{
<a name="l03832"></a>03832         <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>, 0);
<a name="l03833"></a>03833       }
<a name="l03834"></a>03834       rc = <a class="code" href="fts2_8c.html#a9c2e162b4a18492ccc944bd6eccf1dc1">fulltextQuery</a>(v, idxNum-<a class="code" href="fts1_8c.html#abfbb64a2ec7afa6cbb18aa171775c9eca7cecdcf941f69da750fc6af8e0de93f8">QUERY_FULLTEXT</a>, zQuery, -1, &amp;c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>, &amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ae77438aa1d26d57645da02ac9a7317e3">q</a>);
<a name="l03835"></a>03835       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03836"></a>03836       <span class="keywordflow">if</span>( c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.nData!=0 ){
<a name="l03837"></a>03837         <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;c-&gt;<a class="code" href="structfulltext__cursor.html#ad364061ebd037f7228b3599ead044d15">reader</a>, <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a>, c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.pData, c-&gt;<a class="code" href="structfulltext__cursor.html#a8d4d70be8097c6aa7b931373169148bd">result</a>.nData);
<a name="l03838"></a>03838       }
<a name="l03839"></a>03839       <span class="keywordflow">break</span>;
<a name="l03840"></a>03840     }
<a name="l03841"></a>03841   }
<a name="l03842"></a>03842 
<a name="l03843"></a>03843   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a27014ab01a3b771ad685bf0a66ae0f74">fulltextNext</a>(pCursor);
<a name="l03844"></a>03844 }
<a name="l03845"></a>03845 
<a name="l03846"></a>03846 <span class="comment">/* This is the xEof method of the virtual table.  The SQLite core</span>
<a name="l03847"></a>03847 <span class="comment">** calls this routine to find out if it has reached the end of</span>
<a name="l03848"></a>03848 <span class="comment">** a query&apos;s results set.</span>
<a name="l03849"></a>03849 <span class="comment">*/</span>
<a name="l03850"></a><a class="code" href="fts2_8c.html#a04b7b39869da7e2457f1605884eaada7">03850</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a04b7b39869da7e2457f1605884eaada7">fulltextEof</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor){
<a name="l03851"></a>03851   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l03852"></a>03852   <span class="keywordflow">return</span> c-&gt;<a class="code" href="structfulltext__cursor.html#ab2e9ba57936d6312f04756c1d59e9048">eof</a>;
<a name="l03853"></a>03853 }
<a name="l03854"></a>03854 
<a name="l03855"></a>03855 <span class="comment">/* This is the xColumn method of the virtual table.  The SQLite</span>
<a name="l03856"></a>03856 <span class="comment">** core calls this method during a query when it needs the value</span>
<a name="l03857"></a>03857 <span class="comment">** of a column from the virtual table.  This method needs to use</span>
<a name="l03858"></a>03858 <span class="comment">** one of the sqlite3_result_*() routines to store the requested</span>
<a name="l03859"></a>03859 <span class="comment">** value back in the pContext.</span>
<a name="l03860"></a>03860 <span class="comment">*/</span>
<a name="l03861"></a><a class="code" href="fts2_8c.html#a1150d2b45c324680b8f663999690251f">03861</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a1150d2b45c324680b8f663999690251f">fulltextColumn</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor,
<a name="l03862"></a>03862                           <a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext, <span class="keywordtype">int</span> idxCol){
<a name="l03863"></a>03863   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l03864"></a>03864   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = <a class="code" href="fts2_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">cursor_vtab</a>(c);
<a name="l03865"></a>03865 
<a name="l03866"></a>03866   <span class="keywordflow">if</span>( idxCol&lt;v-&gt;nColumn ){
<a name="l03867"></a>03867     <a class="code" href="structMem.html">sqlite3_value</a> *pVal = <a class="code" href="sqlite3_8h.html#aab0b080ede916c9dee19b6a29138e0b7">sqlite3_column_value</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, idxCol+1);
<a name="l03868"></a>03868     <a class="code" href="sqlite3_8h.html#a7cd28ba7a4256aec12262ed3d75bb39a">sqlite3_result_value</a>(pContext, pVal);
<a name="l03869"></a>03869   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( idxCol==v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a> ){
<a name="l03870"></a>03870     <span class="comment">/* The extra column whose name is the same as the table.</span>
<a name="l03871"></a>03871 <span class="comment">    ** Return a blob which is a pointer to the cursor</span>
<a name="l03872"></a>03872 <span class="comment">    */</span>
<a name="l03873"></a>03873     <a class="code" href="sqlite3_8h.html#a7dabc96652dbaf414a4dc55176a11158">sqlite3_result_blob</a>(pContext, &amp;c, <span class="keyword">sizeof</span>(c), <a class="code" href="sqlite3_8h.html#adec3d88e3dff21d4c566daccbede9b3b">SQLITE_TRANSIENT</a>);
<a name="l03874"></a>03874   }
<a name="l03875"></a>03875   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03876"></a>03876 }
<a name="l03877"></a>03877 
<a name="l03878"></a>03878 <span class="comment">/* This is the xRowid method.  The SQLite core calls this routine to</span>
<a name="l03879"></a>03879 <span class="comment">** retrive the rowid for the current row of the result set.  The</span>
<a name="l03880"></a>03880 <span class="comment">** rowid should be written to *pRowid.</span>
<a name="l03881"></a>03881 <span class="comment">*/</span>
<a name="l03882"></a><a class="code" href="fts2_8c.html#a4ede5546134709d20eed03b0b16c85e1">03882</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a4ede5546134709d20eed03b0b16c85e1">fulltextRowid</a>(<a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pCursor, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *pRowid){
<a name="l03883"></a>03883   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *c = (<a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *) pCursor;
<a name="l03884"></a>03884 
<a name="l03885"></a>03885   *pRowid = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(c-&gt;<a class="code" href="structfulltext__cursor.html#aefd3a30792834066a5d0594d86fe1611">pStmt</a>, 0);
<a name="l03886"></a>03886   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03887"></a>03887 }
<a name="l03888"></a>03888 
<a name="l03889"></a>03889 <span class="comment">/* Add all terms in [zText] to pendingTerms table.  If [iColumn] &gt; 0,</span>
<a name="l03890"></a>03890 <span class="comment">** we also store positions and offsets in the hash table using that</span>
<a name="l03891"></a>03891 <span class="comment">** column number.</span>
<a name="l03892"></a>03892 <span class="comment">*/</span>
<a name="l03893"></a><a class="code" href="fts2_8c.html#a8a82a4d4dc7f63ffe5c4a2173a72cd19">03893</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a8a82a4d4dc7f63ffe5c4a2173a72cd19">buildTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid,
<a name="l03894"></a>03894                       <span class="keyword">const</span> <span class="keywordtype">char</span> *zText, <span class="keywordtype">int</span> iColumn){
<a name="l03895"></a>03895   <a class="code" href="structsqlite3__tokenizer.html">sqlite3_tokenizer</a> *pTokenizer = v-&gt;<a class="code" href="structfulltext__vtab.html#ad7f1e6e31f000eb4e3143b428f8a126c">pTokenizer</a>;
<a name="l03896"></a>03896   <a class="code" href="structsqlite3__tokenizer__cursor.html">sqlite3_tokenizer_cursor</a> *pCursor;
<a name="l03897"></a>03897   <span class="keyword">const</span> <span class="keywordtype">char</span> *pToken;
<a name="l03898"></a>03898   <span class="keywordtype">int</span> nTokenBytes;
<a name="l03899"></a>03899   <span class="keywordtype">int</span> iStartOffset, iEndOffset, iPosition;
<a name="l03900"></a>03900   <span class="keywordtype">int</span> rc;
<a name="l03901"></a>03901 
<a name="l03902"></a>03902   rc = pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a44ab0f8ad43cd5900d5ab59f899f6acd">xOpen</a>(pTokenizer, zText, -1, &amp;pCursor);
<a name="l03903"></a>03903   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03904"></a>03904 
<a name="l03905"></a>03905   pCursor-&gt;<a class="code" href="structsqlite3__tokenizer__cursor.html#aa0ec54f843cb47b54daa4e8c8c6013c0">pTokenizer</a> = pTokenizer;
<a name="l03906"></a>03906   <span class="keywordflow">while</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==(rc=pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#a13443eb8fac89e3031f601a38564e2cc">xNext</a>(pCursor,
<a name="l03907"></a>03907                                                    &amp;pToken, &amp;nTokenBytes,
<a name="l03908"></a>03908                                                    &amp;iStartOffset, &amp;iEndOffset,
<a name="l03909"></a>03909                                                    &amp;iPosition)) ){
<a name="l03910"></a>03910     <a class="code" href="structDLCollector.html">DLCollector</a> *p;
<a name="l03911"></a>03911     <span class="keywordtype">int</span> nData;                   <span class="comment">/* Size of doclist before our update. */</span>
<a name="l03912"></a>03912 
<a name="l03913"></a>03913     <span class="comment">/* Positions can&apos;t be negative; we use -1 as a terminator</span>
<a name="l03914"></a>03914 <span class="comment">     * internally.  Token can&apos;t be NULL or empty. */</span>
<a name="l03915"></a>03915     <span class="keywordflow">if</span>( iPosition&lt;0 || pToken == NULL || nTokenBytes == 0 ){
<a name="l03916"></a>03916       rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l03917"></a>03917       <span class="keywordflow">break</span>;
<a name="l03918"></a>03918     }
<a name="l03919"></a>03919 
<a name="l03920"></a>03920     p = <a class="code" href="fts2__hash_8h.html#ae39e658c291ea1d8830db8f14c50b849">fts2HashFind</a>(&amp;v-&gt;<a class="code" href="structfulltext__vtab.html#af7cc40710088b48f62de7c47e5e822c2">pendingTerms</a>, pToken, nTokenBytes);
<a name="l03921"></a>03921     <span class="keywordflow">if</span>( p==NULL ){
<a name="l03922"></a>03922       nData = 0;
<a name="l03923"></a>03923       p = <a class="code" href="fts2_8c.html#a746ed40e8e7435d8e752ad7a72b95c9f">dlcNew</a>(iDocid, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>);
<a name="l03924"></a>03924       <a class="code" href="fts2__hash_8h.html#a9cd1d6aedfce406ba2718a3c440310f6">fts2HashInsert</a>(&amp;v-&gt;<a class="code" href="structfulltext__vtab.html#af7cc40710088b48f62de7c47e5e822c2">pendingTerms</a>, pToken, nTokenBytes, p);
<a name="l03925"></a>03925 
<a name="l03926"></a>03926       <span class="comment">/* Overhead for our hash table entry, the key, and the value. */</span>
<a name="l03927"></a>03927       v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a> += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structfts2HashElem.html">fts2HashElem</a>)+sizeof(*p)+nTokenBytes;
<a name="l03928"></a>03928     }<span class="keywordflow">else</span>{
<a name="l03929"></a>03929       nData = p-&gt;<a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>;
<a name="l03930"></a>03930       <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structDLCollector.html#a8f6f670899344bcb2a45d223ac751b19">dlw</a>.<a class="code" href="structDLWriter.html#a5feaaf8260803c3630b3b8a0188fc727">iPrevDocid</a>!=iDocid ) <a class="code" href="fts2_8c.html#a522aa1434803358cb62a953195f8cc98">dlcNext</a>(p, iDocid);
<a name="l03931"></a>03931     }
<a name="l03932"></a>03932     <span class="keywordflow">if</span>( iColumn&gt;=0 ){
<a name="l03933"></a>03933       <a class="code" href="fts2_8c.html#aa5a392b124ae323b9b9752101858e837">dlcAddPos</a>(p, iColumn, iPosition, iStartOffset, iEndOffset);
<a name="l03934"></a>03934     }
<a name="l03935"></a>03935 
<a name="l03936"></a>03936     <span class="comment">/* Accumulate data added by dlcNew or dlcNext, and dlcAddPos. */</span>
<a name="l03937"></a>03937     v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a> += p-&gt;<a class="code" href="structDLCollector.html#a6828a209095992dcf5589d0fbe5c2cd9">b</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>-nData;
<a name="l03938"></a>03938   }
<a name="l03939"></a>03939 
<a name="l03940"></a>03940   <span class="comment">/* TODO(shess) Check return?  Should this be able to cause errors at</span>
<a name="l03941"></a>03941 <span class="comment">  ** this point?  Actually, same question about sqlite3_finalize(),</span>
<a name="l03942"></a>03942 <span class="comment">  ** though one could argue that failure there means that the data is</span>
<a name="l03943"></a>03943 <span class="comment">  ** not durable.  *ponder*</span>
<a name="l03944"></a>03944 <span class="comment">  */</span>
<a name="l03945"></a>03945   pTokenizer-&gt;<a class="code" href="structsqlite3__tokenizer.html#aed562e212aa7df0db1f97abac9f095c1">pModule</a>-&gt;<a class="code" href="structsqlite3__tokenizer__module.html#ad8bb92424245a38583cbaf36b509efd6">xClose</a>(pCursor);
<a name="l03946"></a>03946   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> == rc ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03947"></a>03947   <span class="keywordflow">return</span> rc;
<a name="l03948"></a>03948 }
<a name="l03949"></a>03949 
<a name="l03950"></a>03950 <span class="comment">/* Add doclists for all terms in [pValues] to pendingTerms table. */</span>
<a name="l03951"></a><a class="code" href="fts2_8c.html#a0c303637b8aadea821d20f8527158982">03951</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a0c303637b8aadea821d20f8527158982">insertTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRowid,
<a name="l03952"></a>03952                        <a class="code" href="structMem.html">sqlite3_value</a> **pValues){
<a name="l03953"></a>03953   <span class="keywordtype">int</span> i;
<a name="l03954"></a>03954   <span class="keywordflow">for</span>(i = 0; i &lt; v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a> ; ++i){
<a name="l03955"></a>03955     <span class="keywordtype">char</span> *zText = (<span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(pValues[i]);
<a name="l03956"></a>03956     <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a8a82a4d4dc7f63ffe5c4a2173a72cd19">buildTerms</a>(v, iRowid, zText, i);
<a name="l03957"></a>03957     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03958"></a>03958   }
<a name="l03959"></a>03959   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03960"></a>03960 }
<a name="l03961"></a>03961 
<a name="l03962"></a>03962 <span class="comment">/* Add empty doclists for all terms in the given row&apos;s content to</span>
<a name="l03963"></a>03963 <span class="comment">** pendingTerms.</span>
<a name="l03964"></a>03964 <span class="comment">*/</span>
<a name="l03965"></a><a class="code" href="fts2_8c.html#a40e0930b01cd44a6a4f7638adcd01a1e">03965</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a40e0930b01cd44a6a4f7638adcd01a1e">deleteTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRowid){
<a name="l03966"></a>03966   <span class="keyword">const</span> <span class="keywordtype">char</span> **pValues;
<a name="l03967"></a>03967   <span class="keywordtype">int</span> i, rc;
<a name="l03968"></a>03968 
<a name="l03969"></a>03969   <span class="comment">/* TODO(shess) Should we allow such tables at all? */</span>
<a name="l03970"></a>03970   <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l03971"></a>03971 
<a name="l03972"></a>03972   rc = <a class="code" href="fts2_8c.html#a45b9abe0a1f6a081cab0c2eeda68794d">content_select</a>(v, iRowid, &amp;pValues);
<a name="l03973"></a>03973   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03974"></a>03974 
<a name="l03975"></a>03975   <span class="keywordflow">for</span>(i = 0 ; i &lt; v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>; ++i) {
<a name="l03976"></a>03976     rc = <a class="code" href="fts2_8c.html#a8a82a4d4dc7f63ffe5c4a2173a72cd19">buildTerms</a>(v, iRowid, pValues[i], -1);
<a name="l03977"></a>03977     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">break</span>;
<a name="l03978"></a>03978   }
<a name="l03979"></a>03979 
<a name="l03980"></a>03980   <a class="code" href="fts2_8c.html#a217321df065d27f4580f1affa711f23b">freeStringArray</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, pValues);
<a name="l03981"></a>03981   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03982"></a>03982 }
<a name="l03983"></a>03983 
<a name="l03984"></a>03984 <span class="comment">/* TODO(shess) Refactor the code to remove this forward decl. */</span>
<a name="l03985"></a>03985 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a96fe0e65990eb6b52b5e04d37a6afa0c">initPendingTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid);
<a name="l03986"></a>03986 
<a name="l03987"></a>03987 <span class="comment">/* Insert a row into the %_content table; set *piRowid to be the ID of the</span>
<a name="l03988"></a>03988 <span class="comment">** new row.  Add doclists for terms to pendingTerms.</span>
<a name="l03989"></a>03989 <span class="comment">*/</span>
<a name="l03990"></a><a class="code" href="fts2_8c.html#ae17acbf0f2d7fa5f24b2b522fab1b578">03990</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ae17acbf0f2d7fa5f24b2b522fab1b578">index_insert</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structMem.html">sqlite3_value</a> *pRequestRowid,
<a name="l03991"></a>03991                         <a class="code" href="structMem.html">sqlite3_value</a> **pValues, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piRowid){
<a name="l03992"></a>03992   <span class="keywordtype">int</span> rc;
<a name="l03993"></a>03993 
<a name="l03994"></a>03994   rc = <a class="code" href="fts2_8c.html#a97f61f9291ab35fbfe2c39993ec56796">content_insert</a>(v, pRequestRowid, pValues);  <span class="comment">/* execute an SQL INSERT */</span>
<a name="l03995"></a>03995   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l03996"></a>03996 
<a name="l03997"></a>03997   *piRowid = <a class="code" href="main_8c.html#ac09d49376c77414ba143635184b7ee10">sqlite3_last_insert_rowid</a>(v-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>);
<a name="l03998"></a>03998   rc = <a class="code" href="fts2_8c.html#a96fe0e65990eb6b52b5e04d37a6afa0c">initPendingTerms</a>(v, *piRowid);
<a name="l03999"></a>03999   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04000"></a>04000 
<a name="l04001"></a>04001   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a0c303637b8aadea821d20f8527158982">insertTerms</a>(v, *piRowid, pValues);
<a name="l04002"></a>04002 }
<a name="l04003"></a>04003 
<a name="l04004"></a>04004 <span class="comment">/* Delete a row from the %_content table; add empty doclists for terms</span>
<a name="l04005"></a>04005 <span class="comment">** to pendingTerms.</span>
<a name="l04006"></a>04006 <span class="comment">*/</span>
<a name="l04007"></a><a class="code" href="fts2_8c.html#a5300d96128a51a0d12276a77aa5ed6c3">04007</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a5300d96128a51a0d12276a77aa5ed6c3">index_delete</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRow){
<a name="l04008"></a>04008   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a96fe0e65990eb6b52b5e04d37a6afa0c">initPendingTerms</a>(v, iRow);
<a name="l04009"></a>04009   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04010"></a>04010 
<a name="l04011"></a>04011   rc = <a class="code" href="fts2_8c.html#a40e0930b01cd44a6a4f7638adcd01a1e">deleteTerms</a>(v, iRow);
<a name="l04012"></a>04012   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04013"></a>04013 
<a name="l04014"></a>04014   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a8d2f433ca2290904b916ff1972b921c3">content_delete</a>(v, iRow);  <span class="comment">/* execute an SQL DELETE */</span>
<a name="l04015"></a>04015 }
<a name="l04016"></a>04016 
<a name="l04017"></a>04017 <span class="comment">/* Update a row in the %_content table; add delete doclists to</span>
<a name="l04018"></a>04018 <span class="comment">** pendingTerms for old terms not in the new data, add insert doclists</span>
<a name="l04019"></a>04019 <span class="comment">** to pendingTerms for terms in the new data.</span>
<a name="l04020"></a>04020 <span class="comment">*/</span>
<a name="l04021"></a><a class="code" href="fts2_8c.html#a1c5901acdbbe05610122c85efae88dac">04021</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a1c5901acdbbe05610122c85efae88dac">index_update</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRow,
<a name="l04022"></a>04022                         <a class="code" href="structMem.html">sqlite3_value</a> **pValues){
<a name="l04023"></a>04023   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a96fe0e65990eb6b52b5e04d37a6afa0c">initPendingTerms</a>(v, iRow);
<a name="l04024"></a>04024   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04025"></a>04025 
<a name="l04026"></a>04026   <span class="comment">/* Generate an empty doclist for each term that previously appeared in this</span>
<a name="l04027"></a>04027 <span class="comment">   * row. */</span>
<a name="l04028"></a>04028   rc = <a class="code" href="fts2_8c.html#a40e0930b01cd44a6a4f7638adcd01a1e">deleteTerms</a>(v, iRow);
<a name="l04029"></a>04029   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04030"></a>04030 
<a name="l04031"></a>04031   rc = <a class="code" href="fts2_8c.html#aff98794eedf8ff43e623a00e0634c566">content_update</a>(v, pValues, iRow);  <span class="comment">/* execute an SQL UPDATE */</span>
<a name="l04032"></a>04032   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04033"></a>04033 
<a name="l04034"></a>04034   <span class="comment">/* Now add positions for terms which appear in the updated row. */</span>
<a name="l04035"></a>04035   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a0c303637b8aadea821d20f8527158982">insertTerms</a>(v, iRow, pValues);
<a name="l04036"></a>04036 }
<a name="l04037"></a>04037 
<a name="l04038"></a>04038 <span class="comment">/*******************************************************************/</span>
<a name="l04039"></a>04039 <span class="comment">/* InteriorWriter is used to collect terms and block references into</span>
<a name="l04040"></a>04040 <span class="comment">** interior nodes in %_segments.  See commentary at top of file for</span>
<a name="l04041"></a>04041 <span class="comment">** format.</span>
<a name="l04042"></a>04042 <span class="comment">*/</span>
<a name="l04043"></a>04043 
<a name="l04044"></a>04044 <span class="comment">/* How large interior nodes can grow. */</span>
<a name="l04045"></a><a class="code" href="fts2_8c.html#ac9d04f781f68ad518fbc6ff1863a2bfd">04045</a> <span class="preprocessor">#define INTERIOR_MAX 2048</span>
<a name="l04046"></a>04046 <span class="preprocessor"></span>
<a name="l04047"></a>04047 <span class="comment">/* Minimum number of terms per interior node (except the root). This</span>
<a name="l04048"></a>04048 <span class="comment">** prevents large terms from making the tree too skinny - must be &gt;0</span>
<a name="l04049"></a>04049 <span class="comment">** so that the tree always makes progress.  Note that the min tree</span>
<a name="l04050"></a>04050 <span class="comment">** fanout will be INTERIOR_MIN_TERMS+1.</span>
<a name="l04051"></a>04051 <span class="comment">*/</span>
<a name="l04052"></a><a class="code" href="fts2_8c.html#ad42a28674f573597f0de849f76cb5436">04052</a> <span class="preprocessor">#define INTERIOR_MIN_TERMS 7</span>
<a name="l04053"></a>04053 <span class="preprocessor"></span><span class="preprocessor">#if INTERIOR_MIN_TERMS&lt;1</span>
<a name="l04054"></a>04054 <span class="preprocessor"></span><span class="preprocessor"># error INTERIOR_MIN_TERMS must be greater than 0.</span>
<a name="l04055"></a>04055 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04056"></a>04056 <span class="preprocessor"></span>
<a name="l04057"></a>04057 <span class="comment">/* ROOT_MAX controls how much data is stored inline in the segment</span>
<a name="l04058"></a>04058 <span class="comment">** directory.</span>
<a name="l04059"></a>04059 <span class="comment">*/</span>
<a name="l04060"></a>04060 <span class="comment">/* TODO(shess) Push ROOT_MAX down to whoever is writing things.  It&apos;s</span>
<a name="l04061"></a>04061 <span class="comment">** only here so that interiorWriterRootInfo() and leafWriterRootInfo()</span>
<a name="l04062"></a>04062 <span class="comment">** can both see it, but if the caller passed it in, we wouldn&apos;t even</span>
<a name="l04063"></a>04063 <span class="comment">** need a define.</span>
<a name="l04064"></a>04064 <span class="comment">*/</span>
<a name="l04065"></a><a class="code" href="fts2_8c.html#a1b6ab30572ba9a027bbb90a0f599f6ad">04065</a> <span class="preprocessor">#define ROOT_MAX 1024</span>
<a name="l04066"></a>04066 <span class="preprocessor"></span><span class="preprocessor">#if ROOT_MAX&lt;VARINT_MAX*2</span>
<a name="l04067"></a>04067 <span class="preprocessor"></span><span class="preprocessor"># error ROOT_MAX must have enough space for a header.</span>
<a name="l04068"></a>04068 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04069"></a>04069 <span class="preprocessor"></span>
<a name="l04070"></a>04070 <span class="comment">/* InteriorBlock stores a linked-list of interior blocks while a lower</span>
<a name="l04071"></a>04071 <span class="comment">** layer is being constructed.</span>
<a name="l04072"></a>04072 <span class="comment">*/</span>
<a name="l04073"></a><a class="code" href="structInteriorBlock.html">04073</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structInteriorBlock.html">InteriorBlock</a> {
<a name="l04074"></a><a class="code" href="structInteriorBlock.html#a589803140cdb75ab5e96aaa569e94c72">04074</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structInteriorBlock.html#a589803140cdb75ab5e96aaa569e94c72">term</a>;           <span class="comment">/* Leftmost term in block&apos;s subtree. */</span>
<a name="l04075"></a><a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">04075</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>;           <span class="comment">/* Accumulated data for the block. */</span>
<a name="l04076"></a><a class="code" href="structInteriorBlock.html#a24a635f2089ef150dace00887e79f29c">04076</a>   <span class="keyword">struct </span><a class="code" href="structInteriorBlock.html">InteriorBlock</a> *<a class="code" href="structInteriorBlock.html#a24a635f2089ef150dace00887e79f29c">next</a>;
<a name="l04077"></a>04077 } <a class="code" href="structInteriorBlock.html">InteriorBlock</a>;
<a name="l04078"></a>04078 
<a name="l04079"></a><a class="code" href="fts2_8c.html#a884cbe5c54b6893251c0b09edb7d096c">04079</a> <span class="keyword">static</span> <a class="code" href="structInteriorBlock.html">InteriorBlock</a> *<a class="code" href="fts2_8c.html#a884cbe5c54b6893251c0b09edb7d096c">interiorBlockNew</a>(<span class="keywordtype">int</span> iHeight, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iChildBlock,
<a name="l04080"></a>04080                                        <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm){
<a name="l04081"></a>04081   <a class="code" href="structInteriorBlock.html">InteriorBlock</a> *<a class="code" href="lparser_8c.html#a235428bed4c6be6cb6d2760cd0fa9d34">block</a> = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="structInteriorBlock.html">InteriorBlock</a>));
<a name="l04082"></a>04082   <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>+<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l04083"></a>04083   <span class="keywordtype">int</span> n;
<a name="l04084"></a>04084 
<a name="l04085"></a>04085   <span class="keywordflow">if</span>( block ){
<a name="l04086"></a>04086     memset(block, 0, <span class="keyword">sizeof</span>(*block));
<a name="l04087"></a>04087     <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;block-&gt;<a class="code" href="structInteriorBlock.html#a589803140cdb75ab5e96aaa569e94c72">term</a>, 0);
<a name="l04088"></a>04088     <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(&amp;block-&gt;<a class="code" href="structInteriorBlock.html#a589803140cdb75ab5e96aaa569e94c72">term</a>, pTerm, nTerm);
<a name="l04089"></a>04089 
<a name="l04090"></a>04090     n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, iHeight);
<a name="l04091"></a>04091     n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, iChildBlock);
<a name="l04092"></a>04092     <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;block-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>, <a class="code" href="fts2_8c.html#ac9d04f781f68ad518fbc6ff1863a2bfd">INTERIOR_MAX</a>);
<a name="l04093"></a>04093     <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(&amp;block-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>, c, n);
<a name="l04094"></a>04094   }
<a name="l04095"></a>04095   <span class="keywordflow">return</span> block;
<a name="l04096"></a>04096 }
<a name="l04097"></a>04097 
<a name="l04098"></a>04098 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l04099"></a>04099 <span class="preprocessor"></span><span class="comment">/* Verify that the data is readable as an interior node. */</span>
<a name="l04100"></a>04100 <span class="keyword">static</span> <span class="keywordtype">void</span> interiorBlockValidate(<a class="code" href="structInteriorBlock.html">InteriorBlock</a> *pBlock){
<a name="l04101"></a>04101   <span class="keyword">const</span> <span class="keywordtype">char</span> *pData = pBlock-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>;
<a name="l04102"></a>04102   <span class="keywordtype">int</span> nData = pBlock-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>;
<a name="l04103"></a>04103   <span class="keywordtype">int</span> n, iDummy;
<a name="l04104"></a>04104   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iBlockid;
<a name="l04105"></a>04105 
<a name="l04106"></a>04106   assert( nData&gt;0 );
<a name="l04107"></a>04107   assert( pData!=0 );
<a name="l04108"></a>04108   assert( pData+nData&gt;pData );
<a name="l04109"></a>04109 
<a name="l04110"></a>04110   <span class="comment">/* Must lead with height of node as a varint(n), n&gt;0 */</span>
<a name="l04111"></a>04111   n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04112"></a>04112   assert( n&gt;0 );
<a name="l04113"></a>04113   assert( iDummy&gt;0 );
<a name="l04114"></a>04114   assert( n&lt;nData );
<a name="l04115"></a>04115   pData += n;
<a name="l04116"></a>04116   nData -= n;
<a name="l04117"></a>04117 
<a name="l04118"></a>04118   <span class="comment">/* Must contain iBlockid. */</span>
<a name="l04119"></a>04119   n = <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pData, &amp;iBlockid);
<a name="l04120"></a>04120   assert( n&gt;0 );
<a name="l04121"></a>04121   assert( n&lt;=nData );
<a name="l04122"></a>04122   pData += n;
<a name="l04123"></a>04123   nData -= n;
<a name="l04124"></a>04124 
<a name="l04125"></a>04125   <span class="comment">/* Zero or more terms of positive length */</span>
<a name="l04126"></a>04126   <span class="keywordflow">if</span>( nData!=0 ){
<a name="l04127"></a>04127     <span class="comment">/* First term is not delta-encoded. */</span>
<a name="l04128"></a>04128     n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04129"></a>04129     assert( n&gt;0 );
<a name="l04130"></a>04130     assert( iDummy&gt;0 );
<a name="l04131"></a>04131     assert( n+iDummy&gt;0);
<a name="l04132"></a>04132     assert( n+iDummy&lt;=nData );
<a name="l04133"></a>04133     pData += n+iDummy;
<a name="l04134"></a>04134     nData -= n+iDummy;
<a name="l04135"></a>04135 
<a name="l04136"></a>04136     <span class="comment">/* Following terms delta-encoded. */</span>
<a name="l04137"></a>04137     <span class="keywordflow">while</span>( nData!=0 ){
<a name="l04138"></a>04138       <span class="comment">/* Length of shared prefix. */</span>
<a name="l04139"></a>04139       n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04140"></a>04140       assert( n&gt;0 );
<a name="l04141"></a>04141       assert( iDummy&gt;=0 );
<a name="l04142"></a>04142       assert( n&lt;nData );
<a name="l04143"></a>04143       pData += n;
<a name="l04144"></a>04144       nData -= n;
<a name="l04145"></a>04145 
<a name="l04146"></a>04146       <span class="comment">/* Length and data of distinct suffix. */</span>
<a name="l04147"></a>04147       n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04148"></a>04148       assert( n&gt;0 );
<a name="l04149"></a>04149       assert( iDummy&gt;0 );
<a name="l04150"></a>04150       assert( n+iDummy&gt;0);
<a name="l04151"></a>04151       assert( n+iDummy&lt;=nData );
<a name="l04152"></a>04152       pData += n+iDummy;
<a name="l04153"></a>04153       nData -= n+iDummy;
<a name="l04154"></a>04154     }
<a name="l04155"></a>04155   }
<a name="l04156"></a>04156 }
<a name="l04157"></a>04157 <span class="preprocessor">#define ASSERT_VALID_INTERIOR_BLOCK(x) interiorBlockValidate(x)</span>
<a name="l04158"></a>04158 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l04159"></a><a class="code" href="fts2_8c.html#a08927decebf72871d845ca645b517e43">04159</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_VALID_INTERIOR_BLOCK(x) assert( 1 )</span>
<a name="l04160"></a>04160 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04161"></a>04161 <span class="preprocessor"></span>
<a name="l04162"></a><a class="code" href="structInteriorWriter.html">04162</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structInteriorWriter.html">InteriorWriter</a> {
<a name="l04163"></a><a class="code" href="structInteriorWriter.html#a66d5e002280fe3fed89d72a67098aece">04163</a>   <span class="keywordtype">int</span> <a class="code" href="structInteriorWriter.html#a66d5e002280fe3fed89d72a67098aece">iHeight</a>;                   <span class="comment">/* from 0 at leaves. */</span>
<a name="l04164"></a><a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">04164</a>   <a class="code" href="structInteriorBlock.html">InteriorBlock</a> *<a class="code" href="structInteriorWriter.html#a5edb641e83e7c9d48a977923927d4d93">first</a>, *<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a>;
<a name="l04165"></a><a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">04165</a>   <span class="keyword">struct </span><a class="code" href="structInteriorWriter.html">InteriorWriter</a> *<a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">parentWriter</a>;
<a name="l04166"></a>04166 
<a name="l04167"></a><a class="code" href="structInteriorWriter.html#a766761f0dffd370a066f1a8eaf490611">04167</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structInteriorWriter.html#a766761f0dffd370a066f1a8eaf490611">term</a>;               <span class="comment">/* Last term written to block &quot;last&quot;. */</span>
<a name="l04168"></a><a class="code" href="structInteriorWriter.html#af660759501f38a750c184fcd7fafe574">04168</a>   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="structInteriorWriter.html#af660759501f38a750c184fcd7fafe574">iOpeningChildBlock</a>; <span class="comment">/* First child block in block &quot;last&quot;. */</span>
<a name="l04169"></a>04169 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l04170"></a>04170 <span class="preprocessor"></span>  <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iLastChildBlock;  <span class="comment">/* for consistency checks. */</span>
<a name="l04171"></a>04171 <span class="preprocessor">#endif</span>
<a name="l04172"></a>04172 <span class="preprocessor"></span>} <a class="code" href="structInteriorWriter.html">InteriorWriter</a>;
<a name="l04173"></a>04173 
<a name="l04174"></a>04174 <span class="comment">/* Initialize an interior node where pTerm[nTerm] marks the leftmost</span>
<a name="l04175"></a>04175 <span class="comment">** term in the tree.  iChildBlock is the leftmost child block at the</span>
<a name="l04176"></a>04176 <span class="comment">** next level down the tree.</span>
<a name="l04177"></a>04177 <span class="comment">*/</span>
<a name="l04178"></a><a class="code" href="fts2_8c.html#ac2e3eb946323c20d303227a16176cbbe">04178</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#ac2e3eb946323c20d303227a16176cbbe">interiorWriterInit</a>(<span class="keywordtype">int</span> <a class="code" href="structInteriorWriter.html#a66d5e002280fe3fed89d72a67098aece">iHeight</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm,
<a name="l04179"></a>04179                                <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iChildBlock,
<a name="l04180"></a>04180                                <a class="code" href="structInteriorWriter.html">InteriorWriter</a> *pWriter){
<a name="l04181"></a>04181   <a class="code" href="structInteriorBlock.html">InteriorBlock</a> *<a class="code" href="lparser_8c.html#a235428bed4c6be6cb6d2760cd0fa9d34">block</a>;
<a name="l04182"></a>04182   assert( iHeight&gt;0 );
<a name="l04183"></a>04183   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(pWriter);
<a name="l04184"></a>04184 
<a name="l04185"></a>04185   pWriter-&gt;<a class="code" href="structInteriorWriter.html#a66d5e002280fe3fed89d72a67098aece">iHeight</a> = iHeight;
<a name="l04186"></a>04186   pWriter-&gt;<a class="code" href="structInteriorWriter.html#af660759501f38a750c184fcd7fafe574">iOpeningChildBlock</a> = iChildBlock;
<a name="l04187"></a>04187 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l04188"></a>04188 <span class="preprocessor"></span>  pWriter-&gt;iLastChildBlock = iChildBlock;
<a name="l04189"></a>04189 <span class="preprocessor">#endif</span>
<a name="l04190"></a>04190 <span class="preprocessor"></span>  block = <a class="code" href="fts2_8c.html#a884cbe5c54b6893251c0b09edb7d096c">interiorBlockNew</a>(iHeight, iChildBlock, pTerm, nTerm);
<a name="l04191"></a>04191   pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a> = pWriter-&gt;<a class="code" href="structInteriorWriter.html#a5edb641e83e7c9d48a977923927d4d93">first</a> = block;
<a name="l04192"></a>04192   <a class="code" href="fts2_8c.html#a08927decebf72871d845ca645b517e43">ASSERT_VALID_INTERIOR_BLOCK</a>(pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a>);
<a name="l04193"></a>04193   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;pWriter-&gt;<a class="code" href="structInteriorWriter.html#a766761f0dffd370a066f1a8eaf490611">term</a>, 0);
<a name="l04194"></a>04194 }
<a name="l04195"></a>04195 
<a name="l04196"></a>04196 <span class="comment">/* Append the child node rooted at iChildBlock to the interior node,</span>
<a name="l04197"></a>04197 <span class="comment">** with pTerm[nTerm] as the leftmost term in iChildBlock&apos;s subtree.</span>
<a name="l04198"></a>04198 <span class="comment">*/</span>
<a name="l04199"></a><a class="code" href="fts2_8c.html#a937af8f1fab6a3e74672f3c2ddf20a04">04199</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a937af8f1fab6a3e74672f3c2ddf20a04">interiorWriterAppend</a>(<a class="code" href="structInteriorWriter.html">InteriorWriter</a> *pWriter,
<a name="l04200"></a>04200                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm,
<a name="l04201"></a>04201                                  <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iChildBlock){
<a name="l04202"></a>04202   <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>+<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l04203"></a>04203   <span class="keywordtype">int</span> n, nPrefix = 0;
<a name="l04204"></a>04204 
<a name="l04205"></a>04205   <a class="code" href="fts2_8c.html#a08927decebf72871d845ca645b517e43">ASSERT_VALID_INTERIOR_BLOCK</a>(pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a>);
<a name="l04206"></a>04206 
<a name="l04207"></a>04207   <span class="comment">/* The first term written into an interior node is actually</span>
<a name="l04208"></a>04208 <span class="comment">  ** associated with the second child added (the first child was added</span>
<a name="l04209"></a>04209 <span class="comment">  ** in interiorWriterInit, or in the if clause at the bottom of this</span>
<a name="l04210"></a>04210 <span class="comment">  ** function).  That term gets encoded straight up, with nPrefix left</span>
<a name="l04211"></a>04211 <span class="comment">  ** at 0.</span>
<a name="l04212"></a>04212 <span class="comment">  */</span>
<a name="l04213"></a>04213   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structInteriorWriter.html#a766761f0dffd370a066f1a8eaf490611">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>==0 ){
<a name="l04214"></a>04214     n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, nTerm);
<a name="l04215"></a>04215   }<span class="keywordflow">else</span>{
<a name="l04216"></a>04216     <span class="keywordflow">while</span>( nPrefix&lt;pWriter-&gt;<a class="code" href="structInteriorWriter.html#a766761f0dffd370a066f1a8eaf490611">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> &amp;&amp;
<a name="l04217"></a>04217            pTerm[nPrefix]==pWriter-&gt;<a class="code" href="structInteriorWriter.html#a766761f0dffd370a066f1a8eaf490611">term</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>[nPrefix] ){
<a name="l04218"></a>04218       nPrefix++;
<a name="l04219"></a>04219     }
<a name="l04220"></a>04220 
<a name="l04221"></a>04221     n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, nPrefix);
<a name="l04222"></a>04222     n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, nTerm-nPrefix);
<a name="l04223"></a>04223   }
<a name="l04224"></a>04224 
<a name="l04225"></a>04225 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l04226"></a>04226 <span class="preprocessor"></span>  pWriter-&gt;iLastChildBlock++;
<a name="l04227"></a>04227 <span class="preprocessor">#endif</span>
<a name="l04228"></a>04228 <span class="preprocessor"></span>  assert( pWriter-&gt;iLastChildBlock==iChildBlock );
<a name="l04229"></a>04229 
<a name="l04230"></a>04230   <span class="comment">/* Overflow to a new block if the new term makes the current block</span>
<a name="l04231"></a>04231 <span class="comment">  ** too big, and the current block already has enough terms.</span>
<a name="l04232"></a>04232 <span class="comment">  */</span>
<a name="l04233"></a>04233   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a>-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>+n+nTerm-nPrefix&gt;<a class="code" href="fts2_8c.html#ac9d04f781f68ad518fbc6ff1863a2bfd">INTERIOR_MAX</a> &amp;&amp;
<a name="l04234"></a>04234       iChildBlock-pWriter-&gt;<a class="code" href="structInteriorWriter.html#af660759501f38a750c184fcd7fafe574">iOpeningChildBlock</a>&gt;<a class="code" href="fts2_8c.html#ad42a28674f573597f0de849f76cb5436">INTERIOR_MIN_TERMS</a> ){
<a name="l04235"></a>04235     pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a>-&gt;<a class="code" href="structInteriorBlock.html#a24a635f2089ef150dace00887e79f29c">next</a> = <a class="code" href="fts2_8c.html#a884cbe5c54b6893251c0b09edb7d096c">interiorBlockNew</a>(pWriter-&gt;<a class="code" href="structInteriorWriter.html#a66d5e002280fe3fed89d72a67098aece">iHeight</a>, iChildBlock,
<a name="l04236"></a>04236                                            pTerm, nTerm);
<a name="l04237"></a>04237     pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a> = pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a>-&gt;<a class="code" href="structInteriorBlock.html#a24a635f2089ef150dace00887e79f29c">next</a>;
<a name="l04238"></a>04238     pWriter-&gt;<a class="code" href="structInteriorWriter.html#af660759501f38a750c184fcd7fafe574">iOpeningChildBlock</a> = iChildBlock;
<a name="l04239"></a>04239     <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(&amp;pWriter-&gt;<a class="code" href="structInteriorWriter.html#a766761f0dffd370a066f1a8eaf490611">term</a>);
<a name="l04240"></a>04240   }<span class="keywordflow">else</span>{
<a name="l04241"></a>04241     <a class="code" href="fts2_8c.html#a5cb462adcb518c795ccb9b8d1a44c0a2">dataBufferAppend2</a>(&amp;pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a>-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>, c, n,
<a name="l04242"></a>04242                       pTerm+nPrefix, nTerm-nPrefix);
<a name="l04243"></a>04243     <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(&amp;pWriter-&gt;<a class="code" href="structInteriorWriter.html#a766761f0dffd370a066f1a8eaf490611">term</a>, pTerm, nTerm);
<a name="l04244"></a>04244   }
<a name="l04245"></a>04245   <a class="code" href="fts2_8c.html#a08927decebf72871d845ca645b517e43">ASSERT_VALID_INTERIOR_BLOCK</a>(pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a>);
<a name="l04246"></a>04246 }
<a name="l04247"></a>04247 
<a name="l04248"></a>04248 <span class="comment">/* Free the space used by pWriter, including the linked-list of</span>
<a name="l04249"></a>04249 <span class="comment">** InteriorBlocks, and parentWriter, if present.</span>
<a name="l04250"></a>04250 <span class="comment">*/</span>
<a name="l04251"></a><a class="code" href="fts2_8c.html#a05d69f95a80b2013c0ac92a5e4ba8db8">04251</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a05d69f95a80b2013c0ac92a5e4ba8db8">interiorWriterDestroy</a>(<a class="code" href="structInteriorWriter.html">InteriorWriter</a> *pWriter){
<a name="l04252"></a>04252   <a class="code" href="structInteriorBlock.html">InteriorBlock</a> *<a class="code" href="lparser_8c.html#a235428bed4c6be6cb6d2760cd0fa9d34">block</a> = pWriter-&gt;<a class="code" href="structInteriorWriter.html#a5edb641e83e7c9d48a977923927d4d93">first</a>;
<a name="l04253"></a>04253 
<a name="l04254"></a>04254   <span class="keywordflow">while</span>( block!=NULL ){
<a name="l04255"></a>04255     <a class="code" href="structInteriorBlock.html">InteriorBlock</a> *b = block;
<a name="l04256"></a>04256     block = block-&gt;<a class="code" href="structInteriorBlock.html#a24a635f2089ef150dace00887e79f29c">next</a>;
<a name="l04257"></a>04257     <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;b-&gt;<a class="code" href="structInteriorBlock.html#a589803140cdb75ab5e96aaa569e94c72">term</a>);
<a name="l04258"></a>04258     <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;b-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>);
<a name="l04259"></a>04259     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(b);
<a name="l04260"></a>04260   }
<a name="l04261"></a>04261   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">parentWriter</a>!=NULL ){
<a name="l04262"></a>04262     <a class="code" href="fts2_8c.html#a05d69f95a80b2013c0ac92a5e4ba8db8">interiorWriterDestroy</a>(pWriter-&gt;<a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">parentWriter</a>);
<a name="l04263"></a>04263     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pWriter-&gt;<a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">parentWriter</a>);
<a name="l04264"></a>04264   }
<a name="l04265"></a>04265   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;pWriter-&gt;<a class="code" href="structInteriorWriter.html#a766761f0dffd370a066f1a8eaf490611">term</a>);
<a name="l04266"></a>04266   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pWriter);
<a name="l04267"></a>04267   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04268"></a>04268 }
<a name="l04269"></a>04269 
<a name="l04270"></a>04270 <span class="comment">/* If pWriter can fit entirely in ROOT_MAX, return it as the root info</span>
<a name="l04271"></a>04271 <span class="comment">** directly, leaving *piEndBlockid unchanged.  Otherwise, flush</span>
<a name="l04272"></a>04272 <span class="comment">** pWriter to %_segments, building a new layer of interior nodes, and</span>
<a name="l04273"></a>04273 <span class="comment">** recursively ask for their root into.</span>
<a name="l04274"></a>04274 <span class="comment">*/</span>
<a name="l04275"></a><a class="code" href="fts2_8c.html#a9e9ec5b4464a4c41a6e1a44dca688c41">04275</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a9e9ec5b4464a4c41a6e1a44dca688c41">interiorWriterRootInfo</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structInteriorWriter.html">InteriorWriter</a> *pWriter,
<a name="l04276"></a>04276                                   <span class="keywordtype">char</span> **ppRootInfo, <span class="keywordtype">int</span> *pnRootInfo,
<a name="l04277"></a>04277                                   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piEndBlockid){
<a name="l04278"></a>04278   <a class="code" href="structInteriorBlock.html">InteriorBlock</a> *<a class="code" href="lparser_8c.html#a235428bed4c6be6cb6d2760cd0fa9d34">block</a> = pWriter-&gt;<a class="code" href="structInteriorWriter.html#a5edb641e83e7c9d48a977923927d4d93">first</a>;
<a name="l04279"></a>04279   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iBlockid = 0;
<a name="l04280"></a>04280   <span class="keywordtype">int</span> rc;
<a name="l04281"></a>04281 
<a name="l04282"></a>04282   <span class="comment">/* If we can fit the segment inline */</span>
<a name="l04283"></a>04283   <span class="keywordflow">if</span>( block==pWriter-&gt;<a class="code" href="structInteriorWriter.html#a34f728dc8455d3b54193ba1837cd69f0">last</a> &amp;&amp; block-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&lt;<a class="code" href="fts2_8c.html#a1b6ab30572ba9a027bbb90a0f599f6ad">ROOT_MAX</a> ){
<a name="l04284"></a>04284     *ppRootInfo = block-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>;
<a name="l04285"></a>04285     *pnRootInfo = block-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>;
<a name="l04286"></a>04286     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04287"></a>04287   }
<a name="l04288"></a>04288 
<a name="l04289"></a>04289   <span class="comment">/* Flush the first block to %_segments, and create a new level of</span>
<a name="l04290"></a>04290 <span class="comment">  ** interior node.</span>
<a name="l04291"></a>04291 <span class="comment">  */</span>
<a name="l04292"></a>04292   <a class="code" href="fts2_8c.html#a08927decebf72871d845ca645b517e43">ASSERT_VALID_INTERIOR_BLOCK</a>(block);
<a name="l04293"></a>04293   rc = <a class="code" href="fts2_8c.html#abaeb71e066db78e51476730392b1f28c">block_insert</a>(v, block-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, block-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, &amp;iBlockid);
<a name="l04294"></a>04294   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04295"></a>04295   *piEndBlockid = iBlockid;
<a name="l04296"></a>04296 
<a name="l04297"></a>04297   pWriter-&gt;<a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">parentWriter</a> = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(<span class="keyword">sizeof</span>(*pWriter-&gt;<a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">parentWriter</a>));
<a name="l04298"></a>04298   <a class="code" href="fts2_8c.html#ac2e3eb946323c20d303227a16176cbbe">interiorWriterInit</a>(pWriter-&gt;<a class="code" href="structInteriorWriter.html#a66d5e002280fe3fed89d72a67098aece">iHeight</a>+1,
<a name="l04299"></a>04299                      block-&gt;<a class="code" href="structInteriorBlock.html#a589803140cdb75ab5e96aaa569e94c72">term</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, block-&gt;<a class="code" href="structInteriorBlock.html#a589803140cdb75ab5e96aaa569e94c72">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>,
<a name="l04300"></a>04300                      iBlockid, pWriter-&gt;<a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">parentWriter</a>);
<a name="l04301"></a>04301 
<a name="l04302"></a>04302   <span class="comment">/* Flush additional blocks and append to the higher interior</span>
<a name="l04303"></a>04303 <span class="comment">  ** node.</span>
<a name="l04304"></a>04304 <span class="comment">  */</span>
<a name="l04305"></a>04305   <span class="keywordflow">for</span>(block=block-&gt;<a class="code" href="structInteriorBlock.html#a24a635f2089ef150dace00887e79f29c">next</a>; block!=NULL; block=block-&gt;<a class="code" href="structInteriorBlock.html#a24a635f2089ef150dace00887e79f29c">next</a>){
<a name="l04306"></a>04306     <a class="code" href="fts2_8c.html#a08927decebf72871d845ca645b517e43">ASSERT_VALID_INTERIOR_BLOCK</a>(block);
<a name="l04307"></a>04307     rc = <a class="code" href="fts2_8c.html#abaeb71e066db78e51476730392b1f28c">block_insert</a>(v, block-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, block-&gt;<a class="code" href="structInteriorBlock.html#af4d1d170ee8b399f006b9573e2e3f1ad">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, &amp;iBlockid);
<a name="l04308"></a>04308     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04309"></a>04309     *piEndBlockid = iBlockid;
<a name="l04310"></a>04310 
<a name="l04311"></a>04311     <a class="code" href="fts2_8c.html#a937af8f1fab6a3e74672f3c2ddf20a04">interiorWriterAppend</a>(pWriter-&gt;<a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">parentWriter</a>,
<a name="l04312"></a>04312                          block-&gt;<a class="code" href="structInteriorBlock.html#a589803140cdb75ab5e96aaa569e94c72">term</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, block-&gt;<a class="code" href="structInteriorBlock.html#a589803140cdb75ab5e96aaa569e94c72">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, iBlockid);
<a name="l04313"></a>04313   }
<a name="l04314"></a>04314 
<a name="l04315"></a>04315   <span class="comment">/* Parent node gets the chance to be the root. */</span>
<a name="l04316"></a>04316   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a9e9ec5b4464a4c41a6e1a44dca688c41">interiorWriterRootInfo</a>(v, pWriter-&gt;<a class="code" href="structInteriorWriter.html#a3379fcd7b99525791aeb5503c2175266">parentWriter</a>,
<a name="l04317"></a>04317                                 ppRootInfo, pnRootInfo, piEndBlockid);
<a name="l04318"></a>04318 }
<a name="l04319"></a>04319 
<a name="l04320"></a>04320 <span class="comment">/****************************************************************/</span>
<a name="l04321"></a>04321 <span class="comment">/* InteriorReader is used to read off the data from an interior node</span>
<a name="l04322"></a>04322 <span class="comment">** (see comment at top of file for the format).</span>
<a name="l04323"></a>04323 <span class="comment">*/</span>
<a name="l04324"></a><a class="code" href="structInteriorReader.html">04324</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structInteriorReader.html">InteriorReader</a> {
<a name="l04325"></a><a class="code" href="structInteriorReader.html#a15be100d9767fb960ea3d256fc84c834">04325</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *pData;
<a name="l04326"></a><a class="code" href="structInteriorReader.html#a2e6441911502d84246fb9054936fd469">04326</a>   <span class="keywordtype">int</span> nData;
<a name="l04327"></a>04327 
<a name="l04328"></a><a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">04328</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>;          <span class="comment">/* previous term, for decoding term delta. */</span>
<a name="l04329"></a>04329 
<a name="l04330"></a><a class="code" href="structInteriorReader.html#a8566d0d403e52de47e6443c7a9c03dbe">04330</a>   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iBlockid;
<a name="l04331"></a>04331 } <a class="code" href="structInteriorReader.html">InteriorReader</a>;
<a name="l04332"></a>04332 
<a name="l04333"></a><a class="code" href="fts2_8c.html#a0bb0bfbe9224066fd21711fccf1f5ac5">04333</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a0bb0bfbe9224066fd21711fccf1f5ac5">interiorReaderDestroy</a>(<a class="code" href="structInteriorReader.html">InteriorReader</a> *pReader){
<a name="l04334"></a>04334   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>);
<a name="l04335"></a>04335   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pReader);
<a name="l04336"></a>04336 }
<a name="l04337"></a>04337 
<a name="l04338"></a>04338 <span class="comment">/* TODO(shess) The assertions are great, but what if we&apos;re in NDEBUG</span>
<a name="l04339"></a>04339 <span class="comment">** and the blob is empty or otherwise contains suspect data?</span>
<a name="l04340"></a>04340 <span class="comment">*/</span>
<a name="l04341"></a><a class="code" href="fts2_8c.html#a09561929f8d74f2ffdf0f7505950b037">04341</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a09561929f8d74f2ffdf0f7505950b037">interiorReaderInit</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l04342"></a>04342                                <a class="code" href="structInteriorReader.html">InteriorReader</a> *pReader){
<a name="l04343"></a>04343   <span class="keywordtype">int</span> n, nTerm;
<a name="l04344"></a>04344 
<a name="l04345"></a>04345   <span class="comment">/* Require at least the leading flag byte */</span>
<a name="l04346"></a>04346   assert( nData&gt;0 );
<a name="l04347"></a>04347   assert( pData[0]!=<span class="charliteral">&apos;\0&apos;</span> );
<a name="l04348"></a>04348 
<a name="l04349"></a>04349   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(pReader);
<a name="l04350"></a>04350 
<a name="l04351"></a>04351   <span class="comment">/* Decode the base blockid, and set the cursor to the first term. */</span>
<a name="l04352"></a>04352   n = <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pData+1, &amp;pReader-&gt;<a class="code" href="structInteriorReader.html#a8566d0d403e52de47e6443c7a9c03dbe">iBlockid</a>);
<a name="l04353"></a>04353   assert( 1+n&lt;=nData );
<a name="l04354"></a>04354   pReader-&gt;<a class="code" href="structInteriorReader.html#a15be100d9767fb960ea3d256fc84c834">pData</a> = pData+1+n;
<a name="l04355"></a>04355   pReader-&gt;<a class="code" href="structInteriorReader.html#a2e6441911502d84246fb9054936fd469">nData</a> = nData-(1+n);
<a name="l04356"></a>04356 
<a name="l04357"></a>04357   <span class="comment">/* A single-child interior node (such as when a leaf node was too</span>
<a name="l04358"></a>04358 <span class="comment">  ** large for the segment directory) won&apos;t have any terms.</span>
<a name="l04359"></a>04359 <span class="comment">  ** Otherwise, decode the first term.</span>
<a name="l04360"></a>04360 <span class="comment">  */</span>
<a name="l04361"></a>04361   <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structInteriorReader.html#a2e6441911502d84246fb9054936fd469">nData</a>==0 ){
<a name="l04362"></a>04362     <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>, 0);
<a name="l04363"></a>04363   }<span class="keywordflow">else</span>{
<a name="l04364"></a>04364     n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structInteriorReader.html#a15be100d9767fb960ea3d256fc84c834">pData</a>, &amp;nTerm);
<a name="l04365"></a>04365     <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>, nTerm);
<a name="l04366"></a>04366     <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(&amp;pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>, pReader-&gt;<a class="code" href="structInteriorReader.html#a15be100d9767fb960ea3d256fc84c834">pData</a>+n, nTerm);
<a name="l04367"></a>04367     assert( n+nTerm&lt;=pReader-&gt;nData );
<a name="l04368"></a>04368     pReader-&gt;<a class="code" href="structInteriorReader.html#a15be100d9767fb960ea3d256fc84c834">pData</a> += n+nTerm;
<a name="l04369"></a>04369     pReader-&gt;<a class="code" href="structInteriorReader.html#a2e6441911502d84246fb9054936fd469">nData</a> -= n+nTerm;
<a name="l04370"></a>04370   }
<a name="l04371"></a>04371 }
<a name="l04372"></a>04372 
<a name="l04373"></a><a class="code" href="fts2_8c.html#a9585535a38c948428465edcb542c4663">04373</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a9585535a38c948428465edcb542c4663">interiorReaderAtEnd</a>(<a class="code" href="structInteriorReader.html">InteriorReader</a> *pReader){
<a name="l04374"></a>04374   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>==0;
<a name="l04375"></a>04375 }
<a name="l04376"></a>04376 
<a name="l04377"></a><a class="code" href="fts2_8c.html#a97fa4341bee8054f286cf1c1b316b978">04377</a> <span class="keyword">static</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="fts2_8c.html#a97fa4341bee8054f286cf1c1b316b978">interiorReaderCurrentBlockid</a>(<a class="code" href="structInteriorReader.html">InteriorReader</a> *pReader){
<a name="l04378"></a>04378   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structInteriorReader.html#a8566d0d403e52de47e6443c7a9c03dbe">iBlockid</a>;
<a name="l04379"></a>04379 }
<a name="l04380"></a>04380 
<a name="l04381"></a><a class="code" href="fts2_8c.html#a86c1bc3f3b72efce99fe5c29dced30c5">04381</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a86c1bc3f3b72efce99fe5c29dced30c5">interiorReaderTermBytes</a>(<a class="code" href="structInteriorReader.html">InteriorReader</a> *pReader){
<a name="l04382"></a>04382   assert( !<a class="code" href="fts2_8c.html#a9585535a38c948428465edcb542c4663">interiorReaderAtEnd</a>(pReader) );
<a name="l04383"></a>04383   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>;
<a name="l04384"></a>04384 }
<a name="l04385"></a><a class="code" href="fts2_8c.html#a10e2ed805e8aa3a7714eb6789e863f31">04385</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a10e2ed805e8aa3a7714eb6789e863f31">interiorReaderTerm</a>(<a class="code" href="structInteriorReader.html">InteriorReader</a> *pReader){
<a name="l04386"></a>04386   assert( !<a class="code" href="fts2_8c.html#a9585535a38c948428465edcb542c4663">interiorReaderAtEnd</a>(pReader) );
<a name="l04387"></a>04387   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>;
<a name="l04388"></a>04388 }
<a name="l04389"></a>04389 
<a name="l04390"></a>04390 <span class="comment">/* Step forward to the next term in the node. */</span>
<a name="l04391"></a><a class="code" href="fts2_8c.html#accf30a1322b22598236f12584001363c">04391</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#accf30a1322b22598236f12584001363c">interiorReaderStep</a>(<a class="code" href="structInteriorReader.html">InteriorReader</a> *pReader){
<a name="l04392"></a>04392   assert( !<a class="code" href="fts2_8c.html#a9585535a38c948428465edcb542c4663">interiorReaderAtEnd</a>(pReader) );
<a name="l04393"></a>04393 
<a name="l04394"></a>04394   <span class="comment">/* If the last term has been read, signal eof, else construct the</span>
<a name="l04395"></a>04395 <span class="comment">  ** next term.</span>
<a name="l04396"></a>04396 <span class="comment">  */</span>
<a name="l04397"></a>04397   <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structInteriorReader.html#a2e6441911502d84246fb9054936fd469">nData</a>==0 ){
<a name="l04398"></a>04398     <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(&amp;pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>);
<a name="l04399"></a>04399   }<span class="keywordflow">else</span>{
<a name="l04400"></a>04400     <span class="keywordtype">int</span> n, nPrefix, nSuffix;
<a name="l04401"></a>04401 
<a name="l04402"></a>04402     n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structInteriorReader.html#a15be100d9767fb960ea3d256fc84c834">pData</a>, &amp;nPrefix);
<a name="l04403"></a>04403     n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structInteriorReader.html#a15be100d9767fb960ea3d256fc84c834">pData</a>+n, &amp;nSuffix);
<a name="l04404"></a>04404 
<a name="l04405"></a>04405     <span class="comment">/* Truncate the current term and append suffix data. */</span>
<a name="l04406"></a>04406     pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> = nPrefix;
<a name="l04407"></a>04407     <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(&amp;pReader-&gt;<a class="code" href="structInteriorReader.html#a8b22852e13776d704fb2c03b2051a980">term</a>, pReader-&gt;<a class="code" href="structInteriorReader.html#a15be100d9767fb960ea3d256fc84c834">pData</a>+n, nSuffix);
<a name="l04408"></a>04408 
<a name="l04409"></a>04409     assert( n+nSuffix&lt;=pReader-&gt;nData );
<a name="l04410"></a>04410     pReader-&gt;<a class="code" href="structInteriorReader.html#a15be100d9767fb960ea3d256fc84c834">pData</a> += n+nSuffix;
<a name="l04411"></a>04411     pReader-&gt;<a class="code" href="structInteriorReader.html#a2e6441911502d84246fb9054936fd469">nData</a> -= n+nSuffix;
<a name="l04412"></a>04412   }
<a name="l04413"></a>04413   pReader-&gt;<a class="code" href="structInteriorReader.html#a8566d0d403e52de47e6443c7a9c03dbe">iBlockid</a>++;
<a name="l04414"></a>04414 }
<a name="l04415"></a>04415 
<a name="l04416"></a>04416 <span class="comment">/* Compare the current term to pTerm[nTerm], returning strcmp-style</span>
<a name="l04417"></a>04417 <span class="comment">** results.  If isPrefix, equality means equal through nTerm bytes.</span>
<a name="l04418"></a>04418 <span class="comment">*/</span>
<a name="l04419"></a><a class="code" href="fts2_8c.html#af2fcb5b213fc28024b1916f605a1a015">04419</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#af2fcb5b213fc28024b1916f605a1a015">interiorReaderTermCmp</a>(<a class="code" href="structInteriorReader.html">InteriorReader</a> *pReader,
<a name="l04420"></a>04420                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix){
<a name="l04421"></a>04421   <span class="keyword">const</span> <span class="keywordtype">char</span> *pReaderTerm = <a class="code" href="fts2_8c.html#a10e2ed805e8aa3a7714eb6789e863f31">interiorReaderTerm</a>(pReader);
<a name="l04422"></a>04422   <span class="keywordtype">int</span> nReaderTerm = <a class="code" href="fts2_8c.html#a86c1bc3f3b72efce99fe5c29dced30c5">interiorReaderTermBytes</a>(pReader);
<a name="l04423"></a>04423   <span class="keywordtype">int</span> c, n = nReaderTerm&lt;nTerm ? nReaderTerm : nTerm;
<a name="l04424"></a>04424 
<a name="l04425"></a>04425   <span class="keywordflow">if</span>( n==0 ){
<a name="l04426"></a>04426     <span class="keywordflow">if</span>( nReaderTerm&gt;0 ) <span class="keywordflow">return</span> -1;
<a name="l04427"></a>04427     <span class="keywordflow">if</span>( nTerm&gt;0 ) <span class="keywordflow">return</span> 1;
<a name="l04428"></a>04428     <span class="keywordflow">return</span> 0;
<a name="l04429"></a>04429   }
<a name="l04430"></a>04430 
<a name="l04431"></a>04431   c = memcmp(pReaderTerm, pTerm, n);
<a name="l04432"></a>04432   <span class="keywordflow">if</span>( c!=0 ) <span class="keywordflow">return</span> c;
<a name="l04433"></a>04433   <span class="keywordflow">if</span>( isPrefix &amp;&amp; n==nTerm ) <span class="keywordflow">return</span> 0;
<a name="l04434"></a>04434   <span class="keywordflow">return</span> nReaderTerm - nTerm;
<a name="l04435"></a>04435 }
<a name="l04436"></a>04436 
<a name="l04437"></a>04437 <span class="comment">/****************************************************************/</span>
<a name="l04438"></a>04438 <span class="comment">/* LeafWriter is used to collect terms and associated doclist data</span>
<a name="l04439"></a>04439 <span class="comment">** into leaf blocks in %_segments (see top of file for format info).</span>
<a name="l04440"></a>04440 <span class="comment">** Expected usage is:</span>
<a name="l04441"></a>04441 <span class="comment">**</span>
<a name="l04442"></a>04442 <span class="comment">** LeafWriter writer;</span>
<a name="l04443"></a>04443 <span class="comment">** leafWriterInit(0, 0, &amp;writer);</span>
<a name="l04444"></a>04444 <span class="comment">** while( sorted_terms_left_to_process ){</span>
<a name="l04445"></a>04445 <span class="comment">**   // data is doclist data for that term.</span>
<a name="l04446"></a>04446 <span class="comment">**   rc = leafWriterStep(v, &amp;writer, pTerm, nTerm, pData, nData);</span>
<a name="l04447"></a>04447 <span class="comment">**   if( rc!=SQLITE_OK ) goto err;</span>
<a name="l04448"></a>04448 <span class="comment">** }</span>
<a name="l04449"></a>04449 <span class="comment">** rc = leafWriterFinalize(v, &amp;writer);</span>
<a name="l04450"></a>04450 <span class="comment">**err:</span>
<a name="l04451"></a>04451 <span class="comment">** leafWriterDestroy(&amp;writer);</span>
<a name="l04452"></a>04452 <span class="comment">** return rc;</span>
<a name="l04453"></a>04453 <span class="comment">**</span>
<a name="l04454"></a>04454 <span class="comment">** leafWriterStep() may write a collected leaf out to %_segments.</span>
<a name="l04455"></a>04455 <span class="comment">** leafWriterFinalize() finishes writing any buffered data and stores</span>
<a name="l04456"></a>04456 <span class="comment">** a root node in %_segdir.  leafWriterDestroy() frees all buffers and</span>
<a name="l04457"></a>04457 <span class="comment">** InteriorWriters allocated as part of writing this segment.</span>
<a name="l04458"></a>04458 <span class="comment">**</span>
<a name="l04459"></a>04459 <span class="comment">** TODO(shess) Document leafWriterStepMerge().</span>
<a name="l04460"></a>04460 <span class="comment">*/</span>
<a name="l04461"></a>04461 
<a name="l04462"></a>04462 <span class="comment">/* Put terms with data this big in their own block. */</span>
<a name="l04463"></a><a class="code" href="fts2_8c.html#a99dabb4a83a0748b5f147318f3d558d2">04463</a> <span class="preprocessor">#define STANDALONE_MIN 1024</span>
<a name="l04464"></a>04464 <span class="preprocessor"></span>
<a name="l04465"></a>04465 <span class="comment">/* Keep leaf blocks below this size. */</span>
<a name="l04466"></a><a class="code" href="fts2_8c.html#a3b0ee26d7e03f91390592ac852e33369">04466</a> <span class="preprocessor">#define LEAF_MAX 2048</span>
<a name="l04467"></a>04467 <span class="preprocessor"></span>
<a name="l04468"></a><a class="code" href="structLeafWriter.html">04468</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structLeafWriter.html">LeafWriter</a> {
<a name="l04469"></a><a class="code" href="structLeafWriter.html#a42551bce2a603ac9a36cf0b0db95f744">04469</a>   <span class="keywordtype">int</span> <a class="code" href="structLeafWriter.html#a42551bce2a603ac9a36cf0b0db95f744">iLevel</a>;
<a name="l04470"></a><a class="code" href="structLeafWriter.html#a385bac876d393a8ac7c8446f05327bff">04470</a>   <span class="keywordtype">int</span> <a class="code" href="structLeafWriter.html#a385bac876d393a8ac7c8446f05327bff">idx</a>;
<a name="l04471"></a><a class="code" href="structLeafWriter.html#a920a4e8f9c822c7fc2b297f68de21572">04471</a>   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="structLeafWriter.html#a920a4e8f9c822c7fc2b297f68de21572">iStartBlockid</a>;     <span class="comment">/* needed to create the root info */</span>
<a name="l04472"></a><a class="code" href="structLeafWriter.html#ab44295ac6f8fede3353a437fafa7d0cf">04472</a>   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> <a class="code" href="structLeafWriter.html#ab44295ac6f8fede3353a437fafa7d0cf">iEndBlockid</a>;       <span class="comment">/* when we&apos;re done writing. */</span>
<a name="l04473"></a>04473 
<a name="l04474"></a><a class="code" href="structLeafWriter.html#a5653e0f44b5a965b3a542064ce49e8a7">04474</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structLeafWriter.html#a5653e0f44b5a965b3a542064ce49e8a7">term</a>;                <span class="comment">/* previous encoded term */</span>
<a name="l04475"></a><a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">04475</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>;                <span class="comment">/* encoding buffer */</span>
<a name="l04476"></a>04476 
<a name="l04477"></a>04477   <span class="comment">/* bytes of first term in the current node which distinguishes that</span>
<a name="l04478"></a>04478 <span class="comment">  ** term from the last term of the previous node.</span>
<a name="l04479"></a>04479 <span class="comment">  */</span>
<a name="l04480"></a><a class="code" href="structLeafWriter.html#ae952429cefa31de5126dd08f2a64ab3f">04480</a>   <span class="keywordtype">int</span> <a class="code" href="structLeafWriter.html#ae952429cefa31de5126dd08f2a64ab3f">nTermDistinct</a>;
<a name="l04481"></a>04481 
<a name="l04482"></a><a class="code" href="structLeafWriter.html#ae1d25750377c616a6f0824584f3e1070">04482</a>   <a class="code" href="structInteriorWriter.html">InteriorWriter</a> <a class="code" href="structLeafWriter.html#ae1d25750377c616a6f0824584f3e1070">parentWriter</a>;    <span class="comment">/* if we overflow */</span>
<a name="l04483"></a><a class="code" href="structLeafWriter.html#a0d231473d9a5cc70239969b5d57216e5">04483</a>   <span class="keywordtype">int</span> <a class="code" href="structLeafWriter.html#a0d231473d9a5cc70239969b5d57216e5">has_parent</a>;
<a name="l04484"></a>04484 } <a class="code" href="structLeafWriter.html">LeafWriter</a>;
<a name="l04485"></a>04485 
<a name="l04486"></a><a class="code" href="fts2_8c.html#a86612bb723ea03d3cf9cee54b300e8d8">04486</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a86612bb723ea03d3cf9cee54b300e8d8">leafWriterInit</a>(<span class="keywordtype">int</span> iLevel, <span class="keywordtype">int</span> idx, <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter){
<a name="l04487"></a>04487   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(pWriter);
<a name="l04488"></a>04488   pWriter-&gt;<a class="code" href="structLeafWriter.html#a42551bce2a603ac9a36cf0b0db95f744">iLevel</a> = iLevel;
<a name="l04489"></a>04489   pWriter-&gt;<a class="code" href="structLeafWriter.html#a385bac876d393a8ac7c8446f05327bff">idx</a> = idx;
<a name="l04490"></a>04490 
<a name="l04491"></a>04491   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a5653e0f44b5a965b3a542064ce49e8a7">term</a>, 32);
<a name="l04492"></a>04492 
<a name="l04493"></a>04493   <span class="comment">/* Start out with a reasonably sized block, though it can grow. */</span>
<a name="l04494"></a>04494   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>, <a class="code" href="fts2_8c.html#a3b0ee26d7e03f91390592ac852e33369">LEAF_MAX</a>);
<a name="l04495"></a>04495 }
<a name="l04496"></a>04496 
<a name="l04497"></a>04497 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l04498"></a>04498 <span class="preprocessor"></span><span class="comment">/* Verify that the data is readable as a leaf node. */</span>
<a name="l04499"></a>04499 <span class="keyword">static</span> <span class="keywordtype">void</span> leafNodeValidate(<span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData){
<a name="l04500"></a>04500   <span class="keywordtype">int</span> n, iDummy;
<a name="l04501"></a>04501 
<a name="l04502"></a>04502   <span class="keywordflow">if</span>( nData==0 ) <span class="keywordflow">return</span>;
<a name="l04503"></a>04503   assert( nData&gt;0 );
<a name="l04504"></a>04504   assert( pData!=0 );
<a name="l04505"></a>04505   assert( pData+nData&gt;pData );
<a name="l04506"></a>04506 
<a name="l04507"></a>04507   <span class="comment">/* Must lead with a varint(0) */</span>
<a name="l04508"></a>04508   n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04509"></a>04509   assert( iDummy==0 );
<a name="l04510"></a>04510   assert( n&gt;0 );
<a name="l04511"></a>04511   assert( n&lt;nData );
<a name="l04512"></a>04512   pData += n;
<a name="l04513"></a>04513   nData -= n;
<a name="l04514"></a>04514 
<a name="l04515"></a>04515   <span class="comment">/* Leading term length and data must fit in buffer. */</span>
<a name="l04516"></a>04516   n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04517"></a>04517   assert( n&gt;0 );
<a name="l04518"></a>04518   assert( iDummy&gt;0 );
<a name="l04519"></a>04519   assert( n+iDummy&gt;0 );
<a name="l04520"></a>04520   assert( n+iDummy&lt;nData );
<a name="l04521"></a>04521   pData += n+iDummy;
<a name="l04522"></a>04522   nData -= n+iDummy;
<a name="l04523"></a>04523 
<a name="l04524"></a>04524   <span class="comment">/* Leading term&apos;s doclist length and data must fit. */</span>
<a name="l04525"></a>04525   n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04526"></a>04526   assert( n&gt;0 );
<a name="l04527"></a>04527   assert( iDummy&gt;0 );
<a name="l04528"></a>04528   assert( n+iDummy&gt;0 );
<a name="l04529"></a>04529   assert( n+iDummy&lt;=nData );
<a name="l04530"></a>04530   <a class="code" href="fts2_8c.html#ac0a9fdb841eb19d55fc4ecb511f6b1aa">ASSERT_VALID_DOCLIST</a>(<a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, pData+n, iDummy, NULL);
<a name="l04531"></a>04531   pData += n+iDummy;
<a name="l04532"></a>04532   nData -= n+iDummy;
<a name="l04533"></a>04533 
<a name="l04534"></a>04534   <span class="comment">/* Verify that trailing terms and doclists also are readable. */</span>
<a name="l04535"></a>04535   <span class="keywordflow">while</span>( nData!=0 ){
<a name="l04536"></a>04536     n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04537"></a>04537     assert( n&gt;0 );
<a name="l04538"></a>04538     assert( iDummy&gt;=0 );
<a name="l04539"></a>04539     assert( n&lt;nData );
<a name="l04540"></a>04540     pData += n;
<a name="l04541"></a>04541     nData -= n;
<a name="l04542"></a>04542     n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04543"></a>04543     assert( n&gt;0 );
<a name="l04544"></a>04544     assert( iDummy&gt;0 );
<a name="l04545"></a>04545     assert( n+iDummy&gt;0 );
<a name="l04546"></a>04546     assert( n+iDummy&lt;nData );
<a name="l04547"></a>04547     pData += n+iDummy;
<a name="l04548"></a>04548     nData -= n+iDummy;
<a name="l04549"></a>04549 
<a name="l04550"></a>04550     n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData, &amp;iDummy);
<a name="l04551"></a>04551     assert( n&gt;0 );
<a name="l04552"></a>04552     assert( iDummy&gt;0 );
<a name="l04553"></a>04553     assert( n+iDummy&gt;0 );
<a name="l04554"></a>04554     assert( n+iDummy&lt;=nData );
<a name="l04555"></a>04555     <a class="code" href="fts2_8c.html#ac0a9fdb841eb19d55fc4ecb511f6b1aa">ASSERT_VALID_DOCLIST</a>(<a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, pData+n, iDummy, NULL);
<a name="l04556"></a>04556     pData += n+iDummy;
<a name="l04557"></a>04557     nData -= n+iDummy;
<a name="l04558"></a>04558   }
<a name="l04559"></a>04559 }
<a name="l04560"></a>04560 <span class="preprocessor">#define ASSERT_VALID_LEAF_NODE(p, n) leafNodeValidate(p, n)</span>
<a name="l04561"></a>04561 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l04562"></a><a class="code" href="fts2_8c.html#acc3ff3feb9c554745218ddb2529eae60">04562</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_VALID_LEAF_NODE(p, n) assert( 1 )</span>
<a name="l04563"></a>04563 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04564"></a>04564 <span class="preprocessor"></span>
<a name="l04565"></a>04565 <span class="comment">/* Flush the current leaf node to %_segments, and adding the resulting</span>
<a name="l04566"></a>04566 <span class="comment">** blockid and the starting term to the interior node which will</span>
<a name="l04567"></a>04567 <span class="comment">** contain it.</span>
<a name="l04568"></a>04568 <span class="comment">*/</span>
<a name="l04569"></a><a class="code" href="fts2_8c.html#ad1a1ccff82b0ee083f3b5e164e4322fe">04569</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ad1a1ccff82b0ee083f3b5e164e4322fe">leafWriterInternalFlush</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter,
<a name="l04570"></a>04570                                    <span class="keywordtype">int</span> iData, <span class="keywordtype">int</span> nData){
<a name="l04571"></a>04571   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iBlockid = 0;
<a name="l04572"></a>04572   <span class="keyword">const</span> <span class="keywordtype">char</span> *pStartingTerm;
<a name="l04573"></a>04573   <span class="keywordtype">int</span> nStartingTerm, rc, n;
<a name="l04574"></a>04574 
<a name="l04575"></a>04575   <span class="comment">/* Must have the leading varint(0) flag, plus at least some</span>
<a name="l04576"></a>04576 <span class="comment">  ** valid-looking data.</span>
<a name="l04577"></a>04577 <span class="comment">  */</span>
<a name="l04578"></a>04578   assert( nData&gt;2 );
<a name="l04579"></a>04579   assert( iData&gt;=0 );
<a name="l04580"></a>04580   assert( iData+nData&lt;=pWriter-&gt;data.nData );
<a name="l04581"></a>04581   <a class="code" href="fts2_8c.html#acc3ff3feb9c554745218ddb2529eae60">ASSERT_VALID_LEAF_NODE</a>(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iData, nData);
<a name="l04582"></a>04582 
<a name="l04583"></a>04583   rc = <a class="code" href="fts2_8c.html#abaeb71e066db78e51476730392b1f28c">block_insert</a>(v, pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iData, nData, &amp;iBlockid);
<a name="l04584"></a>04584   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04585"></a>04585   assert( iBlockid!=0 );
<a name="l04586"></a>04586 
<a name="l04587"></a>04587   <span class="comment">/* Reconstruct the first term in the leaf for purposes of building</span>
<a name="l04588"></a>04588 <span class="comment">  ** the interior node.</span>
<a name="l04589"></a>04589 <span class="comment">  */</span>
<a name="l04590"></a>04590   n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iData+1, &amp;nStartingTerm);
<a name="l04591"></a>04591   pStartingTerm = pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iData+1+n;
<a name="l04592"></a>04592   assert( pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;iData+1+n+nStartingTerm );
<a name="l04593"></a>04593   assert( pWriter-&gt;<a class="code" href="structLeafWriter.html#ae952429cefa31de5126dd08f2a64ab3f">nTermDistinct</a>&gt;0 );
<a name="l04594"></a>04594   assert( pWriter-&gt;<a class="code" href="structLeafWriter.html#ae952429cefa31de5126dd08f2a64ab3f">nTermDistinct</a>&lt;=nStartingTerm );
<a name="l04595"></a>04595   nStartingTerm = pWriter-&gt;<a class="code" href="structLeafWriter.html#ae952429cefa31de5126dd08f2a64ab3f">nTermDistinct</a>;
<a name="l04596"></a>04596 
<a name="l04597"></a>04597   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structLeafWriter.html#a0d231473d9a5cc70239969b5d57216e5">has_parent</a> ){
<a name="l04598"></a>04598     <a class="code" href="fts2_8c.html#a937af8f1fab6a3e74672f3c2ddf20a04">interiorWriterAppend</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#ae1d25750377c616a6f0824584f3e1070">parentWriter</a>,
<a name="l04599"></a>04599                          pStartingTerm, nStartingTerm, iBlockid);
<a name="l04600"></a>04600   }<span class="keywordflow">else</span>{
<a name="l04601"></a>04601     <a class="code" href="fts2_8c.html#ac2e3eb946323c20d303227a16176cbbe">interiorWriterInit</a>(1, pStartingTerm, nStartingTerm, iBlockid,
<a name="l04602"></a>04602                        &amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#ae1d25750377c616a6f0824584f3e1070">parentWriter</a>);
<a name="l04603"></a>04603     pWriter-&gt;<a class="code" href="structLeafWriter.html#a0d231473d9a5cc70239969b5d57216e5">has_parent</a> = 1;
<a name="l04604"></a>04604   }
<a name="l04605"></a>04605 
<a name="l04606"></a>04606   <span class="comment">/* Track the span of this segment&apos;s leaf nodes. */</span>
<a name="l04607"></a>04607   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structLeafWriter.html#ab44295ac6f8fede3353a437fafa7d0cf">iEndBlockid</a>==0 ){
<a name="l04608"></a>04608     pWriter-&gt;<a class="code" href="structLeafWriter.html#ab44295ac6f8fede3353a437fafa7d0cf">iEndBlockid</a> = pWriter-&gt;<a class="code" href="structLeafWriter.html#a920a4e8f9c822c7fc2b297f68de21572">iStartBlockid</a> = iBlockid;
<a name="l04609"></a>04609   }<span class="keywordflow">else</span>{
<a name="l04610"></a>04610     pWriter-&gt;<a class="code" href="structLeafWriter.html#ab44295ac6f8fede3353a437fafa7d0cf">iEndBlockid</a>++;
<a name="l04611"></a>04611     assert( iBlockid==pWriter-&gt;<a class="code" href="structLeafWriter.html#ab44295ac6f8fede3353a437fafa7d0cf">iEndBlockid</a> );
<a name="l04612"></a>04612   }
<a name="l04613"></a>04613 
<a name="l04614"></a>04614   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04615"></a>04615 }
<a name="l04616"></a><a class="code" href="fts2_8c.html#add4f02e883f2c3001c19f9e0ab26b166">04616</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#add4f02e883f2c3001c19f9e0ab26b166">leafWriterFlush</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter){
<a name="l04617"></a>04617   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#ad1a1ccff82b0ee083f3b5e164e4322fe">leafWriterInternalFlush</a>(v, pWriter, 0, pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l04618"></a>04618   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04619"></a>04619 
<a name="l04620"></a>04620   <span class="comment">/* Re-initialize the output buffer. */</span>
<a name="l04621"></a>04621   <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>);
<a name="l04622"></a>04622 
<a name="l04623"></a>04623   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04624"></a>04624 }
<a name="l04625"></a>04625 
<a name="l04626"></a>04626 <span class="comment">/* Fetch the root info for the segment.  If the entire leaf fits</span>
<a name="l04627"></a>04627 <span class="comment">** within ROOT_MAX, then it will be returned directly, otherwise it</span>
<a name="l04628"></a>04628 <span class="comment">** will be flushed and the root info will be returned from the</span>
<a name="l04629"></a>04629 <span class="comment">** interior node.  *piEndBlockid is set to the blockid of the last</span>
<a name="l04630"></a>04630 <span class="comment">** interior or leaf node written to disk (0 if none are written at</span>
<a name="l04631"></a>04631 <span class="comment">** all).</span>
<a name="l04632"></a>04632 <span class="comment">*/</span>
<a name="l04633"></a><a class="code" href="fts2_8c.html#aa58efbe5c169155f2cc96ef3957e5635">04633</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aa58efbe5c169155f2cc96ef3957e5635">leafWriterRootInfo</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter,
<a name="l04634"></a>04634                               <span class="keywordtype">char</span> **ppRootInfo, <span class="keywordtype">int</span> *pnRootInfo,
<a name="l04635"></a>04635                               <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piEndBlockid){
<a name="l04636"></a>04636   <span class="comment">/* we can fit the segment entirely inline */</span>
<a name="l04637"></a>04637   <span class="keywordflow">if</span>( !pWriter-&gt;<a class="code" href="structLeafWriter.html#a0d231473d9a5cc70239969b5d57216e5">has_parent</a> &amp;&amp; pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&lt;<a class="code" href="fts2_8c.html#a1b6ab30572ba9a027bbb90a0f599f6ad">ROOT_MAX</a> ){
<a name="l04638"></a>04638     *ppRootInfo = pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>;
<a name="l04639"></a>04639     *pnRootInfo = pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>;
<a name="l04640"></a>04640     *piEndBlockid = 0;
<a name="l04641"></a>04641     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04642"></a>04642   }
<a name="l04643"></a>04643 
<a name="l04644"></a>04644   <span class="comment">/* Flush remaining leaf data. */</span>
<a name="l04645"></a>04645   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 ){
<a name="l04646"></a>04646     <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#add4f02e883f2c3001c19f9e0ab26b166">leafWriterFlush</a>(v, pWriter);
<a name="l04647"></a>04647     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04648"></a>04648   }
<a name="l04649"></a>04649 
<a name="l04650"></a>04650   <span class="comment">/* We must have flushed a leaf at some point. */</span>
<a name="l04651"></a>04651   assert( pWriter-&gt;<a class="code" href="structLeafWriter.html#a0d231473d9a5cc70239969b5d57216e5">has_parent</a> );
<a name="l04652"></a>04652 
<a name="l04653"></a>04653   <span class="comment">/* Tenatively set the end leaf blockid as the end blockid.  If the</span>
<a name="l04654"></a>04654 <span class="comment">  ** interior node can be returned inline, this will be the final</span>
<a name="l04655"></a>04655 <span class="comment">  ** blockid, otherwise it will be overwritten by</span>
<a name="l04656"></a>04656 <span class="comment">  ** interiorWriterRootInfo().</span>
<a name="l04657"></a>04657 <span class="comment">  */</span>
<a name="l04658"></a>04658   *piEndBlockid = pWriter-&gt;<a class="code" href="structLeafWriter.html#ab44295ac6f8fede3353a437fafa7d0cf">iEndBlockid</a>;
<a name="l04659"></a>04659 
<a name="l04660"></a>04660   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a9e9ec5b4464a4c41a6e1a44dca688c41">interiorWriterRootInfo</a>(v, &amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#ae1d25750377c616a6f0824584f3e1070">parentWriter</a>,
<a name="l04661"></a>04661                                 ppRootInfo, pnRootInfo, piEndBlockid);
<a name="l04662"></a>04662 }
<a name="l04663"></a>04663 
<a name="l04664"></a>04664 <span class="comment">/* Collect the rootInfo data and store it into the segment directory.</span>
<a name="l04665"></a>04665 <span class="comment">** This has the effect of flushing the segment&apos;s leaf data to</span>
<a name="l04666"></a>04666 <span class="comment">** %_segments, and also flushing any interior nodes to %_segments.</span>
<a name="l04667"></a>04667 <span class="comment">*/</span>
<a name="l04668"></a><a class="code" href="fts2_8c.html#a20a5c7ef17056f24bd37097afd4fe67b">04668</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a20a5c7ef17056f24bd37097afd4fe67b">leafWriterFinalize</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter){
<a name="l04669"></a>04669   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iEndBlockid;
<a name="l04670"></a>04670   <span class="keywordtype">char</span> *pRootInfo;
<a name="l04671"></a>04671   <span class="keywordtype">int</span> rc, nRootInfo;
<a name="l04672"></a>04672 
<a name="l04673"></a>04673   rc = <a class="code" href="fts2_8c.html#aa58efbe5c169155f2cc96ef3957e5635">leafWriterRootInfo</a>(v, pWriter, &amp;pRootInfo, &amp;nRootInfo, &amp;iEndBlockid);
<a name="l04674"></a>04674   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04675"></a>04675 
<a name="l04676"></a>04676   <span class="comment">/* Don&apos;t bother storing an entirely empty segment. */</span>
<a name="l04677"></a>04677   <span class="keywordflow">if</span>( iEndBlockid==0 &amp;&amp; nRootInfo==0 ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04678"></a>04678 
<a name="l04679"></a>04679   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a1180b1a1722443432cf152bd68b38bbd">segdir_set</a>(v, pWriter-&gt;<a class="code" href="structLeafWriter.html#a42551bce2a603ac9a36cf0b0db95f744">iLevel</a>, pWriter-&gt;<a class="code" href="structLeafWriter.html#a385bac876d393a8ac7c8446f05327bff">idx</a>,
<a name="l04680"></a>04680                     pWriter-&gt;<a class="code" href="structLeafWriter.html#a920a4e8f9c822c7fc2b297f68de21572">iStartBlockid</a>, pWriter-&gt;<a class="code" href="structLeafWriter.html#ab44295ac6f8fede3353a437fafa7d0cf">iEndBlockid</a>,
<a name="l04681"></a>04681                     iEndBlockid, pRootInfo, nRootInfo);
<a name="l04682"></a>04682 }
<a name="l04683"></a>04683 
<a name="l04684"></a><a class="code" href="fts2_8c.html#a2a86036daf4b9e95f8c4e7105bc8e035">04684</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a2a86036daf4b9e95f8c4e7105bc8e035">leafWriterDestroy</a>(<a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter){
<a name="l04685"></a>04685   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structLeafWriter.html#a0d231473d9a5cc70239969b5d57216e5">has_parent</a> ) <a class="code" href="fts2_8c.html#a05d69f95a80b2013c0ac92a5e4ba8db8">interiorWriterDestroy</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#ae1d25750377c616a6f0824584f3e1070">parentWriter</a>);
<a name="l04686"></a>04686   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a5653e0f44b5a965b3a542064ce49e8a7">term</a>);
<a name="l04687"></a>04687   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>);
<a name="l04688"></a>04688 }
<a name="l04689"></a>04689 
<a name="l04690"></a>04690 <span class="comment">/* Encode a term into the leafWriter, delta-encoding as appropriate.</span>
<a name="l04691"></a>04691 <span class="comment">** Returns the length of the new term which distinguishes it from the</span>
<a name="l04692"></a>04692 <span class="comment">** previous term, which can be used to set nTermDistinct when a node</span>
<a name="l04693"></a>04693 <span class="comment">** boundary is crossed.</span>
<a name="l04694"></a>04694 <span class="comment">*/</span>
<a name="l04695"></a><a class="code" href="fts2_8c.html#a88101d4b309e0409e12e0f0e0e0cb774">04695</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a88101d4b309e0409e12e0f0e0e0cb774">leafWriterEncodeTerm</a>(<a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter,
<a name="l04696"></a>04696                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm){
<a name="l04697"></a>04697   <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>+<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l04698"></a>04698   <span class="keywordtype">int</span> n, nPrefix = 0;
<a name="l04699"></a>04699 
<a name="l04700"></a>04700   assert( nTerm&gt;0 );
<a name="l04701"></a>04701   <span class="keywordflow">while</span>( nPrefix&lt;pWriter-&gt;term.nData &amp;&amp;
<a name="l04702"></a>04702          pTerm[nPrefix]==pWriter-&gt;<a class="code" href="structLeafWriter.html#a5653e0f44b5a965b3a542064ce49e8a7">term</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>[nPrefix] ){
<a name="l04703"></a>04703     nPrefix++;
<a name="l04704"></a>04704     <span class="comment">/* Failing this implies that the terms weren&apos;t in order. */</span>
<a name="l04705"></a>04705     assert( nPrefix&lt;nTerm );
<a name="l04706"></a>04706   }
<a name="l04707"></a>04707 
<a name="l04708"></a>04708   <span class="keywordflow">if</span>( pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>==0 ){
<a name="l04709"></a>04709     <span class="comment">/* Encode the node header and leading term as:</span>
<a name="l04710"></a>04710 <span class="comment">    **  varint(0)</span>
<a name="l04711"></a>04711 <span class="comment">    **  varint(nTerm)</span>
<a name="l04712"></a>04712 <span class="comment">    **  char pTerm[nTerm]</span>
<a name="l04713"></a>04713 <span class="comment">    */</span>
<a name="l04714"></a>04714     n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, <span class="charliteral">&apos;\0&apos;</span>);
<a name="l04715"></a>04715     n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, nTerm);
<a name="l04716"></a>04716     <a class="code" href="fts2_8c.html#a5cb462adcb518c795ccb9b8d1a44c0a2">dataBufferAppend2</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>, c, n, pTerm, nTerm);
<a name="l04717"></a>04717   }<span class="keywordflow">else</span>{
<a name="l04718"></a>04718     <span class="comment">/* Delta-encode the term as:</span>
<a name="l04719"></a>04719 <span class="comment">    **  varint(nPrefix)</span>
<a name="l04720"></a>04720 <span class="comment">    **  varint(nSuffix)</span>
<a name="l04721"></a>04721 <span class="comment">    **  char pTermSuffix[nSuffix]</span>
<a name="l04722"></a>04722 <span class="comment">    */</span>
<a name="l04723"></a>04723     n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, nPrefix);
<a name="l04724"></a>04724     n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, nTerm-nPrefix);
<a name="l04725"></a>04725     <a class="code" href="fts2_8c.html#a5cb462adcb518c795ccb9b8d1a44c0a2">dataBufferAppend2</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>, c, n, pTerm+nPrefix, nTerm-nPrefix);
<a name="l04726"></a>04726   }
<a name="l04727"></a>04727   <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a5653e0f44b5a965b3a542064ce49e8a7">term</a>, pTerm, nTerm);
<a name="l04728"></a>04728 
<a name="l04729"></a>04729   <span class="keywordflow">return</span> nPrefix+1;
<a name="l04730"></a>04730 }
<a name="l04731"></a>04731 
<a name="l04732"></a>04732 <span class="comment">/* Used to avoid a memmove when a large amount of doclist data is in</span>
<a name="l04733"></a>04733 <span class="comment">** the buffer.  This constructs a node and term header before</span>
<a name="l04734"></a>04734 <span class="comment">** iDoclistData and flushes the resulting complete node using</span>
<a name="l04735"></a>04735 <span class="comment">** leafWriterInternalFlush().</span>
<a name="l04736"></a>04736 <span class="comment">*/</span>
<a name="l04737"></a><a class="code" href="fts2_8c.html#ad259af70066766590f819a8c60eb29af">04737</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ad259af70066766590f819a8c60eb29af">leafWriterInlineFlush</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter,
<a name="l04738"></a>04738                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm,
<a name="l04739"></a>04739                                  <span class="keywordtype">int</span> iDoclistData){
<a name="l04740"></a>04740   <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>+<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l04741"></a>04741   <span class="keywordtype">int</span> iData, n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, 0);
<a name="l04742"></a>04742   n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c+n, nTerm);
<a name="l04743"></a>04743 
<a name="l04744"></a>04744   <span class="comment">/* There should always be room for the header.  Even if pTerm shared</span>
<a name="l04745"></a>04745 <span class="comment">  ** a substantial prefix with the previous term, the entire prefix</span>
<a name="l04746"></a>04746 <span class="comment">  ** could be constructed from earlier data in the doclist, so there</span>
<a name="l04747"></a>04747 <span class="comment">  ** should be room.</span>
<a name="l04748"></a>04748 <span class="comment">  */</span>
<a name="l04749"></a>04749   assert( iDoclistData&gt;=n+nTerm );
<a name="l04750"></a>04750 
<a name="l04751"></a>04751   iData = iDoclistData-(n+nTerm);
<a name="l04752"></a>04752   memcpy(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iData, c, n);
<a name="l04753"></a>04753   memcpy(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iData+n, pTerm, nTerm);
<a name="l04754"></a>04754 
<a name="l04755"></a>04755   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#ad1a1ccff82b0ee083f3b5e164e4322fe">leafWriterInternalFlush</a>(v, pWriter, iData, pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>-iData);
<a name="l04756"></a>04756 }
<a name="l04757"></a>04757 
<a name="l04758"></a>04758 <span class="comment">/* Push pTerm[nTerm] along with the doclist data to the leaf layer of</span>
<a name="l04759"></a>04759 <span class="comment">** %_segments.</span>
<a name="l04760"></a>04760 <span class="comment">*/</span>
<a name="l04761"></a><a class="code" href="fts2_8c.html#a212d080a728a28abde0e58a804d265bd">04761</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a212d080a728a28abde0e58a804d265bd">leafWriterStepMerge</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter,
<a name="l04762"></a>04762                                <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm,
<a name="l04763"></a>04763                                <a class="code" href="structDLReader.html">DLReader</a> *pReaders, <span class="keywordtype">int</span> nReaders){
<a name="l04764"></a>04764   <span class="keywordtype">char</span> c[<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>+<a class="code" href="fts1_8c.html#abdded853f553807df4d7ff2363c313e8">VARINT_MAX</a>];
<a name="l04765"></a>04765   <span class="keywordtype">int</span> iTermData = pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, iDoclistData;
<a name="l04766"></a>04766   <span class="keywordtype">int</span> i, nData, n, nActualData, nActual, rc, nTermDistinct;
<a name="l04767"></a>04767 
<a name="l04768"></a>04768   <a class="code" href="fts2_8c.html#acc3ff3feb9c554745218ddb2529eae60">ASSERT_VALID_LEAF_NODE</a>(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l04769"></a>04769   nTermDistinct = <a class="code" href="fts2_8c.html#a88101d4b309e0409e12e0f0e0e0cb774">leafWriterEncodeTerm</a>(pWriter, pTerm, nTerm);
<a name="l04770"></a>04770 
<a name="l04771"></a>04771   <span class="comment">/* Remember nTermDistinct if opening a new node. */</span>
<a name="l04772"></a>04772   <span class="keywordflow">if</span>( iTermData==0 ) pWriter-&gt;<a class="code" href="structLeafWriter.html#ae952429cefa31de5126dd08f2a64ab3f">nTermDistinct</a> = nTermDistinct;
<a name="l04773"></a>04773 
<a name="l04774"></a>04774   iDoclistData = pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>;
<a name="l04775"></a>04775 
<a name="l04776"></a>04776   <span class="comment">/* Estimate the length of the merged doclist so we can leave space</span>
<a name="l04777"></a>04777 <span class="comment">  ** to encode it.</span>
<a name="l04778"></a>04778 <span class="comment">  */</span>
<a name="l04779"></a>04779   <span class="keywordflow">for</span>(i=0, nData=0; i&lt;nReaders; i++){
<a name="l04780"></a>04780     nData += <a class="code" href="fts2_8c.html#a1b98de47a53d77a7616bf2da40965c15">dlrAllDataBytes</a>(&amp;pReaders[i]);
<a name="l04781"></a>04781   }
<a name="l04782"></a>04782   n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, nData);
<a name="l04783"></a>04783   <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>, c, n);
<a name="l04784"></a>04784 
<a name="l04785"></a>04785   <a class="code" href="fts2_8c.html#aa204589d71a5ad4842500f76af21e2b9">docListMerge</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>, pReaders, nReaders);
<a name="l04786"></a>04786   <a class="code" href="fts2_8c.html#ac0a9fdb841eb19d55fc4ecb511f6b1aa">ASSERT_VALID_DOCLIST</a>(<a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>,
<a name="l04787"></a>04787                        pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iDoclistData+n,
<a name="l04788"></a>04788                        pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>-iDoclistData-n, NULL);
<a name="l04789"></a>04789 
<a name="l04790"></a>04790   <span class="comment">/* The actual amount of doclist data at this point could be smaller</span>
<a name="l04791"></a>04791 <span class="comment">  ** than the length we encoded.  Additionally, the space required to</span>
<a name="l04792"></a>04792 <span class="comment">  ** encode this length could be smaller.  For small doclists, this is</span>
<a name="l04793"></a>04793 <span class="comment">  ** not a big deal, we can just use memmove() to adjust things.</span>
<a name="l04794"></a>04794 <span class="comment">  */</span>
<a name="l04795"></a>04795   nActualData = pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>-(iDoclistData+n);
<a name="l04796"></a>04796   nActual = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(c, nActualData);
<a name="l04797"></a>04797   assert( nActualData&lt;=nData );
<a name="l04798"></a>04798   assert( nActual&lt;=n );
<a name="l04799"></a>04799 
<a name="l04800"></a>04800   <span class="comment">/* If the new doclist is big enough for force a standalone leaf</span>
<a name="l04801"></a>04801 <span class="comment">  ** node, we can immediately flush it inline without doing the</span>
<a name="l04802"></a>04802 <span class="comment">  ** memmove().</span>
<a name="l04803"></a>04803 <span class="comment">  */</span>
<a name="l04804"></a>04804   <span class="comment">/* TODO(shess) This test matches leafWriterStep(), which does this</span>
<a name="l04805"></a>04805 <span class="comment">  ** test before it knows the cost to varint-encode the term and</span>
<a name="l04806"></a>04806 <span class="comment">  ** doclist lengths.  At some point, change to</span>
<a name="l04807"></a>04807 <span class="comment">  ** pWriter-&gt;data.nData-iTermData&gt;STANDALONE_MIN.</span>
<a name="l04808"></a>04808 <span class="comment">  */</span>
<a name="l04809"></a>04809   <span class="keywordflow">if</span>( nTerm+nActualData&gt;<a class="code" href="fts2_8c.html#a99dabb4a83a0748b5f147318f3d558d2">STANDALONE_MIN</a> ){
<a name="l04810"></a>04810     <span class="comment">/* Push leaf node from before this term. */</span>
<a name="l04811"></a>04811     <span class="keywordflow">if</span>( iTermData&gt;0 ){
<a name="l04812"></a>04812       rc = <a class="code" href="fts2_8c.html#ad1a1ccff82b0ee083f3b5e164e4322fe">leafWriterInternalFlush</a>(v, pWriter, 0, iTermData);
<a name="l04813"></a>04813       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04814"></a>04814 
<a name="l04815"></a>04815       pWriter-&gt;<a class="code" href="structLeafWriter.html#ae952429cefa31de5126dd08f2a64ab3f">nTermDistinct</a> = nTermDistinct;
<a name="l04816"></a>04816     }
<a name="l04817"></a>04817 
<a name="l04818"></a>04818     <span class="comment">/* Fix the encoded doclist length. */</span>
<a name="l04819"></a>04819     iDoclistData += n - nActual;
<a name="l04820"></a>04820     memcpy(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iDoclistData, c, nActual);
<a name="l04821"></a>04821 
<a name="l04822"></a>04822     <span class="comment">/* Push the standalone leaf node. */</span>
<a name="l04823"></a>04823     rc = <a class="code" href="fts2_8c.html#ad259af70066766590f819a8c60eb29af">leafWriterInlineFlush</a>(v, pWriter, pTerm, nTerm, iDoclistData);
<a name="l04824"></a>04824     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04825"></a>04825 
<a name="l04826"></a>04826     <span class="comment">/* Leave the node empty. */</span>
<a name="l04827"></a>04827     <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(&amp;pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>);
<a name="l04828"></a>04828 
<a name="l04829"></a>04829     <span class="keywordflow">return</span> rc;
<a name="l04830"></a>04830   }
<a name="l04831"></a>04831 
<a name="l04832"></a>04832   <span class="comment">/* At this point, we know that the doclist was small, so do the</span>
<a name="l04833"></a>04833 <span class="comment">  ** memmove if indicated.</span>
<a name="l04834"></a>04834 <span class="comment">  */</span>
<a name="l04835"></a>04835   <span class="keywordflow">if</span>( nActual&lt;n ){
<a name="l04836"></a>04836     memmove(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iDoclistData+nActual,
<a name="l04837"></a>04837             pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iDoclistData+n,
<a name="l04838"></a>04838             pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>-(iDoclistData+n));
<a name="l04839"></a>04839     pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> -= n-nActual;
<a name="l04840"></a>04840   }
<a name="l04841"></a>04841 
<a name="l04842"></a>04842   <span class="comment">/* Replace written length with actual length. */</span>
<a name="l04843"></a>04843   memcpy(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iDoclistData, c, nActual);
<a name="l04844"></a>04844 
<a name="l04845"></a>04845   <span class="comment">/* If the node is too large, break things up. */</span>
<a name="l04846"></a>04846   <span class="comment">/* TODO(shess) This test matches leafWriterStep(), which does this</span>
<a name="l04847"></a>04847 <span class="comment">  ** test before it knows the cost to varint-encode the term and</span>
<a name="l04848"></a>04848 <span class="comment">  ** doclist lengths.  At some point, change to</span>
<a name="l04849"></a>04849 <span class="comment">  ** pWriter-&gt;data.nData&gt;LEAF_MAX.</span>
<a name="l04850"></a>04850 <span class="comment">  */</span>
<a name="l04851"></a>04851   <span class="keywordflow">if</span>( iTermData+nTerm+nActualData&gt;<a class="code" href="fts2_8c.html#a3b0ee26d7e03f91390592ac852e33369">LEAF_MAX</a> ){
<a name="l04852"></a>04852     <span class="comment">/* Flush out the leading data as a node */</span>
<a name="l04853"></a>04853     rc = <a class="code" href="fts2_8c.html#ad1a1ccff82b0ee083f3b5e164e4322fe">leafWriterInternalFlush</a>(v, pWriter, 0, iTermData);
<a name="l04854"></a>04854     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04855"></a>04855 
<a name="l04856"></a>04856     pWriter-&gt;<a class="code" href="structLeafWriter.html#ae952429cefa31de5126dd08f2a64ab3f">nTermDistinct</a> = nTermDistinct;
<a name="l04857"></a>04857 
<a name="l04858"></a>04858     <span class="comment">/* Rebuild header using the current term */</span>
<a name="l04859"></a>04859     n = <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, 0);
<a name="l04860"></a>04860     n += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+n, nTerm);
<a name="l04861"></a>04861     memcpy(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+n, pTerm, nTerm);
<a name="l04862"></a>04862     n += nTerm;
<a name="l04863"></a>04863 
<a name="l04864"></a>04864     <span class="comment">/* There should always be room, because the previous encoding</span>
<a name="l04865"></a>04865 <span class="comment">    ** included all data necessary to construct the term.</span>
<a name="l04866"></a>04866 <span class="comment">    */</span>
<a name="l04867"></a>04867     assert( n&lt;iDoclistData );
<a name="l04868"></a>04868     <span class="comment">/* So long as STANDALONE_MIN is half or less of LEAF_MAX, the</span>
<a name="l04869"></a>04869 <span class="comment">    ** following memcpy() is safe (as opposed to needing a memmove).</span>
<a name="l04870"></a>04870 <span class="comment">    */</span>
<a name="l04871"></a>04871     assert( 2*<a class="code" href="fts2_8c.html#a99dabb4a83a0748b5f147318f3d558d2">STANDALONE_MIN</a>&lt;=<a class="code" href="fts2_8c.html#a3b0ee26d7e03f91390592ac852e33369">LEAF_MAX</a> );
<a name="l04872"></a>04872     assert( n+pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>-iDoclistData&lt;iDoclistData );
<a name="l04873"></a>04873     memcpy(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+n,
<a name="l04874"></a>04874            pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>+iDoclistData,
<a name="l04875"></a>04875            pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>-iDoclistData);
<a name="l04876"></a>04876     pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> -= iDoclistData-n;
<a name="l04877"></a>04877   }
<a name="l04878"></a>04878   <a class="code" href="fts2_8c.html#acc3ff3feb9c554745218ddb2529eae60">ASSERT_VALID_LEAF_NODE</a>(pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, pWriter-&gt;<a class="code" href="structLeafWriter.html#a0203f0e9487ad6c992df368f96cbf717">data</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l04879"></a>04879 
<a name="l04880"></a>04880   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04881"></a>04881 }
<a name="l04882"></a>04882 
<a name="l04883"></a>04883 <span class="comment">/* Push pTerm[nTerm] along with the doclist data to the leaf layer of</span>
<a name="l04884"></a>04884 <span class="comment">** %_segments.</span>
<a name="l04885"></a>04885 <span class="comment">*/</span>
<a name="l04886"></a>04886 <span class="comment">/* TODO(shess) Revise writeZeroSegment() so that doclists are</span>
<a name="l04887"></a>04887 <span class="comment">** constructed directly in pWriter-&gt;data.</span>
<a name="l04888"></a>04888 <span class="comment">*/</span>
<a name="l04889"></a><a class="code" href="fts2_8c.html#a869165e5ff35ff1e763028a045db0236">04889</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a869165e5ff35ff1e763028a045db0236">leafWriterStep</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter,
<a name="l04890"></a>04890                           <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm,
<a name="l04891"></a>04891                           <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData){
<a name="l04892"></a>04892   <span class="keywordtype">int</span> rc;
<a name="l04893"></a>04893   <a class="code" href="structDLReader.html">DLReader</a> reader;
<a name="l04894"></a>04894 
<a name="l04895"></a>04895   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;reader, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, pData, nData);
<a name="l04896"></a>04896   rc = <a class="code" href="fts2_8c.html#a212d080a728a28abde0e58a804d265bd">leafWriterStepMerge</a>(v, pWriter, pTerm, nTerm, &amp;reader, 1);
<a name="l04897"></a>04897   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;reader);
<a name="l04898"></a>04898 
<a name="l04899"></a>04899   <span class="keywordflow">return</span> rc;
<a name="l04900"></a>04900 }
<a name="l04901"></a>04901 
<a name="l04902"></a>04902 
<a name="l04903"></a>04903 <span class="comment">/****************************************************************/</span>
<a name="l04904"></a>04904 <span class="comment">/* LeafReader is used to iterate over an individual leaf node. */</span>
<a name="l04905"></a><a class="code" href="structLeafReader.html">04905</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structLeafReader.html">LeafReader</a> {
<a name="l04906"></a><a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">04906</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>;          <span class="comment">/* copy of current term. */</span>
<a name="l04907"></a>04907 
<a name="l04908"></a><a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">04908</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *pData;        <span class="comment">/* data for current term. */</span>
<a name="l04909"></a><a class="code" href="structLeafReader.html#a09a31c25f114ea6b3e3b9283f9c6bbc0">04909</a>   <span class="keywordtype">int</span> nData;
<a name="l04910"></a>04910 } <a class="code" href="structLeafReader.html">LeafReader</a>;
<a name="l04911"></a>04911 
<a name="l04912"></a><a class="code" href="fts2_8c.html#ab54351e3555215d9f539ef2172eefce5">04912</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#ab54351e3555215d9f539ef2172eefce5">leafReaderDestroy</a>(<a class="code" href="structLeafReader.html">LeafReader</a> *pReader){
<a name="l04913"></a>04913   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>);
<a name="l04914"></a>04914   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pReader);
<a name="l04915"></a>04915 }
<a name="l04916"></a>04916 
<a name="l04917"></a><a class="code" href="fts2_8c.html#ac4dc419cdf1996a0336e223631dcbe11">04917</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ac4dc419cdf1996a0336e223631dcbe11">leafReaderAtEnd</a>(<a class="code" href="structLeafReader.html">LeafReader</a> *pReader){
<a name="l04918"></a>04918   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structLeafReader.html#a09a31c25f114ea6b3e3b9283f9c6bbc0">nData</a>&lt;=0;
<a name="l04919"></a>04919 }
<a name="l04920"></a>04920 
<a name="l04921"></a>04921 <span class="comment">/* Access the current term. */</span>
<a name="l04922"></a><a class="code" href="fts2_8c.html#a51eaf9c2819ef57b7fce28affd2b1c0e">04922</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a51eaf9c2819ef57b7fce28affd2b1c0e">leafReaderTermBytes</a>(<a class="code" href="structLeafReader.html">LeafReader</a> *pReader){
<a name="l04923"></a>04923   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>;
<a name="l04924"></a>04924 }
<a name="l04925"></a><a class="code" href="fts2_8c.html#a1107d913d1829e48eede087250060b3d">04925</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a1107d913d1829e48eede087250060b3d">leafReaderTerm</a>(<a class="code" href="structLeafReader.html">LeafReader</a> *pReader){
<a name="l04926"></a>04926   assert( pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 );
<a name="l04927"></a>04927   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>;
<a name="l04928"></a>04928 }
<a name="l04929"></a>04929 
<a name="l04930"></a>04930 <span class="comment">/* Access the doclist data for the current term. */</span>
<a name="l04931"></a><a class="code" href="fts2_8c.html#aac8f956414a04b931f3f50a78967daee">04931</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aac8f956414a04b931f3f50a78967daee">leafReaderDataBytes</a>(<a class="code" href="structLeafReader.html">LeafReader</a> *pReader){
<a name="l04932"></a>04932   <span class="keywordtype">int</span> nData;
<a name="l04933"></a>04933   assert( pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 );
<a name="l04934"></a>04934   <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a>, &amp;nData);
<a name="l04935"></a>04935   <span class="keywordflow">return</span> nData;
<a name="l04936"></a>04936 }
<a name="l04937"></a><a class="code" href="fts2_8c.html#ab6a1e53a61475ab86c5d0862775d12ec">04937</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#ab6a1e53a61475ab86c5d0862775d12ec">leafReaderData</a>(<a class="code" href="structLeafReader.html">LeafReader</a> *pReader){
<a name="l04938"></a>04938   <span class="keywordtype">int</span> n, nData;
<a name="l04939"></a>04939   assert( pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 );
<a name="l04940"></a>04940   n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a>, &amp;nData);
<a name="l04941"></a>04941   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a>+n;
<a name="l04942"></a>04942 }
<a name="l04943"></a>04943 
<a name="l04944"></a><a class="code" href="fts2_8c.html#a52025ab047c301a943c74614de27e297">04944</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a52025ab047c301a943c74614de27e297">leafReaderInit</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l04945"></a>04945                            <a class="code" href="structLeafReader.html">LeafReader</a> *pReader){
<a name="l04946"></a>04946   <span class="keywordtype">int</span> nTerm, n;
<a name="l04947"></a>04947 
<a name="l04948"></a>04948   assert( nData&gt;0 );
<a name="l04949"></a>04949   assert( pData[0]==<span class="charliteral">&apos;\0&apos;</span> );
<a name="l04950"></a>04950 
<a name="l04951"></a>04951   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(pReader);
<a name="l04952"></a>04952 
<a name="l04953"></a>04953   <span class="comment">/* Read the first term, skipping the header byte. */</span>
<a name="l04954"></a>04954   n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pData+1, &amp;nTerm);
<a name="l04955"></a>04955   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>, nTerm);
<a name="l04956"></a>04956   <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(&amp;pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>, pData+1+n, nTerm);
<a name="l04957"></a>04957 
<a name="l04958"></a>04958   <span class="comment">/* Position after the first term. */</span>
<a name="l04959"></a>04959   assert( 1+n+nTerm&lt;nData );
<a name="l04960"></a>04960   pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a> = pData+1+n+nTerm;
<a name="l04961"></a>04961   pReader-&gt;<a class="code" href="structLeafReader.html#a09a31c25f114ea6b3e3b9283f9c6bbc0">nData</a> = nData-1-n-nTerm;
<a name="l04962"></a>04962 }
<a name="l04963"></a>04963 
<a name="l04964"></a>04964 <span class="comment">/* Step the reader forward to the next term. */</span>
<a name="l04965"></a><a class="code" href="fts2_8c.html#af49e9a7f364e86b641bb1323d78585f0">04965</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#af49e9a7f364e86b641bb1323d78585f0">leafReaderStep</a>(<a class="code" href="structLeafReader.html">LeafReader</a> *pReader){
<a name="l04966"></a>04966   <span class="keywordtype">int</span> n, nData, nPrefix, nSuffix;
<a name="l04967"></a>04967   assert( !<a class="code" href="fts2_8c.html#ac4dc419cdf1996a0336e223631dcbe11">leafReaderAtEnd</a>(pReader) );
<a name="l04968"></a>04968 
<a name="l04969"></a>04969   <span class="comment">/* Skip previous entry&apos;s data block. */</span>
<a name="l04970"></a>04970   n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a>, &amp;nData);
<a name="l04971"></a>04971   assert( n+nData&lt;=pReader-&gt;nData );
<a name="l04972"></a>04972   pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a> += n+nData;
<a name="l04973"></a>04973   pReader-&gt;<a class="code" href="structLeafReader.html#a09a31c25f114ea6b3e3b9283f9c6bbc0">nData</a> -= n+nData;
<a name="l04974"></a>04974 
<a name="l04975"></a>04975   <span class="keywordflow">if</span>( !<a class="code" href="fts2_8c.html#ac4dc419cdf1996a0336e223631dcbe11">leafReaderAtEnd</a>(pReader) ){
<a name="l04976"></a>04976     <span class="comment">/* Construct the new term using a prefix from the old term plus a</span>
<a name="l04977"></a>04977 <span class="comment">    ** suffix from the leaf data.</span>
<a name="l04978"></a>04978 <span class="comment">    */</span>
<a name="l04979"></a>04979     n = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a>, &amp;nPrefix);
<a name="l04980"></a>04980     n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a>+n, &amp;nSuffix);
<a name="l04981"></a>04981     assert( n+nSuffix&lt;pReader-&gt;nData );
<a name="l04982"></a>04982     pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> = nPrefix;
<a name="l04983"></a>04983     <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(&amp;pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>, pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a>+n, nSuffix);
<a name="l04984"></a>04984 
<a name="l04985"></a>04985     pReader-&gt;<a class="code" href="structLeafReader.html#acfffd40d402ac70926bc43fe48435045">pData</a> += n+nSuffix;
<a name="l04986"></a>04986     pReader-&gt;<a class="code" href="structLeafReader.html#a09a31c25f114ea6b3e3b9283f9c6bbc0">nData</a> -= n+nSuffix;
<a name="l04987"></a>04987   }
<a name="l04988"></a>04988 }
<a name="l04989"></a>04989 
<a name="l04990"></a>04990 <span class="comment">/* strcmp-style comparison of pReader&apos;s current term against pTerm.</span>
<a name="l04991"></a>04991 <span class="comment">** If isPrefix, equality means equal through nTerm bytes.</span>
<a name="l04992"></a>04992 <span class="comment">*/</span>
<a name="l04993"></a><a class="code" href="fts2_8c.html#af573af3f12be16d66bf0ca228a8cc82e">04993</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#af573af3f12be16d66bf0ca228a8cc82e">leafReaderTermCmp</a>(<a class="code" href="structLeafReader.html">LeafReader</a> *pReader,
<a name="l04994"></a>04994                              <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix){
<a name="l04995"></a>04995   <span class="keywordtype">int</span> c, n = pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&lt;nTerm ? pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> : nTerm;
<a name="l04996"></a>04996   <span class="keywordflow">if</span>( n==0 ){
<a name="l04997"></a>04997     <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 ) <span class="keywordflow">return</span> -1;
<a name="l04998"></a>04998     <span class="keywordflow">if</span>(nTerm&gt;0 ) <span class="keywordflow">return</span> 1;
<a name="l04999"></a>04999     <span class="keywordflow">return</span> 0;
<a name="l05000"></a>05000   }
<a name="l05001"></a>05001 
<a name="l05002"></a>05002   c = memcmp(pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, pTerm, n);
<a name="l05003"></a>05003   <span class="keywordflow">if</span>( c!=0 ) <span class="keywordflow">return</span> c;
<a name="l05004"></a>05004   <span class="keywordflow">if</span>( isPrefix &amp;&amp; n==nTerm ) <span class="keywordflow">return</span> 0;
<a name="l05005"></a>05005   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structLeafReader.html#a67c5edc60c40a47a0bdffdec95a4df26">term</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> - nTerm;
<a name="l05006"></a>05006 }
<a name="l05007"></a>05007 
<a name="l05008"></a>05008 
<a name="l05009"></a>05009 <span class="comment">/****************************************************************/</span>
<a name="l05010"></a>05010 <span class="comment">/* LeavesReader wraps LeafReader to allow iterating over the entire</span>
<a name="l05011"></a>05011 <span class="comment">** leaf layer of the tree.</span>
<a name="l05012"></a>05012 <span class="comment">*/</span>
<a name="l05013"></a><a class="code" href="structLeavesReader.html">05013</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structLeavesReader.html">LeavesReader</a> {
<a name="l05014"></a><a class="code" href="structLeavesReader.html#aa9b69a1418fe046ef543a71dc19fdb25">05014</a>   <span class="keywordtype">int</span> <a class="code" href="structLeavesReader.html#aa9b69a1418fe046ef543a71dc19fdb25">idx</a>;                  <span class="comment">/* Index within the segment. */</span>
<a name="l05015"></a>05015 
<a name="l05016"></a><a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">05016</a>   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a>;      <span class="comment">/* Statement we&apos;re streaming leaves from. */</span>
<a name="l05017"></a><a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">05017</a>   <span class="keywordtype">int</span> <a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">eof</a>;                  <span class="comment">/* we&apos;ve seen SQLITE_DONE from pStmt. */</span>
<a name="l05018"></a>05018 
<a name="l05019"></a><a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">05019</a>   <a class="code" href="structLeafReader.html">LeafReader</a> <a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>;    <span class="comment">/* reader for the current leaf. */</span>
<a name="l05020"></a><a class="code" href="structLeavesReader.html#a4ab5c79a21b54f207ded8814e8d48446">05020</a>   <a class="code" href="structDataBuffer.html">DataBuffer</a> <a class="code" href="structLeavesReader.html#a4ab5c79a21b54f207ded8814e8d48446">rootData</a>;      <span class="comment">/* root data for inline. */</span>
<a name="l05021"></a>05021 } <a class="code" href="structLeavesReader.html">LeavesReader</a>;
<a name="l05022"></a>05022 
<a name="l05023"></a>05023 <span class="comment">/* Access the current term. */</span>
<a name="l05024"></a><a class="code" href="fts2_8c.html#ab1b844350e43ffea25791355eff5fe6d">05024</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ab1b844350e43ffea25791355eff5fe6d">leavesReaderTermBytes</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader){
<a name="l05025"></a>05025   assert( !pReader-&gt;<a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">eof</a> );
<a name="l05026"></a>05026   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a51eaf9c2819ef57b7fce28affd2b1c0e">leafReaderTermBytes</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05027"></a>05027 }
<a name="l05028"></a><a class="code" href="fts2_8c.html#aeb47709b8fd707f2705051ccd9f95ea2">05028</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#aeb47709b8fd707f2705051ccd9f95ea2">leavesReaderTerm</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader){
<a name="l05029"></a>05029   assert( !pReader-&gt;<a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">eof</a> );
<a name="l05030"></a>05030   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a1107d913d1829e48eede087250060b3d">leafReaderTerm</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05031"></a>05031 }
<a name="l05032"></a>05032 
<a name="l05033"></a>05033 <span class="comment">/* Access the doclist data for the current term. */</span>
<a name="l05034"></a><a class="code" href="fts2_8c.html#a54bac53899528f039168ab9eb55ae866">05034</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a54bac53899528f039168ab9eb55ae866">leavesReaderDataBytes</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader){
<a name="l05035"></a>05035   assert( !pReader-&gt;<a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">eof</a> );
<a name="l05036"></a>05036   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#aac8f956414a04b931f3f50a78967daee">leafReaderDataBytes</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05037"></a>05037 }
<a name="l05038"></a><a class="code" href="fts2_8c.html#a80da0054c63cf95a7ba519c023094244">05038</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a80da0054c63cf95a7ba519c023094244">leavesReaderData</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader){
<a name="l05039"></a>05039   assert( !pReader-&gt;<a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">eof</a> );
<a name="l05040"></a>05040   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#ab6a1e53a61475ab86c5d0862775d12ec">leafReaderData</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05041"></a>05041 }
<a name="l05042"></a>05042 
<a name="l05043"></a><a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">05043</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader){
<a name="l05044"></a>05044   <span class="keywordflow">return</span> pReader-&gt;<a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">eof</a>;
<a name="l05045"></a>05045 }
<a name="l05046"></a>05046 
<a name="l05047"></a>05047 <span class="comment">/* loadSegmentLeaves() may not read all the way to SQLITE_DONE, thus</span>
<a name="l05048"></a>05048 <span class="comment">** leaving the statement handle open, which locks the table.</span>
<a name="l05049"></a>05049 <span class="comment">*/</span>
<a name="l05050"></a>05050 <span class="comment">/* TODO(shess) This &quot;solution&quot; is not satisfactory.  Really, there</span>
<a name="l05051"></a>05051 <span class="comment">** should be check-in function for all statement handles which</span>
<a name="l05052"></a>05052 <span class="comment">** arranges to call sqlite3_reset().  This most likely will require</span>
<a name="l05053"></a>05053 <span class="comment">** modification to control flow all over the place, though, so for now</span>
<a name="l05054"></a>05054 <span class="comment">** just punt.</span>
<a name="l05055"></a>05055 <span class="comment">**</span>
<a name="l05056"></a>05056 <span class="comment">** Note the the current system assumes that segment merges will run to</span>
<a name="l05057"></a>05057 <span class="comment">** completion, which is why this particular probably hasn&apos;t arisen in</span>
<a name="l05058"></a>05058 <span class="comment">** this case.  Probably a brittle assumption.</span>
<a name="l05059"></a>05059 <span class="comment">*/</span>
<a name="l05060"></a><a class="code" href="fts2_8c.html#a84e7629d66616828816845202398f5b3">05060</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a84e7629d66616828816845202398f5b3">leavesReaderReset</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader){
<a name="l05061"></a>05061   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(pReader-&gt;<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a>);
<a name="l05062"></a>05062 }
<a name="l05063"></a>05063 
<a name="l05064"></a><a class="code" href="fts2_8c.html#a855cb94e7913e2a38eb8c281a85f12f9">05064</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a855cb94e7913e2a38eb8c281a85f12f9">leavesReaderDestroy</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader){
<a name="l05065"></a>05065   <span class="comment">/* If idx is -1, that means we&apos;re using a non-cached statement</span>
<a name="l05066"></a>05066 <span class="comment">  ** handle in the optimize() case, so we need to release it.</span>
<a name="l05067"></a>05067 <span class="comment">  */</span>
<a name="l05068"></a>05068   <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a>!=NULL &amp;&amp; pReader-&gt;<a class="code" href="structLeavesReader.html#aa9b69a1418fe046ef543a71dc19fdb25">idx</a>==-1 ){
<a name="l05069"></a>05069     <a class="code" href="sqlite3_8h.html#aaf6c3dbc23f33c0752588425c7e9d498">sqlite3_finalize</a>(pReader-&gt;<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a>);
<a name="l05070"></a>05070   }
<a name="l05071"></a>05071   <a class="code" href="fts2_8c.html#ab54351e3555215d9f539ef2172eefce5">leafReaderDestroy</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05072"></a>05072   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#a4ab5c79a21b54f207ded8814e8d48446">rootData</a>);
<a name="l05073"></a>05073   <a class="code" href="fts2_8c.html#ababcedb512d5b0c3efd976dc55c6234c">SCRAMBLE</a>(pReader);
<a name="l05074"></a>05074 }
<a name="l05075"></a>05075 
<a name="l05076"></a>05076 <span class="comment">/* Initialize pReader with the given root data (if iStartBlockid==0</span>
<a name="l05077"></a>05077 <span class="comment">** the leaf data was entirely contained in the root), or from the</span>
<a name="l05078"></a>05078 <span class="comment">** stream of blocks between iStartBlockid and iEndBlockid, inclusive.</span>
<a name="l05079"></a>05079 <span class="comment">*/</span>
<a name="l05080"></a><a class="code" href="fts2_8c.html#a80fb079e0710324da4be7fe56c5dd7e5">05080</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a80fb079e0710324da4be7fe56c5dd7e5">leavesReaderInit</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,
<a name="l05081"></a>05081                             <span class="keywordtype">int</span> idx,
<a name="l05082"></a>05082                             <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iStartBlockid,
<a name="l05083"></a>05083                             <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iEndBlockid,
<a name="l05084"></a>05084                             <span class="keyword">const</span> <span class="keywordtype">char</span> *pRootData, <span class="keywordtype">int</span> nRootData,
<a name="l05085"></a>05085                             <a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader){
<a name="l05086"></a>05086   <a class="code" href="fts2_8c.html#a4888c276f04877b89b6f697e0b23636c">CLEAR</a>(pReader);
<a name="l05087"></a>05087   pReader-&gt;<a class="code" href="structLeavesReader.html#aa9b69a1418fe046ef543a71dc19fdb25">idx</a> = idx;
<a name="l05088"></a>05088 
<a name="l05089"></a>05089   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#a4ab5c79a21b54f207ded8814e8d48446">rootData</a>, 0);
<a name="l05090"></a>05090   <span class="keywordflow">if</span>( iStartBlockid==0 ){
<a name="l05091"></a>05091     <span class="comment">/* Entire leaf level fit in root data. */</span>
<a name="l05092"></a>05092     <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#a4ab5c79a21b54f207ded8814e8d48446">rootData</a>, pRootData, nRootData);
<a name="l05093"></a>05093     <a class="code" href="fts2_8c.html#a52025ab047c301a943c74614de27e297">leafReaderInit</a>(pReader-&gt;<a class="code" href="structLeavesReader.html#a4ab5c79a21b54f207ded8814e8d48446">rootData</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, pReader-&gt;<a class="code" href="structLeavesReader.html#a4ab5c79a21b54f207ded8814e8d48446">rootData</a>.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>,
<a name="l05094"></a>05094                    &amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05095"></a>05095   }<span class="keywordflow">else</span>{
<a name="l05096"></a>05096     <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l05097"></a>05097     <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#af6f50d47986ffc800da3bf8c6176615f">sql_get_leaf_statement</a>(v, idx, &amp;s);
<a name="l05098"></a>05098     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05099"></a>05099 
<a name="l05100"></a>05100     rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, iStartBlockid);
<a name="l05101"></a>05101     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05102"></a>05102 
<a name="l05103"></a>05103     rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 2, iEndBlockid);
<a name="l05104"></a>05104     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05105"></a>05105 
<a name="l05106"></a>05106     rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l05107"></a>05107     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l05108"></a>05108       pReader-&gt;<a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">eof</a> = 1;
<a name="l05109"></a>05109       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05110"></a>05110     }
<a name="l05111"></a>05111     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> rc;
<a name="l05112"></a>05112 
<a name="l05113"></a>05113     pReader-&gt;<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a> = s;
<a name="l05114"></a>05114     <a class="code" href="fts2_8c.html#a52025ab047c301a943c74614de27e297">leafReaderInit</a>(<a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(pReader-&gt;<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a>, 0),
<a name="l05115"></a>05115                    <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(pReader-&gt;<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a>, 0),
<a name="l05116"></a>05116                    &amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05117"></a>05117   }
<a name="l05118"></a>05118   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05119"></a>05119 }
<a name="l05120"></a>05120 
<a name="l05121"></a>05121 <span class="comment">/* Step the current leaf forward to the next term.  If we reach the</span>
<a name="l05122"></a>05122 <span class="comment">** end of the current leaf, step forward to the next leaf block.</span>
<a name="l05123"></a>05123 <span class="comment">*/</span>
<a name="l05124"></a><a class="code" href="fts2_8c.html#a0cba191ae8402798782d84a133bbccd8">05124</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a0cba191ae8402798782d84a133bbccd8">leavesReaderStep</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader){
<a name="l05125"></a>05125   assert( !<a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(pReader) );
<a name="l05126"></a>05126   <a class="code" href="fts2_8c.html#af49e9a7f364e86b641bb1323d78585f0">leafReaderStep</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05127"></a>05127 
<a name="l05128"></a>05128   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#ac4dc419cdf1996a0336e223631dcbe11">leafReaderAtEnd</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>) ){
<a name="l05129"></a>05129     <span class="keywordtype">int</span> rc;
<a name="l05130"></a>05130     <span class="keywordflow">if</span>( pReader-&gt;<a class="code" href="structLeavesReader.html#a4ab5c79a21b54f207ded8814e8d48446">rootData</a>.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a> ){
<a name="l05131"></a>05131       pReader-&gt;<a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">eof</a> = 1;
<a name="l05132"></a>05132       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05133"></a>05133     }
<a name="l05134"></a>05134     rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(pReader-&gt;<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a>);
<a name="l05135"></a>05135     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l05136"></a>05136       pReader-&gt;<a class="code" href="structLeavesReader.html#a0a90232a5012f131ad69a5a1ccc5f18e">eof</a> = 1;
<a name="l05137"></a>05137       <span class="keywordflow">return</span> rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ? <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> : rc;
<a name="l05138"></a>05138     }
<a name="l05139"></a>05139     <a class="code" href="fts2_8c.html#ab54351e3555215d9f539ef2172eefce5">leafReaderDestroy</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05140"></a>05140     <a class="code" href="fts2_8c.html#a52025ab047c301a943c74614de27e297">leafReaderInit</a>(<a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(pReader-&gt;<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a>, 0),
<a name="l05141"></a>05141                    <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(pReader-&gt;<a class="code" href="structLeavesReader.html#ab358256ff1bdccba5621711bb523ef8a">pStmt</a>, 0),
<a name="l05142"></a>05142                    &amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>);
<a name="l05143"></a>05143   }
<a name="l05144"></a>05144   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05145"></a>05145 }
<a name="l05146"></a>05146 
<a name="l05147"></a>05147 <span class="comment">/* Order LeavesReaders by their term, ignoring idx.  Readers at eof</span>
<a name="l05148"></a>05148 <span class="comment">** always sort to the end.</span>
<a name="l05149"></a>05149 <span class="comment">*/</span>
<a name="l05150"></a><a class="code" href="fts2_8c.html#a5a7698146081534829ccc62636a39764">05150</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a5a7698146081534829ccc62636a39764">leavesReaderTermCmp</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *lr1, <a class="code" href="structLeavesReader.html">LeavesReader</a> *lr2){
<a name="l05151"></a>05151   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(lr1) ){
<a name="l05152"></a>05152     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(lr2) ) <span class="keywordflow">return</span> 0;
<a name="l05153"></a>05153     <span class="keywordflow">return</span> 1;
<a name="l05154"></a>05154   }
<a name="l05155"></a>05155   <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(lr2) ) <span class="keywordflow">return</span> -1;
<a name="l05156"></a>05156 
<a name="l05157"></a>05157   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#af573af3f12be16d66bf0ca228a8cc82e">leafReaderTermCmp</a>(&amp;lr1-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>,
<a name="l05158"></a>05158                            <a class="code" href="fts2_8c.html#aeb47709b8fd707f2705051ccd9f95ea2">leavesReaderTerm</a>(lr2), <a class="code" href="fts2_8c.html#ab1b844350e43ffea25791355eff5fe6d">leavesReaderTermBytes</a>(lr2),
<a name="l05159"></a>05159                            0);
<a name="l05160"></a>05160 }
<a name="l05161"></a>05161 
<a name="l05162"></a>05162 <span class="comment">/* Similar to leavesReaderTermCmp(), with additional ordering by idx</span>
<a name="l05163"></a>05163 <span class="comment">** so that older segments sort before newer segments.</span>
<a name="l05164"></a>05164 <span class="comment">*/</span>
<a name="l05165"></a><a class="code" href="fts2_8c.html#adafe6b960faaf3bc0e0abd1256759b23">05165</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#adafe6b960faaf3bc0e0abd1256759b23">leavesReaderCmp</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *lr1, <a class="code" href="structLeavesReader.html">LeavesReader</a> *lr2){
<a name="l05166"></a>05166   <span class="keywordtype">int</span> c = <a class="code" href="fts2_8c.html#a5a7698146081534829ccc62636a39764">leavesReaderTermCmp</a>(lr1, lr2);
<a name="l05167"></a>05167   <span class="keywordflow">if</span>( c!=0 ) <span class="keywordflow">return</span> c;
<a name="l05168"></a>05168   <span class="keywordflow">return</span> lr1-&gt;<a class="code" href="structLeavesReader.html#aa9b69a1418fe046ef543a71dc19fdb25">idx</a>-lr2-&gt;<a class="code" href="structLeavesReader.html#aa9b69a1418fe046ef543a71dc19fdb25">idx</a>;
<a name="l05169"></a>05169 }
<a name="l05170"></a>05170 
<a name="l05171"></a>05171 <span class="comment">/* Assume that pLr[1]..pLr[nLr] are sorted.  Bubble pLr[0] into its</span>
<a name="l05172"></a>05172 <span class="comment">** sorted position.</span>
<a name="l05173"></a>05173 <span class="comment">*/</span>
<a name="l05174"></a><a class="code" href="fts2_8c.html#ab184135f11789df9334d659c45dbbd8a">05174</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#ab184135f11789df9334d659c45dbbd8a">leavesReaderReorder</a>(<a class="code" href="structLeavesReader.html">LeavesReader</a> *pLr, <span class="keywordtype">int</span> nLr){
<a name="l05175"></a>05175   <span class="keywordflow">while</span>( nLr&gt;1 &amp;&amp; <a class="code" href="fts2_8c.html#adafe6b960faaf3bc0e0abd1256759b23">leavesReaderCmp</a>(pLr, pLr+1)&gt;0 ){
<a name="l05176"></a>05176     <a class="code" href="structLeavesReader.html">LeavesReader</a> tmp = pLr[0];
<a name="l05177"></a>05177     pLr[0] = pLr[1];
<a name="l05178"></a>05178     pLr[1] = tmp;
<a name="l05179"></a>05179     nLr--;
<a name="l05180"></a>05180     pLr++;
<a name="l05181"></a>05181   }
<a name="l05182"></a>05182 }
<a name="l05183"></a>05183 
<a name="l05184"></a>05184 <span class="comment">/* Initializes pReaders with the segments from level iLevel, returning</span>
<a name="l05185"></a>05185 <span class="comment">** the number of segments in *piReaders.  Leaves pReaders in sorted</span>
<a name="l05186"></a>05186 <span class="comment">** order.</span>
<a name="l05187"></a>05187 <span class="comment">*/</span>
<a name="l05188"></a><a class="code" href="fts2_8c.html#a4ca356a1d85747886560cceb1b5b1031">05188</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a4ca356a1d85747886560cceb1b5b1031">leavesReadersInit</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iLevel,
<a name="l05189"></a>05189                              <a class="code" href="structLeavesReader.html">LeavesReader</a> *pReaders, <span class="keywordtype">int</span> *piReaders){
<a name="l05190"></a>05190   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l05191"></a>05191   <span class="keywordtype">int</span> i, rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a6189c67dce3ec517210faabb4e4651f4">SEGDIR_SELECT_LEVEL_STMT</a>, &amp;s);
<a name="l05192"></a>05192   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05193"></a>05193 
<a name="l05194"></a>05194   rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 1, iLevel);
<a name="l05195"></a>05195   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05196"></a>05196 
<a name="l05197"></a>05197   i = 0;
<a name="l05198"></a>05198   <span class="keywordflow">while</span>( (rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s))==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l05199"></a>05199     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iStart = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 0);
<a name="l05200"></a>05200     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iEnd = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 1);
<a name="l05201"></a>05201     <span class="keyword">const</span> <span class="keywordtype">char</span> *pRootData = <a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(s, 2);
<a name="l05202"></a>05202     <span class="keywordtype">int</span> nRootData = <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(s, 2);
<a name="l05203"></a>05203 
<a name="l05204"></a>05204     assert( i&lt;<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a> );
<a name="l05205"></a>05205     rc = <a class="code" href="fts2_8c.html#a80fb079e0710324da4be7fe56c5dd7e5">leavesReaderInit</a>(v, i, iStart, iEnd, pRootData, nRootData,
<a name="l05206"></a>05206                           &amp;pReaders[i]);
<a name="l05207"></a>05207     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">break</span>;
<a name="l05208"></a>05208 
<a name="l05209"></a>05209     i++;
<a name="l05210"></a>05210   }
<a name="l05211"></a>05211   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l05212"></a>05212     <span class="keywordflow">while</span>( i--&gt;0 ){
<a name="l05213"></a>05213       <a class="code" href="fts2_8c.html#a855cb94e7913e2a38eb8c281a85f12f9">leavesReaderDestroy</a>(&amp;pReaders[i]);
<a name="l05214"></a>05214     }
<a name="l05215"></a>05215     <span class="keywordflow">return</span> rc;
<a name="l05216"></a>05216   }
<a name="l05217"></a>05217 
<a name="l05218"></a>05218   *piReaders = i;
<a name="l05219"></a>05219 
<a name="l05220"></a>05220   <span class="comment">/* Leave our results sorted by term, then age. */</span>
<a name="l05221"></a>05221   <span class="keywordflow">while</span>( i-- ){
<a name="l05222"></a>05222     <a class="code" href="fts2_8c.html#ab184135f11789df9334d659c45dbbd8a">leavesReaderReorder</a>(pReaders+i, *piReaders-i);
<a name="l05223"></a>05223   }
<a name="l05224"></a>05224   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05225"></a>05225 }
<a name="l05226"></a>05226 
<a name="l05227"></a>05227 <span class="comment">/* Merge doclists from pReaders[nReaders] into a single doclist, which</span>
<a name="l05228"></a>05228 <span class="comment">** is written to pWriter.  Assumes pReaders is ordered oldest to</span>
<a name="l05229"></a>05229 <span class="comment">** newest.</span>
<a name="l05230"></a>05230 <span class="comment">*/</span>
<a name="l05231"></a>05231 <span class="comment">/* TODO(shess) Consider putting this inline in segmentMerge(). */</span>
<a name="l05232"></a><a class="code" href="fts2_8c.html#a849e273e554d74f6457f23b6b62391b7">05232</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a849e273e554d74f6457f23b6b62391b7">leavesReadersMerge</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,
<a name="l05233"></a>05233                               <a class="code" href="structLeavesReader.html">LeavesReader</a> *pReaders, <span class="keywordtype">int</span> nReaders,
<a name="l05234"></a>05234                               <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter){
<a name="l05235"></a>05235   <a class="code" href="structDLReader.html">DLReader</a> dlReaders[<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>];
<a name="l05236"></a>05236   <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm = <a class="code" href="fts2_8c.html#aeb47709b8fd707f2705051ccd9f95ea2">leavesReaderTerm</a>(pReaders);
<a name="l05237"></a>05237   <span class="keywordtype">int</span> i, nTerm = <a class="code" href="fts2_8c.html#ab1b844350e43ffea25791355eff5fe6d">leavesReaderTermBytes</a>(pReaders);
<a name="l05238"></a>05238 
<a name="l05239"></a>05239   assert( nReaders&lt;=<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a> );
<a name="l05240"></a>05240 
<a name="l05241"></a>05241   <span class="keywordflow">for</span>(i=0; i&lt;nReaders; i++){
<a name="l05242"></a>05242     <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;dlReaders[i], <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>,
<a name="l05243"></a>05243             <a class="code" href="fts2_8c.html#a80da0054c63cf95a7ba519c023094244">leavesReaderData</a>(pReaders+i),
<a name="l05244"></a>05244             <a class="code" href="fts2_8c.html#a54bac53899528f039168ab9eb55ae866">leavesReaderDataBytes</a>(pReaders+i));
<a name="l05245"></a>05245   }
<a name="l05246"></a>05246 
<a name="l05247"></a>05247   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a212d080a728a28abde0e58a804d265bd">leafWriterStepMerge</a>(v, pWriter, pTerm, nTerm, dlReaders, nReaders);
<a name="l05248"></a>05248 }
<a name="l05249"></a>05249 
<a name="l05250"></a>05250 <span class="comment">/* Forward ref due to mutual recursion with segdirNextIndex(). */</span>
<a name="l05251"></a>05251 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a994ee9f93d055d7947918f30a2cd5bba">segmentMerge</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iLevel);
<a name="l05252"></a>05252 
<a name="l05253"></a>05253 <span class="comment">/* Put the next available index at iLevel into *pidx.  If iLevel</span>
<a name="l05254"></a>05254 <span class="comment">** already has MERGE_COUNT segments, they are merged to a higher</span>
<a name="l05255"></a>05255 <span class="comment">** level to make room.</span>
<a name="l05256"></a>05256 <span class="comment">*/</span>
<a name="l05257"></a><a class="code" href="fts2_8c.html#abf2af74d861514ae1481ff4f176e6771">05257</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#abf2af74d861514ae1481ff4f176e6771">segdirNextIndex</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iLevel, <span class="keywordtype">int</span> *pidx){
<a name="l05258"></a>05258   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a6fb5e7757b149795cb2f3eb774368db2">segdir_max_index</a>(v, iLevel, pidx);
<a name="l05259"></a>05259   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){              <span class="comment">/* No segments at iLevel. */</span>
<a name="l05260"></a>05260     *pidx = 0;
<a name="l05261"></a>05261   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l05262"></a>05262     <span class="keywordflow">if</span>( *pidx==(<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>-1) ){
<a name="l05263"></a>05263       rc = <a class="code" href="fts2_8c.html#a994ee9f93d055d7947918f30a2cd5bba">segmentMerge</a>(v, iLevel);
<a name="l05264"></a>05264       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05265"></a>05265       *pidx = 0;
<a name="l05266"></a>05266     }<span class="keywordflow">else</span>{
<a name="l05267"></a>05267       (*pidx)++;
<a name="l05268"></a>05268     }
<a name="l05269"></a>05269   }<span class="keywordflow">else</span>{
<a name="l05270"></a>05270     <span class="keywordflow">return</span> rc;
<a name="l05271"></a>05271   }
<a name="l05272"></a>05272   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05273"></a>05273 }
<a name="l05274"></a>05274 
<a name="l05275"></a>05275 <span class="comment">/* Merge MERGE_COUNT segments at iLevel into a new segment at</span>
<a name="l05276"></a>05276 <span class="comment">** iLevel+1.  If iLevel+1 is already full of segments, those will be</span>
<a name="l05277"></a>05277 <span class="comment">** merged to make room.</span>
<a name="l05278"></a>05278 <span class="comment">*/</span>
<a name="l05279"></a><a class="code" href="fts2_8c.html#a994ee9f93d055d7947918f30a2cd5bba">05279</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a994ee9f93d055d7947918f30a2cd5bba">segmentMerge</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iLevel){
<a name="l05280"></a>05280   <a class="code" href="structLeafWriter.html">LeafWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l05281"></a>05281   <a class="code" href="structLeavesReader.html">LeavesReader</a> lrs[<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>];
<a name="l05282"></a>05282   <span class="keywordtype">int</span> i, rc, idx = 0;
<a name="l05283"></a>05283 
<a name="l05284"></a>05284   <span class="comment">/* Determine the next available segment index at the next level,</span>
<a name="l05285"></a>05285 <span class="comment">  ** merging as necessary.</span>
<a name="l05286"></a>05286 <span class="comment">  */</span>
<a name="l05287"></a>05287   rc = <a class="code" href="fts2_8c.html#abf2af74d861514ae1481ff4f176e6771">segdirNextIndex</a>(v, iLevel+1, &amp;idx);
<a name="l05288"></a>05288   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05289"></a>05289 
<a name="l05290"></a>05290   <span class="comment">/* TODO(shess) This assumes that we&apos;ll always see exactly</span>
<a name="l05291"></a>05291 <span class="comment">  ** MERGE_COUNT segments to merge at a given level.  That will be</span>
<a name="l05292"></a>05292 <span class="comment">  ** broken if we allow the developer to request preemptive or</span>
<a name="l05293"></a>05293 <span class="comment">  ** deferred merging.</span>
<a name="l05294"></a>05294 <span class="comment">  */</span>
<a name="l05295"></a>05295   memset(&amp;lrs, <span class="charliteral">&apos;\0&apos;</span>, <span class="keyword">sizeof</span>(lrs));
<a name="l05296"></a>05296   rc = <a class="code" href="fts2_8c.html#a4ca356a1d85747886560cceb1b5b1031">leavesReadersInit</a>(v, iLevel, lrs, &amp;i);
<a name="l05297"></a>05297   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05298"></a>05298   assert( i==<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a> );
<a name="l05299"></a>05299 
<a name="l05300"></a>05300   <a class="code" href="fts2_8c.html#a86612bb723ea03d3cf9cee54b300e8d8">leafWriterInit</a>(iLevel+1, idx, &amp;writer);
<a name="l05301"></a>05301 
<a name="l05302"></a>05302   <span class="comment">/* Since leavesReaderReorder() pushes readers at eof to the end,</span>
<a name="l05303"></a>05303 <span class="comment">  ** when the first reader is empty, all will be empty.</span>
<a name="l05304"></a>05304 <span class="comment">  */</span>
<a name="l05305"></a>05305   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(lrs) ){
<a name="l05306"></a>05306     <span class="comment">/* Figure out how many readers share their next term. */</span>
<a name="l05307"></a>05307     <span class="keywordflow">for</span>(i=1; i&lt;<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a> &amp;&amp; !<a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(lrs+i); i++){
<a name="l05308"></a>05308       <span class="keywordflow">if</span>( 0!=<a class="code" href="fts2_8c.html#a5a7698146081534829ccc62636a39764">leavesReaderTermCmp</a>(lrs, lrs+i) ) <span class="keywordflow">break</span>;
<a name="l05309"></a>05309     }
<a name="l05310"></a>05310 
<a name="l05311"></a>05311     rc = <a class="code" href="fts2_8c.html#a849e273e554d74f6457f23b6b62391b7">leavesReadersMerge</a>(v, lrs, i, &amp;writer);
<a name="l05312"></a>05312     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l05313"></a>05313 
<a name="l05314"></a>05314     <span class="comment">/* Step forward those that were merged. */</span>
<a name="l05315"></a>05315     <span class="keywordflow">while</span>( i--&gt;0 ){
<a name="l05316"></a>05316       rc = <a class="code" href="fts2_8c.html#a0cba191ae8402798782d84a133bbccd8">leavesReaderStep</a>(v, lrs+i);
<a name="l05317"></a>05317       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l05318"></a>05318 
<a name="l05319"></a>05319       <span class="comment">/* Reorder by term, then by age. */</span>
<a name="l05320"></a>05320       <a class="code" href="fts2_8c.html#ab184135f11789df9334d659c45dbbd8a">leavesReaderReorder</a>(lrs+i, <a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>-i);
<a name="l05321"></a>05321     }
<a name="l05322"></a>05322   }
<a name="l05323"></a>05323 
<a name="l05324"></a>05324   <span class="keywordflow">for</span>(i=0; i&lt;<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>; i++){
<a name="l05325"></a>05325     <a class="code" href="fts2_8c.html#a855cb94e7913e2a38eb8c281a85f12f9">leavesReaderDestroy</a>(&amp;lrs[i]);
<a name="l05326"></a>05326   }
<a name="l05327"></a>05327 
<a name="l05328"></a>05328   rc = <a class="code" href="fts2_8c.html#a20a5c7ef17056f24bd37097afd4fe67b">leafWriterFinalize</a>(v, &amp;writer);
<a name="l05329"></a>05329   <a class="code" href="fts2_8c.html#a2a86036daf4b9e95f8c4e7105bc8e035">leafWriterDestroy</a>(&amp;writer);
<a name="l05330"></a>05330   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05331"></a>05331 
<a name="l05332"></a>05332   <span class="comment">/* Delete the merged segment data. */</span>
<a name="l05333"></a>05333   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a4f5564997dda64601c2138e86b85a96a">segdir_delete</a>(v, iLevel);
<a name="l05334"></a>05334 
<a name="l05335"></a>05335  err:
<a name="l05336"></a>05336   <span class="keywordflow">for</span>(i=0; i&lt;MERGE_COUNT; i++){
<a name="l05337"></a>05337     <a class="code" href="fts2_8c.html#a855cb94e7913e2a38eb8c281a85f12f9">leavesReaderDestroy</a>(&amp;lrs[i]);
<a name="l05338"></a>05338   }
<a name="l05339"></a>05339   <a class="code" href="fts2_8c.html#a2a86036daf4b9e95f8c4e7105bc8e035">leafWriterDestroy</a>(&amp;writer);
<a name="l05340"></a>05340   <span class="keywordflow">return</span> rc;
<a name="l05341"></a>05341 }
<a name="l05342"></a>05342 
<a name="l05343"></a>05343 <span class="comment">/* Accumulate the union of *acc and *pData into *acc. */</span>
<a name="l05344"></a><a class="code" href="fts2_8c.html#a38ed7d983475f7c02a0054ff132fa901">05344</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a38ed7d983475f7c02a0054ff132fa901">docListAccumulateUnion</a>(<a class="code" href="structDataBuffer.html">DataBuffer</a> *acc,
<a name="l05345"></a>05345                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData) {
<a name="l05346"></a>05346   <a class="code" href="structDataBuffer.html">DataBuffer</a> tmp = *acc;
<a name="l05347"></a>05347   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(acc, tmp.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>+nData);
<a name="l05348"></a>05348   <a class="code" href="fts2_8c.html#a1378255319ef7fb8ca0763a7fef50619">docListUnion</a>(tmp.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, tmp.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, pData, nData, acc);
<a name="l05349"></a>05349   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;tmp);
<a name="l05350"></a>05350 }
<a name="l05351"></a>05351 
<a name="l05352"></a>05352 <span class="comment">/* TODO(shess) It might be interesting to explore different merge</span>
<a name="l05353"></a>05353 <span class="comment">** strategies, here.  For instance, since this is a sorted merge, we</span>
<a name="l05354"></a>05354 <span class="comment">** could easily merge many doclists in parallel.  With some</span>
<a name="l05355"></a>05355 <span class="comment">** comprehension of the storage format, we could merge all of the</span>
<a name="l05356"></a>05356 <span class="comment">** doclists within a leaf node directly from the leaf node&apos;s storage.</span>
<a name="l05357"></a>05357 <span class="comment">** It may be worthwhile to merge smaller doclists before larger</span>
<a name="l05358"></a>05358 <span class="comment">** doclists, since they can be traversed more quickly - but the</span>
<a name="l05359"></a>05359 <span class="comment">** results may have less overlap, making them more expensive in a</span>
<a name="l05360"></a>05360 <span class="comment">** different way.</span>
<a name="l05361"></a>05361 <span class="comment">*/</span>
<a name="l05362"></a>05362 
<a name="l05363"></a>05363 <span class="comment">/* Scan pReader for pTerm/nTerm, and merge the term&apos;s doclist over</span>
<a name="l05364"></a>05364 <span class="comment">** *out (any doclists with duplicate docids overwrite those in *out).</span>
<a name="l05365"></a>05365 <span class="comment">** Internal function for loadSegmentLeaf().</span>
<a name="l05366"></a>05366 <span class="comment">*/</span>
<a name="l05367"></a><a class="code" href="fts2_8c.html#a6f70d4514db224007d950cefa391512d">05367</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a6f70d4514db224007d950cefa391512d">loadSegmentLeavesInt</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structLeavesReader.html">LeavesReader</a> *pReader,
<a name="l05368"></a>05368                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix,
<a name="l05369"></a>05369                                 <a class="code" href="structDataBuffer.html">DataBuffer</a> *out){
<a name="l05370"></a>05370   <span class="comment">/* doclist data is accumulated into pBuffers similar to how one does</span>
<a name="l05371"></a>05371 <span class="comment">  ** increment in binary arithmetic.  If index 0 is empty, the data is</span>
<a name="l05372"></a>05372 <span class="comment">  ** stored there.  If there is data there, it is merged and the</span>
<a name="l05373"></a>05373 <span class="comment">  ** results carried into position 1, with further merge-and-carry</span>
<a name="l05374"></a>05374 <span class="comment">  ** until an empty position is found.</span>
<a name="l05375"></a>05375 <span class="comment">  */</span>
<a name="l05376"></a>05376   <a class="code" href="structDataBuffer.html">DataBuffer</a> *pBuffers = NULL;
<a name="l05377"></a>05377   <span class="keywordtype">int</span> nBuffers = 0, nMaxBuffers = 0, rc;
<a name="l05378"></a>05378 
<a name="l05379"></a>05379   assert( nTerm&gt;0 );
<a name="l05380"></a>05380 
<a name="l05381"></a>05381   <span class="keywordflow">for</span>(rc=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; !<a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(pReader);
<a name="l05382"></a>05382       rc=<a class="code" href="fts2_8c.html#a0cba191ae8402798782d84a133bbccd8">leavesReaderStep</a>(v, pReader)){
<a name="l05383"></a>05383     <span class="comment">/* TODO(shess) Really want leavesReaderTermCmp(), but that name is</span>
<a name="l05384"></a>05384 <span class="comment">    ** already taken to compare the terms of two LeavesReaders.  Think</span>
<a name="l05385"></a>05385 <span class="comment">    ** on a better name.  [Meanwhile, break encapsulation rather than</span>
<a name="l05386"></a>05386 <span class="comment">    ** use a confusing name.]</span>
<a name="l05387"></a>05387 <span class="comment">    */</span>
<a name="l05388"></a>05388     <span class="keywordtype">int</span> c = <a class="code" href="fts2_8c.html#af573af3f12be16d66bf0ca228a8cc82e">leafReaderTermCmp</a>(&amp;pReader-&gt;<a class="code" href="structLeavesReader.html#aaa88b51485e48940f5d73ec0fab3618a">leafReader</a>, pTerm, nTerm, isPrefix);
<a name="l05389"></a>05389     <span class="keywordflow">if</span>( c&gt;0 ) <span class="keywordflow">break</span>;      <span class="comment">/* Past any possible matches. */</span>
<a name="l05390"></a>05390     <span class="keywordflow">if</span>( c==0 ){
<a name="l05391"></a>05391       <span class="keyword">const</span> <span class="keywordtype">char</span> *pData = <a class="code" href="fts2_8c.html#a80da0054c63cf95a7ba519c023094244">leavesReaderData</a>(pReader);
<a name="l05392"></a>05392       <span class="keywordtype">int</span> iBuffer, nData = <a class="code" href="fts2_8c.html#a54bac53899528f039168ab9eb55ae866">leavesReaderDataBytes</a>(pReader);
<a name="l05393"></a>05393 
<a name="l05394"></a>05394       <span class="comment">/* Find the first empty buffer. */</span>
<a name="l05395"></a>05395       <span class="keywordflow">for</span>(iBuffer=0; iBuffer&lt;nBuffers; ++iBuffer){
<a name="l05396"></a>05396         <span class="keywordflow">if</span>( 0==pBuffers[iBuffer].nData ) <span class="keywordflow">break</span>;
<a name="l05397"></a>05397       }
<a name="l05398"></a>05398 
<a name="l05399"></a>05399       <span class="comment">/* Out of buffers, add an empty one. */</span>
<a name="l05400"></a>05400       <span class="keywordflow">if</span>( iBuffer==nBuffers ){
<a name="l05401"></a>05401         <span class="keywordflow">if</span>( nBuffers==nMaxBuffers ){
<a name="l05402"></a>05402           <a class="code" href="structDataBuffer.html">DataBuffer</a> *p;
<a name="l05403"></a>05403           nMaxBuffers += 20;
<a name="l05404"></a>05404 
<a name="l05405"></a>05405           <span class="comment">/* Manual realloc so we can handle NULL appropriately. */</span>
<a name="l05406"></a>05406           p = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(nMaxBuffers*<span class="keyword">sizeof</span>(*pBuffers));
<a name="l05407"></a>05407           <span class="keywordflow">if</span>( p==NULL ){
<a name="l05408"></a>05408             rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l05409"></a>05409             <span class="keywordflow">break</span>;
<a name="l05410"></a>05410           }
<a name="l05411"></a>05411 
<a name="l05412"></a>05412           <span class="keywordflow">if</span>( nBuffers&gt;0 ){
<a name="l05413"></a>05413             assert(pBuffers!=NULL);
<a name="l05414"></a>05414             memcpy(p, pBuffers, nBuffers*<span class="keyword">sizeof</span>(*pBuffers));
<a name="l05415"></a>05415             <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pBuffers);
<a name="l05416"></a>05416           }
<a name="l05417"></a>05417           pBuffers = p;
<a name="l05418"></a>05418         }
<a name="l05419"></a>05419         <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;(pBuffers[nBuffers]), 0);
<a name="l05420"></a>05420         nBuffers++;
<a name="l05421"></a>05421       }
<a name="l05422"></a>05422 
<a name="l05423"></a>05423       <span class="comment">/* At this point, must have an empty at iBuffer. */</span>
<a name="l05424"></a>05424       assert(iBuffer&lt;nBuffers &amp;&amp; pBuffers[iBuffer].nData==0);
<a name="l05425"></a>05425 
<a name="l05426"></a>05426       <span class="comment">/* If empty was first buffer, no need for merge logic. */</span>
<a name="l05427"></a>05427       <span class="keywordflow">if</span>( iBuffer==0 ){
<a name="l05428"></a>05428         <a class="code" href="fts2_8c.html#aea631ff401eb0769ab1e97801306c33a">dataBufferReplace</a>(&amp;(pBuffers[0]), pData, nData);
<a name="l05429"></a>05429       }<span class="keywordflow">else</span>{
<a name="l05430"></a>05430         <span class="comment">/* pAcc is the empty buffer the merged data will end up in. */</span>
<a name="l05431"></a>05431         <a class="code" href="structDataBuffer.html">DataBuffer</a> *pAcc = &amp;(pBuffers[iBuffer]);
<a name="l05432"></a>05432         <a class="code" href="structDataBuffer.html">DataBuffer</a> *p = &amp;(pBuffers[0]);
<a name="l05433"></a>05433 
<a name="l05434"></a>05434         <span class="comment">/* Handle position 0 specially to avoid need to prime pAcc</span>
<a name="l05435"></a>05435 <span class="comment">        ** with pData/nData.</span>
<a name="l05436"></a>05436 <span class="comment">        */</span>
<a name="l05437"></a>05437         <a class="code" href="fts2_8c.html#aa9ed042d26904ee854cb8a87c6d2d666">dataBufferSwap</a>(p, pAcc);
<a name="l05438"></a>05438         <a class="code" href="fts2_8c.html#a38ed7d983475f7c02a0054ff132fa901">docListAccumulateUnion</a>(pAcc, pData, nData);
<a name="l05439"></a>05439 
<a name="l05440"></a>05440         <span class="comment">/* Accumulate remaining doclists into pAcc. */</span>
<a name="l05441"></a>05441         <span class="keywordflow">for</span>(++p; p&lt;pAcc; ++p){
<a name="l05442"></a>05442           <a class="code" href="fts2_8c.html#a38ed7d983475f7c02a0054ff132fa901">docListAccumulateUnion</a>(pAcc, p-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, p-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l05443"></a>05443 
<a name="l05444"></a>05444           <span class="comment">/* dataBufferReset() could allow a large doclist to blow up</span>
<a name="l05445"></a>05445 <span class="comment">          ** our memory requirements.</span>
<a name="l05446"></a>05446 <span class="comment">          */</span>
<a name="l05447"></a>05447           <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structDataBuffer.html#a94be96e6647b66004cdc163cd6cd1df4">nCapacity</a>&lt;1024 ){
<a name="l05448"></a>05448             <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(p);
<a name="l05449"></a>05449           }<span class="keywordflow">else</span>{
<a name="l05450"></a>05450             <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(p);
<a name="l05451"></a>05451             <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(p, 0);
<a name="l05452"></a>05452           }
<a name="l05453"></a>05453         }
<a name="l05454"></a>05454       }
<a name="l05455"></a>05455     }
<a name="l05456"></a>05456   }
<a name="l05457"></a>05457 
<a name="l05458"></a>05458   <span class="comment">/* Union all the doclists together into *out. */</span>
<a name="l05459"></a>05459   <span class="comment">/* TODO(shess) What if *out is big?  Sigh. */</span>
<a name="l05460"></a>05460   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; nBuffers&gt;0 ){
<a name="l05461"></a>05461     <span class="keywordtype">int</span> iBuffer;
<a name="l05462"></a>05462     <span class="keywordflow">for</span>(iBuffer=0; iBuffer&lt;nBuffers; ++iBuffer){
<a name="l05463"></a>05463       <span class="keywordflow">if</span>( pBuffers[iBuffer].nData&gt;0 ){
<a name="l05464"></a>05464         <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>==0 ){
<a name="l05465"></a>05465           <a class="code" href="fts2_8c.html#aa9ed042d26904ee854cb8a87c6d2d666">dataBufferSwap</a>(out, &amp;(pBuffers[iBuffer]));
<a name="l05466"></a>05466         }<span class="keywordflow">else</span>{
<a name="l05467"></a>05467           <a class="code" href="fts2_8c.html#a38ed7d983475f7c02a0054ff132fa901">docListAccumulateUnion</a>(out, pBuffers[iBuffer].pData,
<a name="l05468"></a>05468                                  pBuffers[iBuffer].nData);
<a name="l05469"></a>05469         }
<a name="l05470"></a>05470       }
<a name="l05471"></a>05471     }
<a name="l05472"></a>05472   }
<a name="l05473"></a>05473 
<a name="l05474"></a>05474   <span class="keywordflow">while</span>( nBuffers-- ){
<a name="l05475"></a>05475     <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;(pBuffers[nBuffers]));
<a name="l05476"></a>05476   }
<a name="l05477"></a>05477   <span class="keywordflow">if</span>( pBuffers!=NULL ) <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pBuffers);
<a name="l05478"></a>05478 
<a name="l05479"></a>05479   <span class="keywordflow">return</span> rc;
<a name="l05480"></a>05480 }
<a name="l05481"></a>05481 
<a name="l05482"></a>05482 <span class="comment">/* Call loadSegmentLeavesInt() with pData/nData as input. */</span>
<a name="l05483"></a><a class="code" href="fts2_8c.html#a4ad901ebe758f3b5f87a7e12fbba3082">05483</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a4ad901ebe758f3b5f87a7e12fbba3082">loadSegmentLeaf</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l05484"></a>05484                            <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix,
<a name="l05485"></a>05485                            <a class="code" href="structDataBuffer.html">DataBuffer</a> *out){
<a name="l05486"></a>05486   <a class="code" href="structLeavesReader.html">LeavesReader</a> reader;
<a name="l05487"></a>05487   <span class="keywordtype">int</span> rc;
<a name="l05488"></a>05488 
<a name="l05489"></a>05489   assert( nData&gt;1 );
<a name="l05490"></a>05490   assert( *pData==<span class="charliteral">&apos;\0&apos;</span> );
<a name="l05491"></a>05491   rc = <a class="code" href="fts2_8c.html#a80fb079e0710324da4be7fe56c5dd7e5">leavesReaderInit</a>(v, 0, 0, 0, pData, nData, &amp;reader);
<a name="l05492"></a>05492   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05493"></a>05493 
<a name="l05494"></a>05494   rc = <a class="code" href="fts2_8c.html#a6f70d4514db224007d950cefa391512d">loadSegmentLeavesInt</a>(v, &amp;reader, pTerm, nTerm, isPrefix, out);
<a name="l05495"></a>05495   <a class="code" href="fts2_8c.html#a84e7629d66616828816845202398f5b3">leavesReaderReset</a>(&amp;reader);
<a name="l05496"></a>05496   <a class="code" href="fts2_8c.html#a855cb94e7913e2a38eb8c281a85f12f9">leavesReaderDestroy</a>(&amp;reader);
<a name="l05497"></a>05497   <span class="keywordflow">return</span> rc;
<a name="l05498"></a>05498 }
<a name="l05499"></a>05499 
<a name="l05500"></a>05500 <span class="comment">/* Call loadSegmentLeavesInt() with the leaf nodes from iStartLeaf to</span>
<a name="l05501"></a>05501 <span class="comment">** iEndLeaf (inclusive) as input, and merge the resulting doclist into</span>
<a name="l05502"></a>05502 <span class="comment">** out.</span>
<a name="l05503"></a>05503 <span class="comment">*/</span>
<a name="l05504"></a><a class="code" href="fts2_8c.html#aae1663b324f36b21a9fb96a49b6cbd59">05504</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aae1663b324f36b21a9fb96a49b6cbd59">loadSegmentLeaves</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,
<a name="l05505"></a>05505                              <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iStartLeaf, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iEndLeaf,
<a name="l05506"></a>05506                              <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix,
<a name="l05507"></a>05507                              <a class="code" href="structDataBuffer.html">DataBuffer</a> *out){
<a name="l05508"></a>05508   <span class="keywordtype">int</span> rc;
<a name="l05509"></a>05509   <a class="code" href="structLeavesReader.html">LeavesReader</a> reader;
<a name="l05510"></a>05510 
<a name="l05511"></a>05511   assert( iStartLeaf&lt;=iEndLeaf );
<a name="l05512"></a>05512   rc = <a class="code" href="fts2_8c.html#a80fb079e0710324da4be7fe56c5dd7e5">leavesReaderInit</a>(v, 0, iStartLeaf, iEndLeaf, NULL, 0, &amp;reader);
<a name="l05513"></a>05513   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05514"></a>05514 
<a name="l05515"></a>05515   rc = <a class="code" href="fts2_8c.html#a6f70d4514db224007d950cefa391512d">loadSegmentLeavesInt</a>(v, &amp;reader, pTerm, nTerm, isPrefix, out);
<a name="l05516"></a>05516   <a class="code" href="fts2_8c.html#a84e7629d66616828816845202398f5b3">leavesReaderReset</a>(&amp;reader);
<a name="l05517"></a>05517   <a class="code" href="fts2_8c.html#a855cb94e7913e2a38eb8c281a85f12f9">leavesReaderDestroy</a>(&amp;reader);
<a name="l05518"></a>05518   <span class="keywordflow">return</span> rc;
<a name="l05519"></a>05519 }
<a name="l05520"></a>05520 
<a name="l05521"></a>05521 <span class="comment">/* Taking pData/nData as an interior node, find the sequence of child</span>
<a name="l05522"></a>05522 <span class="comment">** nodes which could include pTerm/nTerm/isPrefix.  Note that the</span>
<a name="l05523"></a>05523 <span class="comment">** interior node terms logically come between the blocks, so there is</span>
<a name="l05524"></a>05524 <span class="comment">** one more blockid than there are terms (that block contains terms &gt;=</span>
<a name="l05525"></a>05525 <span class="comment">** the last interior-node term).</span>
<a name="l05526"></a>05526 <span class="comment">*/</span>
<a name="l05527"></a>05527 <span class="comment">/* TODO(shess) The calling code may already know that the end child is</span>
<a name="l05528"></a>05528 <span class="comment">** not worth calculating, because the end may be in a later sibling</span>
<a name="l05529"></a>05529 <span class="comment">** node.  Consider whether breaking symmetry is worthwhile.  I suspect</span>
<a name="l05530"></a>05530 <span class="comment">** it is not worthwhile.</span>
<a name="l05531"></a>05531 <span class="comment">*/</span>
<a name="l05532"></a><a class="code" href="fts2_8c.html#af9502d16e6c7c5b853d1a9dcc36bf228">05532</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#af9502d16e6c7c5b853d1a9dcc36bf228">getChildrenContaining</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l05533"></a>05533                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix,
<a name="l05534"></a>05534                                   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piStartChild,
<a name="l05535"></a>05535                                   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piEndChild){
<a name="l05536"></a>05536   <a class="code" href="structInteriorReader.html">InteriorReader</a> reader;
<a name="l05537"></a>05537 
<a name="l05538"></a>05538   assert( nData&gt;1 );
<a name="l05539"></a>05539   assert( *pData!=<span class="charliteral">&apos;\0&apos;</span> );
<a name="l05540"></a>05540   <a class="code" href="fts2_8c.html#a09561929f8d74f2ffdf0f7505950b037">interiorReaderInit</a>(pData, nData, &amp;reader);
<a name="l05541"></a>05541 
<a name="l05542"></a>05542   <span class="comment">/* Scan for the first child which could contain pTerm/nTerm. */</span>
<a name="l05543"></a>05543   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#a9585535a38c948428465edcb542c4663">interiorReaderAtEnd</a>(&amp;reader) ){
<a name="l05544"></a>05544     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#af2fcb5b213fc28024b1916f605a1a015">interiorReaderTermCmp</a>(&amp;reader, pTerm, nTerm, 0)&gt;0 ) <span class="keywordflow">break</span>;
<a name="l05545"></a>05545     <a class="code" href="fts2_8c.html#accf30a1322b22598236f12584001363c">interiorReaderStep</a>(&amp;reader);
<a name="l05546"></a>05546   }
<a name="l05547"></a>05547   *piStartChild = <a class="code" href="fts2_8c.html#a97fa4341bee8054f286cf1c1b316b978">interiorReaderCurrentBlockid</a>(&amp;reader);
<a name="l05548"></a>05548 
<a name="l05549"></a>05549   <span class="comment">/* Keep scanning to find a term greater than our term, using prefix</span>
<a name="l05550"></a>05550 <span class="comment">  ** comparison if indicated.  If isPrefix is false, this will be the</span>
<a name="l05551"></a>05551 <span class="comment">  ** same blockid as the starting block.</span>
<a name="l05552"></a>05552 <span class="comment">  */</span>
<a name="l05553"></a>05553   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#a9585535a38c948428465edcb542c4663">interiorReaderAtEnd</a>(&amp;reader) ){
<a name="l05554"></a>05554     <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#af2fcb5b213fc28024b1916f605a1a015">interiorReaderTermCmp</a>(&amp;reader, pTerm, nTerm, isPrefix)&gt;0 ) <span class="keywordflow">break</span>;
<a name="l05555"></a>05555     <a class="code" href="fts2_8c.html#accf30a1322b22598236f12584001363c">interiorReaderStep</a>(&amp;reader);
<a name="l05556"></a>05556   }
<a name="l05557"></a>05557   *piEndChild = <a class="code" href="fts2_8c.html#a97fa4341bee8054f286cf1c1b316b978">interiorReaderCurrentBlockid</a>(&amp;reader);
<a name="l05558"></a>05558 
<a name="l05559"></a>05559   <a class="code" href="fts2_8c.html#a0bb0bfbe9224066fd21711fccf1f5ac5">interiorReaderDestroy</a>(&amp;reader);
<a name="l05560"></a>05560 
<a name="l05561"></a>05561   <span class="comment">/* Children must ascend, and if !prefix, both must be the same. */</span>
<a name="l05562"></a>05562   assert( *piEndChild&gt;=*piStartChild );
<a name="l05563"></a>05563   assert( isPrefix || *piStartChild==*piEndChild );
<a name="l05564"></a>05564 }
<a name="l05565"></a>05565 
<a name="l05566"></a>05566 <span class="comment">/* Read block at iBlockid and pass it with other params to</span>
<a name="l05567"></a>05567 <span class="comment">** getChildrenContaining().</span>
<a name="l05568"></a>05568 <span class="comment">*/</span>
<a name="l05569"></a><a class="code" href="fts2_8c.html#a3446409e7c4888ecba55681eb897984c">05569</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a3446409e7c4888ecba55681eb897984c">loadAndGetChildrenContaining</a>(
<a name="l05570"></a>05570   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,
<a name="l05571"></a>05571   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iBlockid,
<a name="l05572"></a>05572   <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix,
<a name="l05573"></a>05573   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piStartChild, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *piEndChild
<a name="l05574"></a>05574 ){
<a name="l05575"></a>05575   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s = NULL;
<a name="l05576"></a>05576   <span class="keywordtype">int</span> rc;
<a name="l05577"></a>05577 
<a name="l05578"></a>05578   assert( iBlockid!=0 );
<a name="l05579"></a>05579   assert( pTerm!=NULL );
<a name="l05580"></a>05580   assert( nTerm!=0 );        <span class="comment">/* TODO(shess) Why not allow this? */</span>
<a name="l05581"></a>05581   assert( piStartChild!=NULL );
<a name="l05582"></a>05582   assert( piEndChild!=NULL );
<a name="l05583"></a>05583 
<a name="l05584"></a>05584   rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a098557abf15da2ebb1ff53f662254240">BLOCK_SELECT_STMT</a>, &amp;s);
<a name="l05585"></a>05585   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05586"></a>05586 
<a name="l05587"></a>05587   rc = <a class="code" href="sqlite3_8h.html#aefd78e20f41e9d96f27b755e8ef54578">sqlite3_bind_int64</a>(s, 1, iBlockid);
<a name="l05588"></a>05588   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05589"></a>05589 
<a name="l05590"></a>05590   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l05591"></a>05591   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l05592"></a>05592   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> rc;
<a name="l05593"></a>05593 
<a name="l05594"></a>05594   <a class="code" href="fts2_8c.html#af9502d16e6c7c5b853d1a9dcc36bf228">getChildrenContaining</a>(<a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(s, 0), <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(s, 0),
<a name="l05595"></a>05595                         pTerm, nTerm, isPrefix, piStartChild, piEndChild);
<a name="l05596"></a>05596 
<a name="l05597"></a>05597   <span class="comment">/* We expect only one row.  We must execute another sqlite3_step()</span>
<a name="l05598"></a>05598 <span class="comment">   * to complete the iteration; otherwise the table will remain</span>
<a name="l05599"></a>05599 <span class="comment">   * locked. */</span>
<a name="l05600"></a>05600   rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l05601"></a>05601   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l05602"></a>05602   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ) <span class="keywordflow">return</span> rc;
<a name="l05603"></a>05603 
<a name="l05604"></a>05604   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05605"></a>05605 }
<a name="l05606"></a>05606 
<a name="l05607"></a>05607 <span class="comment">/* Traverse the tree represented by pData[nData] looking for</span>
<a name="l05608"></a>05608 <span class="comment">** pTerm[nTerm], placing its doclist into *out.  This is internal to</span>
<a name="l05609"></a>05609 <span class="comment">** loadSegment() to make error-handling cleaner.</span>
<a name="l05610"></a>05610 <span class="comment">*/</span>
<a name="l05611"></a><a class="code" href="fts2_8c.html#a64e3744b4180058a7922d895bf6ee2fc">05611</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a64e3744b4180058a7922d895bf6ee2fc">loadSegmentInt</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l05612"></a>05612                           <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iLeavesEnd,
<a name="l05613"></a>05613                           <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix,
<a name="l05614"></a>05614                           <a class="code" href="structDataBuffer.html">DataBuffer</a> *out){
<a name="l05615"></a>05615   <span class="comment">/* Special case where root is a leaf. */</span>
<a name="l05616"></a>05616   <span class="keywordflow">if</span>( *pData==<span class="charliteral">&apos;\0&apos;</span> ){
<a name="l05617"></a>05617     <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a4ad901ebe758f3b5f87a7e12fbba3082">loadSegmentLeaf</a>(v, pData, nData, pTerm, nTerm, isPrefix, out);
<a name="l05618"></a>05618   }<span class="keywordflow">else</span>{
<a name="l05619"></a>05619     <span class="keywordtype">int</span> rc;
<a name="l05620"></a>05620     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iStartChild, iEndChild;
<a name="l05621"></a>05621 
<a name="l05622"></a>05622     <span class="comment">/* Process pData as an interior node, then loop down the tree</span>
<a name="l05623"></a>05623 <span class="comment">    ** until we find the set of leaf nodes to scan for the term.</span>
<a name="l05624"></a>05624 <span class="comment">    */</span>
<a name="l05625"></a>05625     <a class="code" href="fts2_8c.html#af9502d16e6c7c5b853d1a9dcc36bf228">getChildrenContaining</a>(pData, nData, pTerm, nTerm, isPrefix,
<a name="l05626"></a>05626                           &amp;iStartChild, &amp;iEndChild);
<a name="l05627"></a>05627     <span class="keywordflow">while</span>( iStartChild&gt;iLeavesEnd ){
<a name="l05628"></a>05628       <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iNextStart, iNextEnd;
<a name="l05629"></a>05629       rc = <a class="code" href="fts2_8c.html#a3446409e7c4888ecba55681eb897984c">loadAndGetChildrenContaining</a>(v, iStartChild, pTerm, nTerm, isPrefix,
<a name="l05630"></a>05630                                         &amp;iNextStart, &amp;iNextEnd);
<a name="l05631"></a>05631       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05632"></a>05632 
<a name="l05633"></a>05633       <span class="comment">/* If we&apos;ve branched, follow the end branch, too. */</span>
<a name="l05634"></a>05634       <span class="keywordflow">if</span>( iStartChild!=iEndChild ){
<a name="l05635"></a>05635         <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDummy;
<a name="l05636"></a>05636         rc = <a class="code" href="fts2_8c.html#a3446409e7c4888ecba55681eb897984c">loadAndGetChildrenContaining</a>(v, iEndChild, pTerm, nTerm, isPrefix,
<a name="l05637"></a>05637                                           &amp;iDummy, &amp;iNextEnd);
<a name="l05638"></a>05638         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05639"></a>05639       }
<a name="l05640"></a>05640 
<a name="l05641"></a>05641       assert( iNextStart&lt;=iNextEnd );
<a name="l05642"></a>05642       iStartChild = iNextStart;
<a name="l05643"></a>05643       iEndChild = iNextEnd;
<a name="l05644"></a>05644     }
<a name="l05645"></a>05645     assert( iStartChild&lt;=iLeavesEnd );
<a name="l05646"></a>05646     assert( iEndChild&lt;=iLeavesEnd );
<a name="l05647"></a>05647 
<a name="l05648"></a>05648     <span class="comment">/* Scan through the leaf segments for doclists. */</span>
<a name="l05649"></a>05649     <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#aae1663b324f36b21a9fb96a49b6cbd59">loadSegmentLeaves</a>(v, iStartChild, iEndChild,
<a name="l05650"></a>05650                              pTerm, nTerm, isPrefix, out);
<a name="l05651"></a>05651   }
<a name="l05652"></a>05652 }
<a name="l05653"></a>05653 
<a name="l05654"></a>05654 <span class="comment">/* Call loadSegmentInt() to collect the doclist for pTerm/nTerm, then</span>
<a name="l05655"></a>05655 <span class="comment">** merge its doclist over *out (any duplicate doclists read from the</span>
<a name="l05656"></a>05656 <span class="comment">** segment rooted at pData will overwrite those in *out).</span>
<a name="l05657"></a>05657 <span class="comment">*/</span>
<a name="l05658"></a>05658 <span class="comment">/* TODO(shess) Consider changing this to determine the depth of the</span>
<a name="l05659"></a>05659 <span class="comment">** leaves using either the first characters of interior nodes (when</span>
<a name="l05660"></a>05660 <span class="comment">** ==1, we&apos;re one level above the leaves), or the first character of</span>
<a name="l05661"></a>05661 <span class="comment">** the root (which will describe the height of the tree directly).</span>
<a name="l05662"></a>05662 <span class="comment">** Either feels somewhat tricky to me.</span>
<a name="l05663"></a>05663 <span class="comment">*/</span>
<a name="l05664"></a>05664 <span class="comment">/* TODO(shess) The current merge is likely to be slow for large</span>
<a name="l05665"></a>05665 <span class="comment">** doclists (though it should process from newest/smallest to</span>
<a name="l05666"></a>05666 <span class="comment">** oldest/largest, so it may not be that bad).  It might be useful to</span>
<a name="l05667"></a>05667 <span class="comment">** modify things to allow for N-way merging.  This could either be</span>
<a name="l05668"></a>05668 <span class="comment">** within a segment, with pairwise merges across segments, or across</span>
<a name="l05669"></a>05669 <span class="comment">** all segments at once.</span>
<a name="l05670"></a>05670 <span class="comment">*/</span>
<a name="l05671"></a><a class="code" href="fts2_8c.html#a18c8b542f9f0f319792e6178c64c6543">05671</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a18c8b542f9f0f319792e6178c64c6543">loadSegment</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData,
<a name="l05672"></a>05672                        <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iLeavesEnd,
<a name="l05673"></a>05673                        <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix,
<a name="l05674"></a>05674                        <a class="code" href="structDataBuffer.html">DataBuffer</a> *out){
<a name="l05675"></a>05675   <a class="code" href="structDataBuffer.html">DataBuffer</a> result;
<a name="l05676"></a>05676   <span class="keywordtype">int</span> rc;
<a name="l05677"></a>05677 
<a name="l05678"></a>05678   assert( nData&gt;1 );
<a name="l05679"></a>05679 
<a name="l05680"></a>05680   <span class="comment">/* This code should never be called with buffered updates. */</span>
<a name="l05681"></a>05681   assert( v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>&lt;0 );
<a name="l05682"></a>05682 
<a name="l05683"></a>05683   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;result, 0);
<a name="l05684"></a>05684   rc = <a class="code" href="fts2_8c.html#a64e3744b4180058a7922d895bf6ee2fc">loadSegmentInt</a>(v, pData, nData, iLeavesEnd,
<a name="l05685"></a>05685                       pTerm, nTerm, isPrefix, &amp;result);
<a name="l05686"></a>05686   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; result.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 ){
<a name="l05687"></a>05687     <span class="keywordflow">if</span>( out-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>==0 ){
<a name="l05688"></a>05688       <a class="code" href="structDataBuffer.html">DataBuffer</a> tmp = *out;
<a name="l05689"></a>05689       *out = result;
<a name="l05690"></a>05690       result = tmp;
<a name="l05691"></a>05691     }<span class="keywordflow">else</span>{
<a name="l05692"></a>05692       <a class="code" href="structDataBuffer.html">DataBuffer</a> merged;
<a name="l05693"></a>05693       <a class="code" href="structDLReader.html">DLReader</a> readers[2];
<a name="l05694"></a>05694 
<a name="l05695"></a>05695       <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;readers[0], <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, out-&gt;<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, out-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l05696"></a>05696       <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;readers[1], <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, result.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, result.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l05697"></a>05697       <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;merged, out-&gt;<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>+result.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l05698"></a>05698       <a class="code" href="fts2_8c.html#aa204589d71a5ad4842500f76af21e2b9">docListMerge</a>(&amp;merged, readers, 2);
<a name="l05699"></a>05699       <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(out);
<a name="l05700"></a>05700       *out = merged;
<a name="l05701"></a>05701       <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;readers[0]);
<a name="l05702"></a>05702       <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;readers[1]);
<a name="l05703"></a>05703     }
<a name="l05704"></a>05704   }
<a name="l05705"></a>05705   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;result);
<a name="l05706"></a>05706   <span class="keywordflow">return</span> rc;
<a name="l05707"></a>05707 }
<a name="l05708"></a>05708 
<a name="l05709"></a>05709 <span class="comment">/* Scan the database and merge together the posting lists for the term</span>
<a name="l05710"></a>05710 <span class="comment">** into *out.</span>
<a name="l05711"></a>05711 <span class="comment">*/</span>
<a name="l05712"></a><a class="code" href="fts2_8c.html#aa6bae5d86dd40972de224e7986a9450d">05712</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aa6bae5d86dd40972de224e7986a9450d">termSelect</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <span class="keywordtype">int</span> iColumn,
<a name="l05713"></a>05713                       <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm, <span class="keywordtype">int</span> nTerm, <span class="keywordtype">int</span> isPrefix,
<a name="l05714"></a>05714                       <a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7b">DocListType</a> iType, <a class="code" href="structDataBuffer.html">DataBuffer</a> *out){
<a name="l05715"></a>05715   <a class="code" href="structDataBuffer.html">DataBuffer</a> doclist;
<a name="l05716"></a>05716   <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l05717"></a>05717   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a81b342bd8dbd7d6ef31c6e8357c12b89">SEGDIR_SELECT_ALL_STMT</a>, &amp;s);
<a name="l05718"></a>05718   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05719"></a>05719 
<a name="l05720"></a>05720   <span class="comment">/* This code should never be called with buffered updates. */</span>
<a name="l05721"></a>05721   assert( v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>&lt;0 );
<a name="l05722"></a>05722 
<a name="l05723"></a>05723   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;doclist, 0);
<a name="l05724"></a>05724 
<a name="l05725"></a>05725   <span class="comment">/* Traverse the segments from oldest to newest so that newer doclist</span>
<a name="l05726"></a>05726 <span class="comment">  ** elements for given docids overwrite older elements.</span>
<a name="l05727"></a>05727 <span class="comment">  */</span>
<a name="l05728"></a>05728   <span class="keywordflow">while</span>( (rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s))==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l05729"></a>05729     <span class="keyword">const</span> <span class="keywordtype">char</span> *pData = <a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(s, 2);
<a name="l05730"></a>05730     <span class="keyword">const</span> <span class="keywordtype">int</span> nData = <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(s, 2);
<a name="l05731"></a>05731     <span class="keyword">const</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iLeavesEnd = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 1);
<a name="l05732"></a>05732     rc = <a class="code" href="fts2_8c.html#a18c8b542f9f0f319792e6178c64c6543">loadSegment</a>(v, pData, nData, iLeavesEnd, pTerm, nTerm, isPrefix,
<a name="l05733"></a>05733                      &amp;doclist);
<a name="l05734"></a>05734     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l05735"></a>05735   }
<a name="l05736"></a>05736   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l05737"></a>05737     <span class="keywordflow">if</span>( doclist.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>!=0 ){
<a name="l05738"></a>05738       <span class="comment">/* TODO(shess) The old term_select_all() code applied the column</span>
<a name="l05739"></a>05739 <span class="comment">      ** restrict as we merged segments, leading to smaller buffers.</span>
<a name="l05740"></a>05740 <span class="comment">      ** This is probably worthwhile to bring back, once the new storage</span>
<a name="l05741"></a>05741 <span class="comment">      ** system is checked in.</span>
<a name="l05742"></a>05742 <span class="comment">      */</span>
<a name="l05743"></a>05743       <span class="keywordflow">if</span>( iColumn==v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>) iColumn = -1;
<a name="l05744"></a>05744       <a class="code" href="fts2_8c.html#a2b1eafafb5e270c5d938362c43da3e15">docListTrim</a>(<a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, doclist.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, doclist.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>,
<a name="l05745"></a>05745                   iColumn, iType, out);
<a name="l05746"></a>05746     }
<a name="l05747"></a>05747     rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05748"></a>05748   }
<a name="l05749"></a>05749 
<a name="l05750"></a>05750  err:
<a name="l05751"></a>05751   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;doclist);
<a name="l05752"></a>05752   <span class="keywordflow">return</span> rc;
<a name="l05753"></a>05753 }
<a name="l05754"></a>05754 
<a name="l05755"></a>05755 <span class="comment">/****************************************************************/</span>
<a name="l05756"></a>05756 <span class="comment">/* Used to hold hashtable data for sorting. */</span>
<a name="l05757"></a><a class="code" href="structTermData.html">05757</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structTermData.html">TermData</a> {
<a name="l05758"></a><a class="code" href="structTermData.html#a5e1b65f58146756e3a42dbe775380411">05758</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structTermData.html#a5e1b65f58146756e3a42dbe775380411">pTerm</a>;
<a name="l05759"></a><a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">05759</a>   <span class="keywordtype">int</span> <a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a>;
<a name="l05760"></a><a class="code" href="structTermData.html#a6a23f22df387bc05ee939d46032d0fb2">05760</a>   <a class="code" href="structDLCollector.html">DLCollector</a> *<a class="code" href="structTermData.html#a6a23f22df387bc05ee939d46032d0fb2">pCollector</a>;
<a name="l05761"></a>05761 } <a class="code" href="structTermData.html">TermData</a>;
<a name="l05762"></a>05762 
<a name="l05763"></a>05763 <span class="comment">/* Orders TermData elements in strcmp fashion ( &lt;0 for less-than, 0</span>
<a name="l05764"></a>05764 <span class="comment">** for equal, &gt;0 for greater-than).</span>
<a name="l05765"></a>05765 <span class="comment">*/</span>
<a name="l05766"></a><a class="code" href="fts2_8c.html#a73fa3de230c66dfe5996f389a1de7e0c">05766</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a73fa3de230c66dfe5996f389a1de7e0c">termDataCmp</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *av, <span class="keyword">const</span> <span class="keywordtype">void</span> *bv){
<a name="l05767"></a>05767   <span class="keyword">const</span> <a class="code" href="structTermData.html">TermData</a> *a = (<span class="keyword">const</span> <a class="code" href="structTermData.html">TermData</a> *)av;
<a name="l05768"></a>05768   <span class="keyword">const</span> <a class="code" href="structTermData.html">TermData</a> *b = (<span class="keyword">const</span> <a class="code" href="structTermData.html">TermData</a> *)bv;
<a name="l05769"></a>05769   <span class="keywordtype">int</span> n = a-&gt;<a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a>&lt;b-&gt;<a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a> ? a-&gt;<a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a> : b-&gt;<a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a>;
<a name="l05770"></a>05770   <span class="keywordtype">int</span> c = memcmp(a-&gt;<a class="code" href="structTermData.html#a5e1b65f58146756e3a42dbe775380411">pTerm</a>, b-&gt;<a class="code" href="structTermData.html#a5e1b65f58146756e3a42dbe775380411">pTerm</a>, n);
<a name="l05771"></a>05771   <span class="keywordflow">if</span>( c!=0 ) <span class="keywordflow">return</span> c;
<a name="l05772"></a>05772   <span class="keywordflow">return</span> a-&gt;<a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a>-b-&gt;<a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a>;
<a name="l05773"></a>05773 }
<a name="l05774"></a>05774 
<a name="l05775"></a>05775 <span class="comment">/* Order pTerms data by term, then write a new level 0 segment using</span>
<a name="l05776"></a>05776 <span class="comment">** LeafWriter.</span>
<a name="l05777"></a>05777 <span class="comment">*/</span>
<a name="l05778"></a><a class="code" href="fts2_8c.html#af636325137e336d34e1f80df9d29cc8e">05778</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#af636325137e336d34e1f80df9d29cc8e">writeZeroSegment</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structfts2Hash.html">fts2Hash</a> *pTerms){
<a name="l05779"></a>05779   <a class="code" href="structfts2HashElem.html">fts2HashElem</a> *e;
<a name="l05780"></a>05780   <span class="keywordtype">int</span> idx, rc, i, n;
<a name="l05781"></a>05781   <a class="code" href="structTermData.html">TermData</a> *pData;
<a name="l05782"></a>05782   <a class="code" href="structLeafWriter.html">LeafWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l05783"></a>05783   <a class="code" href="structDataBuffer.html">DataBuffer</a> dl;
<a name="l05784"></a>05784 
<a name="l05785"></a>05785   <span class="comment">/* Determine the next index at level 0, merging as necessary. */</span>
<a name="l05786"></a>05786   rc = <a class="code" href="fts2_8c.html#abf2af74d861514ae1481ff4f176e6771">segdirNextIndex</a>(v, 0, &amp;idx);
<a name="l05787"></a>05787   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05788"></a>05788 
<a name="l05789"></a>05789   n = <a class="code" href="fts2__hash_8h.html#a3b294f028b00dd4a01a8d5215db2f452">fts2HashCount</a>(pTerms);
<a name="l05790"></a>05790   pData = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(n*<span class="keyword">sizeof</span>(<a class="code" href="structTermData.html">TermData</a>));
<a name="l05791"></a>05791 
<a name="l05792"></a>05792   <span class="keywordflow">for</span>(i = 0, e = <a class="code" href="fts2__hash_8h.html#ac47206d032f149dcae50c48bd5925b90">fts2HashFirst</a>(pTerms); e; i++, e = <a class="code" href="fts2__hash_8h.html#aeea646b638ec4170a2d66b5cc1be24fe">fts2HashNext</a>(e)){
<a name="l05793"></a>05793     assert( i&lt;n );
<a name="l05794"></a>05794     pData[i].<a class="code" href="structTermData.html#a5e1b65f58146756e3a42dbe775380411">pTerm</a> = <a class="code" href="fts2__hash_8h.html#aea07b5040fb15dda61e981e5862a2442">fts2HashKey</a>(e);
<a name="l05795"></a>05795     pData[i].<a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a> = <a class="code" href="fts2__hash_8h.html#a39e5381b1ee44765a17451320c7c760f">fts2HashKeysize</a>(e);
<a name="l05796"></a>05796     pData[i].<a class="code" href="structTermData.html#a6a23f22df387bc05ee939d46032d0fb2">pCollector</a> = <a class="code" href="fts2__hash_8h.html#a5a5c378c8faddd4ec893b3f42683837b">fts2HashData</a>(e);
<a name="l05797"></a>05797   }
<a name="l05798"></a>05798   assert( i==n );
<a name="l05799"></a>05799 
<a name="l05800"></a>05800   <span class="comment">/* TODO(shess) Should we allow user-defined collation sequences,</span>
<a name="l05801"></a>05801 <span class="comment">  ** here?  I think we only need that once we support prefix searches.</span>
<a name="l05802"></a>05802 <span class="comment">  */</span>
<a name="l05803"></a>05803   <span class="keywordflow">if</span>( n&gt;1 ) qsort(pData, n, <span class="keyword">sizeof</span>(*pData), <a class="code" href="fts2_8c.html#a73fa3de230c66dfe5996f389a1de7e0c">termDataCmp</a>);
<a name="l05804"></a>05804 
<a name="l05805"></a>05805   <span class="comment">/* TODO(shess) Refactor so that we can write directly to the segment</span>
<a name="l05806"></a>05806 <span class="comment">  ** DataBuffer, as happens for segment merges.</span>
<a name="l05807"></a>05807 <span class="comment">  */</span>
<a name="l05808"></a>05808   <a class="code" href="fts2_8c.html#a86612bb723ea03d3cf9cee54b300e8d8">leafWriterInit</a>(0, idx, &amp;writer);
<a name="l05809"></a>05809   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;dl, 0);
<a name="l05810"></a>05810   <span class="keywordflow">for</span>(i=0; i&lt;n; i++){
<a name="l05811"></a>05811     <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(&amp;dl);
<a name="l05812"></a>05812     <a class="code" href="fts2_8c.html#a205a5a118cd3fd98dee5ba95a666a6cb">dlcAddDoclist</a>(pData[i].pCollector, &amp;dl);
<a name="l05813"></a>05813     rc = <a class="code" href="fts2_8c.html#a869165e5ff35ff1e763028a045db0236">leafWriterStep</a>(v, &amp;writer,
<a name="l05814"></a>05814                         pData[i].pTerm, pData[i].nTerm, dl.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, dl.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l05815"></a>05815     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l05816"></a>05816   }
<a name="l05817"></a>05817   rc = <a class="code" href="fts2_8c.html#a20a5c7ef17056f24bd37097afd4fe67b">leafWriterFinalize</a>(v, &amp;writer);
<a name="l05818"></a>05818 
<a name="l05819"></a>05819  err:
<a name="l05820"></a>05820   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;dl);
<a name="l05821"></a>05821   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pData);
<a name="l05822"></a>05822   <a class="code" href="fts2_8c.html#a2a86036daf4b9e95f8c4e7105bc8e035">leafWriterDestroy</a>(&amp;writer);
<a name="l05823"></a>05823   <span class="keywordflow">return</span> rc;
<a name="l05824"></a>05824 }
<a name="l05825"></a>05825 
<a name="l05826"></a>05826 <span class="comment">/* If pendingTerms has data, free it. */</span>
<a name="l05827"></a><a class="code" href="fts2_8c.html#a6e35ee9ad89ff36849eee74a55a0cc65">05827</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a6e35ee9ad89ff36849eee74a55a0cc65">clearPendingTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l05828"></a>05828   <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>&gt;=0 ){
<a name="l05829"></a>05829     <a class="code" href="structfts2HashElem.html">fts2HashElem</a> *e;
<a name="l05830"></a>05830     <span class="keywordflow">for</span>(e=<a class="code" href="fts2__hash_8h.html#ac47206d032f149dcae50c48bd5925b90">fts2HashFirst</a>(&amp;v-&gt;<a class="code" href="structfulltext__vtab.html#af7cc40710088b48f62de7c47e5e822c2">pendingTerms</a>); e; e=<a class="code" href="fts2__hash_8h.html#aeea646b638ec4170a2d66b5cc1be24fe">fts2HashNext</a>(e)){
<a name="l05831"></a>05831       <a class="code" href="fts2_8c.html#aacb9c17923676be8a13c887bdcdcf18a">dlcDelete</a>(<a class="code" href="fts2__hash_8h.html#a5a5c378c8faddd4ec893b3f42683837b">fts2HashData</a>(e));
<a name="l05832"></a>05832     }
<a name="l05833"></a>05833     <a class="code" href="fts2__hash_8h.html#a300397d501f7238b4a4e237294e45f88">fts2HashClear</a>(&amp;v-&gt;<a class="code" href="structfulltext__vtab.html#af7cc40710088b48f62de7c47e5e822c2">pendingTerms</a>);
<a name="l05834"></a>05834     v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a> = -1;
<a name="l05835"></a>05835   }
<a name="l05836"></a>05836   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05837"></a>05837 }
<a name="l05838"></a>05838 
<a name="l05839"></a>05839 <span class="comment">/* If pendingTerms has data, flush it to a level-zero segment, and</span>
<a name="l05840"></a>05840 <span class="comment">** free it.</span>
<a name="l05841"></a>05841 <span class="comment">*/</span>
<a name="l05842"></a><a class="code" href="fts2_8c.html#a7562cdf287e12b6322a65b44f508d177">05842</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a7562cdf287e12b6322a65b44f508d177">flushPendingTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v){
<a name="l05843"></a>05843   <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>&gt;=0 ){
<a name="l05844"></a>05844     <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#af636325137e336d34e1f80df9d29cc8e">writeZeroSegment</a>(v, &amp;v-&gt;<a class="code" href="structfulltext__vtab.html#af7cc40710088b48f62de7c47e5e822c2">pendingTerms</a>);
<a name="l05845"></a>05845     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <a class="code" href="fts2_8c.html#a6e35ee9ad89ff36849eee74a55a0cc65">clearPendingTerms</a>(v);
<a name="l05846"></a>05846     <span class="keywordflow">return</span> rc;
<a name="l05847"></a>05847   }
<a name="l05848"></a>05848   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05849"></a>05849 }
<a name="l05850"></a>05850 
<a name="l05851"></a>05851 <span class="comment">/* If pendingTerms is &quot;too big&quot;, or docid is out of order, flush it.</span>
<a name="l05852"></a>05852 <span class="comment">** Regardless, be certain that pendingTerms is initialized for use.</span>
<a name="l05853"></a>05853 <span class="comment">*/</span>
<a name="l05854"></a><a class="code" href="fts2_8c.html#a96fe0e65990eb6b52b5e04d37a6afa0c">05854</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a96fe0e65990eb6b52b5e04d37a6afa0c">initPendingTerms</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iDocid){
<a name="l05855"></a>05855   <span class="comment">/* TODO(shess) Explore whether partially flushing the buffer on</span>
<a name="l05856"></a>05856 <span class="comment">  ** forced-flush would provide better performance.  I suspect that if</span>
<a name="l05857"></a>05857 <span class="comment">  ** we ordered the doclists by size and flushed the largest until the</span>
<a name="l05858"></a>05858 <span class="comment">  ** buffer was half empty, that would let the less frequent terms</span>
<a name="l05859"></a>05859 <span class="comment">  ** generate longer doclists.</span>
<a name="l05860"></a>05860 <span class="comment">  */</span>
<a name="l05861"></a>05861   <span class="keywordflow">if</span>( iDocid&lt;=v-&gt;iPrevDocid || v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>&gt;<a class="code" href="fts2_8c.html#a27c3c050492b57112b6f6d4dd7bf1120">kPendingThreshold</a> ){
<a name="l05862"></a>05862     <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a7562cdf287e12b6322a65b44f508d177">flushPendingTerms</a>(v);
<a name="l05863"></a>05863     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l05864"></a>05864   }
<a name="l05865"></a>05865   <span class="keywordflow">if</span>( v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>&lt;0 ){
<a name="l05866"></a>05866     <a class="code" href="fts2__hash_8h.html#a4c39e59154be8f3cb30d0b608ae0e9c8">fts2HashInit</a>(&amp;v-&gt;<a class="code" href="structfulltext__vtab.html#af7cc40710088b48f62de7c47e5e822c2">pendingTerms</a>, <a class="code" href="fts2__hash_8h.html#a32d375e016bc4f8e368ca7a8a2bff48b">FTS2_HASH_STRING</a>, 1);
<a name="l05867"></a>05867     v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a> = 0;
<a name="l05868"></a>05868   }
<a name="l05869"></a>05869   v-&gt;<a class="code" href="structfulltext__vtab.html#ac2af915a8f5f2957c8f73e4419d0bbee">iPrevDocid</a> = iDocid;
<a name="l05870"></a>05870   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05871"></a>05871 }
<a name="l05872"></a>05872 
<a name="l05873"></a>05873 <span class="comment">/* This function implements the xUpdate callback; it is the top-level entry</span>
<a name="l05874"></a>05874 <span class="comment"> * point for inserting, deleting or updating a row in a full-text table. */</span>
<a name="l05875"></a><a class="code" href="fts2_8c.html#a8e291fd12023cffe80976a33530e839d">05875</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a8e291fd12023cffe80976a33530e839d">fulltextUpdate</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab, <span class="keywordtype">int</span> nArg, <a class="code" href="structMem.html">sqlite3_value</a> **ppArg,
<a name="l05876"></a>05876                    <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> *pRowid){
<a name="l05877"></a>05877   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *) pVtab;
<a name="l05878"></a>05878   <span class="keywordtype">int</span> rc;
<a name="l05879"></a>05879 
<a name="l05880"></a>05880   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 Update %p\n&quot;</span>, pVtab));
<a name="l05881"></a>05881 
<a name="l05882"></a>05882   <span class="keywordflow">if</span>( nArg&lt;2 ){
<a name="l05883"></a>05883     rc = <a class="code" href="fts2_8c.html#a5300d96128a51a0d12276a77aa5ed6c3">index_delete</a>(v, <a class="code" href="sqlite3_8h.html#a8e6a9f5cda11dec1ca742f58695feded">sqlite3_value_int64</a>(ppArg[0]));
<a name="l05884"></a>05884     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05885"></a>05885       <span class="comment">/* If we just deleted the last row in the table, clear out the</span>
<a name="l05886"></a>05886 <span class="comment">      ** index data.</span>
<a name="l05887"></a>05887 <span class="comment">      */</span>
<a name="l05888"></a>05888       rc = <a class="code" href="fts2_8c.html#a151618fa123f92b062b1a98a6ebeefac">content_exists</a>(v);
<a name="l05889"></a>05889       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l05890"></a>05890         rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05891"></a>05891       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l05892"></a>05892         <span class="comment">/* Clear the pending terms so we don&apos;t flush a useless level-0</span>
<a name="l05893"></a>05893 <span class="comment">        ** segment when the transaction closes.</span>
<a name="l05894"></a>05894 <span class="comment">        */</span>
<a name="l05895"></a>05895         rc = <a class="code" href="fts2_8c.html#a6e35ee9ad89ff36849eee74a55a0cc65">clearPendingTerms</a>(v);
<a name="l05896"></a>05896         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05897"></a>05897           rc = <a class="code" href="fts2_8c.html#a96b31172512ccbfbdf69e7bd70419ae2">segdir_delete_all</a>(v);
<a name="l05898"></a>05898         }
<a name="l05899"></a>05899       }
<a name="l05900"></a>05900     }
<a name="l05901"></a>05901   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(ppArg[0]) != <a class="code" href="sqlite3_8h.html#afd180931f2d06d6c245791d187da5802">SQLITE_NULL</a> ){
<a name="l05902"></a>05902     <span class="comment">/* An update:</span>
<a name="l05903"></a>05903 <span class="comment">     * ppArg[0] = old rowid</span>
<a name="l05904"></a>05904 <span class="comment">     * ppArg[1] = new rowid</span>
<a name="l05905"></a>05905 <span class="comment">     * ppArg[2..2+v-&gt;nColumn-1] = values</span>
<a name="l05906"></a>05906 <span class="comment">     * ppArg[2+v-&gt;nColumn] = value for magic column (we ignore this)</span>
<a name="l05907"></a>05907 <span class="comment">     */</span>
<a name="l05908"></a>05908     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> rowid = <a class="code" href="sqlite3_8h.html#a8e6a9f5cda11dec1ca742f58695feded">sqlite3_value_int64</a>(ppArg[0]);
<a name="l05909"></a>05909     <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(ppArg[1]) != <a class="code" href="sqlite3_8h.html#a7453d71905f10fa330940428f8abe21c">SQLITE_INTEGER</a> ||
<a name="l05910"></a>05910       <a class="code" href="sqlite3_8h.html#a8e6a9f5cda11dec1ca742f58695feded">sqlite3_value_int64</a>(ppArg[1]) != rowid ){
<a name="l05911"></a>05911       rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;  <span class="comment">/* we don&apos;t allow changing the rowid */</span>
<a name="l05912"></a>05912     } <span class="keywordflow">else</span> {
<a name="l05913"></a>05913       assert( nArg==2+v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>+1);
<a name="l05914"></a>05914       rc = <a class="code" href="fts2_8c.html#a1c5901acdbbe05610122c85efae88dac">index_update</a>(v, rowid, &amp;ppArg[2]);
<a name="l05915"></a>05915     }
<a name="l05916"></a>05916   } <span class="keywordflow">else</span> {
<a name="l05917"></a>05917     <span class="comment">/* An insert:</span>
<a name="l05918"></a>05918 <span class="comment">     * ppArg[1] = requested rowid</span>
<a name="l05919"></a>05919 <span class="comment">     * ppArg[2..2+v-&gt;nColumn-1] = values</span>
<a name="l05920"></a>05920 <span class="comment">     * ppArg[2+v-&gt;nColumn] = value for magic column (we ignore this)</span>
<a name="l05921"></a>05921 <span class="comment">     */</span>
<a name="l05922"></a>05922     assert( nArg==2+v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>+1);
<a name="l05923"></a>05923     rc = <a class="code" href="fts2_8c.html#ae17acbf0f2d7fa5f24b2b522fab1b578">index_insert</a>(v, ppArg[1], &amp;ppArg[2], pRowid);
<a name="l05924"></a>05924   }
<a name="l05925"></a>05925 
<a name="l05926"></a>05926   <span class="keywordflow">return</span> rc;
<a name="l05927"></a>05927 }
<a name="l05928"></a>05928 
<a name="l05929"></a><a class="code" href="fts2_8c.html#ae5aa5c271805b6239b93f217a15ad527">05929</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ae5aa5c271805b6239b93f217a15ad527">fulltextSync</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab){
<a name="l05930"></a>05930   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 xSync()\n&quot;</span>));
<a name="l05931"></a>05931   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a7562cdf287e12b6322a65b44f508d177">flushPendingTerms</a>((<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVtab);
<a name="l05932"></a>05932 }
<a name="l05933"></a>05933 
<a name="l05934"></a><a class="code" href="fts2_8c.html#af3886601e4f6c64a5db1ba163ac3acdb">05934</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#af3886601e4f6c64a5db1ba163ac3acdb">fulltextBegin</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab){
<a name="l05935"></a>05935   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *) pVtab;
<a name="l05936"></a>05936   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 xBegin()\n&quot;</span>));
<a name="l05937"></a>05937 
<a name="l05938"></a>05938   <span class="comment">/* Any buffered updates should have been cleared by the previous</span>
<a name="l05939"></a>05939 <span class="comment">  ** transaction.</span>
<a name="l05940"></a>05940 <span class="comment">  */</span>
<a name="l05941"></a>05941   assert( v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>&lt;0 );
<a name="l05942"></a>05942   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a6e35ee9ad89ff36849eee74a55a0cc65">clearPendingTerms</a>(v);
<a name="l05943"></a>05943 }
<a name="l05944"></a>05944 
<a name="l05945"></a><a class="code" href="fts2_8c.html#a690130dfc7a5ce5f50554fee442598f3">05945</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a690130dfc7a5ce5f50554fee442598f3">fulltextCommit</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab){
<a name="l05946"></a>05946   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *) pVtab;
<a name="l05947"></a>05947   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 xCommit()\n&quot;</span>));
<a name="l05948"></a>05948 
<a name="l05949"></a>05949   <span class="comment">/* Buffered updates should have been cleared by fulltextSync(). */</span>
<a name="l05950"></a>05950   assert( v-&gt;<a class="code" href="structfulltext__vtab.html#a83724e0f9b715a9b4f2976a86e2a3966">nPendingData</a>&lt;0 );
<a name="l05951"></a>05951   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a6e35ee9ad89ff36849eee74a55a0cc65">clearPendingTerms</a>(v);
<a name="l05952"></a>05952 }
<a name="l05953"></a>05953 
<a name="l05954"></a><a class="code" href="fts2_8c.html#a1471cac8645cdd390f8a36774a4c91bf">05954</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a1471cac8645cdd390f8a36774a4c91bf">fulltextRollback</a>(<a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab){
<a name="l05955"></a>05955   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FTS2 xRollback()\n&quot;</span>));
<a name="l05956"></a>05956   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a6e35ee9ad89ff36849eee74a55a0cc65">clearPendingTerms</a>((<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVtab);
<a name="l05957"></a>05957 }
<a name="l05958"></a>05958 
<a name="l05959"></a>05959 <span class="comment">/*</span>
<a name="l05960"></a>05960 <span class="comment">** Implementation of the snippet() function for FTS2</span>
<a name="l05961"></a>05961 <span class="comment">*/</span>
<a name="l05962"></a><a class="code" href="fts2_8c.html#a57b1d2e6eb52243a8c4a2a32f238dc03">05962</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a57b1d2e6eb52243a8c4a2a32f238dc03">snippetFunc</a>(
<a name="l05963"></a>05963   <a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext,
<a name="l05964"></a>05964   <span class="keywordtype">int</span> argc,
<a name="l05965"></a>05965   <a class="code" href="structMem.html">sqlite3_value</a> **argv
<a name="l05966"></a>05966 ){
<a name="l05967"></a>05967   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *pCursor;
<a name="l05968"></a>05968   <span class="keywordflow">if</span>( argc&lt;1 ) <span class="keywordflow">return</span>;
<a name="l05969"></a>05969   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(argv[0])!=<a class="code" href="sqlite3_8h.html#a26c29a137b2a35bbde7048e5e48b794a">SQLITE_BLOB</a> ||
<a name="l05970"></a>05970       <a class="code" href="sqlite3_8h.html#a2aff2bf1311b5bd05d8e30738445b186">sqlite3_value_bytes</a>(argv[0])!=<span class="keyword">sizeof</span>(pCursor) ){
<a name="l05971"></a>05971     <a class="code" href="sqlite3_8h.html#a02826d87e45fd4f04445a3c99a14b54e">sqlite3_result_error</a>(pContext, <span class="stringliteral">&quot;illegal first argument to html_snippet&quot;</span>,-1);
<a name="l05972"></a>05972   }<span class="keywordflow">else</span>{
<a name="l05973"></a>05973     <span class="keyword">const</span> <span class="keywordtype">char</span> *zStart = <span class="stringliteral">&quot;&lt;b&gt;&quot;</span>;
<a name="l05974"></a>05974     <span class="keyword">const</span> <span class="keywordtype">char</span> *zEnd = <span class="stringliteral">&quot;&lt;/b&gt;&quot;</span>;
<a name="l05975"></a>05975     <span class="keyword">const</span> <span class="keywordtype">char</span> *zEllipsis = <span class="stringliteral">&quot;&lt;b&gt;...&lt;/b&gt;&quot;</span>;
<a name="l05976"></a>05976     memcpy(&amp;pCursor, <a class="code" href="sqlite3_8h.html#a81138be97f3e5124e33fb50925b710b6">sqlite3_value_blob</a>(argv[0]), <span class="keyword">sizeof</span>(pCursor));
<a name="l05977"></a>05977     <span class="keywordflow">if</span>( argc&gt;=2 ){
<a name="l05978"></a>05978       zStart = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[1]);
<a name="l05979"></a>05979       <span class="keywordflow">if</span>( argc&gt;=3 ){
<a name="l05980"></a>05980         zEnd = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[2]);
<a name="l05981"></a>05981         <span class="keywordflow">if</span>( argc&gt;=4 ){
<a name="l05982"></a>05982           zEllipsis = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[3]);
<a name="l05983"></a>05983         }
<a name="l05984"></a>05984       }
<a name="l05985"></a>05985     }
<a name="l05986"></a>05986     <a class="code" href="fts2_8c.html#a59f88d7e78ca82c2ded0ad6d0dc761cf">snippetAllOffsets</a>(pCursor);
<a name="l05987"></a>05987     <a class="code" href="fts2_8c.html#a27d12dfb6aab92e44fc0af3dc2a72ad7">snippetText</a>(pCursor, zStart, zEnd, zEllipsis);
<a name="l05988"></a>05988     <a class="code" href="sqlite3_8h.html#a2dfd2d971e743b8d5a24725606a733ac">sqlite3_result_text</a>(pContext, pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#ae4b3f8a21cfc04fd41e664d75f59d760">zSnippet</a>,
<a name="l05989"></a>05989                         pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a467392bb026bc056ab7c5466873f8f11">nSnippet</a>, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l05990"></a>05990   }
<a name="l05991"></a>05991 }
<a name="l05992"></a>05992 
<a name="l05993"></a>05993 <span class="comment">/*</span>
<a name="l05994"></a>05994 <span class="comment">** Implementation of the offsets() function for FTS2</span>
<a name="l05995"></a>05995 <span class="comment">*/</span>
<a name="l05996"></a><a class="code" href="fts2_8c.html#a3f6879fa82ea5cee0633e4f0c2acb89e">05996</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a3f6879fa82ea5cee0633e4f0c2acb89e">snippetOffsetsFunc</a>(
<a name="l05997"></a>05997   <a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext,
<a name="l05998"></a>05998   <span class="keywordtype">int</span> argc,
<a name="l05999"></a>05999   <a class="code" href="structMem.html">sqlite3_value</a> **argv
<a name="l06000"></a>06000 ){
<a name="l06001"></a>06001   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *pCursor;
<a name="l06002"></a>06002   <span class="keywordflow">if</span>( argc&lt;1 ) <span class="keywordflow">return</span>;
<a name="l06003"></a>06003   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(argv[0])!=<a class="code" href="sqlite3_8h.html#a26c29a137b2a35bbde7048e5e48b794a">SQLITE_BLOB</a> ||
<a name="l06004"></a>06004       <a class="code" href="sqlite3_8h.html#a2aff2bf1311b5bd05d8e30738445b186">sqlite3_value_bytes</a>(argv[0])!=<span class="keyword">sizeof</span>(pCursor) ){
<a name="l06005"></a>06005     <a class="code" href="sqlite3_8h.html#a02826d87e45fd4f04445a3c99a14b54e">sqlite3_result_error</a>(pContext, <span class="stringliteral">&quot;illegal first argument to offsets&quot;</span>,-1);
<a name="l06006"></a>06006   }<span class="keywordflow">else</span>{
<a name="l06007"></a>06007     memcpy(&amp;pCursor, <a class="code" href="sqlite3_8h.html#a81138be97f3e5124e33fb50925b710b6">sqlite3_value_blob</a>(argv[0]), <span class="keyword">sizeof</span>(pCursor));
<a name="l06008"></a>06008     <a class="code" href="fts2_8c.html#a59f88d7e78ca82c2ded0ad6d0dc761cf">snippetAllOffsets</a>(pCursor);
<a name="l06009"></a>06009     <a class="code" href="fts2_8c.html#a0be87d3def9290916cff3b6cb84f04bc">snippetOffsetText</a>(&amp;pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>);
<a name="l06010"></a>06010     <a class="code" href="sqlite3_8h.html#a2dfd2d971e743b8d5a24725606a733ac">sqlite3_result_text</a>(pContext,
<a name="l06011"></a>06011                         pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a6bf46467ec9f663dd550222069e9ddbf">zOffset</a>, pCursor-&gt;<a class="code" href="structfulltext__cursor.html#afcbd37f2f0712df2bd5fc2201688089e">snippet</a>.<a class="code" href="structSnippet.html#a68aacd704960f6ab1c8f7de23a5d0730">nOffset</a>,
<a name="l06012"></a>06012                         <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l06013"></a>06013   }
<a name="l06014"></a>06014 }
<a name="l06015"></a>06015 
<a name="l06016"></a>06016 <span class="comment">/* OptLeavesReader is nearly identical to LeavesReader, except that</span>
<a name="l06017"></a>06017 <span class="comment">** where LeavesReader is geared towards the merging of complete</span>
<a name="l06018"></a>06018 <span class="comment">** segment levels (with exactly MERGE_COUNT segments), OptLeavesReader</span>
<a name="l06019"></a>06019 <span class="comment">** is geared towards implementation of the optimize() function, and</span>
<a name="l06020"></a>06020 <span class="comment">** can merge all segments simultaneously.  This version may be</span>
<a name="l06021"></a>06021 <span class="comment">** somewhat less efficient than LeavesReader because it merges into an</span>
<a name="l06022"></a>06022 <span class="comment">** accumulator rather than doing an N-way merge, but since segment</span>
<a name="l06023"></a>06023 <span class="comment">** size grows exponentially (so segment count logrithmically) this is</span>
<a name="l06024"></a>06024 <span class="comment">** probably not an immediate problem.</span>
<a name="l06025"></a>06025 <span class="comment">*/</span>
<a name="l06026"></a>06026 <span class="comment">/* TODO(shess): Prove that assertion, or extend the merge code to</span>
<a name="l06027"></a>06027 <span class="comment">** merge tree fashion (like the prefix-searching code does).</span>
<a name="l06028"></a>06028 <span class="comment">*/</span>
<a name="l06029"></a>06029 <span class="comment">/* TODO(shess): OptLeavesReader and LeavesReader could probably be</span>
<a name="l06030"></a>06030 <span class="comment">** merged with little or no loss of performance for LeavesReader.  The</span>
<a name="l06031"></a>06031 <span class="comment">** merged code would need to handle &gt;MERGE_COUNT segments, and would</span>
<a name="l06032"></a>06032 <span class="comment">** also need to be able to optionally optimize away deletes.</span>
<a name="l06033"></a>06033 <span class="comment">*/</span>
<a name="l06034"></a><a class="code" href="structOptLeavesReader.html">06034</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> {
<a name="l06035"></a>06035   <span class="comment">/* Segment number, to order readers by age. */</span>
<a name="l06036"></a><a class="code" href="structOptLeavesReader.html#a0b11ecc3978d1318f3aebf20649e79fa">06036</a>   <span class="keywordtype">int</span> <a class="code" href="structOptLeavesReader.html#a0b11ecc3978d1318f3aebf20649e79fa">segment</a>;
<a name="l06037"></a><a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">06037</a>   <a class="code" href="structLeavesReader.html">LeavesReader</a> <a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">reader</a>;
<a name="l06038"></a>06038 } <a class="code" href="structOptLeavesReader.html">OptLeavesReader</a>;
<a name="l06039"></a>06039 
<a name="l06040"></a><a class="code" href="fts2_8c.html#a3ac3c81062a830df91ee18f9ef138852">06040</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a3ac3c81062a830df91ee18f9ef138852">optLeavesReaderAtEnd</a>(<a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *pReader){
<a name="l06041"></a>06041   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(&amp;pReader-&gt;<a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">reader</a>);
<a name="l06042"></a>06042 }
<a name="l06043"></a><a class="code" href="fts2_8c.html#a5eb9cbed91fffb20782e1528e3c108e4">06043</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a5eb9cbed91fffb20782e1528e3c108e4">optLeavesReaderTermBytes</a>(<a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *pReader){
<a name="l06044"></a>06044   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#ab1b844350e43ffea25791355eff5fe6d">leavesReaderTermBytes</a>(&amp;pReader-&gt;<a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">reader</a>);
<a name="l06045"></a>06045 }
<a name="l06046"></a><a class="code" href="fts2_8c.html#a2cacf604820439b4b3a7697bf0f83113">06046</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a2cacf604820439b4b3a7697bf0f83113">optLeavesReaderData</a>(<a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *pReader){
<a name="l06047"></a>06047   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a80da0054c63cf95a7ba519c023094244">leavesReaderData</a>(&amp;pReader-&gt;<a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">reader</a>);
<a name="l06048"></a>06048 }
<a name="l06049"></a><a class="code" href="fts2_8c.html#aa570029c58788cd468b52ed660565fbf">06049</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aa570029c58788cd468b52ed660565fbf">optLeavesReaderDataBytes</a>(<a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *pReader){
<a name="l06050"></a>06050   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a54bac53899528f039168ab9eb55ae866">leavesReaderDataBytes</a>(&amp;pReader-&gt;<a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">reader</a>);
<a name="l06051"></a>06051 }
<a name="l06052"></a><a class="code" href="fts2_8c.html#a450696f13a34eb5faab493883a46fd33">06052</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="fts2_8c.html#a450696f13a34eb5faab493883a46fd33">optLeavesReaderTerm</a>(<a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *pReader){
<a name="l06053"></a>06053   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#aeb47709b8fd707f2705051ccd9f95ea2">leavesReaderTerm</a>(&amp;pReader-&gt;<a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">reader</a>);
<a name="l06054"></a>06054 }
<a name="l06055"></a><a class="code" href="fts2_8c.html#ad4ede602f423f38e4f6c483c57050ffa">06055</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#ad4ede602f423f38e4f6c483c57050ffa">optLeavesReaderStep</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *pReader){
<a name="l06056"></a>06056   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a0cba191ae8402798782d84a133bbccd8">leavesReaderStep</a>(v, &amp;pReader-&gt;<a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">reader</a>);
<a name="l06057"></a>06057 }
<a name="l06058"></a><a class="code" href="fts2_8c.html#af2e899d6bbc1470992680dc876de62eb">06058</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#af2e899d6bbc1470992680dc876de62eb">optLeavesReaderTermCmp</a>(<a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *lr1, <a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *lr2){
<a name="l06059"></a>06059   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#a5a7698146081534829ccc62636a39764">leavesReaderTermCmp</a>(&amp;lr1-&gt;<a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">reader</a>, &amp;lr2-&gt;<a class="code" href="structOptLeavesReader.html#a0920cae7a32a78449ba9936b7bb5adec">reader</a>);
<a name="l06060"></a>06060 }
<a name="l06061"></a>06061 <span class="comment">/* Order by term ascending, segment ascending (oldest to newest), with</span>
<a name="l06062"></a>06062 <span class="comment">** exhausted readers to the end.</span>
<a name="l06063"></a>06063 <span class="comment">*/</span>
<a name="l06064"></a><a class="code" href="fts2_8c.html#a50c769976a5d518ab127144f7ebe7cb6">06064</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a50c769976a5d518ab127144f7ebe7cb6">optLeavesReaderCmp</a>(<a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *lr1, <a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *lr2){
<a name="l06065"></a>06065   <span class="keywordtype">int</span> c = <a class="code" href="fts2_8c.html#af2e899d6bbc1470992680dc876de62eb">optLeavesReaderTermCmp</a>(lr1, lr2);
<a name="l06066"></a>06066   <span class="keywordflow">if</span>( c!=0 ) <span class="keywordflow">return</span> c;
<a name="l06067"></a>06067   <span class="keywordflow">return</span> lr1-&gt;<a class="code" href="structOptLeavesReader.html#a0b11ecc3978d1318f3aebf20649e79fa">segment</a>-lr2-&gt;<a class="code" href="structOptLeavesReader.html#a0b11ecc3978d1318f3aebf20649e79fa">segment</a>;
<a name="l06068"></a>06068 }
<a name="l06069"></a>06069 <span class="comment">/* Bubble pLr[0] to appropriate place in pLr[1..nLr-1].  Assumes that</span>
<a name="l06070"></a>06070 <span class="comment">** pLr[1..nLr-1] is already sorted.</span>
<a name="l06071"></a>06071 <span class="comment">*/</span>
<a name="l06072"></a><a class="code" href="fts2_8c.html#a0b986fb12866b75e1c9db0b481c55a47">06072</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a0b986fb12866b75e1c9db0b481c55a47">optLeavesReaderReorder</a>(<a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *pLr, <span class="keywordtype">int</span> nLr){
<a name="l06073"></a>06073   <span class="keywordflow">while</span>( nLr&gt;1 &amp;&amp; <a class="code" href="fts2_8c.html#a50c769976a5d518ab127144f7ebe7cb6">optLeavesReaderCmp</a>(pLr, pLr+1)&gt;0 ){
<a name="l06074"></a>06074     <a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> tmp = pLr[0];
<a name="l06075"></a>06075     pLr[0] = pLr[1];
<a name="l06076"></a>06076     pLr[1] = tmp;
<a name="l06077"></a>06077     nLr--;
<a name="l06078"></a>06078     pLr++;
<a name="l06079"></a>06079   }
<a name="l06080"></a>06080 }
<a name="l06081"></a>06081 
<a name="l06082"></a>06082 <span class="comment">/* optimize() helper function.  Put the readers in order and iterate</span>
<a name="l06083"></a>06083 <span class="comment">** through them, merging doclists for matching terms into pWriter.</span>
<a name="l06084"></a>06084 <span class="comment">** Returns SQLITE_OK on success, or the SQLite error code which</span>
<a name="l06085"></a>06085 <span class="comment">** prevented success.</span>
<a name="l06086"></a>06086 <span class="comment">*/</span>
<a name="l06087"></a><a class="code" href="fts2_8c.html#aabfd3d844aae1591704d4e540e0ef899">06087</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#aabfd3d844aae1591704d4e540e0ef899">optimizeInternal</a>(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v,
<a name="l06088"></a>06088                             <a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *readers, <span class="keywordtype">int</span> nReaders,
<a name="l06089"></a>06089                             <a class="code" href="structLeafWriter.html">LeafWriter</a> *pWriter){
<a name="l06090"></a>06090   <span class="keywordtype">int</span> i, rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l06091"></a>06091   <a class="code" href="structDataBuffer.html">DataBuffer</a> doclist, merged, tmp;
<a name="l06092"></a>06092 
<a name="l06093"></a>06093   <span class="comment">/* Order the readers. */</span>
<a name="l06094"></a>06094   i = nReaders;
<a name="l06095"></a>06095   <span class="keywordflow">while</span>( i-- &gt; 0 ){
<a name="l06096"></a>06096     <a class="code" href="fts2_8c.html#a0b986fb12866b75e1c9db0b481c55a47">optLeavesReaderReorder</a>(&amp;readers[i], nReaders-i);
<a name="l06097"></a>06097   }
<a name="l06098"></a>06098 
<a name="l06099"></a>06099   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;doclist, <a class="code" href="fts2_8c.html#a3b0ee26d7e03f91390592ac852e33369">LEAF_MAX</a>);
<a name="l06100"></a>06100   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;merged, <a class="code" href="fts2_8c.html#a3b0ee26d7e03f91390592ac852e33369">LEAF_MAX</a>);
<a name="l06101"></a>06101 
<a name="l06102"></a>06102   <span class="comment">/* Exhausted readers bubble to the end, so when the first reader is</span>
<a name="l06103"></a>06103 <span class="comment">  ** at eof, all are at eof.</span>
<a name="l06104"></a>06104 <span class="comment">  */</span>
<a name="l06105"></a>06105   <span class="keywordflow">while</span>( !<a class="code" href="fts2_8c.html#a3ac3c81062a830df91ee18f9ef138852">optLeavesReaderAtEnd</a>(&amp;readers[0]) ){
<a name="l06106"></a>06106 
<a name="l06107"></a>06107     <span class="comment">/* Figure out how many readers share the next term. */</span>
<a name="l06108"></a>06108     <span class="keywordflow">for</span>(i=1; i&lt;nReaders &amp;&amp; !<a class="code" href="fts2_8c.html#a3ac3c81062a830df91ee18f9ef138852">optLeavesReaderAtEnd</a>(&amp;readers[i]); i++){
<a name="l06109"></a>06109       <span class="keywordflow">if</span>( 0!=<a class="code" href="fts2_8c.html#af2e899d6bbc1470992680dc876de62eb">optLeavesReaderTermCmp</a>(&amp;readers[0], &amp;readers[i]) ) <span class="keywordflow">break</span>;
<a name="l06110"></a>06110     }
<a name="l06111"></a>06111 
<a name="l06112"></a>06112     <span class="comment">/* Special-case for no merge. */</span>
<a name="l06113"></a>06113     <span class="keywordflow">if</span>( i==1 ){
<a name="l06114"></a>06114       <span class="comment">/* Trim deletions from the doclist. */</span>
<a name="l06115"></a>06115       <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(&amp;merged);
<a name="l06116"></a>06116       <a class="code" href="fts2_8c.html#a2b1eafafb5e270c5d938362c43da3e15">docListTrim</a>(<a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>,
<a name="l06117"></a>06117                   <a class="code" href="fts2_8c.html#a2cacf604820439b4b3a7697bf0f83113">optLeavesReaderData</a>(&amp;readers[0]),
<a name="l06118"></a>06118                   <a class="code" href="fts2_8c.html#aa570029c58788cd468b52ed660565fbf">optLeavesReaderDataBytes</a>(&amp;readers[0]),
<a name="l06119"></a>06119                   -1, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, &amp;merged);
<a name="l06120"></a>06120     }<span class="keywordflow">else</span>{
<a name="l06121"></a>06121       <a class="code" href="structDLReader.html">DLReader</a> dlReaders[<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>];
<a name="l06122"></a>06122       <span class="keywordtype">int</span> iReader, nReaders;
<a name="l06123"></a>06123 
<a name="l06124"></a>06124       <span class="comment">/* Prime the pipeline with the first reader&apos;s doclist.  After</span>
<a name="l06125"></a>06125 <span class="comment">      ** one pass index 0 will reference the accumulated doclist.</span>
<a name="l06126"></a>06126 <span class="comment">      */</span>
<a name="l06127"></a>06127       <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;dlReaders[0], <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>,
<a name="l06128"></a>06128               <a class="code" href="fts2_8c.html#a2cacf604820439b4b3a7697bf0f83113">optLeavesReaderData</a>(&amp;readers[0]),
<a name="l06129"></a>06129               <a class="code" href="fts2_8c.html#aa570029c58788cd468b52ed660565fbf">optLeavesReaderDataBytes</a>(&amp;readers[0]));
<a name="l06130"></a>06130       iReader = 1;
<a name="l06131"></a>06131 
<a name="l06132"></a>06132       assert( iReader&lt;i );  <span class="comment">/* Must execute the loop at least once. */</span>
<a name="l06133"></a>06133       <span class="keywordflow">while</span>( iReader&lt;i ){
<a name="l06134"></a>06134         <span class="comment">/* Merge 16 inputs per pass. */</span>
<a name="l06135"></a>06135         <span class="keywordflow">for</span>( nReaders=1; iReader&lt;i &amp;&amp; nReaders&lt;<a class="code" href="fts2_8c.html#acd03eb00783e62f66390a9acf3263165">MERGE_COUNT</a>;
<a name="l06136"></a>06136              iReader++, nReaders++ ){
<a name="l06137"></a>06137           <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;dlReaders[nReaders], <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>,
<a name="l06138"></a>06138                   <a class="code" href="fts2_8c.html#a2cacf604820439b4b3a7697bf0f83113">optLeavesReaderData</a>(&amp;readers[iReader]),
<a name="l06139"></a>06139                   <a class="code" href="fts2_8c.html#aa570029c58788cd468b52ed660565fbf">optLeavesReaderDataBytes</a>(&amp;readers[iReader]));
<a name="l06140"></a>06140         }
<a name="l06141"></a>06141 
<a name="l06142"></a>06142         <span class="comment">/* Merge doclists and swap result into accumulator. */</span>
<a name="l06143"></a>06143         <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(&amp;merged);
<a name="l06144"></a>06144         <a class="code" href="fts2_8c.html#aa204589d71a5ad4842500f76af21e2b9">docListMerge</a>(&amp;merged, dlReaders, nReaders);
<a name="l06145"></a>06145         tmp = merged;
<a name="l06146"></a>06146         merged = doclist;
<a name="l06147"></a>06147         doclist = tmp;
<a name="l06148"></a>06148 
<a name="l06149"></a>06149         <span class="keywordflow">while</span>( nReaders-- &gt; 0 ){
<a name="l06150"></a>06150           <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;dlReaders[nReaders]);
<a name="l06151"></a>06151         }
<a name="l06152"></a>06152 
<a name="l06153"></a>06153         <span class="comment">/* Accumulated doclist to reader 0 for next pass. */</span>
<a name="l06154"></a>06154         <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;dlReaders[0], <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, doclist.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, doclist.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l06155"></a>06155       }
<a name="l06156"></a>06156 
<a name="l06157"></a>06157       <span class="comment">/* Destroy reader that was left in the pipeline. */</span>
<a name="l06158"></a>06158       <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;dlReaders[0]);
<a name="l06159"></a>06159 
<a name="l06160"></a>06160       <span class="comment">/* Trim deletions from the doclist. */</span>
<a name="l06161"></a>06161       <a class="code" href="fts2_8c.html#a7629abbee7b895cf4141e524c7ab8dd5">dataBufferReset</a>(&amp;merged);
<a name="l06162"></a>06162       <a class="code" href="fts2_8c.html#a2b1eafafb5e270c5d938362c43da3e15">docListTrim</a>(<a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, doclist.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, doclist.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>,
<a name="l06163"></a>06163                   -1, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, &amp;merged);
<a name="l06164"></a>06164     }
<a name="l06165"></a>06165 
<a name="l06166"></a>06166     <span class="comment">/* Only pass doclists with hits (skip if all hits deleted). */</span>
<a name="l06167"></a>06167     <span class="keywordflow">if</span>( merged.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 ){
<a name="l06168"></a>06168       rc = <a class="code" href="fts2_8c.html#a869165e5ff35ff1e763028a045db0236">leafWriterStep</a>(v, pWriter,
<a name="l06169"></a>06169                           <a class="code" href="fts2_8c.html#a450696f13a34eb5faab493883a46fd33">optLeavesReaderTerm</a>(&amp;readers[0]),
<a name="l06170"></a>06170                           <a class="code" href="fts2_8c.html#a5eb9cbed91fffb20782e1528e3c108e4">optLeavesReaderTermBytes</a>(&amp;readers[0]),
<a name="l06171"></a>06171                           merged.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, merged.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l06172"></a>06172       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l06173"></a>06173     }
<a name="l06174"></a>06174 
<a name="l06175"></a>06175     <span class="comment">/* Step merged readers to next term and reorder. */</span>
<a name="l06176"></a>06176     <span class="keywordflow">while</span>( i-- &gt; 0 ){
<a name="l06177"></a>06177       rc = <a class="code" href="fts2_8c.html#ad4ede602f423f38e4f6c483c57050ffa">optLeavesReaderStep</a>(v, &amp;readers[i]);
<a name="l06178"></a>06178       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l06179"></a>06179 
<a name="l06180"></a>06180       <a class="code" href="fts2_8c.html#a0b986fb12866b75e1c9db0b481c55a47">optLeavesReaderReorder</a>(&amp;readers[i], nReaders-i);
<a name="l06181"></a>06181     }
<a name="l06182"></a>06182   }
<a name="l06183"></a>06183 
<a name="l06184"></a>06184  err:
<a name="l06185"></a>06185   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;doclist);
<a name="l06186"></a>06186   <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;merged);
<a name="l06187"></a>06187   <span class="keywordflow">return</span> rc;
<a name="l06188"></a>06188 }
<a name="l06189"></a>06189 
<a name="l06190"></a>06190 <span class="comment">/* Implement optimize() function for FTS3.  optimize(t) merges all</span>
<a name="l06191"></a>06191 <span class="comment">** segments in the fts index into a single segment.  &apos;t&apos; is the magic</span>
<a name="l06192"></a>06192 <span class="comment">** table-named column.</span>
<a name="l06193"></a>06193 <span class="comment">*/</span>
<a name="l06194"></a><a class="code" href="fts2_8c.html#a667787b2b48cc3fe4970cf220d7f161d">06194</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a667787b2b48cc3fe4970cf220d7f161d">optimizeFunc</a>(<a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext,
<a name="l06195"></a>06195                          <span class="keywordtype">int</span> argc, <a class="code" href="structMem.html">sqlite3_value</a> **argv){
<a name="l06196"></a>06196   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *pCursor;
<a name="l06197"></a>06197   <span class="keywordflow">if</span>( argc&gt;1 ){
<a name="l06198"></a>06198     <a class="code" href="sqlite3_8h.html#a02826d87e45fd4f04445a3c99a14b54e">sqlite3_result_error</a>(pContext, <span class="stringliteral">&quot;excess arguments to optimize()&quot;</span>,-1);
<a name="l06199"></a>06199   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(argv[0])!=<a class="code" href="sqlite3_8h.html#a26c29a137b2a35bbde7048e5e48b794a">SQLITE_BLOB</a> ||
<a name="l06200"></a>06200             <a class="code" href="sqlite3_8h.html#a2aff2bf1311b5bd05d8e30738445b186">sqlite3_value_bytes</a>(argv[0])!=<span class="keyword">sizeof</span>(pCursor) ){
<a name="l06201"></a>06201     <a class="code" href="sqlite3_8h.html#a02826d87e45fd4f04445a3c99a14b54e">sqlite3_result_error</a>(pContext, <span class="stringliteral">&quot;illegal first argument to optimize&quot;</span>,-1);
<a name="l06202"></a>06202   }<span class="keywordflow">else</span>{
<a name="l06203"></a>06203     <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v;
<a name="l06204"></a>06204     <span class="keywordtype">int</span> i, rc, iMaxLevel;
<a name="l06205"></a>06205     <a class="code" href="structOptLeavesReader.html">OptLeavesReader</a> *readers;
<a name="l06206"></a>06206     <span class="keywordtype">int</span> nReaders;
<a name="l06207"></a>06207     <a class="code" href="structLeafWriter.html">LeafWriter</a> <a class="code" href="lstrlib_8c.html#ae67cb3a8aef2fe1be04d689cddf5d587">writer</a>;
<a name="l06208"></a>06208     <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s;
<a name="l06209"></a>06209 
<a name="l06210"></a>06210     memcpy(&amp;pCursor, <a class="code" href="sqlite3_8h.html#a81138be97f3e5124e33fb50925b710b6">sqlite3_value_blob</a>(argv[0]), <span class="keyword">sizeof</span>(pCursor));
<a name="l06211"></a>06211     v = <a class="code" href="fts2_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">cursor_vtab</a>(pCursor);
<a name="l06212"></a>06212 
<a name="l06213"></a>06213     <span class="comment">/* Flush any buffered updates before optimizing. */</span>
<a name="l06214"></a>06214     rc = <a class="code" href="fts2_8c.html#a7562cdf287e12b6322a65b44f508d177">flushPendingTerms</a>(v);
<a name="l06215"></a>06215     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l06216"></a>06216 
<a name="l06217"></a>06217     rc = <a class="code" href="fts2_8c.html#a8952407493e082f2740936253854c9c9">segdir_count</a>(v, &amp;nReaders, &amp;iMaxLevel);
<a name="l06218"></a>06218     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l06219"></a>06219     <span class="keywordflow">if</span>( nReaders==0 || nReaders==1 ){
<a name="l06220"></a>06220       <a class="code" href="sqlite3_8h.html#a2dfd2d971e743b8d5a24725606a733ac">sqlite3_result_text</a>(pContext, <span class="stringliteral">&quot;Index already optimal&quot;</span>, -1,
<a name="l06221"></a>06221                           <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l06222"></a>06222       <span class="keywordflow">return</span>;
<a name="l06223"></a>06223     }
<a name="l06224"></a>06224 
<a name="l06225"></a>06225     rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a81b342bd8dbd7d6ef31c6e8357c12b89">SEGDIR_SELECT_ALL_STMT</a>, &amp;s);
<a name="l06226"></a>06226     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l06227"></a>06227 
<a name="l06228"></a>06228     readers = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(nReaders*<span class="keyword">sizeof</span>(readers[0]));
<a name="l06229"></a>06229     <span class="keywordflow">if</span>( readers==NULL ) <span class="keywordflow">goto</span> err;
<a name="l06230"></a>06230 
<a name="l06231"></a>06231     <span class="comment">/* Note that there will already be a segment at this position</span>
<a name="l06232"></a>06232 <span class="comment">    ** until we call segdir_delete() on iMaxLevel.</span>
<a name="l06233"></a>06233 <span class="comment">    */</span>
<a name="l06234"></a>06234     <a class="code" href="fts2_8c.html#a86612bb723ea03d3cf9cee54b300e8d8">leafWriterInit</a>(iMaxLevel, 0, &amp;writer);
<a name="l06235"></a>06235 
<a name="l06236"></a>06236     i = 0;
<a name="l06237"></a>06237     <span class="keywordflow">while</span>( (rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s))==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l06238"></a>06238       <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iStart = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 0);
<a name="l06239"></a>06239       <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iEnd = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 1);
<a name="l06240"></a>06240       <span class="keyword">const</span> <span class="keywordtype">char</span> *pRootData = <a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(s, 2);
<a name="l06241"></a>06241       <span class="keywordtype">int</span> nRootData = <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(s, 2);
<a name="l06242"></a>06242 
<a name="l06243"></a>06243       assert( i&lt;nReaders );
<a name="l06244"></a>06244       rc = <a class="code" href="fts2_8c.html#a80fb079e0710324da4be7fe56c5dd7e5">leavesReaderInit</a>(v, -1, iStart, iEnd, pRootData, nRootData,
<a name="l06245"></a>06245                             &amp;readers[i].reader);
<a name="l06246"></a>06246       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">break</span>;
<a name="l06247"></a>06247 
<a name="l06248"></a>06248       readers[i].<a class="code" href="structOptLeavesReader.html#a0b11ecc3978d1318f3aebf20649e79fa">segment</a> = i;
<a name="l06249"></a>06249       i++;
<a name="l06250"></a>06250     }
<a name="l06251"></a>06251 
<a name="l06252"></a>06252     <span class="comment">/* If we managed to succesfully read them all, optimize them. */</span>
<a name="l06253"></a>06253     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l06254"></a>06254       assert( i==nReaders );
<a name="l06255"></a>06255       rc = <a class="code" href="fts2_8c.html#aabfd3d844aae1591704d4e540e0ef899">optimizeInternal</a>(v, readers, nReaders, &amp;writer);
<a name="l06256"></a>06256     }
<a name="l06257"></a>06257 
<a name="l06258"></a>06258     <span class="keywordflow">while</span>( i-- &gt; 0 ){
<a name="l06259"></a>06259       <a class="code" href="fts2_8c.html#a855cb94e7913e2a38eb8c281a85f12f9">leavesReaderDestroy</a>(&amp;readers[i].reader);
<a name="l06260"></a>06260     }
<a name="l06261"></a>06261     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(readers);
<a name="l06262"></a>06262 
<a name="l06263"></a>06263     <span class="comment">/* If we&apos;ve successfully gotten to here, delete the old segments</span>
<a name="l06264"></a>06264 <span class="comment">    ** and flush the interior structure of the new segment.</span>
<a name="l06265"></a>06265 <span class="comment">    */</span>
<a name="l06266"></a>06266     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06267"></a>06267       <span class="keywordflow">for</span>( i=0; i&lt;=iMaxLevel; i++ ){
<a name="l06268"></a>06268         rc = <a class="code" href="fts2_8c.html#a4f5564997dda64601c2138e86b85a96a">segdir_delete</a>(v, i);
<a name="l06269"></a>06269         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">break</span>;
<a name="l06270"></a>06270       }
<a name="l06271"></a>06271 
<a name="l06272"></a>06272       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) rc = <a class="code" href="fts2_8c.html#a20a5c7ef17056f24bd37097afd4fe67b">leafWriterFinalize</a>(v, &amp;writer);
<a name="l06273"></a>06273     }
<a name="l06274"></a>06274 
<a name="l06275"></a>06275     <a class="code" href="fts2_8c.html#a2a86036daf4b9e95f8c4e7105bc8e035">leafWriterDestroy</a>(&amp;writer);
<a name="l06276"></a>06276 
<a name="l06277"></a>06277     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> err;
<a name="l06278"></a>06278 
<a name="l06279"></a>06279     <a class="code" href="sqlite3_8h.html#a2dfd2d971e743b8d5a24725606a733ac">sqlite3_result_text</a>(pContext, <span class="stringliteral">&quot;Index optimized&quot;</span>, -1, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l06280"></a>06280     <span class="keywordflow">return</span>;
<a name="l06281"></a>06281 
<a name="l06282"></a>06282     <span class="comment">/* TODO(shess): Error-handling needs to be improved along the</span>
<a name="l06283"></a>06283 <span class="comment">    ** lines of the dump_ functions.</span>
<a name="l06284"></a>06284 <span class="comment">    */</span>
<a name="l06285"></a>06285  err:
<a name="l06286"></a>06286     {
<a name="l06287"></a>06287       <span class="keywordtype">char</span> buf[512];
<a name="l06288"></a>06288       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(buf), buf, <span class="stringliteral">&quot;Error in optimize: %s&quot;</span>,
<a name="l06289"></a>06289                        <a class="code" href="main_8c.html#ad2a9feca40ee5a7c629c2af6d0ae1d27">sqlite3_errmsg</a>(<a class="code" href="sqlite3_8h.html#a1e7f6948a7eea4d05f66d9df4f885a81">sqlite3_context_db_handle</a>(pContext)));
<a name="l06290"></a>06290       <a class="code" href="sqlite3_8h.html#a02826d87e45fd4f04445a3c99a14b54e">sqlite3_result_error</a>(pContext, buf, -1);
<a name="l06291"></a>06291     }
<a name="l06292"></a>06292   }
<a name="l06293"></a>06293 }
<a name="l06294"></a>06294 
<a name="l06295"></a>06295 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l06296"></a>06296 <span class="preprocessor"></span><span class="comment">/* Generate an error of the form &quot;&lt;prefix&gt;: &lt;msg&gt;&quot;.  If msg is NULL,</span>
<a name="l06297"></a>06297 <span class="comment">** pull the error from the context&apos;s db handle.</span>
<a name="l06298"></a>06298 <span class="comment">*/</span>
<a name="l06299"></a>06299 <span class="keyword">static</span> <span class="keywordtype">void</span> generateError(<a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext,
<a name="l06300"></a>06300                           <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg){
<a name="l06301"></a>06301   <span class="keywordtype">char</span> buf[512];
<a name="l06302"></a>06302   <span class="keywordflow">if</span>( msg==NULL ) msg = <a class="code" href="main_8c.html#ad2a9feca40ee5a7c629c2af6d0ae1d27">sqlite3_errmsg</a>(<a class="code" href="sqlite3_8h.html#a1e7f6948a7eea4d05f66d9df4f885a81">sqlite3_context_db_handle</a>(pContext));
<a name="l06303"></a>06303   <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(buf), buf, <span class="stringliteral">&quot;%s: %s&quot;</span>, prefix, msg);
<a name="l06304"></a>06304   <a class="code" href="sqlite3_8h.html#a02826d87e45fd4f04445a3c99a14b54e">sqlite3_result_error</a>(pContext, buf, -1);
<a name="l06305"></a>06305 }
<a name="l06306"></a>06306 
<a name="l06307"></a>06307 <span class="comment">/* Helper function to collect the set of terms in the segment into</span>
<a name="l06308"></a>06308 <span class="comment">** pTerms.  The segment is defined by the leaf nodes between</span>
<a name="l06309"></a>06309 <span class="comment">** iStartBlockid and iEndBlockid, inclusive, or by the contents of</span>
<a name="l06310"></a>06310 <span class="comment">** pRootData if iStartBlockid is 0 (in which case the entire segment</span>
<a name="l06311"></a>06311 <span class="comment">** fit in a leaf).</span>
<a name="l06312"></a>06312 <span class="comment">*/</span>
<a name="l06313"></a>06313 <span class="keyword">static</span> <span class="keywordtype">int</span> collectSegmentTerms(<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v, <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s,
<a name="l06314"></a>06314                                <a class="code" href="structfts2Hash.html">fts2Hash</a> *pTerms){
<a name="l06315"></a>06315   <span class="keyword">const</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iStartBlockid = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 0);
<a name="l06316"></a>06316   <span class="keyword">const</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iEndBlockid = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 1);
<a name="l06317"></a>06317   <span class="keyword">const</span> <span class="keywordtype">char</span> *pRootData = <a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(s, 2);
<a name="l06318"></a>06318   <span class="keyword">const</span> <span class="keywordtype">int</span> nRootData = <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(s, 2);
<a name="l06319"></a>06319   <a class="code" href="structLeavesReader.html">LeavesReader</a> reader;
<a name="l06320"></a>06320   <span class="keywordtype">int</span> rc = <a class="code" href="fts2_8c.html#a80fb079e0710324da4be7fe56c5dd7e5">leavesReaderInit</a>(v, 0, iStartBlockid, iEndBlockid,
<a name="l06321"></a>06321                             pRootData, nRootData, &amp;reader);
<a name="l06322"></a>06322   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l06323"></a>06323 
<a name="l06324"></a>06324   <span class="keywordflow">while</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; !<a class="code" href="fts2_8c.html#a5448710f27fb0c6e9365a7ef05e2c16e">leavesReaderAtEnd</a>(&amp;reader) ){
<a name="l06325"></a>06325     <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm = <a class="code" href="fts2_8c.html#aeb47709b8fd707f2705051ccd9f95ea2">leavesReaderTerm</a>(&amp;reader);
<a name="l06326"></a>06326     <span class="keyword">const</span> <span class="keywordtype">int</span> nTerm = <a class="code" href="fts2_8c.html#ab1b844350e43ffea25791355eff5fe6d">leavesReaderTermBytes</a>(&amp;reader);
<a name="l06327"></a>06327     <span class="keywordtype">void</span> *oldValue = <a class="code" href="fts2__hash_8c.html#a14439ab02f3df4a2a00056e440b4eb6a">sqlite3Fts2HashFind</a>(pTerms, pTerm, nTerm);
<a name="l06328"></a>06328     <span class="keywordtype">void</span> *newValue = (<span class="keywordtype">void</span> *)((<span class="keywordtype">char</span> *)oldValue+1);
<a name="l06329"></a>06329 
<a name="l06330"></a>06330     <span class="comment">/* From the comment before sqlite3Fts2HashInsert in fts2_hash.c,</span>
<a name="l06331"></a>06331 <span class="comment">    ** the data value passed is returned in case of malloc failure.</span>
<a name="l06332"></a>06332 <span class="comment">    */</span>
<a name="l06333"></a>06333     <span class="keywordflow">if</span>( newValue==<a class="code" href="fts2__hash_8c.html#ac35c0c4fb1cb817018b7778db3047d8f">sqlite3Fts2HashInsert</a>(pTerms, pTerm, nTerm, newValue) ){
<a name="l06334"></a>06334       rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l06335"></a>06335     }<span class="keywordflow">else</span>{
<a name="l06336"></a>06336       rc = <a class="code" href="fts2_8c.html#a0cba191ae8402798782d84a133bbccd8">leavesReaderStep</a>(v, &amp;reader);
<a name="l06337"></a>06337     }
<a name="l06338"></a>06338   }
<a name="l06339"></a>06339 
<a name="l06340"></a>06340   <a class="code" href="fts2_8c.html#a855cb94e7913e2a38eb8c281a85f12f9">leavesReaderDestroy</a>(&amp;reader);
<a name="l06341"></a>06341   <span class="keywordflow">return</span> rc;
<a name="l06342"></a>06342 }
<a name="l06343"></a>06343 
<a name="l06344"></a>06344 <span class="comment">/* Helper function to build the result string for dump_terms(). */</span>
<a name="l06345"></a>06345 <span class="keyword">static</span> <span class="keywordtype">int</span> generateTermsResult(<a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext, <a class="code" href="structfts2Hash.html">fts2Hash</a> *pTerms){
<a name="l06346"></a>06346   <span class="keywordtype">int</span> iTerm, nTerms, nResultBytes, iByte;
<a name="l06347"></a>06347   <span class="keywordtype">char</span> *result;
<a name="l06348"></a>06348   <a class="code" href="structTermData.html">TermData</a> *pData;
<a name="l06349"></a>06349   <a class="code" href="structfts2HashElem.html">fts2HashElem</a> *e;
<a name="l06350"></a>06350 
<a name="l06351"></a>06351   <span class="comment">/* Iterate pTerms to generate an array of terms in pData for</span>
<a name="l06352"></a>06352 <span class="comment">  ** sorting.</span>
<a name="l06353"></a>06353 <span class="comment">  */</span>
<a name="l06354"></a>06354   nTerms = <a class="code" href="fts2__hash_8h.html#a3b294f028b00dd4a01a8d5215db2f452">fts2HashCount</a>(pTerms);
<a name="l06355"></a>06355   assert( nTerms&gt;0 );
<a name="l06356"></a>06356   pData = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(nTerms*<span class="keyword">sizeof</span>(<a class="code" href="structTermData.html">TermData</a>));
<a name="l06357"></a>06357   <span class="keywordflow">if</span>( pData==NULL ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l06358"></a>06358 
<a name="l06359"></a>06359   nResultBytes = 0;
<a name="l06360"></a>06360   <span class="keywordflow">for</span>(iTerm = 0, e = <a class="code" href="fts2__hash_8h.html#ac47206d032f149dcae50c48bd5925b90">fts2HashFirst</a>(pTerms); e; iTerm++, e = <a class="code" href="fts2__hash_8h.html#aeea646b638ec4170a2d66b5cc1be24fe">fts2HashNext</a>(e)){
<a name="l06361"></a>06361     nResultBytes += <a class="code" href="fts2__hash_8h.html#a39e5381b1ee44765a17451320c7c760f">fts2HashKeysize</a>(e)+1;   <span class="comment">/* Term plus trailing space */</span>
<a name="l06362"></a>06362     assert( iTerm&lt;nTerms );
<a name="l06363"></a>06363     pData[iTerm].<a class="code" href="structTermData.html#a5e1b65f58146756e3a42dbe775380411">pTerm</a> = <a class="code" href="fts2__hash_8h.html#aea07b5040fb15dda61e981e5862a2442">fts2HashKey</a>(e);
<a name="l06364"></a>06364     pData[iTerm].<a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a> = <a class="code" href="fts2__hash_8h.html#a39e5381b1ee44765a17451320c7c760f">fts2HashKeysize</a>(e);
<a name="l06365"></a>06365     pData[iTerm].<a class="code" href="structTermData.html#a6a23f22df387bc05ee939d46032d0fb2">pCollector</a> = <a class="code" href="fts2__hash_8h.html#a5a5c378c8faddd4ec893b3f42683837b">fts2HashData</a>(e);  <span class="comment">/* unused */</span>
<a name="l06366"></a>06366   }
<a name="l06367"></a>06367   assert( iTerm==nTerms );
<a name="l06368"></a>06368 
<a name="l06369"></a>06369   assert( nResultBytes&gt;0 );   <span class="comment">/* nTerms&gt;0, nResultsBytes must be, too. */</span>
<a name="l06370"></a>06370   result = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(nResultBytes);
<a name="l06371"></a>06371   <span class="keywordflow">if</span>( result==NULL ){
<a name="l06372"></a>06372     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pData);
<a name="l06373"></a>06373     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l06374"></a>06374   }
<a name="l06375"></a>06375 
<a name="l06376"></a>06376   <span class="keywordflow">if</span>( nTerms&gt;1 ) qsort(pData, nTerms, <span class="keyword">sizeof</span>(*pData), <a class="code" href="fts2_8c.html#a73fa3de230c66dfe5996f389a1de7e0c">termDataCmp</a>);
<a name="l06377"></a>06377 
<a name="l06378"></a>06378   <span class="comment">/* Read the terms in order to build the result. */</span>
<a name="l06379"></a>06379   iByte = 0;
<a name="l06380"></a>06380   <span class="keywordflow">for</span>(iTerm=0; iTerm&lt;nTerms; ++iTerm){
<a name="l06381"></a>06381     memcpy(result+iByte, pData[iTerm].pTerm, pData[iTerm].nTerm);
<a name="l06382"></a>06382     iByte += pData[iTerm].<a class="code" href="structTermData.html#abd4bd226cf93f7bf1d79fb64cb03097d">nTerm</a>;
<a name="l06383"></a>06383     result[iByte++] = <span class="charliteral">&apos; &apos;</span>;
<a name="l06384"></a>06384   }
<a name="l06385"></a>06385   assert( iByte==nResultBytes );
<a name="l06386"></a>06386   assert( result[nResultBytes-1]==<span class="charliteral">&apos; &apos;</span> );
<a name="l06387"></a>06387   result[nResultBytes-1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l06388"></a>06388 
<a name="l06389"></a>06389   <span class="comment">/* Passes away ownership of result. */</span>
<a name="l06390"></a>06390   <a class="code" href="sqlite3_8h.html#a2dfd2d971e743b8d5a24725606a733ac">sqlite3_result_text</a>(pContext, result, nResultBytes-1, <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>);
<a name="l06391"></a>06391   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pData);
<a name="l06392"></a>06392   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l06393"></a>06393 }
<a name="l06394"></a>06394 
<a name="l06395"></a>06395 <span class="comment">/* Implements dump_terms() for use in inspecting the fts2 index from</span>
<a name="l06396"></a>06396 <span class="comment">** tests.  TEXT result containing the ordered list of terms joined by</span>
<a name="l06397"></a>06397 <span class="comment">** spaces.  dump_terms(t, level, idx) dumps the terms for the segment</span>
<a name="l06398"></a>06398 <span class="comment">** specified by level, idx (in %_segdir), while dump_terms(t) dumps</span>
<a name="l06399"></a>06399 <span class="comment">** all terms in the index.  In both cases t is the fts table&apos;s magic</span>
<a name="l06400"></a>06400 <span class="comment">** table-named column.</span>
<a name="l06401"></a>06401 <span class="comment">*/</span>
<a name="l06402"></a>06402 <span class="keyword">static</span> <span class="keywordtype">void</span> dumpTermsFunc(
<a name="l06403"></a>06403   <a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext,
<a name="l06404"></a>06404   <span class="keywordtype">int</span> argc, <a class="code" href="structMem.html">sqlite3_value</a> **argv
<a name="l06405"></a>06405 ){
<a name="l06406"></a>06406   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *pCursor;
<a name="l06407"></a>06407   <span class="keywordflow">if</span>( argc!=3 &amp;&amp; argc!=1 ){
<a name="l06408"></a>06408     generateError(pContext, <span class="stringliteral">&quot;dump_terms&quot;</span>, <span class="stringliteral">&quot;incorrect arguments&quot;</span>);
<a name="l06409"></a>06409   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(argv[0])!=<a class="code" href="sqlite3_8h.html#a26c29a137b2a35bbde7048e5e48b794a">SQLITE_BLOB</a> ||
<a name="l06410"></a>06410             <a class="code" href="sqlite3_8h.html#a2aff2bf1311b5bd05d8e30738445b186">sqlite3_value_bytes</a>(argv[0])!=<span class="keyword">sizeof</span>(pCursor) ){
<a name="l06411"></a>06411     generateError(pContext, <span class="stringliteral">&quot;dump_terms&quot;</span>, <span class="stringliteral">&quot;illegal first argument&quot;</span>);
<a name="l06412"></a>06412   }<span class="keywordflow">else</span>{
<a name="l06413"></a>06413     <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v;
<a name="l06414"></a>06414     <a class="code" href="structfts2Hash.html">fts2Hash</a> terms;
<a name="l06415"></a>06415     <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s = NULL;
<a name="l06416"></a>06416     <span class="keywordtype">int</span> rc;
<a name="l06417"></a>06417 
<a name="l06418"></a>06418     memcpy(&amp;pCursor, <a class="code" href="sqlite3_8h.html#a81138be97f3e5124e33fb50925b710b6">sqlite3_value_blob</a>(argv[0]), <span class="keyword">sizeof</span>(pCursor));
<a name="l06419"></a>06419     v = <a class="code" href="fts2_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">cursor_vtab</a>(pCursor);
<a name="l06420"></a>06420 
<a name="l06421"></a>06421     <span class="comment">/* If passed only the cursor column, get all segments.  Otherwise</span>
<a name="l06422"></a>06422 <span class="comment">    ** get the segment described by the following two arguments.</span>
<a name="l06423"></a>06423 <span class="comment">    */</span>
<a name="l06424"></a>06424     <span class="keywordflow">if</span>( argc==1 ){
<a name="l06425"></a>06425       rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a81b342bd8dbd7d6ef31c6e8357c12b89">SEGDIR_SELECT_ALL_STMT</a>, &amp;s);
<a name="l06426"></a>06426     }<span class="keywordflow">else</span>{
<a name="l06427"></a>06427       rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3756eca57cdc28e500ada182a256ac41">SEGDIR_SELECT_SEGMENT_STMT</a>, &amp;s);
<a name="l06428"></a>06428       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06429"></a>06429         rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 1, <a class="code" href="sqlite3_8h.html#af85c1bccdd78d4eefdcdb0136aaf9149">sqlite3_value_int</a>(argv[1]));
<a name="l06430"></a>06430         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06431"></a>06431           rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 2, <a class="code" href="sqlite3_8h.html#af85c1bccdd78d4eefdcdb0136aaf9149">sqlite3_value_int</a>(argv[2]));
<a name="l06432"></a>06432         }
<a name="l06433"></a>06433       }
<a name="l06434"></a>06434     }
<a name="l06435"></a>06435 
<a name="l06436"></a>06436     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06437"></a>06437       generateError(pContext, <span class="stringliteral">&quot;dump_terms&quot;</span>, NULL);
<a name="l06438"></a>06438       <span class="keywordflow">return</span>;
<a name="l06439"></a>06439     }
<a name="l06440"></a>06440 
<a name="l06441"></a>06441     <span class="comment">/* Collect the terms for each segment. */</span>
<a name="l06442"></a>06442     <a class="code" href="fts2__hash_8c.html#a12107e26db4496f65b40f888b62fd9b7">sqlite3Fts2HashInit</a>(&amp;terms, <a class="code" href="fts2__hash_8h.html#a32d375e016bc4f8e368ca7a8a2bff48b">FTS2_HASH_STRING</a>, 1);
<a name="l06443"></a>06443     <span class="keywordflow">while</span>( (rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s))==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l06444"></a>06444       rc = collectSegmentTerms(v, s, &amp;terms);
<a name="l06445"></a>06445       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">break</span>;
<a name="l06446"></a>06446     }
<a name="l06447"></a>06447 
<a name="l06448"></a>06448     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l06449"></a>06449       <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(s);
<a name="l06450"></a>06450       generateError(pContext, <span class="stringliteral">&quot;dump_terms&quot;</span>, NULL);
<a name="l06451"></a>06451     }<span class="keywordflow">else</span>{
<a name="l06452"></a>06452       <span class="keyword">const</span> <span class="keywordtype">int</span> nTerms = <a class="code" href="fts2__hash_8h.html#a3b294f028b00dd4a01a8d5215db2f452">fts2HashCount</a>(&amp;terms);
<a name="l06453"></a>06453       <span class="keywordflow">if</span>( nTerms&gt;0 ){
<a name="l06454"></a>06454         rc = generateTermsResult(pContext, &amp;terms);
<a name="l06455"></a>06455         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a> ){
<a name="l06456"></a>06456           generateError(pContext, <span class="stringliteral">&quot;dump_terms&quot;</span>, <span class="stringliteral">&quot;out of memory&quot;</span>);
<a name="l06457"></a>06457         }<span class="keywordflow">else</span>{
<a name="l06458"></a>06458           assert( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> );
<a name="l06459"></a>06459         }
<a name="l06460"></a>06460       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( argc==3 ){
<a name="l06461"></a>06461         <span class="comment">/* The specific segment asked for could not be found. */</span>
<a name="l06462"></a>06462         generateError(pContext, <span class="stringliteral">&quot;dump_terms&quot;</span>, <span class="stringliteral">&quot;segment not found&quot;</span>);
<a name="l06463"></a>06463       }<span class="keywordflow">else</span>{
<a name="l06464"></a>06464         <span class="comment">/* No segments found. */</span>
<a name="l06465"></a>06465         <span class="comment">/* TODO(shess): It should be impossible to reach this.  This</span>
<a name="l06466"></a>06466 <span class="comment">        ** case can only happen for an empty table, in which case</span>
<a name="l06467"></a>06467 <span class="comment">        ** SQLite has no rows to call this function on.</span>
<a name="l06468"></a>06468 <span class="comment">        */</span>
<a name="l06469"></a>06469         <a class="code" href="sqlite3_8h.html#aae1ddb43f87c897288e26fd7d890c6bd">sqlite3_result_null</a>(pContext);
<a name="l06470"></a>06470       }
<a name="l06471"></a>06471     }
<a name="l06472"></a>06472     <a class="code" href="fts2__hash_8c.html#ae418104a453b340caac3f68e8972a88f">sqlite3Fts2HashClear</a>(&amp;terms);
<a name="l06473"></a>06473   }
<a name="l06474"></a>06474 }
<a name="l06475"></a>06475 
<a name="l06476"></a>06476 <span class="comment">/* Expand the DL_DEFAULT doclist in pData into a text result in</span>
<a name="l06477"></a>06477 <span class="comment">** pContext.</span>
<a name="l06478"></a>06478 <span class="comment">*/</span>
<a name="l06479"></a>06479 <span class="keyword">static</span> <span class="keywordtype">void</span> createDoclistResult(<a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext,
<a name="l06480"></a>06480                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *pData, <span class="keywordtype">int</span> nData){
<a name="l06481"></a>06481   <a class="code" href="structDataBuffer.html">DataBuffer</a> dump;
<a name="l06482"></a>06482   <a class="code" href="structDLReader.html">DLReader</a> dlReader;
<a name="l06483"></a>06483 
<a name="l06484"></a>06484   assert( pData!=NULL &amp;&amp; nData&gt;0 );
<a name="l06485"></a>06485 
<a name="l06486"></a>06486   <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;dump, 0);
<a name="l06487"></a>06487   <a class="code" href="fts2_8c.html#a81d08aa7ce3639bb044dcc35301346bc">dlrInit</a>(&amp;dlReader, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, pData, nData);
<a name="l06488"></a>06488   <span class="keywordflow">for</span>( ; !<a class="code" href="fts2_8c.html#aa5713c8966767391b49d9989bb5e4611">dlrAtEnd</a>(&amp;dlReader); <a class="code" href="fts2_8c.html#ac19e84b7c4b542fbb2d5ca2d779b3086">dlrStep</a>(&amp;dlReader) ){
<a name="l06489"></a>06489     <span class="keywordtype">char</span> buf[256];
<a name="l06490"></a>06490     <a class="code" href="structPLReader.html">PLReader</a> plReader;
<a name="l06491"></a>06491 
<a name="l06492"></a>06492     <a class="code" href="fts2_8c.html#ac211994cb69d057e6e933363854b92b0">plrInit</a>(&amp;plReader, &amp;dlReader);
<a name="l06493"></a>06493     <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7baf7fcfc44f3d5dcd6ab13b0486aa4d307">DL_DOCIDS</a> || <a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(&amp;plReader) ){
<a name="l06494"></a>06494       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(buf), buf, <span class="stringliteral">&quot;[%lld] &quot;</span>, <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;dlReader));
<a name="l06495"></a>06495       <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(&amp;dump, buf, strlen(buf));
<a name="l06496"></a>06496     }<span class="keywordflow">else</span>{
<a name="l06497"></a>06497       <span class="keywordtype">int</span> iColumn = <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;plReader);
<a name="l06498"></a>06498 
<a name="l06499"></a>06499       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(buf), buf, <span class="stringliteral">&quot;[%lld %d[&quot;</span>,
<a name="l06500"></a>06500                        <a class="code" href="fts2_8c.html#ae4bfa0aad30dd529e95a060133e2f1ea">dlrDocid</a>(&amp;dlReader), iColumn);
<a name="l06501"></a>06501       <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(&amp;dump, buf, strlen(buf));
<a name="l06502"></a>06502 
<a name="l06503"></a>06503       <span class="keywordflow">for</span>( ; !<a class="code" href="fts2_8c.html#ab1762e223a1220584963840b2136e02a">plrAtEnd</a>(&amp;plReader); <a class="code" href="fts2_8c.html#a5e0bb198da051ec0927b8b5bf662989e">plrStep</a>(&amp;plReader) ){
<a name="l06504"></a>06504         <span class="keywordflow">if</span>( <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;plReader)!=iColumn ){
<a name="l06505"></a>06505           iColumn = <a class="code" href="fts2_8c.html#a0f938d994adeb917b3464f6ff27233b2">plrColumn</a>(&amp;plReader);
<a name="l06506"></a>06506           <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(buf), buf, <span class="stringliteral">&quot;] %d[&quot;</span>, iColumn);
<a name="l06507"></a>06507           assert( dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 );
<a name="l06508"></a>06508           dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>--;                     <span class="comment">/* Overwrite trailing space. */</span>
<a name="l06509"></a>06509           assert( dump.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>[dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>]==<span class="charliteral">&apos; &apos;</span>);
<a name="l06510"></a>06510           <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(&amp;dump, buf, strlen(buf));
<a name="l06511"></a>06511         }
<a name="l06512"></a>06512         <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7bad32ed850ac18f1c4cde9c6e973c3fa8b">DL_POSITIONS_OFFSETS</a> ){
<a name="l06513"></a>06513           <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(buf), buf, <span class="stringliteral">&quot;%d,%d,%d &quot;</span>,
<a name="l06514"></a>06514                            <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(&amp;plReader),
<a name="l06515"></a>06515                            <a class="code" href="fts2_8c.html#a53f94db5ee5ec2bbb60962eb9d1c292a">plrStartOffset</a>(&amp;plReader), <a class="code" href="fts2_8c.html#a41ebd653df431023f9c89b13ac282e37">plrEndOffset</a>(&amp;plReader));
<a name="l06516"></a>06516         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>==<a class="code" href="fts1_8c.html#a6176b53cd6fd43e2eb2409bdf936cd7ba0db67f9bc47cc8cd59027480c0977fd8">DL_POSITIONS</a> ){
<a name="l06517"></a>06517           <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(buf), buf, <span class="stringliteral">&quot;%d &quot;</span>, <a class="code" href="fts2_8c.html#af57a3470fd5e0ac0e17188284b2480cd">plrPosition</a>(&amp;plReader));
<a name="l06518"></a>06518         }<span class="keywordflow">else</span>{
<a name="l06519"></a>06519           assert( NULL==<span class="stringliteral">&quot;Unhandled DL_DEFAULT value&quot;</span>);
<a name="l06520"></a>06520         }
<a name="l06521"></a>06521         <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(&amp;dump, buf, strlen(buf));
<a name="l06522"></a>06522       }
<a name="l06523"></a>06523       <a class="code" href="fts2_8c.html#a4f4258f283f5c91fbb885c1726e16455">plrDestroy</a>(&amp;plReader);
<a name="l06524"></a>06524 
<a name="l06525"></a>06525       assert( dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 );
<a name="l06526"></a>06526       dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>--;                     <span class="comment">/* Overwrite trailing space. */</span>
<a name="l06527"></a>06527       assert( dump.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>[dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>]==<span class="charliteral">&apos; &apos;</span>);
<a name="l06528"></a>06528       <a class="code" href="fts2_8c.html#a8eeef40b0420b405957be9bb2500d223">dataBufferAppend</a>(&amp;dump, <span class="stringliteral">&quot;]] &quot;</span>, 3);
<a name="l06529"></a>06529     }
<a name="l06530"></a>06530   }
<a name="l06531"></a>06531   <a class="code" href="fts2_8c.html#abd5ca98ed067a8aada1db6c5e2819d4e">dlrDestroy</a>(&amp;dlReader);
<a name="l06532"></a>06532 
<a name="l06533"></a>06533   assert( dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 );
<a name="l06534"></a>06534   dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>--;                     <span class="comment">/* Overwrite trailing space. */</span>
<a name="l06535"></a>06535   assert( dump.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>[dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>]==<span class="charliteral">&apos; &apos;</span>);
<a name="l06536"></a>06536   dump.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>[dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l06537"></a>06537   assert( dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 );
<a name="l06538"></a>06538 
<a name="l06539"></a>06539   <span class="comment">/* Passes ownership of dump&apos;s buffer to pContext. */</span>
<a name="l06540"></a>06540   <a class="code" href="sqlite3_8h.html#a2dfd2d971e743b8d5a24725606a733ac">sqlite3_result_text</a>(pContext, dump.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>, <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>);
<a name="l06541"></a>06541   dump.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a> = NULL;
<a name="l06542"></a>06542   dump.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a> = dump.<a class="code" href="structDataBuffer.html#a94be96e6647b66004cdc163cd6cd1df4">nCapacity</a> = 0;
<a name="l06543"></a>06543 }
<a name="l06544"></a>06544 
<a name="l06545"></a>06545 <span class="comment">/* Implements dump_doclist() for use in inspecting the fts2 index from</span>
<a name="l06546"></a>06546 <span class="comment">** tests.  TEXT result containing a string representation of the</span>
<a name="l06547"></a>06547 <span class="comment">** doclist for the indicated term.  dump_doclist(t, term, level, idx)</span>
<a name="l06548"></a>06548 <span class="comment">** dumps the doclist for term from the segment specified by level, idx</span>
<a name="l06549"></a>06549 <span class="comment">** (in %_segdir), while dump_doclist(t, term) dumps the logical</span>
<a name="l06550"></a>06550 <span class="comment">** doclist for the term across all segments.  The per-segment doclist</span>
<a name="l06551"></a>06551 <span class="comment">** can contain deletions, while the full-index doclist will not</span>
<a name="l06552"></a>06552 <span class="comment">** (deletions are omitted).</span>
<a name="l06553"></a>06553 <span class="comment">**</span>
<a name="l06554"></a>06554 <span class="comment">** Result formats differ with the setting of DL_DEFAULTS.  Examples:</span>
<a name="l06555"></a>06555 <span class="comment">**</span>
<a name="l06556"></a>06556 <span class="comment">** DL_DOCIDS: [1] [3] [7]</span>
<a name="l06557"></a>06557 <span class="comment">** DL_POSITIONS: [1 0[0 4] 1[17]] [3 1[5]]</span>
<a name="l06558"></a>06558 <span class="comment">** DL_POSITIONS_OFFSETS: [1 0[0,0,3 4,23,26] 1[17,102,105]] [3 1[5,20,23]]</span>
<a name="l06559"></a>06559 <span class="comment">**</span>
<a name="l06560"></a>06560 <span class="comment">** In each case the number after the outer &apos;[&apos; is the docid.  In the</span>
<a name="l06561"></a>06561 <span class="comment">** latter two cases, the number before the inner &apos;[&apos; is the column</span>
<a name="l06562"></a>06562 <span class="comment">** associated with the values within.  For DL_POSITIONS the numbers</span>
<a name="l06563"></a>06563 <span class="comment">** within are the positions, for DL_POSITIONS_OFFSETS they are the</span>
<a name="l06564"></a>06564 <span class="comment">** position, the start offset, and the end offset.</span>
<a name="l06565"></a>06565 <span class="comment">*/</span>
<a name="l06566"></a>06566 <span class="keyword">static</span> <span class="keywordtype">void</span> dumpDoclistFunc(
<a name="l06567"></a>06567   <a class="code" href="structsqlite3__context.html">sqlite3_context</a> *pContext,
<a name="l06568"></a>06568   <span class="keywordtype">int</span> argc, <a class="code" href="structMem.html">sqlite3_value</a> **argv
<a name="l06569"></a>06569 ){
<a name="l06570"></a>06570   <a class="code" href="structfulltext__cursor.html">fulltext_cursor</a> *pCursor;
<a name="l06571"></a>06571   <span class="keywordflow">if</span>( argc!=2 &amp;&amp; argc!=4 ){
<a name="l06572"></a>06572     generateError(pContext, <span class="stringliteral">&quot;dump_doclist&quot;</span>, <span class="stringliteral">&quot;incorrect arguments&quot;</span>);
<a name="l06573"></a>06573   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#aed137fb0d21554419bc7de5675057503">sqlite3_value_type</a>(argv[0])!=<a class="code" href="sqlite3_8h.html#a26c29a137b2a35bbde7048e5e48b794a">SQLITE_BLOB</a> ||
<a name="l06574"></a>06574             <a class="code" href="sqlite3_8h.html#a2aff2bf1311b5bd05d8e30738445b186">sqlite3_value_bytes</a>(argv[0])!=<span class="keyword">sizeof</span>(pCursor) ){
<a name="l06575"></a>06575     generateError(pContext, <span class="stringliteral">&quot;dump_doclist&quot;</span>, <span class="stringliteral">&quot;illegal first argument&quot;</span>);
<a name="l06576"></a>06576   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[1])==NULL ||
<a name="l06577"></a>06577             <a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[1])[0]==<span class="charliteral">&apos;\0&apos;</span> ){
<a name="l06578"></a>06578     generateError(pContext, <span class="stringliteral">&quot;dump_doclist&quot;</span>, <span class="stringliteral">&quot;empty second argument&quot;</span>);
<a name="l06579"></a>06579   }<span class="keywordflow">else</span>{
<a name="l06580"></a>06580     <span class="keyword">const</span> <span class="keywordtype">char</span> *pTerm = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)<a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(argv[1]);
<a name="l06581"></a>06581     <span class="keyword">const</span> <span class="keywordtype">int</span> nTerm = strlen(pTerm);
<a name="l06582"></a>06582     <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *v;
<a name="l06583"></a>06583     <span class="keywordtype">int</span> rc;
<a name="l06584"></a>06584     <a class="code" href="structDataBuffer.html">DataBuffer</a> doclist;
<a name="l06585"></a>06585 
<a name="l06586"></a>06586     memcpy(&amp;pCursor, <a class="code" href="sqlite3_8h.html#a81138be97f3e5124e33fb50925b710b6">sqlite3_value_blob</a>(argv[0]), <span class="keyword">sizeof</span>(pCursor));
<a name="l06587"></a>06587     v = <a class="code" href="fts2_8c.html#aebc0e65b2b59a9b0cf78f80fc453c840">cursor_vtab</a>(pCursor);
<a name="l06588"></a>06588 
<a name="l06589"></a>06589     <a class="code" href="fts2_8c.html#aff3e40084ad9f876b400eaa966692220">dataBufferInit</a>(&amp;doclist, 0);
<a name="l06590"></a>06590 
<a name="l06591"></a>06591     <span class="comment">/* termSelect() yields the same logical doclist that queries are</span>
<a name="l06592"></a>06592 <span class="comment">    ** run against.</span>
<a name="l06593"></a>06593 <span class="comment">    */</span>
<a name="l06594"></a>06594     <span class="keywordflow">if</span>( argc==2 ){
<a name="l06595"></a>06595       rc = <a class="code" href="fts2_8c.html#aa6bae5d86dd40972de224e7986a9450d">termSelect</a>(v, v-&gt;<a class="code" href="structfulltext__vtab.html#ac72f6f5f01f231103e198eb5ed0c188f">nColumn</a>, pTerm, nTerm, 0, <a class="code" href="fts1_8c.html#a70391ac551b05c2ea7dced856bae3ff4">DL_DEFAULT</a>, &amp;doclist);
<a name="l06596"></a>06596     }<span class="keywordflow">else</span>{
<a name="l06597"></a>06597       <a class="code" href="sqlite3_8h.html#af2a033da1327cdd77f0a174a09aedd0c">sqlite3_stmt</a> *s = NULL;
<a name="l06598"></a>06598 
<a name="l06599"></a>06599       <span class="comment">/* Get our specific segment&apos;s information. */</span>
<a name="l06600"></a>06600       rc = <a class="code" href="fts2_8c.html#a7e45aa2b1d2aed5ad8b6be35340cd1aa">sql_get_statement</a>(v, <a class="code" href="fts2_8c.html#a7db51187ce1214f4ed34fe3d2dfa3789a3756eca57cdc28e500ada182a256ac41">SEGDIR_SELECT_SEGMENT_STMT</a>, &amp;s);
<a name="l06601"></a>06601       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06602"></a>06602         rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 1, <a class="code" href="sqlite3_8h.html#af85c1bccdd78d4eefdcdb0136aaf9149">sqlite3_value_int</a>(argv[2]));
<a name="l06603"></a>06603         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06604"></a>06604           rc = <a class="code" href="sqlite3_8h.html#acb3c1ebeca0b79c87807bf9d7c13ae9c">sqlite3_bind_int</a>(s, 2, <a class="code" href="sqlite3_8h.html#af85c1bccdd78d4eefdcdb0136aaf9149">sqlite3_value_int</a>(argv[3]));
<a name="l06605"></a>06605         }
<a name="l06606"></a>06606       }
<a name="l06607"></a>06607 
<a name="l06608"></a>06608       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06609"></a>06609         rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l06610"></a>06610 
<a name="l06611"></a>06611         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l06612"></a>06612           <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;doclist);
<a name="l06613"></a>06613           generateError(pContext, <span class="stringliteral">&quot;dump_doclist&quot;</span>, <span class="stringliteral">&quot;segment not found&quot;</span>);
<a name="l06614"></a>06614           <span class="keywordflow">return</span>;
<a name="l06615"></a>06615         }
<a name="l06616"></a>06616 
<a name="l06617"></a>06617         <span class="comment">/* Found a segment, load it into doclist. */</span>
<a name="l06618"></a>06618         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a> ){
<a name="l06619"></a>06619           <span class="keyword">const</span> <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iLeavesEnd = <a class="code" href="sqlite3_8h.html#ab4682ca3ca98c59191beb769e0503ed1">sqlite3_column_int64</a>(s, 1);
<a name="l06620"></a>06620           <span class="keyword">const</span> <span class="keywordtype">char</span> *pData = <a class="code" href="sqlite3_8h.html#a5d8f43f1554039ceb9bec0bbffd63887">sqlite3_column_blob</a>(s, 2);
<a name="l06621"></a>06621           <span class="keyword">const</span> <span class="keywordtype">int</span> nData = <a class="code" href="sqlite3_8h.html#a139c52b22f8c1183edf7708fa291aec4">sqlite3_column_bytes</a>(s, 2);
<a name="l06622"></a>06622 
<a name="l06623"></a>06623           <span class="comment">/* loadSegment() is used by termSelect() to load each</span>
<a name="l06624"></a>06624 <span class="comment">          ** segment&apos;s data.</span>
<a name="l06625"></a>06625 <span class="comment">          */</span>
<a name="l06626"></a>06626           rc = <a class="code" href="fts2_8c.html#a18c8b542f9f0f319792e6178c64c6543">loadSegment</a>(v, pData, nData, iLeavesEnd, pTerm, nTerm, 0,
<a name="l06627"></a>06627                            &amp;doclist);
<a name="l06628"></a>06628           <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06629"></a>06629             rc = <a class="code" href="sqlite3_8h.html#ae04a3cf3ae391dabf1161cc0e040e9e8">sqlite3_step</a>(s);
<a name="l06630"></a>06630 
<a name="l06631"></a>06631             <span class="comment">/* Should not have more than one matching segment. */</span>
<a name="l06632"></a>06632             <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l06633"></a>06633               <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(s);
<a name="l06634"></a>06634               <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;doclist);
<a name="l06635"></a>06635               generateError(pContext, <span class="stringliteral">&quot;dump_doclist&quot;</span>, <span class="stringliteral">&quot;invalid segdir&quot;</span>);
<a name="l06636"></a>06636               <span class="keywordflow">return</span>;
<a name="l06637"></a>06637             }
<a name="l06638"></a>06638             rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l06639"></a>06639           }
<a name="l06640"></a>06640         }
<a name="l06641"></a>06641       }
<a name="l06642"></a>06642 
<a name="l06643"></a>06643       <a class="code" href="sqlite3_8h.html#a4f90cba6b396574cf3d5b1ac009de0c7">sqlite3_reset</a>(s);
<a name="l06644"></a>06644     }
<a name="l06645"></a>06645 
<a name="l06646"></a>06646     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06647"></a>06647       <span class="keywordflow">if</span>( doclist.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>&gt;0 ){
<a name="l06648"></a>06648         createDoclistResult(pContext, doclist.<a class="code" href="structDataBuffer.html#a7ce7b9e0393e8f7f4ab43dff880f3316">pData</a>, doclist.<a class="code" href="structDataBuffer.html#acd7410e0204142998c4351532a3a639d">nData</a>);
<a name="l06649"></a>06649       }<span class="keywordflow">else</span>{
<a name="l06650"></a>06650         <span class="comment">/* TODO(shess): This can happen if the term is not present, or</span>
<a name="l06651"></a>06651 <span class="comment">        ** if all instances of the term have been deleted and this is</span>
<a name="l06652"></a>06652 <span class="comment">        ** an all-index dump.  It may be interesting to distinguish</span>
<a name="l06653"></a>06653 <span class="comment">        ** these cases.</span>
<a name="l06654"></a>06654 <span class="comment">        */</span>
<a name="l06655"></a>06655         <a class="code" href="sqlite3_8h.html#a2dfd2d971e743b8d5a24725606a733ac">sqlite3_result_text</a>(pContext, <span class="stringliteral">&quot;&quot;</span>, 0, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l06656"></a>06656       }
<a name="l06657"></a>06657     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a> ){
<a name="l06658"></a>06658       <span class="comment">/* Handle out-of-memory cases specially because if they are</span>
<a name="l06659"></a>06659 <span class="comment">      ** generated in fts2 code they may not be reflected in the db</span>
<a name="l06660"></a>06660 <span class="comment">      ** handle.</span>
<a name="l06661"></a>06661 <span class="comment">      */</span>
<a name="l06662"></a>06662       <span class="comment">/* TODO(shess): Handle this more comprehensively.</span>
<a name="l06663"></a>06663 <span class="comment">      ** sqlite3ErrStr() has what I need, but is internal.</span>
<a name="l06664"></a>06664 <span class="comment">      */</span>
<a name="l06665"></a>06665       generateError(pContext, <span class="stringliteral">&quot;dump_doclist&quot;</span>, <span class="stringliteral">&quot;out of memory&quot;</span>);
<a name="l06666"></a>06666     }<span class="keywordflow">else</span>{
<a name="l06667"></a>06667       generateError(pContext, <span class="stringliteral">&quot;dump_doclist&quot;</span>, NULL);
<a name="l06668"></a>06668     }
<a name="l06669"></a>06669 
<a name="l06670"></a>06670     <a class="code" href="fts2_8c.html#af80e60676efa441178b1610cf8bfe66a">dataBufferDestroy</a>(&amp;doclist);
<a name="l06671"></a>06671   }
<a name="l06672"></a>06672 }
<a name="l06673"></a>06673 <span class="preprocessor">#endif</span>
<a name="l06674"></a>06674 <span class="preprocessor"></span>
<a name="l06675"></a>06675 <span class="comment">/*</span>
<a name="l06676"></a>06676 <span class="comment">** This routine implements the xFindFunction method for the FTS2</span>
<a name="l06677"></a>06677 <span class="comment">** virtual table.</span>
<a name="l06678"></a>06678 <span class="comment">*/</span>
<a name="l06679"></a><a class="code" href="fts2_8c.html#a7cb32fb10372dfd938ed8fe350c6be86">06679</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a7cb32fb10372dfd938ed8fe350c6be86">fulltextFindFunction</a>(
<a name="l06680"></a>06680   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab,
<a name="l06681"></a>06681   <span class="keywordtype">int</span> nArg,
<a name="l06682"></a>06682   <span class="keyword">const</span> <span class="keywordtype">char</span> *zName,
<a name="l06683"></a>06683   <span class="keywordtype">void</span> (**pxFunc)(<a class="code" href="structsqlite3__context.html">sqlite3_context</a>*,<span class="keywordtype">int</span>,<a class="code" href="structMem.html">sqlite3_value</a>**),
<a name="l06684"></a>06684   <span class="keywordtype">void</span> **ppArg
<a name="l06685"></a>06685 ){
<a name="l06686"></a>06686   <span class="keywordflow">if</span>( strcmp(zName,<span class="stringliteral">&quot;snippet&quot;</span>)==0 ){
<a name="l06687"></a>06687     *pxFunc = <a class="code" href="fts2_8c.html#a57b1d2e6eb52243a8c4a2a32f238dc03">snippetFunc</a>;
<a name="l06688"></a>06688     <span class="keywordflow">return</span> 1;
<a name="l06689"></a>06689   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( strcmp(zName,<span class="stringliteral">&quot;offsets&quot;</span>)==0 ){
<a name="l06690"></a>06690     *pxFunc = <a class="code" href="fts2_8c.html#a3f6879fa82ea5cee0633e4f0c2acb89e">snippetOffsetsFunc</a>;
<a name="l06691"></a>06691     <span class="keywordflow">return</span> 1;
<a name="l06692"></a>06692   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( strcmp(zName,<span class="stringliteral">&quot;optimize&quot;</span>)==0 ){
<a name="l06693"></a>06693     *pxFunc = <a class="code" href="fts2_8c.html#a667787b2b48cc3fe4970cf220d7f161d">optimizeFunc</a>;
<a name="l06694"></a>06694     <span class="keywordflow">return</span> 1;
<a name="l06695"></a>06695 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l06696"></a>06696 <span class="preprocessor"></span>    <span class="comment">/* NOTE(shess): These functions are present only for testing</span>
<a name="l06697"></a>06697 <span class="comment">    ** purposes.  No particular effort is made to optimize their</span>
<a name="l06698"></a>06698 <span class="comment">    ** execution or how they build their results.</span>
<a name="l06699"></a>06699 <span class="comment">    */</span>
<a name="l06700"></a>06700   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( strcmp(zName,<span class="stringliteral">&quot;dump_terms&quot;</span>)==0 ){
<a name="l06701"></a>06701     <span class="comment">/* fprintf(stderr, &quot;Found dump_terms\n&quot;); */</span>
<a name="l06702"></a>06702     *pxFunc = dumpTermsFunc;
<a name="l06703"></a>06703     <span class="keywordflow">return</span> 1;
<a name="l06704"></a>06704   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( strcmp(zName,<span class="stringliteral">&quot;dump_doclist&quot;</span>)==0 ){
<a name="l06705"></a>06705     <span class="comment">/* fprintf(stderr, &quot;Found dump_doclist\n&quot;); */</span>
<a name="l06706"></a>06706     *pxFunc = dumpDoclistFunc;
<a name="l06707"></a>06707     <span class="keywordflow">return</span> 1;
<a name="l06708"></a>06708 <span class="preprocessor">#endif</span>
<a name="l06709"></a>06709 <span class="preprocessor"></span>  }
<a name="l06710"></a>06710   <span class="keywordflow">return</span> 0;
<a name="l06711"></a>06711 }
<a name="l06712"></a>06712 
<a name="l06713"></a>06713 <span class="comment">/*</span>
<a name="l06714"></a>06714 <span class="comment">** Rename an fts2 table.</span>
<a name="l06715"></a>06715 <span class="comment">*/</span>
<a name="l06716"></a><a class="code" href="fts2_8c.html#a960164105e1dc37b37c8bde9edac2bfc">06716</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#a960164105e1dc37b37c8bde9edac2bfc">fulltextRename</a>(
<a name="l06717"></a>06717   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab,
<a name="l06718"></a>06718   <span class="keyword">const</span> <span class="keywordtype">char</span> *zName
<a name="l06719"></a>06719 ){
<a name="l06720"></a>06720   <a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *p = (<a class="code" href="structfulltext__vtab.html">fulltext_vtab</a> *)pVtab;
<a name="l06721"></a>06721   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l06722"></a>06722   <span class="keywordtype">char</span> *zSql = <a class="code" href="printf_8c.html#a708f6775f57f33c17e982512a00df665">sqlite3_mprintf</a>(
<a name="l06723"></a>06723     <span class="stringliteral">&quot;ALTER TABLE %Q.&apos;%q_content&apos;  RENAME TO &apos;%q_content&apos;;&quot;</span>
<a name="l06724"></a>06724     <span class="stringliteral">&quot;ALTER TABLE %Q.&apos;%q_segments&apos; RENAME TO &apos;%q_segments&apos;;&quot;</span>
<a name="l06725"></a>06725     <span class="stringliteral">&quot;ALTER TABLE %Q.&apos;%q_segdir&apos;   RENAME TO &apos;%q_segdir&apos;;&quot;</span>
<a name="l06726"></a>06726     , p-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, p-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, zName 
<a name="l06727"></a>06727     , p-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, p-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, zName 
<a name="l06728"></a>06728     , p-&gt;<a class="code" href="structfulltext__vtab.html#a7fc1014edddede46e4ccfd9b7a584989">zDb</a>, p-&gt;<a class="code" href="structfulltext__vtab.html#a7571c00e7ed68e398e6ea0707237867c">zName</a>, zName
<a name="l06729"></a>06729   );
<a name="l06730"></a>06730   <span class="keywordflow">if</span>( zSql ){
<a name="l06731"></a>06731     rc = <a class="code" href="legacy_8c.html#ada787486cf95a994521cfd0c64e853e4">sqlite3_exec</a>(p-&gt;<a class="code" href="structfulltext__vtab.html#af6f85a1105b4ec18d08d4c2fa5acf673">db</a>, zSql, 0, 0, 0);
<a name="l06732"></a>06732     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zSql);
<a name="l06733"></a>06733   }
<a name="l06734"></a>06734   <span class="keywordflow">return</span> rc;
<a name="l06735"></a>06735 }
<a name="l06736"></a>06736 
<a name="l06737"></a>06737 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> fts2Module = {
<a name="l06738"></a>06738   <span class="comment">/* iVersion      */</span> 0,
<a name="l06739"></a>06739   <span class="comment">/* xCreate       */</span> <a class="code" href="fts2_8c.html#a0d5b27c0376561066f14ab3a59d8b6a2">fulltextCreate</a>,
<a name="l06740"></a>06740   <span class="comment">/* xConnect      */</span> <a class="code" href="fts2_8c.html#a42d060bb429eb8ae7a86e9042b4fb232">fulltextConnect</a>,
<a name="l06741"></a>06741   <span class="comment">/* xBestIndex    */</span> <a class="code" href="fts2_8c.html#abf18e0da44ece3b370a714c8e95e2de6">fulltextBestIndex</a>,
<a name="l06742"></a>06742   <span class="comment">/* xDisconnect   */</span> <a class="code" href="fts2_8c.html#a8314ee27dd1e598b803db35bf1aa393d">fulltextDisconnect</a>,
<a name="l06743"></a>06743   <span class="comment">/* xDestroy      */</span> <a class="code" href="fts2_8c.html#ace0e89f70928f42ce6dc7769c8309ba6">fulltextDestroy</a>,
<a name="l06744"></a>06744   <span class="comment">/* xOpen         */</span> <a class="code" href="fts2_8c.html#a124d1580023f422308936a6fad63ce4f">fulltextOpen</a>,
<a name="l06745"></a>06745   <span class="comment">/* xClose        */</span> <a class="code" href="fts2_8c.html#ae78b3ae93fcfb9b8b2e8b4dc9a380ad7">fulltextClose</a>,
<a name="l06746"></a>06746   <span class="comment">/* xFilter       */</span> <a class="code" href="fts2_8c.html#a77f0a9cad4b0dcb1a60143d08036b466">fulltextFilter</a>,
<a name="l06747"></a>06747   <span class="comment">/* xNext         */</span> <a class="code" href="fts2_8c.html#a27014ab01a3b771ad685bf0a66ae0f74">fulltextNext</a>,
<a name="l06748"></a>06748   <span class="comment">/* xEof          */</span> <a class="code" href="fts2_8c.html#a04b7b39869da7e2457f1605884eaada7">fulltextEof</a>,
<a name="l06749"></a>06749   <span class="comment">/* xColumn       */</span> <a class="code" href="fts2_8c.html#a1150d2b45c324680b8f663999690251f">fulltextColumn</a>,
<a name="l06750"></a>06750   <span class="comment">/* xRowid        */</span> <a class="code" href="fts2_8c.html#a4ede5546134709d20eed03b0b16c85e1">fulltextRowid</a>,
<a name="l06751"></a>06751   <span class="comment">/* xUpdate       */</span> <a class="code" href="fts2_8c.html#a8e291fd12023cffe80976a33530e839d">fulltextUpdate</a>,
<a name="l06752"></a>06752   <span class="comment">/* xBegin        */</span> <a class="code" href="fts2_8c.html#af3886601e4f6c64a5db1ba163ac3acdb">fulltextBegin</a>,
<a name="l06753"></a>06753   <span class="comment">/* xSync         */</span> <a class="code" href="fts2_8c.html#ae5aa5c271805b6239b93f217a15ad527">fulltextSync</a>,
<a name="l06754"></a>06754   <span class="comment">/* xCommit       */</span> <a class="code" href="fts2_8c.html#a690130dfc7a5ce5f50554fee442598f3">fulltextCommit</a>,
<a name="l06755"></a>06755   <span class="comment">/* xRollback     */</span> <a class="code" href="fts2_8c.html#a1471cac8645cdd390f8a36774a4c91bf">fulltextRollback</a>,
<a name="l06756"></a>06756   <span class="comment">/* xFindFunction */</span> <a class="code" href="fts2_8c.html#a7cb32fb10372dfd938ed8fe350c6be86">fulltextFindFunction</a>,
<a name="l06757"></a>06757   <span class="comment">/* xRename */</span>       <a class="code" href="fts2_8c.html#a960164105e1dc37b37c8bde9edac2bfc">fulltextRename</a>,
<a name="l06758"></a>06758 };
<a name="l06759"></a>06759 
<a name="l06760"></a><a class="code" href="fts2_8c.html#aab090d781363354bfeda763f0027eae1">06760</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#aab090d781363354bfeda763f0027eae1">hashDestroy</a>(<span class="keywordtype">void</span> *p){
<a name="l06761"></a>06761   <a class="code" href="structfts2Hash.html">fts2Hash</a> *pHash = (<a class="code" href="structfts2Hash.html">fts2Hash</a> *)p;
<a name="l06762"></a>06762   <a class="code" href="fts2__hash_8c.html#ae418104a453b340caac3f68e8972a88f">sqlite3Fts2HashClear</a>(pHash);
<a name="l06763"></a>06763   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pHash);
<a name="l06764"></a>06764 }
<a name="l06765"></a>06765 
<a name="l06766"></a>06766 <span class="comment">/*</span>
<a name="l06767"></a>06767 <span class="comment">** The fts2 built-in tokenizers - &quot;simple&quot; and &quot;porter&quot; - are implemented</span>
<a name="l06768"></a>06768 <span class="comment">** in files fts2_tokenizer1.c and fts2_porter.c respectively. The following</span>
<a name="l06769"></a>06769 <span class="comment">** two forward declarations are for functions declared in these files</span>
<a name="l06770"></a>06770 <span class="comment">** used to retrieve the respective implementations.</span>
<a name="l06771"></a>06771 <span class="comment">**</span>
<a name="l06772"></a>06772 <span class="comment">** Calling sqlite3Fts2SimpleTokenizerModule() sets the value pointed</span>
<a name="l06773"></a>06773 <span class="comment">** to by the argument to point a the &quot;simple&quot; tokenizer implementation.</span>
<a name="l06774"></a>06774 <span class="comment">** Function ...PorterTokenizerModule() sets *pModule to point to the</span>
<a name="l06775"></a>06775 <span class="comment">** porter tokenizer/stemmer implementation.</span>
<a name="l06776"></a>06776 <span class="comment">*/</span>
<a name="l06777"></a>06777 <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a4e23ab971c4dd9877841a543d8691399">sqlite3Fts2SimpleTokenizerModule</a>(<a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> <span class="keyword">const</span>**ppModule);
<a name="l06778"></a>06778 <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a960ad2db6f2f08461170dc5834c4313d">sqlite3Fts2PorterTokenizerModule</a>(<a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> <span class="keyword">const</span>**ppModule);
<a name="l06779"></a>06779 <span class="keywordtype">void</span> <a class="code" href="fts2_8c.html#a518fd0740b9a675ca70d5084fed37bbe">sqlite3Fts2IcuTokenizerModule</a>(<a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> <span class="keyword">const</span>**ppModule);
<a name="l06780"></a>06780 
<a name="l06781"></a>06781 <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#acb2f6a98887a7c5c022afe1b7d317543">sqlite3Fts2InitHashTable</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *, <a class="code" href="structfts2Hash.html">fts2Hash</a> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l06782"></a>06782 
<a name="l06783"></a>06783 <span class="comment">/*</span>
<a name="l06784"></a>06784 <span class="comment">** Initialise the fts2 extension. If this extension is built as part</span>
<a name="l06785"></a>06785 <span class="comment">** of the sqlite library, then this function is called directly by</span>
<a name="l06786"></a>06786 <span class="comment">** SQLite. If fts2 is built as a dynamically loadable extension, this</span>
<a name="l06787"></a>06787 <span class="comment">** function is called by the sqlite3_extension_init() entry point.</span>
<a name="l06788"></a>06788 <span class="comment">*/</span>
<a name="l06789"></a><a class="code" href="fts2_8h.html#add2936d592337ec982c1a3c83b907a09">06789</a> <span class="keywordtype">int</span> <a class="code" href="fts2_8c.html#add2936d592337ec982c1a3c83b907a09">sqlite3Fts2Init</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>){
<a name="l06790"></a>06790   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l06791"></a>06791   <a class="code" href="structfts2Hash.html">fts2Hash</a> *pHash = 0;
<a name="l06792"></a>06792   <span class="keyword">const</span> <a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *pSimple = 0;
<a name="l06793"></a>06793   <span class="keyword">const</span> <a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *pPorter = 0;
<a name="l06794"></a>06794   <span class="keyword">const</span> <a class="code" href="structsqlite3__tokenizer__module.html">sqlite3_tokenizer_module</a> *pIcu = 0;
<a name="l06795"></a>06795 
<a name="l06796"></a>06796   <a class="code" href="fts2_8c.html#a4e23ab971c4dd9877841a543d8691399">sqlite3Fts2SimpleTokenizerModule</a>(&amp;pSimple);
<a name="l06797"></a>06797   <a class="code" href="fts2_8c.html#a960ad2db6f2f08461170dc5834c4313d">sqlite3Fts2PorterTokenizerModule</a>(&amp;pPorter);
<a name="l06798"></a>06798 <span class="preprocessor">#ifdef SQLITE_ENABLE_ICU</span>
<a name="l06799"></a>06799 <span class="preprocessor"></span>  <a class="code" href="fts2_8c.html#a518fd0740b9a675ca70d5084fed37bbe">sqlite3Fts2IcuTokenizerModule</a>(&amp;pIcu);
<a name="l06800"></a>06800 <span class="preprocessor">#endif</span>
<a name="l06801"></a>06801 <span class="preprocessor"></span>
<a name="l06802"></a>06802   <span class="comment">/* Allocate and initialise the hash-table used to store tokenizers. */</span>
<a name="l06803"></a>06803   pHash = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="structfts2Hash.html">fts2Hash</a>));
<a name="l06804"></a>06804   <span class="keywordflow">if</span>( !pHash ){
<a name="l06805"></a>06805     rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l06806"></a>06806   }<span class="keywordflow">else</span>{
<a name="l06807"></a>06807     <a class="code" href="fts2__hash_8c.html#a12107e26db4496f65b40f888b62fd9b7">sqlite3Fts2HashInit</a>(pHash, <a class="code" href="fts2__hash_8h.html#a32d375e016bc4f8e368ca7a8a2bff48b">FTS2_HASH_STRING</a>, 1);
<a name="l06808"></a>06808   }
<a name="l06809"></a>06809 
<a name="l06810"></a>06810   <span class="comment">/* Load the built-in tokenizers into the hash table */</span>
<a name="l06811"></a>06811   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06812"></a>06812     <span class="keywordflow">if</span>( <a class="code" href="fts2__hash_8c.html#ac35c0c4fb1cb817018b7778db3047d8f">sqlite3Fts2HashInsert</a>(pHash, <span class="stringliteral">&quot;simple&quot;</span>, 7, (<span class="keywordtype">void</span> *)pSimple)
<a name="l06813"></a>06813      || <a class="code" href="fts2__hash_8c.html#ac35c0c4fb1cb817018b7778db3047d8f">sqlite3Fts2HashInsert</a>(pHash, <span class="stringliteral">&quot;porter&quot;</span>, 7, (<span class="keywordtype">void</span> *)pPorter) 
<a name="l06814"></a>06814      || (pIcu &amp;&amp; <a class="code" href="fts2__hash_8c.html#ac35c0c4fb1cb817018b7778db3047d8f">sqlite3Fts2HashInsert</a>(pHash, <span class="stringliteral">&quot;icu&quot;</span>, 4, (<span class="keywordtype">void</span> *)pIcu))
<a name="l06815"></a>06815     ){
<a name="l06816"></a>06816       rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l06817"></a>06817     }
<a name="l06818"></a>06818   }
<a name="l06819"></a>06819 
<a name="l06820"></a>06820   <span class="comment">/* Create the virtual table wrapper around the hash-table and overload </span>
<a name="l06821"></a>06821 <span class="comment">  ** the two scalar functions. If this is successful, register the</span>
<a name="l06822"></a>06822 <span class="comment">  ** module with sqlite.</span>
<a name="l06823"></a>06823 <span class="comment">  */</span>
<a name="l06824"></a>06824   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==rc 
<a name="l06825"></a>06825    &amp;&amp; <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==(rc = <a class="code" href="fts2_8c.html#acb2f6a98887a7c5c022afe1b7d317543">sqlite3Fts2InitHashTable</a>(db, pHash, <span class="stringliteral">&quot;fts2_tokenizer&quot;</span>))
<a name="l06826"></a>06826    &amp;&amp; <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==(rc = <a class="code" href="main_8c.html#a6bb015d93679bb25951ed1ce935a4261">sqlite3_overload_function</a>(db, <span class="stringliteral">&quot;snippet&quot;</span>, -1))
<a name="l06827"></a>06827    &amp;&amp; <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==(rc = <a class="code" href="main_8c.html#a6bb015d93679bb25951ed1ce935a4261">sqlite3_overload_function</a>(db, <span class="stringliteral">&quot;offsets&quot;</span>, -1))
<a name="l06828"></a>06828    &amp;&amp; <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==(rc = <a class="code" href="main_8c.html#a6bb015d93679bb25951ed1ce935a4261">sqlite3_overload_function</a>(db, <span class="stringliteral">&quot;optimize&quot;</span>, -1))
<a name="l06829"></a>06829 #ifdef SQLITE_TEST
<a name="l06830"></a>06830    &amp;&amp; <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==(rc = <a class="code" href="main_8c.html#a6bb015d93679bb25951ed1ce935a4261">sqlite3_overload_function</a>(db, <span class="stringliteral">&quot;dump_terms&quot;</span>, -1))
<a name="l06831"></a>06831    &amp;&amp; <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==(rc = <a class="code" href="main_8c.html#a6bb015d93679bb25951ed1ce935a4261">sqlite3_overload_function</a>(db, <span class="stringliteral">&quot;dump_doclist&quot;</span>, -1))
<a name="l06832"></a>06832 #endif
<a name="l06833"></a>06833   ){
<a name="l06834"></a>06834     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a721d3b2e12b6c39cf4bb21b678c403ce">sqlite3_create_module_v2</a>(
<a name="l06835"></a>06835         db, <span class="stringliteral">&quot;fts2&quot;</span>, &amp;fts2Module, (<span class="keywordtype">void</span> *)pHash, <a class="code" href="fts2_8c.html#aab090d781363354bfeda763f0027eae1">hashDestroy</a>
<a name="l06836"></a>06836     );
<a name="l06837"></a>06837   }
<a name="l06838"></a>06838 
<a name="l06839"></a>06839   <span class="comment">/* An error has occured. Delete the hash table and return the error code. */</span>
<a name="l06840"></a>06840   assert( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> );
<a name="l06841"></a>06841   <span class="keywordflow">if</span>( pHash ){
<a name="l06842"></a>06842     <a class="code" href="fts2__hash_8c.html#ae418104a453b340caac3f68e8972a88f">sqlite3Fts2HashClear</a>(pHash);
<a name="l06843"></a>06843     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pHash);
<a name="l06844"></a>06844   }
<a name="l06845"></a>06845   <span class="keywordflow">return</span> rc;
<a name="l06846"></a>06846 }
<a name="l06847"></a>06847 
<a name="l06848"></a>06848 <span class="preprocessor">#if !SQLITE_CORE</span>
<a name="l06849"></a><a class="code" href="fts2_8c.html#aa42ef32f7f9c08b35a1c1984e1006606">06849</a> <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="fts1_8c.html#aa42ef32f7f9c08b35a1c1984e1006606">sqlite3_extension_init</a>(
<a name="l06850"></a>06850   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, 
<a name="l06851"></a>06851   <span class="keywordtype">char</span> **pzErrMsg,
<a name="l06852"></a>06852   <span class="keyword">const</span> <a class="code" href="structsqlite3__api__routines.html">sqlite3_api_routines</a> *pApi
<a name="l06853"></a>06853 ){
<a name="l06854"></a>06854   <a class="code" href="sqlite3ext_8h.html#a472c32f7c8217246a63b2bceb680d273">SQLITE_EXTENSION_INIT2</a>(pApi)
<a name="l06855"></a>06855   <span class="keywordflow">return</span> <a class="code" href="fts2_8c.html#add2936d592337ec982c1a3c83b907a09">sqlite3Fts2Init</a>(db);
<a name="l06856"></a>06856 }
<a name="l06857"></a>06857 <span class="preprocessor">#endif</span>
<a name="l06858"></a>06858 <span class="preprocessor"></span>
<a name="l06859"></a>06859 <span class="preprocessor">#endif </span><span class="comment">/* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS2) */</span>
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:53 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
