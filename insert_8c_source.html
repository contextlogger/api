<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: insert.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>insert.c</h1><a href="insert_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">** 2001 September 15</span>
<a name="l00003"></a>00003 <span class="comment">**</span>
<a name="l00004"></a>00004 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00005"></a>00005 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00006"></a>00006 <span class="comment">**</span>
<a name="l00007"></a>00007 <span class="comment">**    May you do good and not evil.</span>
<a name="l00008"></a>00008 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00009"></a>00009 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">*************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment">** This file contains C code routines that are called by the parser</span>
<a name="l00013"></a>00013 <span class="comment">** to handle INSERT statements in SQLite.</span>
<a name="l00014"></a>00014 <span class="comment">**</span>
<a name="l00015"></a>00015 <span class="comment">** $Id: insert.c,v 1.251 2008/11/03 20:55:07 drh Exp $</span>
<a name="l00016"></a>00016 <span class="comment">*/</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;<a class="code" href="sqliteInt_8h.html">sqliteInt.h</a>&quot;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">/*</span>
<a name="l00020"></a>00020 <span class="comment">** Set P4 of the most recently inserted opcode to a column affinity</span>
<a name="l00021"></a>00021 <span class="comment">** string for index pIdx. A column affinity string has one character</span>
<a name="l00022"></a>00022 <span class="comment">** for each column in the table, according to the affinity of the column:</span>
<a name="l00023"></a>00023 <span class="comment">**</span>
<a name="l00024"></a>00024 <span class="comment">**  Character      Column affinity</span>
<a name="l00025"></a>00025 <span class="comment">**  ------------------------------</span>
<a name="l00026"></a>00026 <span class="comment">**  &apos;a&apos;            TEXT</span>
<a name="l00027"></a>00027 <span class="comment">**  &apos;b&apos;            NONE</span>
<a name="l00028"></a>00028 <span class="comment">**  &apos;c&apos;            NUMERIC</span>
<a name="l00029"></a>00029 <span class="comment">**  &apos;d&apos;            INTEGER</span>
<a name="l00030"></a>00030 <span class="comment">**  &apos;e&apos;            REAL</span>
<a name="l00031"></a>00031 <span class="comment">**</span>
<a name="l00032"></a>00032 <span class="comment">** An extra &apos;b&apos; is appended to the end of the string to cover the</span>
<a name="l00033"></a>00033 <span class="comment">** rowid that appears as the last column in every index.</span>
<a name="l00034"></a>00034 <span class="comment">*/</span>
<a name="l00035"></a><a class="code" href="sqliteInt_8h.html#a47475e702ec2e47bed90c5ffe44022a9">00035</a> <span class="keywordtype">void</span> <a class="code" href="insert_8c.html#ad02fc8bcec6054484efe92ff3cd6ab34">sqlite3IndexAffinityStr</a>(<a class="code" href="structVdbe.html">Vdbe</a> *v, <a class="code" href="structIndex.html">Index</a> *pIdx){
<a name="l00036"></a>00036   <span class="keywordflow">if</span>( !pIdx-&gt;<a class="code" href="structIndex.html#af076df9f74dd836001c0a59d27274c0e">zColAff</a> ){
<a name="l00037"></a>00037     <span class="comment">/* The first time a column affinity string for a particular index is</span>
<a name="l00038"></a>00038 <span class="comment">    ** required, it is allocated and populated here. It is then stored as</span>
<a name="l00039"></a>00039 <span class="comment">    ** a member of the Index structure for subsequent use.</span>
<a name="l00040"></a>00040 <span class="comment">    **</span>
<a name="l00041"></a>00041 <span class="comment">    ** The column affinity string will eventually be deleted by</span>
<a name="l00042"></a>00042 <span class="comment">    ** sqliteDeleteIndex() when the Index structure itself is cleaned</span>
<a name="l00043"></a>00043 <span class="comment">    ** up.</span>
<a name="l00044"></a>00044 <span class="comment">    */</span>
<a name="l00045"></a>00045     <span class="keywordtype">int</span> n;
<a name="l00046"></a>00046     <a class="code" href="structTable.html">Table</a> *pTab = pIdx-&gt;<a class="code" href="structIndex.html#a01c6d4da27cba325ca58f333f87a6f44">pTable</a>;
<a name="l00047"></a>00047     <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = <a class="code" href="vdbe_8h.html#af0e1e3c12dca9f250170460e88bccdad">sqlite3VdbeDb</a>(v);
<a name="l00048"></a>00048     pIdx-&gt;<a class="code" href="structIndex.html#af076df9f74dd836001c0a59d27274c0e">zColAff</a> = (<span class="keywordtype">char</span> *)<a class="code" href="malloc_8c.html#a8c1a33577a57524c7c6eef3d9e64e742">sqlite3Malloc</a>(pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>+2);
<a name="l00049"></a>00049     <span class="keywordflow">if</span>( !pIdx-&gt;<a class="code" href="structIndex.html#af076df9f74dd836001c0a59d27274c0e">zColAff</a> ){
<a name="l00050"></a>00050       db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l00051"></a>00051       <span class="keywordflow">return</span>;
<a name="l00052"></a>00052     }
<a name="l00053"></a>00053     <span class="keywordflow">for</span>(n=0; n&lt;pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>; n++){
<a name="l00054"></a>00054       pIdx-&gt;<a class="code" href="structIndex.html#af076df9f74dd836001c0a59d27274c0e">zColAff</a>[n] = pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[pIdx-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[n]].<a class="code" href="structColumn.html#ac9d6fe31c45888cecaf3f5ad5b93bf23">affinity</a>;
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056     pIdx-&gt;<a class="code" href="structIndex.html#af076df9f74dd836001c0a59d27274c0e">zColAff</a>[n++] = <a class="code" href="sqliteInt_8h.html#a1173a38e4836a42c0a7992df894a0972">SQLITE_AFF_NONE</a>;
<a name="l00057"></a>00057     pIdx-&gt;<a class="code" href="structIndex.html#af076df9f74dd836001c0a59d27274c0e">zColAff</a>[n] = 0;
<a name="l00058"></a>00058   }
<a name="l00059"></a>00059  
<a name="l00060"></a>00060   <a class="code" href="vdbe_8h.html#a0417c7b01c7f0c8d93910a5dc00965ce">sqlite3VdbeChangeP4</a>(v, -1, pIdx-&gt;<a class="code" href="structIndex.html#af076df9f74dd836001c0a59d27274c0e">zColAff</a>, 0);
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">/*</span>
<a name="l00064"></a>00064 <span class="comment">** Set P4 of the most recently inserted opcode to a column affinity</span>
<a name="l00065"></a>00065 <span class="comment">** string for table pTab. A column affinity string has one character</span>
<a name="l00066"></a>00066 <span class="comment">** for each column indexed by the index, according to the affinity of the</span>
<a name="l00067"></a>00067 <span class="comment">** column:</span>
<a name="l00068"></a>00068 <span class="comment">**</span>
<a name="l00069"></a>00069 <span class="comment">**  Character      Column affinity</span>
<a name="l00070"></a>00070 <span class="comment">**  ------------------------------</span>
<a name="l00071"></a>00071 <span class="comment">**  &apos;a&apos;            TEXT</span>
<a name="l00072"></a>00072 <span class="comment">**  &apos;b&apos;            NONE</span>
<a name="l00073"></a>00073 <span class="comment">**  &apos;c&apos;            NUMERIC</span>
<a name="l00074"></a>00074 <span class="comment">**  &apos;d&apos;            INTEGER</span>
<a name="l00075"></a>00075 <span class="comment">**  &apos;e&apos;            REAL</span>
<a name="l00076"></a>00076 <span class="comment">*/</span>
<a name="l00077"></a><a class="code" href="sqliteInt_8h.html#a5db4e210e9f26f26056813d4741bec16">00077</a> <span class="keywordtype">void</span> <a class="code" href="insert_8c.html#ad89a146ebc8b75355716cb0f2fd513c6">sqlite3TableAffinityStr</a>(<a class="code" href="structVdbe.html">Vdbe</a> *v, <a class="code" href="structTable.html">Table</a> *pTab){
<a name="l00078"></a>00078   <span class="comment">/* The first time a column affinity string for a particular table</span>
<a name="l00079"></a>00079 <span class="comment">  ** is required, it is allocated and populated here. It is then </span>
<a name="l00080"></a>00080 <span class="comment">  ** stored as a member of the Table structure for subsequent use.</span>
<a name="l00081"></a>00081 <span class="comment">  **</span>
<a name="l00082"></a>00082 <span class="comment">  ** The column affinity string will eventually be deleted by</span>
<a name="l00083"></a>00083 <span class="comment">  ** sqlite3DeleteTable() when the Table structure itself is cleaned up.</span>
<a name="l00084"></a>00084 <span class="comment">  */</span>
<a name="l00085"></a>00085   <span class="keywordflow">if</span>( !pTab-&gt;<a class="code" href="structTable.html#ac95c0c7b04f2c8367beb98d386d4228f">zColAff</a> ){
<a name="l00086"></a>00086     <span class="keywordtype">char</span> *zColAff;
<a name="l00087"></a>00087     <span class="keywordtype">int</span> i;
<a name="l00088"></a>00088     <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = <a class="code" href="vdbe_8h.html#af0e1e3c12dca9f250170460e88bccdad">sqlite3VdbeDb</a>(v);
<a name="l00089"></a>00089 
<a name="l00090"></a>00090     zColAff = (<span class="keywordtype">char</span> *)<a class="code" href="malloc_8c.html#a8c1a33577a57524c7c6eef3d9e64e742">sqlite3Malloc</a>(pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>+1);
<a name="l00091"></a>00091     <span class="keywordflow">if</span>( !zColAff ){
<a name="l00092"></a>00092       db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l00093"></a>00093       <span class="keywordflow">return</span>;
<a name="l00094"></a>00094     }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096     <span class="keywordflow">for</span>(i=0; i&lt;pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>; i++){
<a name="l00097"></a>00097       zColAff[i] = pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#ac9d6fe31c45888cecaf3f5ad5b93bf23">affinity</a>;
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099     zColAff[pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101     pTab-&gt;<a class="code" href="structTable.html#ac95c0c7b04f2c8367beb98d386d4228f">zColAff</a> = zColAff;
<a name="l00102"></a>00102   }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <a class="code" href="vdbe_8h.html#a0417c7b01c7f0c8d93910a5dc00965ce">sqlite3VdbeChangeP4</a>(v, -1, pTab-&gt;<a class="code" href="structTable.html#ac95c0c7b04f2c8367beb98d386d4228f">zColAff</a>, 0);
<a name="l00105"></a>00105 }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="comment">/*</span>
<a name="l00108"></a>00108 <span class="comment">** Return non-zero if the table pTab in database iDb or any of its indices</span>
<a name="l00109"></a>00109 <span class="comment">** have been opened at any point in the VDBE program beginning at location</span>
<a name="l00110"></a>00110 <span class="comment">** iStartAddr throught the end of the program.  This is used to see if </span>
<a name="l00111"></a>00111 <span class="comment">** a statement of the form  &quot;INSERT INTO &lt;iDb, pTab&gt; SELECT ...&quot; can </span>
<a name="l00112"></a>00112 <span class="comment">** run without using temporary table for the results of the SELECT. </span>
<a name="l00113"></a>00113 <span class="comment">*/</span>
<a name="l00114"></a><a class="code" href="insert_8c.html#a21e21a8360113641ae60122a35b9556b">00114</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="insert_8c.html#a21e21a8360113641ae60122a35b9556b">readsTable</a>(<a class="code" href="structVdbe.html">Vdbe</a> *v, <span class="keywordtype">int</span> iStartAddr, <span class="keywordtype">int</span> iDb, <a class="code" href="structTable.html">Table</a> *pTab){
<a name="l00115"></a>00115   <span class="keywordtype">int</span> i;
<a name="l00116"></a>00116   <span class="keywordtype">int</span> iEnd = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l00117"></a>00117   <span class="keywordflow">for</span>(i=iStartAddr; i&lt;iEnd; i++){
<a name="l00118"></a>00118     <a class="code" href="structVdbeOp.html">VdbeOp</a> *pOp = <a class="code" href="vdbe_8h.html#a1badd052381dc9cd17422bcc7e09db43">sqlite3VdbeGetOp</a>(v, i);
<a name="l00119"></a>00119     assert( pOp!=0 );
<a name="l00120"></a>00120     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a0c72fbe4989449cdc9a69e1bbb2e91c2">OP_OpenRead</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>==iDb ){
<a name="l00121"></a>00121       <a class="code" href="structIndex.html">Index</a> *pIndex;
<a name="l00122"></a>00122       <span class="keywordtype">int</span> tnum = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l00123"></a>00123       <span class="keywordflow">if</span>( tnum==pTab-&gt;<a class="code" href="structTable.html#aebe1abbfb2fd4b5e5dff8e74a4f3c890">tnum</a> ){
<a name="l00124"></a>00124         <span class="keywordflow">return</span> 1;
<a name="l00125"></a>00125       }
<a name="l00126"></a>00126       <span class="keywordflow">for</span>(pIndex=pTab-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>; pIndex; pIndex=pIndex-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>){
<a name="l00127"></a>00127         <span class="keywordflow">if</span>( tnum==pIndex-&gt;<a class="code" href="structIndex.html#af895a09c01701021c3e36362c04a1ae6">tnum</a> ){
<a name="l00128"></a>00128           <span class="keywordflow">return</span> 1;
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130       }
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a46978f7bad0f7fd6157acf8eddaae12e">OP_VOpen</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a47739d78857f4d8fe62b4a5e0d721345">pVtab</a>==pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a> ){
<a name="l00134"></a>00134       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a47739d78857f4d8fe62b4a5e0d721345">pVtab</a>!=0 );
<a name="l00135"></a>00135       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a7a5cdd538a2cb9cf421f7e2f14b3947f">P4_VTAB</a> );
<a name="l00136"></a>00136       <span class="keywordflow">return</span> 1;
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138 <span class="preprocessor">#endif</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span>  }
<a name="l00140"></a>00140   <span class="keywordflow">return</span> 0;
<a name="l00141"></a>00141 }
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOINCREMENT</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00145"></a>00145 <span class="comment">** Write out code to initialize the autoincrement logic.  This code</span>
<a name="l00146"></a>00146 <span class="comment">** looks up the current autoincrement value in the sqlite_sequence</span>
<a name="l00147"></a>00147 <span class="comment">** table and stores that value in a register.  Code generated by</span>
<a name="l00148"></a>00148 <span class="comment">** autoIncStep() will keep that register holding the largest</span>
<a name="l00149"></a>00149 <span class="comment">** rowid value.  Code generated by autoIncEnd() will write the new</span>
<a name="l00150"></a>00150 <span class="comment">** largest value of the counter back into the sqlite_sequence table.</span>
<a name="l00151"></a>00151 <span class="comment">**</span>
<a name="l00152"></a>00152 <span class="comment">** This routine returns the index of the mem[] cell that contains</span>
<a name="l00153"></a>00153 <span class="comment">** the maximum rowid counter.</span>
<a name="l00154"></a>00154 <span class="comment">**</span>
<a name="l00155"></a>00155 <span class="comment">** Three consecutive registers are allocated by this routine.  The</span>
<a name="l00156"></a>00156 <span class="comment">** first two hold the name of the target table and the maximum rowid </span>
<a name="l00157"></a>00157 <span class="comment">** inserted into the target table, respectively.</span>
<a name="l00158"></a>00158 <span class="comment">** The third holds the rowid in sqlite_sequence where we will</span>
<a name="l00159"></a>00159 <span class="comment">** write back the revised maximum rowid.  This routine returns the</span>
<a name="l00160"></a>00160 <span class="comment">** index of the second of these three registers.</span>
<a name="l00161"></a>00161 <span class="comment">*/</span>
<a name="l00162"></a><a class="code" href="insert_8c.html#ace6be0edf9dfebbb8a650d2f4728b885">00162</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="insert_8c.html#ace6be0edf9dfebbb8a650d2f4728b885">autoIncBegin</a>(
<a name="l00163"></a>00163   <a class="code" href="structParse.html">Parse</a> *pParse,      <span class="comment">/* Parsing context */</span>
<a name="l00164"></a>00164   <span class="keywordtype">int</span> iDb,            <span class="comment">/* Index of the database holding pTab */</span>
<a name="l00165"></a>00165   <a class="code" href="structTable.html">Table</a> *pTab         <span class="comment">/* The table we are writing to */</span>
<a name="l00166"></a>00166 ){
<a name="l00167"></a>00167   <span class="keywordtype">int</span> memId = 0;      <span class="comment">/* Register holding maximum rowid */</span>
<a name="l00168"></a>00168   <span class="keywordflow">if</span>( pTab-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#ae917a67699dcdc0ef1930f64df96d57c">TF_Autoincrement</a> ){
<a name="l00169"></a>00169     <a class="code" href="structVdbe.html">Vdbe</a> *v = pParse-&gt;<a class="code" href="structParse.html#a81774053fd5063046f532c07e3daa98b">pVdbe</a>;
<a name="l00170"></a>00170     <a class="code" href="structDb.html">Db</a> *pDb = &amp;pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb];
<a name="l00171"></a>00171     <span class="keywordtype">int</span> iCur = pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>;
<a name="l00172"></a>00172     <span class="keywordtype">int</span> addr;               <span class="comment">/* Address of the top of the loop */</span>
<a name="l00173"></a>00173     assert( v );
<a name="l00174"></a>00174     pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>++;         <span class="comment">/* Holds name of table */</span>
<a name="l00175"></a>00175     memId = ++pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>;
<a name="l00176"></a>00176     pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>++;
<a name="l00177"></a>00177     <a class="code" href="delete_8c.html#a45432dea9b811619b910763795b476f3">sqlite3OpenTable</a>(pParse, iCur, iDb, pDb-&gt;<a class="code" href="structDb.html#afd8647a83a4a7053231b92814520d6d4">pSchema</a>-&gt;<a class="code" href="structSchema.html#ad580e4e662724bee95571d297f94da37">pSeqTab</a>, <a class="code" href="opcodes_8h.html#a0c72fbe4989449cdc9a69e1bbb2e91c2">OP_OpenRead</a>);
<a name="l00178"></a>00178     addr = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l00179"></a>00179     <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a0ab67291a4b5d78f4f5b359b9c3d33e3">OP_String8</a>, 0, memId-1, 0, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>, 0);
<a name="l00180"></a>00180     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>, iCur, addr+9);
<a name="l00181"></a>00181     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a>, iCur, 0, memId);
<a name="l00182"></a>00182     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a72f505669c4d1c712c51c3eaff262b57">OP_Ne</a>, memId-1, addr+7, memId);
<a name="l00183"></a>00183     <a class="code" href="vdbe_8h.html#adb56646cb8d4e3ef524755e857b0f702">sqlite3VdbeChangeP5</a>(v, <a class="code" href="sqliteInt_8h.html#ae3bc696255d4fc2767f872371662bcd1">SQLITE_JUMPIFNULL</a>);
<a name="l00184"></a>00184     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a5a05393545770c35a6071b83679e6be7">OP_Rowid</a>, iCur, memId+1);
<a name="l00185"></a>00185     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a>, iCur, 1, memId);
<a name="l00186"></a>00186     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, addr+9);
<a name="l00187"></a>00187     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a>, iCur, addr+2);
<a name="l00188"></a>00188     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, 0, memId);
<a name="l00189"></a>00189     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, iCur, 0);
<a name="l00190"></a>00190   }
<a name="l00191"></a>00191   <span class="keywordflow">return</span> memId;
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="comment">/*</span>
<a name="l00195"></a>00195 <span class="comment">** Update the maximum rowid for an autoincrement calculation.</span>
<a name="l00196"></a>00196 <span class="comment">**</span>
<a name="l00197"></a>00197 <span class="comment">** This routine should be called when the top of the stack holds a</span>
<a name="l00198"></a>00198 <span class="comment">** new rowid that is about to be inserted.  If that new rowid is</span>
<a name="l00199"></a>00199 <span class="comment">** larger than the maximum rowid in the memId memory cell, then the</span>
<a name="l00200"></a>00200 <span class="comment">** memory cell is updated.  The stack is unchanged.</span>
<a name="l00201"></a>00201 <span class="comment">*/</span>
<a name="l00202"></a><a class="code" href="insert_8c.html#af9b0d0bb1338fe4bf074901ad8f6eb1b">00202</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="insert_8c.html#af9b0d0bb1338fe4bf074901ad8f6eb1b">autoIncStep</a>(<a class="code" href="structParse.html">Parse</a> *pParse, <span class="keywordtype">int</span> memId, <span class="keywordtype">int</span> regRowid){
<a name="l00203"></a>00203   <span class="keywordflow">if</span>( memId&gt;0 ){
<a name="l00204"></a>00204     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(pParse-&gt;<a class="code" href="structParse.html#a81774053fd5063046f532c07e3daa98b">pVdbe</a>, <a class="code" href="opcodes_8h.html#a23e5aec151480e0962baaf2ed063f823">OP_MemMax</a>, memId, regRowid);
<a name="l00205"></a>00205   }
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="comment">/*</span>
<a name="l00209"></a>00209 <span class="comment">** After doing one or more inserts, the maximum rowid is stored</span>
<a name="l00210"></a>00210 <span class="comment">** in reg[memId].  Generate code to write this value back into the</span>
<a name="l00211"></a>00211 <span class="comment">** the sqlite_sequence table.</span>
<a name="l00212"></a>00212 <span class="comment">*/</span>
<a name="l00213"></a><a class="code" href="insert_8c.html#a00c877d23537fbd22de156afc6c52f9d">00213</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="insert_8c.html#a00c877d23537fbd22de156afc6c52f9d">autoIncEnd</a>(
<a name="l00214"></a>00214   <a class="code" href="structParse.html">Parse</a> *pParse,     <span class="comment">/* The parsing context */</span>
<a name="l00215"></a>00215   <span class="keywordtype">int</span> iDb,           <span class="comment">/* Index of the database holding pTab */</span>
<a name="l00216"></a>00216   <a class="code" href="structTable.html">Table</a> *pTab,       <span class="comment">/* Table we are inserting into */</span>
<a name="l00217"></a>00217   <span class="keywordtype">int</span> memId          <span class="comment">/* Memory cell holding the maximum rowid */</span>
<a name="l00218"></a>00218 ){
<a name="l00219"></a>00219   <span class="keywordflow">if</span>( pTab-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#ae917a67699dcdc0ef1930f64df96d57c">TF_Autoincrement</a> ){
<a name="l00220"></a>00220     <span class="keywordtype">int</span> iCur = pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>;
<a name="l00221"></a>00221     <a class="code" href="structVdbe.html">Vdbe</a> *v = pParse-&gt;<a class="code" href="structParse.html#a81774053fd5063046f532c07e3daa98b">pVdbe</a>;
<a name="l00222"></a>00222     <a class="code" href="structDb.html">Db</a> *pDb = &amp;pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb];
<a name="l00223"></a>00223     <span class="keywordtype">int</span> j1;
<a name="l00224"></a>00224     <span class="keywordtype">int</span> iRec = ++pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>;    <span class="comment">/* Memory cell used for record */</span>
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     assert( v );
<a name="l00227"></a>00227     <a class="code" href="delete_8c.html#a45432dea9b811619b910763795b476f3">sqlite3OpenTable</a>(pParse, iCur, iDb, pDb-&gt;<a class="code" href="structDb.html#afd8647a83a4a7053231b92814520d6d4">pSchema</a>-&gt;<a class="code" href="structSchema.html#ad580e4e662724bee95571d297f94da37">pSeqTab</a>, <a class="code" href="opcodes_8h.html#a98af8f9fca78ddf04bbc472cf2761f10">OP_OpenWrite</a>);
<a name="l00228"></a>00228     j1 = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a2c2d69757c7bf41ae12092a80b04c088">OP_NotNull</a>, memId+1);
<a name="l00229"></a>00229     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#aebc7e3a304f9b4b81abce298ff9704ec">OP_NewRowid</a>, iCur, memId+1);
<a name="l00230"></a>00230     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, j1);
<a name="l00231"></a>00231     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#aaa8701055972e3d38e2f9801708cd9fc">OP_MakeRecord</a>, memId-1, 2, iRec);
<a name="l00232"></a>00232     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#af8ec5cb3f4bce8e904b41f713c2c7d86">OP_Insert</a>, iCur, iRec, memId+1);
<a name="l00233"></a>00233     <a class="code" href="vdbe_8h.html#adb56646cb8d4e3ef524755e857b0f702">sqlite3VdbeChangeP5</a>(v, <a class="code" href="sqliteInt_8h.html#a2402d52d244d3dcbc0bb4d6a796194a0">OPFLAG_APPEND</a>);
<a name="l00234"></a>00234     <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, iCur);
<a name="l00235"></a>00235   }
<a name="l00236"></a>00236 }
<a name="l00237"></a>00237 <span class="preprocessor">#else</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00239"></a>00239 <span class="comment">** If SQLITE_OMIT_AUTOINCREMENT is defined, then the three routines</span>
<a name="l00240"></a>00240 <span class="comment">** above are all no-ops</span>
<a name="l00241"></a>00241 <span class="comment">*/</span>
<a name="l00242"></a>00242 <span class="preprocessor"># define autoIncBegin(A,B,C) (0)</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span><span class="preprocessor"># define autoIncStep(A,B,C)</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span><span class="preprocessor"># define autoIncEnd(A,B,C,D)</span>
<a name="l00245"></a>00245 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_AUTOINCREMENT */</span>
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">/* Forward declaration */</span>
<a name="l00249"></a>00249 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="insert_8c.html#ae85c90f7d064fe83f4ed930e708855d2">xferOptimization</a>(
<a name="l00250"></a>00250   <a class="code" href="structParse.html">Parse</a> *pParse,        <span class="comment">/* Parser context */</span>
<a name="l00251"></a>00251   <a class="code" href="structTable.html">Table</a> *pDest,         <span class="comment">/* The table we are inserting into */</span>
<a name="l00252"></a>00252   <a class="code" href="structSelect.html">Select</a> *pSelect,      <span class="comment">/* A SELECT statement to use as the data source */</span>
<a name="l00253"></a>00253   <span class="keywordtype">int</span> onError,          <span class="comment">/* How to handle constraint errors */</span>
<a name="l00254"></a>00254   <span class="keywordtype">int</span> iDbDest           <span class="comment">/* The database of pDest */</span>
<a name="l00255"></a>00255 );
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="comment">/*</span>
<a name="l00258"></a>00258 <span class="comment">** This routine is call to handle SQL of the following forms:</span>
<a name="l00259"></a>00259 <span class="comment">**</span>
<a name="l00260"></a>00260 <span class="comment">**    insert into TABLE (IDLIST) values(EXPRLIST)</span>
<a name="l00261"></a>00261 <span class="comment">**    insert into TABLE (IDLIST) select</span>
<a name="l00262"></a>00262 <span class="comment">**</span>
<a name="l00263"></a>00263 <span class="comment">** The IDLIST following the table name is always optional.  If omitted,</span>
<a name="l00264"></a>00264 <span class="comment">** then a list of all columns for the table is substituted.  The IDLIST</span>
<a name="l00265"></a>00265 <span class="comment">** appears in the pColumn parameter.  pColumn is NULL if IDLIST is omitted.</span>
<a name="l00266"></a>00266 <span class="comment">**</span>
<a name="l00267"></a>00267 <span class="comment">** The pList parameter holds EXPRLIST in the first form of the INSERT</span>
<a name="l00268"></a>00268 <span class="comment">** statement above, and pSelect is NULL.  For the second form, pList is</span>
<a name="l00269"></a>00269 <span class="comment">** NULL and pSelect is a pointer to the select statement used to generate</span>
<a name="l00270"></a>00270 <span class="comment">** data for the insert.</span>
<a name="l00271"></a>00271 <span class="comment">**</span>
<a name="l00272"></a>00272 <span class="comment">** The code generated follows one of four templates.  For a simple</span>
<a name="l00273"></a>00273 <span class="comment">** select with data coming from a VALUES clause, the code executes</span>
<a name="l00274"></a>00274 <span class="comment">** once straight down through.  Pseudo-code follows (we call this</span>
<a name="l00275"></a>00275 <span class="comment">** the &quot;1st template&quot;):</span>
<a name="l00276"></a>00276 <span class="comment">**</span>
<a name="l00277"></a>00277 <span class="comment">**         open write cursor to &lt;table&gt; and its indices</span>
<a name="l00278"></a>00278 <span class="comment">**         puts VALUES clause expressions onto the stack</span>
<a name="l00279"></a>00279 <span class="comment">**         write the resulting record into &lt;table&gt;</span>
<a name="l00280"></a>00280 <span class="comment">**         cleanup</span>
<a name="l00281"></a>00281 <span class="comment">**</span>
<a name="l00282"></a>00282 <span class="comment">** The three remaining templates assume the statement is of the form</span>
<a name="l00283"></a>00283 <span class="comment">**</span>
<a name="l00284"></a>00284 <span class="comment">**   INSERT INTO &lt;table&gt; SELECT ...</span>
<a name="l00285"></a>00285 <span class="comment">**</span>
<a name="l00286"></a>00286 <span class="comment">** If the SELECT clause is of the restricted form &quot;SELECT * FROM &lt;table2&gt;&quot; -</span>
<a name="l00287"></a>00287 <span class="comment">** in other words if the SELECT pulls all columns from a single table</span>
<a name="l00288"></a>00288 <span class="comment">** and there is no WHERE or LIMIT or GROUP BY or ORDER BY clauses, and</span>
<a name="l00289"></a>00289 <span class="comment">** if &lt;table2&gt; and &lt;table1&gt; are distinct tables but have identical</span>
<a name="l00290"></a>00290 <span class="comment">** schemas, including all the same indices, then a special optimization</span>
<a name="l00291"></a>00291 <span class="comment">** is invoked that copies raw records from &lt;table2&gt; over to &lt;table1&gt;.</span>
<a name="l00292"></a>00292 <span class="comment">** See the xferOptimization() function for the implementation of this</span>
<a name="l00293"></a>00293 <span class="comment">** template.  This is the 2nd template.</span>
<a name="l00294"></a>00294 <span class="comment">**</span>
<a name="l00295"></a>00295 <span class="comment">**         open a write cursor to &lt;table&gt;</span>
<a name="l00296"></a>00296 <span class="comment">**         open read cursor on &lt;table2&gt;</span>
<a name="l00297"></a>00297 <span class="comment">**         transfer all records in &lt;table2&gt; over to &lt;table&gt;</span>
<a name="l00298"></a>00298 <span class="comment">**         close cursors</span>
<a name="l00299"></a>00299 <span class="comment">**         foreach index on &lt;table&gt;</span>
<a name="l00300"></a>00300 <span class="comment">**           open a write cursor on the &lt;table&gt; index</span>
<a name="l00301"></a>00301 <span class="comment">**           open a read cursor on the corresponding &lt;table2&gt; index</span>
<a name="l00302"></a>00302 <span class="comment">**           transfer all records from the read to the write cursors</span>
<a name="l00303"></a>00303 <span class="comment">**           close cursors</span>
<a name="l00304"></a>00304 <span class="comment">**         end foreach</span>
<a name="l00305"></a>00305 <span class="comment">**</span>
<a name="l00306"></a>00306 <span class="comment">** The 3rd template is for when the second template does not apply</span>
<a name="l00307"></a>00307 <span class="comment">** and the SELECT clause does not read from &lt;table&gt; at any time.</span>
<a name="l00308"></a>00308 <span class="comment">** The generated code follows this template:</span>
<a name="l00309"></a>00309 <span class="comment">**</span>
<a name="l00310"></a>00310 <span class="comment">**         EOF &lt;- 0</span>
<a name="l00311"></a>00311 <span class="comment">**         X &lt;- A</span>
<a name="l00312"></a>00312 <span class="comment">**         goto B</span>
<a name="l00313"></a>00313 <span class="comment">**      A: setup for the SELECT</span>
<a name="l00314"></a>00314 <span class="comment">**         loop over the rows in the SELECT</span>
<a name="l00315"></a>00315 <span class="comment">**           load values into registers R..R+n</span>
<a name="l00316"></a>00316 <span class="comment">**           yield X</span>
<a name="l00317"></a>00317 <span class="comment">**         end loop</span>
<a name="l00318"></a>00318 <span class="comment">**         cleanup after the SELECT</span>
<a name="l00319"></a>00319 <span class="comment">**         EOF &lt;- 1</span>
<a name="l00320"></a>00320 <span class="comment">**         yield X</span>
<a name="l00321"></a>00321 <span class="comment">**         goto A</span>
<a name="l00322"></a>00322 <span class="comment">**      B: open write cursor to &lt;table&gt; and its indices</span>
<a name="l00323"></a>00323 <span class="comment">**      C: yield X</span>
<a name="l00324"></a>00324 <span class="comment">**         if EOF goto D</span>
<a name="l00325"></a>00325 <span class="comment">**         insert the select result into &lt;table&gt; from R..R+n</span>
<a name="l00326"></a>00326 <span class="comment">**         goto C</span>
<a name="l00327"></a>00327 <span class="comment">**      D: cleanup</span>
<a name="l00328"></a>00328 <span class="comment">**</span>
<a name="l00329"></a>00329 <span class="comment">** The 4th template is used if the insert statement takes its</span>
<a name="l00330"></a>00330 <span class="comment">** values from a SELECT but the data is being inserted into a table</span>
<a name="l00331"></a>00331 <span class="comment">** that is also read as part of the SELECT.  In the third form,</span>
<a name="l00332"></a>00332 <span class="comment">** we have to use a intermediate table to store the results of</span>
<a name="l00333"></a>00333 <span class="comment">** the select.  The template is like this:</span>
<a name="l00334"></a>00334 <span class="comment">**</span>
<a name="l00335"></a>00335 <span class="comment">**         EOF &lt;- 0</span>
<a name="l00336"></a>00336 <span class="comment">**         X &lt;- A</span>
<a name="l00337"></a>00337 <span class="comment">**         goto B</span>
<a name="l00338"></a>00338 <span class="comment">**      A: setup for the SELECT</span>
<a name="l00339"></a>00339 <span class="comment">**         loop over the tables in the SELECT</span>
<a name="l00340"></a>00340 <span class="comment">**           load value into register R..R+n</span>
<a name="l00341"></a>00341 <span class="comment">**           yield X</span>
<a name="l00342"></a>00342 <span class="comment">**         end loop</span>
<a name="l00343"></a>00343 <span class="comment">**         cleanup after the SELECT</span>
<a name="l00344"></a>00344 <span class="comment">**         EOF &lt;- 1</span>
<a name="l00345"></a>00345 <span class="comment">**         yield X</span>
<a name="l00346"></a>00346 <span class="comment">**         halt-error</span>
<a name="l00347"></a>00347 <span class="comment">**      B: open temp table</span>
<a name="l00348"></a>00348 <span class="comment">**      L: yield X</span>
<a name="l00349"></a>00349 <span class="comment">**         if EOF goto M</span>
<a name="l00350"></a>00350 <span class="comment">**         insert row from R..R+n into temp table</span>
<a name="l00351"></a>00351 <span class="comment">**         goto L</span>
<a name="l00352"></a>00352 <span class="comment">**      M: open write cursor to &lt;table&gt; and its indices</span>
<a name="l00353"></a>00353 <span class="comment">**         rewind temp table</span>
<a name="l00354"></a>00354 <span class="comment">**      C: loop over rows of intermediate table</span>
<a name="l00355"></a>00355 <span class="comment">**           transfer values form intermediate table into &lt;table&gt;</span>
<a name="l00356"></a>00356 <span class="comment">**         end loop</span>
<a name="l00357"></a>00357 <span class="comment">**      D: cleanup</span>
<a name="l00358"></a>00358 <span class="comment">*/</span>
<a name="l00359"></a><a class="code" href="sqliteInt_8h.html#a0b37b0f481c2f353d0a8621016aa8342">00359</a> <span class="keywordtype">void</span> <a class="code" href="insert_8c.html#a7aa32665ebaa695f70d5a8836a82abd1">sqlite3Insert</a>(
<a name="l00360"></a>00360   <a class="code" href="structParse.html">Parse</a> *pParse,        <span class="comment">/* Parser context */</span>
<a name="l00361"></a>00361   <a class="code" href="structSrcList.html">SrcList</a> *pTabList,    <span class="comment">/* Name of table into which we are inserting */</span>
<a name="l00362"></a>00362   <a class="code" href="structExprList.html">ExprList</a> *pList,      <span class="comment">/* List of values to be inserted */</span>
<a name="l00363"></a>00363   <a class="code" href="structSelect.html">Select</a> *pSelect,      <span class="comment">/* A SELECT statement to use as the data source */</span>
<a name="l00364"></a>00364   <a class="code" href="structIdList.html">IdList</a> *pColumn,      <span class="comment">/* Column names corresponding to IDLIST. */</span>
<a name="l00365"></a>00365   <span class="keywordtype">int</span> onError           <span class="comment">/* How to handle constraint errors */</span>
<a name="l00366"></a>00366 ){
<a name="l00367"></a>00367   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>;          <span class="comment">/* The main database structure */</span>
<a name="l00368"></a>00368   <a class="code" href="structTable.html">Table</a> *pTab;          <span class="comment">/* The table to insert into.  aka TABLE */</span>
<a name="l00369"></a>00369   <span class="keywordtype">char</span> *zTab;           <span class="comment">/* Name of the table into which we are inserting */</span>
<a name="l00370"></a>00370   <span class="keyword">const</span> <span class="keywordtype">char</span> *zDb;      <span class="comment">/* Name of the database holding this table */</span>
<a name="l00371"></a>00371   <span class="keywordtype">int</span> i, j, idx;        <span class="comment">/* Loop counters */</span>
<a name="l00372"></a>00372   <a class="code" href="structVdbe.html">Vdbe</a> *v;              <span class="comment">/* Generate code into this virtual machine */</span>
<a name="l00373"></a>00373   <a class="code" href="structIndex.html">Index</a> *pIdx;          <span class="comment">/* For looping over indices of the table */</span>
<a name="l00374"></a>00374   <span class="keywordtype">int</span> nColumn;          <span class="comment">/* Number of columns in the data */</span>
<a name="l00375"></a>00375   <span class="keywordtype">int</span> nHidden = 0;      <span class="comment">/* Number of hidden columns if TABLE is virtual */</span>
<a name="l00376"></a>00376   <span class="keywordtype">int</span> baseCur = 0;      <span class="comment">/* VDBE Cursor number for pTab */</span>
<a name="l00377"></a>00377   <span class="keywordtype">int</span> keyColumn = -1;   <span class="comment">/* Column that is the INTEGER PRIMARY KEY */</span>
<a name="l00378"></a>00378   <span class="keywordtype">int</span> endOfLoop;        <span class="comment">/* Label for the end of the insertion loop */</span>
<a name="l00379"></a>00379   <span class="keywordtype">int</span> useTempTable = 0; <span class="comment">/* Store SELECT results in intermediate table */</span>
<a name="l00380"></a>00380   <span class="keywordtype">int</span> srcTab = 0;       <span class="comment">/* Data comes from this temporary cursor if &gt;=0 */</span>
<a name="l00381"></a>00381   <span class="keywordtype">int</span> addrInsTop = 0;   <span class="comment">/* Jump to label &quot;D&quot; */</span>
<a name="l00382"></a>00382   <span class="keywordtype">int</span> addrCont = 0;     <span class="comment">/* Top of insert loop. Label &quot;C&quot; in templates 3 and 4 */</span>
<a name="l00383"></a>00383   <span class="keywordtype">int</span> addrSelect = 0;   <span class="comment">/* Address of coroutine that implements the SELECT */</span>
<a name="l00384"></a>00384   <a class="code" href="structSelectDest.html">SelectDest</a> dest;      <span class="comment">/* Destination for SELECT on rhs of INSERT */</span>
<a name="l00385"></a>00385   <span class="keywordtype">int</span> newIdx = -1;      <span class="comment">/* Cursor for the NEW pseudo-table */</span>
<a name="l00386"></a>00386   <span class="keywordtype">int</span> iDb;              <span class="comment">/* Index of database holding TABLE */</span>
<a name="l00387"></a>00387   <a class="code" href="structDb.html">Db</a> *pDb;              <span class="comment">/* The database containing table being inserted into */</span>
<a name="l00388"></a>00388   <span class="keywordtype">int</span> appendFlag = 0;   <span class="comment">/* True if the insert is likely to be an append */</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390   <span class="comment">/* Register allocations */</span>
<a name="l00391"></a>00391   <span class="keywordtype">int</span> regFromSelect;    <span class="comment">/* Base register for data coming from SELECT */</span>
<a name="l00392"></a>00392   <span class="keywordtype">int</span> regAutoinc = 0;   <span class="comment">/* Register holding the AUTOINCREMENT counter */</span>
<a name="l00393"></a>00393   <span class="keywordtype">int</span> regRowCount = 0;  <span class="comment">/* Memory cell used for the row counter */</span>
<a name="l00394"></a>00394   <span class="keywordtype">int</span> regIns;           <span class="comment">/* Block of regs holding rowid+data being inserted */</span>
<a name="l00395"></a>00395   <span class="keywordtype">int</span> regRowid;         <span class="comment">/* registers holding insert rowid */</span>
<a name="l00396"></a>00396   <span class="keywordtype">int</span> regData;          <span class="comment">/* register holding first column to insert */</span>
<a name="l00397"></a>00397   <span class="keywordtype">int</span> regRecord;        <span class="comment">/* Holds the assemblied row record */</span>
<a name="l00398"></a>00398   <span class="keywordtype">int</span> regEof;           <span class="comment">/* Register recording end of SELECT data */</span>
<a name="l00399"></a>00399   <span class="keywordtype">int</span> *aRegIdx = 0;     <span class="comment">/* One register allocated to each index */</span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 <span class="preprocessor">#ifndef SQLITE_OMIT_TRIGGER</span>
<a name="l00403"></a>00403 <span class="preprocessor"></span>  <span class="keywordtype">int</span> isView;                 <span class="comment">/* True if attempting to insert into a view */</span>
<a name="l00404"></a>00404   <span class="keywordtype">int</span> triggers_exist = 0;     <span class="comment">/* True if there are FOR EACH ROW triggers */</span>
<a name="l00405"></a>00405 <span class="preprocessor">#endif</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span>
<a name="l00407"></a>00407   db = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00408"></a>00408   <span class="keywordflow">if</span>( pParse-&gt;<a class="code" href="structParse.html#ac7206f0c7e580ab32b7dfb20950bb1c9">nErr</a> || db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00409"></a>00409     <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00410"></a>00410   }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   <span class="comment">/* Locate the table into which we will be inserting new information.</span>
<a name="l00413"></a>00413 <span class="comment">  */</span>
<a name="l00414"></a>00414   assert( pTabList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>==1 );
<a name="l00415"></a>00415   zTab = pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[0].<a class="code" href="structSrcList_1_1SrcList__item.html#afee5c5a84594fed8100be3cdb3e3ff1c">zName</a>;
<a name="l00416"></a>00416   <span class="keywordflow">if</span>( zTab==0 ) <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00417"></a>00417   pTab = <a class="code" href="delete_8c.html#abf73fb258b0f02c58bc9225c64eabe4e">sqlite3SrcListLookup</a>(pParse, pTabList);
<a name="l00418"></a>00418   <span class="keywordflow">if</span>( pTab==0 ){
<a name="l00419"></a>00419     <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421   iDb = <a class="code" href="prepare_8c.html#aecd8922611e561d76d5e9f16655e8a7c">sqlite3SchemaToIndex</a>(db, pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>);
<a name="l00422"></a>00422   assert( iDb&lt;db-&gt;nDb );
<a name="l00423"></a>00423   pDb = &amp;db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb];
<a name="l00424"></a>00424   zDb = pDb-&gt;<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>;
<a name="l00425"></a>00425   <span class="keywordflow">if</span>( <a class="code" href="auth_8c.html#a7c993bc216f5c07cf032f3123167d658">sqlite3AuthCheck</a>(pParse, <a class="code" href="sqlite3_8h.html#a0d32c3f24fcfd33411eecb1e4da64a40">SQLITE_INSERT</a>, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>, 0, zDb) ){
<a name="l00426"></a>00426     <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00427"></a>00427   }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="comment">/* Figure out if we have any triggers and if the table being</span>
<a name="l00430"></a>00430 <span class="comment">  ** inserted into is a view</span>
<a name="l00431"></a>00431 <span class="comment">  */</span>
<a name="l00432"></a>00432 <span class="preprocessor">#ifndef SQLITE_OMIT_TRIGGER</span>
<a name="l00433"></a>00433 <span class="preprocessor"></span>  triggers_exist = <a class="code" href="sqliteInt_8h.html#aa64a87ec65ca9e35e155374ff8fca43b">sqlite3TriggersExist</a>(pParse, pTab, <a class="code" href="parse_8h.html#a407a8abe71ab89c3d8e5d4ddc2328cc7">TK_INSERT</a>, 0);
<a name="l00434"></a>00434   isView = pTab-&gt;<a class="code" href="structTable.html#a39d620182fe2174fc97d04094421fa60">pSelect</a>!=0;
<a name="l00435"></a>00435 <span class="preprocessor">#else</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span><span class="preprocessor"># define triggers_exist 0</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span><span class="preprocessor"># define isView 0</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span><span class="preprocessor">#ifdef SQLITE_OMIT_VIEW</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span><span class="preprocessor"># undef isView</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span><span class="preprocessor"># define isView 0</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00443"></a>00443 <span class="preprocessor"></span>
<a name="l00444"></a>00444   <span class="comment">/* Ensure that:</span>
<a name="l00445"></a>00445 <span class="comment">  *  (a) the table is not read-only, </span>
<a name="l00446"></a>00446 <span class="comment">  *  (b) that if it is a view then ON INSERT triggers exist</span>
<a name="l00447"></a>00447 <span class="comment">  */</span>
<a name="l00448"></a>00448   <span class="keywordflow">if</span>( <a class="code" href="delete_8c.html#a406cde1e21e1792792e96d168f3cc96e">sqlite3IsReadOnly</a>(pParse, pTab, triggers_exist) ){
<a name="l00449"></a>00449     <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00450"></a>00450   }
<a name="l00451"></a>00451   assert( pTab!=0 );
<a name="l00452"></a>00452 
<a name="l00453"></a>00453   <span class="comment">/* If pTab is really a view, make sure it has been initialized.</span>
<a name="l00454"></a>00454 <span class="comment">  ** ViewGetColumnNames() is a no-op if pTab is not a view (or virtual </span>
<a name="l00455"></a>00455 <span class="comment">  ** module table).</span>
<a name="l00456"></a>00456 <span class="comment">  */</span>
<a name="l00457"></a>00457   <span class="keywordflow">if</span>( <a class="code" href="build_8c.html#ad2bfa8879560735bfdffd6201cc9bd21">sqlite3ViewGetColumnNames</a>(pParse, pTab) ){
<a name="l00458"></a>00458     <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00459"></a>00459   }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="comment">/* Allocate a VDBE</span>
<a name="l00462"></a>00462 <span class="comment">  */</span>
<a name="l00463"></a>00463   v = <a class="code" href="select_8c.html#a5a1f85a5a6bef8f820dddfcb407b61dc">sqlite3GetVdbe</a>(pParse);
<a name="l00464"></a>00464   <span class="keywordflow">if</span>( v==0 ) <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00465"></a>00465   <span class="keywordflow">if</span>( pParse-&gt;<a class="code" href="structParse.html#a33d62687b6d368acf94e954490358819">nested</a>==0 ) <a class="code" href="vdbe_8h.html#a22fff0ed8212f3d787e80d22571b04b6">sqlite3VdbeCountChanges</a>(v);
<a name="l00466"></a>00466   <a class="code" href="build_8c.html#ace73d724d7a8ab9ddd87b84940b3a55e">sqlite3BeginWriteOperation</a>(pParse, pSelect || triggers_exist, iDb);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   <span class="comment">/* if there are row triggers, allocate a temp table for new.* references. */</span>
<a name="l00469"></a>00469   <span class="keywordflow">if</span>( triggers_exist ){
<a name="l00470"></a>00470     newIdx = pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>++;
<a name="l00471"></a>00471   }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="preprocessor">#ifndef SQLITE_OMIT_XFER_OPT</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span>  <span class="comment">/* If the statement is of the form</span>
<a name="l00475"></a>00475 <span class="comment">  **</span>
<a name="l00476"></a>00476 <span class="comment">  **       INSERT INTO &lt;table1&gt; SELECT * FROM &lt;table2&gt;;</span>
<a name="l00477"></a>00477 <span class="comment">  **</span>
<a name="l00478"></a>00478 <span class="comment">  ** Then special optimizations can be applied that make the transfer</span>
<a name="l00479"></a>00479 <span class="comment">  ** very fast and which reduce fragmentation of indices.</span>
<a name="l00480"></a>00480 <span class="comment">  **</span>
<a name="l00481"></a>00481 <span class="comment">  ** This is the 2nd template.</span>
<a name="l00482"></a>00482 <span class="comment">  */</span>
<a name="l00483"></a>00483   <span class="keywordflow">if</span>( pColumn==0 &amp;&amp; <a class="code" href="insert_8c.html#ae85c90f7d064fe83f4ed930e708855d2">xferOptimization</a>(pParse, pTab, pSelect, onError, iDb) ){
<a name="l00484"></a>00484     assert( !triggers_exist );
<a name="l00485"></a>00485     assert( pList==0 );
<a name="l00486"></a>00486     <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00487"></a>00487   }
<a name="l00488"></a>00488 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_XFER_OPT */</span>
<a name="l00489"></a>00489 
<a name="l00490"></a>00490   <span class="comment">/* If this is an AUTOINCREMENT table, look up the sequence number in the</span>
<a name="l00491"></a>00491 <span class="comment">  ** sqlite_sequence table and store it in memory cell regAutoinc.</span>
<a name="l00492"></a>00492 <span class="comment">  */</span>
<a name="l00493"></a>00493   regAutoinc = <a class="code" href="insert_8c.html#ace6be0edf9dfebbb8a650d2f4728b885">autoIncBegin</a>(pParse, iDb, pTab);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="comment">/* Figure out how many columns of data are supplied.  If the data</span>
<a name="l00496"></a>00496 <span class="comment">  ** is coming from a SELECT statement, then generate a co-routine that</span>
<a name="l00497"></a>00497 <span class="comment">  ** produces a single row of the SELECT on each invocation.  The</span>
<a name="l00498"></a>00498 <span class="comment">  ** co-routine is the common header to the 3rd and 4th templates.</span>
<a name="l00499"></a>00499 <span class="comment">  */</span>
<a name="l00500"></a>00500   <span class="keywordflow">if</span>( pSelect ){
<a name="l00501"></a>00501     <span class="comment">/* Data is coming from a SELECT.  Generate code to implement that SELECT</span>
<a name="l00502"></a>00502 <span class="comment">    ** as a co-routine.  The code is common to both the 3rd and 4th</span>
<a name="l00503"></a>00503 <span class="comment">    ** templates:</span>
<a name="l00504"></a>00504 <span class="comment">    **</span>
<a name="l00505"></a>00505 <span class="comment">    **         EOF &lt;- 0</span>
<a name="l00506"></a>00506 <span class="comment">    **         X &lt;- A</span>
<a name="l00507"></a>00507 <span class="comment">    **         goto B</span>
<a name="l00508"></a>00508 <span class="comment">    **      A: setup for the SELECT</span>
<a name="l00509"></a>00509 <span class="comment">    **         loop over the tables in the SELECT</span>
<a name="l00510"></a>00510 <span class="comment">    **           load value into register R..R+n</span>
<a name="l00511"></a>00511 <span class="comment">    **           yield X</span>
<a name="l00512"></a>00512 <span class="comment">    **         end loop</span>
<a name="l00513"></a>00513 <span class="comment">    **         cleanup after the SELECT</span>
<a name="l00514"></a>00514 <span class="comment">    **         EOF &lt;- 1</span>
<a name="l00515"></a>00515 <span class="comment">    **         yield X</span>
<a name="l00516"></a>00516 <span class="comment">    **         halt-error</span>
<a name="l00517"></a>00517 <span class="comment">    **</span>
<a name="l00518"></a>00518 <span class="comment">    ** On each invocation of the co-routine, it puts a single row of the</span>
<a name="l00519"></a>00519 <span class="comment">    ** SELECT result into registers dest.iMem...dest.iMem+dest.nMem-1.</span>
<a name="l00520"></a>00520 <span class="comment">    ** (These output registers are allocated by sqlite3Select().)  When</span>
<a name="l00521"></a>00521 <span class="comment">    ** the SELECT completes, it sets the EOF flag stored in regEof.</span>
<a name="l00522"></a>00522 <span class="comment">    */</span>
<a name="l00523"></a>00523     <span class="keywordtype">int</span> rc, j1;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525     regEof = ++pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>;
<a name="l00526"></a>00526     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, 0, regEof);      <span class="comment">/* EOF &lt;- 0 */</span>
<a name="l00527"></a>00527     <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;SELECT eof flag&quot;</span>));
<a name="l00528"></a>00528     <a class="code" href="select_8c.html#ac8d69a3ff16ec67407ab5fa732e1c447">sqlite3SelectDestInit</a>(&amp;dest, <a class="code" href="sqliteInt_8h.html#a79494a24284507774f3f45deb5bf2b2f">SRT_Coroutine</a>, ++pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>);
<a name="l00529"></a>00529     addrSelect = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v)+2;
<a name="l00530"></a>00530     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, addrSelect-1, dest.<a class="code" href="structSelectDest.html#a6ca726a6f8054df61baa150c5010c53f">iParm</a>);
<a name="l00531"></a>00531     j1 = <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, 0);
<a name="l00532"></a>00532     <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;Jump over SELECT coroutine&quot;</span>));
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     <span class="comment">/* Resolve the expressions in the SELECT statement and execute it. */</span>
<a name="l00535"></a>00535     rc = <a class="code" href="select_8c.html#ad8001cf7227eb1d0bd486102a3de7e0e">sqlite3Select</a>(pParse, pSelect, &amp;dest);
<a name="l00536"></a>00536     <span class="keywordflow">if</span>( rc || pParse-&gt;<a class="code" href="structParse.html#ac7206f0c7e580ab32b7dfb20950bb1c9">nErr</a> || db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00537"></a>00537       <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, 1, regEof);         <span class="comment">/* EOF &lt;- 1 */</span>
<a name="l00540"></a>00540     <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a7ebd9b3f2515a2a3787fcb78265ec036">OP_Yield</a>, dest.<a class="code" href="structSelectDest.html#a6ca726a6f8054df61baa150c5010c53f">iParm</a>);   <span class="comment">/* yield X */</span>
<a name="l00541"></a>00541     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af1020441d30e76aa4d065ac2ec56c23d">OP_Halt</a>, <a class="code" href="sqlite3_8h.html#a76bdc16193e1d007e258ca26e6ffd9f1">SQLITE_INTERNAL</a>, <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>);
<a name="l00542"></a>00542     <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;End of SELECT coroutine&quot;</span>));
<a name="l00543"></a>00543     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, j1);                          <span class="comment">/* label B: */</span>
<a name="l00544"></a>00544 
<a name="l00545"></a>00545     regFromSelect = dest.<a class="code" href="structSelectDest.html#ab060aa655304afa76b1a2f923a2b0ae5">iMem</a>;
<a name="l00546"></a>00546     assert( pSelect-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a> );
<a name="l00547"></a>00547     nColumn = pSelect-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>;
<a name="l00548"></a>00548     assert( dest.<a class="code" href="structSelectDest.html#a1868d637be46616a4206fd8ff9f4ac52">nMem</a>==nColumn );
<a name="l00549"></a>00549 
<a name="l00550"></a>00550     <span class="comment">/* Set useTempTable to TRUE if the result of the SELECT statement</span>
<a name="l00551"></a>00551 <span class="comment">    ** should be written into a temporary table (template 4).  Set to</span>
<a name="l00552"></a>00552 <span class="comment">    ** FALSE if each* row of the SELECT can be written directly into</span>
<a name="l00553"></a>00553 <span class="comment">    ** the destination table (template 3).</span>
<a name="l00554"></a>00554 <span class="comment">    **</span>
<a name="l00555"></a>00555 <span class="comment">    ** A temp table must be used if the table being updated is also one</span>
<a name="l00556"></a>00556 <span class="comment">    ** of the tables being read by the SELECT statement.  Also use a </span>
<a name="l00557"></a>00557 <span class="comment">    ** temp table in the case of row triggers.</span>
<a name="l00558"></a>00558 <span class="comment">    */</span>
<a name="l00559"></a>00559     <span class="keywordflow">if</span>( triggers_exist || <a class="code" href="insert_8c.html#a21e21a8360113641ae60122a35b9556b">readsTable</a>(v, addrSelect, iDb, pTab) ){
<a name="l00560"></a>00560       useTempTable = 1;
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     <span class="keywordflow">if</span>( useTempTable ){
<a name="l00564"></a>00564       <span class="comment">/* Invoke the coroutine to extract information from the SELECT</span>
<a name="l00565"></a>00565 <span class="comment">      ** and add it to a transient table srcTab.  The code generated</span>
<a name="l00566"></a>00566 <span class="comment">      ** here is from the 4th template:</span>
<a name="l00567"></a>00567 <span class="comment">      **</span>
<a name="l00568"></a>00568 <span class="comment">      **      B: open temp table</span>
<a name="l00569"></a>00569 <span class="comment">      **      L: yield X</span>
<a name="l00570"></a>00570 <span class="comment">      **         if EOF goto M</span>
<a name="l00571"></a>00571 <span class="comment">      **         insert row from R..R+n into temp table</span>
<a name="l00572"></a>00572 <span class="comment">      **         goto L</span>
<a name="l00573"></a>00573 <span class="comment">      **      M: ...</span>
<a name="l00574"></a>00574 <span class="comment">      */</span>
<a name="l00575"></a>00575       <span class="keywordtype">int</span> regRec;      <span class="comment">/* Register to hold packed record */</span>
<a name="l00576"></a>00576       <span class="keywordtype">int</span> regRowid;    <span class="comment">/* Register to hold temp table ROWID */</span>
<a name="l00577"></a>00577       <span class="keywordtype">int</span> addrTop;     <span class="comment">/* Label &quot;L&quot; */</span>
<a name="l00578"></a>00578       <span class="keywordtype">int</span> addrIf;      <span class="comment">/* Address of jump to M */</span>
<a name="l00579"></a>00579 
<a name="l00580"></a>00580       srcTab = pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>++;
<a name="l00581"></a>00581       regRec = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l00582"></a>00582       regRowid = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l00583"></a>00583       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a2c9ec21e951d5ecf39b32e118d57a262">OP_OpenEphemeral</a>, srcTab, nColumn);
<a name="l00584"></a>00584       addrTop = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a7ebd9b3f2515a2a3787fcb78265ec036">OP_Yield</a>, dest.<a class="code" href="structSelectDest.html#a6ca726a6f8054df61baa150c5010c53f">iParm</a>);
<a name="l00585"></a>00585       addrIf = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#ac2b8b882b701cfbad6bfca4ac6db76bc">OP_If</a>, regEof);
<a name="l00586"></a>00586       <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#aaa8701055972e3d38e2f9801708cd9fc">OP_MakeRecord</a>, regFromSelect, nColumn, regRec);
<a name="l00587"></a>00587       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#aebc7e3a304f9b4b81abce298ff9704ec">OP_NewRowid</a>, srcTab, regRowid);
<a name="l00588"></a>00588       <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#af8ec5cb3f4bce8e904b41f713c2c7d86">OP_Insert</a>, srcTab, regRec, regRowid);
<a name="l00589"></a>00589       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, addrTop);
<a name="l00590"></a>00590       <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, addrIf);
<a name="l00591"></a>00591       <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, regRec);
<a name="l00592"></a>00592       <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, regRowid);
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594   }<span class="keywordflow">else</span>{
<a name="l00595"></a>00595     <span class="comment">/* This is the case if the data for the INSERT is coming from a VALUES</span>
<a name="l00596"></a>00596 <span class="comment">    ** clause</span>
<a name="l00597"></a>00597 <span class="comment">    */</span>
<a name="l00598"></a>00598     <a class="code" href="structNameContext.html">NameContext</a> sNC;
<a name="l00599"></a>00599     memset(&amp;sNC, 0, <span class="keyword">sizeof</span>(sNC));
<a name="l00600"></a>00600     sNC.<a class="code" href="structNameContext.html#a14635249bf75d5e18124089571dd2386">pParse</a> = pParse;
<a name="l00601"></a>00601     srcTab = -1;
<a name="l00602"></a>00602     assert( useTempTable==0 );
<a name="l00603"></a>00603     nColumn = pList ? pList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a> : 0;
<a name="l00604"></a>00604     <span class="keywordflow">for</span>(i=0; i&lt;nColumn; i++){
<a name="l00605"></a>00605       <span class="keywordflow">if</span>( <a class="code" href="resolve_8c.html#afc8765990fa4299c3dc9bd295ae85291">sqlite3ResolveExprNames</a>(&amp;sNC, pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>) ){
<a name="l00606"></a>00606         <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00607"></a>00607       }
<a name="l00608"></a>00608     }
<a name="l00609"></a>00609   }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="comment">/* Make sure the number of columns in the source data matches the number</span>
<a name="l00612"></a>00612 <span class="comment">  ** of columns to be inserted into the table.</span>
<a name="l00613"></a>00613 <span class="comment">  */</span>
<a name="l00614"></a>00614   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) ){
<a name="l00615"></a>00615     <span class="keywordflow">for</span>(i=0; i&lt;pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>; i++){
<a name="l00616"></a>00616       nHidden += (<a class="code" href="sqliteInt_8h.html#a9fd2abca84f1958348fd71cd0bbe672a">IsHiddenColumn</a>(&amp;pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i]) ? 1 : 0);
<a name="l00617"></a>00617     }
<a name="l00618"></a>00618   }
<a name="l00619"></a>00619   <span class="keywordflow">if</span>( pColumn==0 &amp;&amp; nColumn &amp;&amp; nColumn!=(pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>-nHidden) ){
<a name="l00620"></a>00620     <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, 
<a name="l00621"></a>00621        <span class="stringliteral">&quot;table %S has %d columns but %d values were supplied&quot;</span>,
<a name="l00622"></a>00622        pTabList, 0, pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>, nColumn);
<a name="l00623"></a>00623     <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00624"></a>00624   }
<a name="l00625"></a>00625   <span class="keywordflow">if</span>( pColumn!=0 &amp;&amp; nColumn!=pColumn-&gt;<a class="code" href="structIdList.html#afb785717796d8b3c72d1ae682dcb6ff0">nId</a> ){
<a name="l00626"></a>00626     <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;%d values for %d columns&quot;</span>, nColumn, pColumn-&gt;<a class="code" href="structIdList.html#afb785717796d8b3c72d1ae682dcb6ff0">nId</a>);
<a name="l00627"></a>00627     <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00628"></a>00628   }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630   <span class="comment">/* If the INSERT statement included an IDLIST term, then make sure</span>
<a name="l00631"></a>00631 <span class="comment">  ** all elements of the IDLIST really are columns of the table and </span>
<a name="l00632"></a>00632 <span class="comment">  ** remember the column indices.</span>
<a name="l00633"></a>00633 <span class="comment">  **</span>
<a name="l00634"></a>00634 <span class="comment">  ** If the table has an INTEGER PRIMARY KEY column and that column</span>
<a name="l00635"></a>00635 <span class="comment">  ** is named in the IDLIST, then record in the keyColumn variable</span>
<a name="l00636"></a>00636 <span class="comment">  ** the index into IDLIST of the primary key column.  keyColumn is</span>
<a name="l00637"></a>00637 <span class="comment">  ** the index of the primary key as it appears in IDLIST, not as</span>
<a name="l00638"></a>00638 <span class="comment">  ** is appears in the original table.  (The index of the primary</span>
<a name="l00639"></a>00639 <span class="comment">  ** key in the original table is pTab-&gt;iPKey.)</span>
<a name="l00640"></a>00640 <span class="comment">  */</span>
<a name="l00641"></a>00641   <span class="keywordflow">if</span>( pColumn ){
<a name="l00642"></a>00642     <span class="keywordflow">for</span>(i=0; i&lt;pColumn-&gt;<a class="code" href="structIdList.html#afb785717796d8b3c72d1ae682dcb6ff0">nId</a>; i++){
<a name="l00643"></a>00643       pColumn-&gt;<a class="code" href="structIdList.html#ad33082fd71286c1159711a1a3e979763">a</a>[i].<a class="code" href="structIdList_1_1IdList__item.html#a869d1a5ee03bcb018e38fae6c9ac0572">idx</a> = -1;
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645     <span class="keywordflow">for</span>(i=0; i&lt;pColumn-&gt;<a class="code" href="structIdList.html#afb785717796d8b3c72d1ae682dcb6ff0">nId</a>; i++){
<a name="l00646"></a>00646       <span class="keywordflow">for</span>(j=0; j&lt;pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>; j++){
<a name="l00647"></a>00647         <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(pColumn-&gt;<a class="code" href="structIdList.html#ad33082fd71286c1159711a1a3e979763">a</a>[i].<a class="code" href="structIdList_1_1IdList__item.html#acd44e1182dc46441939cd6a5d935724c">zName</a>, pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[j].<a class="code" href="structColumn.html#a6450a4e9fde68b3a2d79425d826eccc3">zName</a>)==0 ){
<a name="l00648"></a>00648           pColumn-&gt;<a class="code" href="structIdList.html#ad33082fd71286c1159711a1a3e979763">a</a>[i].<a class="code" href="structIdList_1_1IdList__item.html#a869d1a5ee03bcb018e38fae6c9ac0572">idx</a> = j;
<a name="l00649"></a>00649           <span class="keywordflow">if</span>( j==pTab-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a> ){
<a name="l00650"></a>00650             keyColumn = i;
<a name="l00651"></a>00651           }
<a name="l00652"></a>00652           <span class="keywordflow">break</span>;
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654       }
<a name="l00655"></a>00655       <span class="keywordflow">if</span>( j&gt;=pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a> ){
<a name="l00656"></a>00656         <span class="keywordflow">if</span>( <a class="code" href="expr_8c.html#a8e6c995eb12a56470a6faf997c587c78">sqlite3IsRowid</a>(pColumn-&gt;<a class="code" href="structIdList.html#ad33082fd71286c1159711a1a3e979763">a</a>[i].<a class="code" href="structIdList_1_1IdList__item.html#acd44e1182dc46441939cd6a5d935724c">zName</a>) ){
<a name="l00657"></a>00657           keyColumn = i;
<a name="l00658"></a>00658         }<span class="keywordflow">else</span>{
<a name="l00659"></a>00659           <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;table %S has no column named %s&quot;</span>,
<a name="l00660"></a>00660               pTabList, 0, pColumn-&gt;<a class="code" href="structIdList.html#ad33082fd71286c1159711a1a3e979763">a</a>[i].<a class="code" href="structIdList_1_1IdList__item.html#acd44e1182dc46441939cd6a5d935724c">zName</a>);
<a name="l00661"></a>00661           pParse-&gt;<a class="code" href="structParse.html#ac7206f0c7e580ab32b7dfb20950bb1c9">nErr</a>++;
<a name="l00662"></a>00662           <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00663"></a>00663         }
<a name="l00664"></a>00664       }
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666   }
<a name="l00667"></a>00667 
<a name="l00668"></a>00668   <span class="comment">/* If there is no IDLIST term but the table has an integer primary</span>
<a name="l00669"></a>00669 <span class="comment">  ** key, the set the keyColumn variable to the primary key column index</span>
<a name="l00670"></a>00670 <span class="comment">  ** in the original table definition.</span>
<a name="l00671"></a>00671 <span class="comment">  */</span>
<a name="l00672"></a>00672   <span class="keywordflow">if</span>( pColumn==0 &amp;&amp; nColumn&gt;0 ){
<a name="l00673"></a>00673     keyColumn = pTab-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a>;
<a name="l00674"></a>00674   }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676   <span class="comment">/* Open the temp table for FOR EACH ROW triggers</span>
<a name="l00677"></a>00677 <span class="comment">  */</span>
<a name="l00678"></a>00678   <span class="keywordflow">if</span>( triggers_exist ){
<a name="l00679"></a>00679     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a573b06e057d808cf609dd66f29e0d998">OP_SetNumColumns</a>, 0, pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>);
<a name="l00680"></a>00680     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a4128984c342a0dd41b6d9c57c649ab29">OP_OpenPseudo</a>, newIdx, 0);
<a name="l00681"></a>00681   }
<a name="l00682"></a>00682     
<a name="l00683"></a>00683   <span class="comment">/* Initialize the count of rows to be inserted</span>
<a name="l00684"></a>00684 <span class="comment">  */</span>
<a name="l00685"></a>00685   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a8a0782a46f20beb040aeac0e89435d53">SQLITE_CountRows</a> ){
<a name="l00686"></a>00686     regRowCount = ++pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>;
<a name="l00687"></a>00687     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, 0, regRowCount);
<a name="l00688"></a>00688   }
<a name="l00689"></a>00689 
<a name="l00690"></a>00690   <span class="comment">/* If this is not a view, open the table and and all indices */</span>
<a name="l00691"></a>00691   <span class="keywordflow">if</span>( !isView ){
<a name="l00692"></a>00692     <span class="keywordtype">int</span> nIdx;
<a name="l00693"></a>00693     <span class="keywordtype">int</span> i;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     baseCur = pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>;
<a name="l00696"></a>00696     nIdx = <a class="code" href="insert_8c.html#a89b08e161706d849be60bc38e892021a">sqlite3OpenTableAndIndices</a>(pParse, pTab, baseCur, <a class="code" href="opcodes_8h.html#a98af8f9fca78ddf04bbc472cf2761f10">OP_OpenWrite</a>);
<a name="l00697"></a>00697     aRegIdx = <a class="code" href="malloc_8c.html#a043f868d32456bd7cdca4a62837277c1">sqlite3DbMallocRaw</a>(db, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*(nIdx+1));
<a name="l00698"></a>00698     <span class="keywordflow">if</span>( aRegIdx==0 ){
<a name="l00699"></a>00699       <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00700"></a>00700     }
<a name="l00701"></a>00701     <span class="keywordflow">for</span>(i=0; i&lt;nIdx; i++){
<a name="l00702"></a>00702       aRegIdx[i] = ++pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>;
<a name="l00703"></a>00703     }
<a name="l00704"></a>00704   }
<a name="l00705"></a>00705 
<a name="l00706"></a>00706   <span class="comment">/* This is the top of the main insertion loop */</span>
<a name="l00707"></a>00707   <span class="keywordflow">if</span>( useTempTable ){
<a name="l00708"></a>00708     <span class="comment">/* This block codes the top of loop only.  The complete loop is the</span>
<a name="l00709"></a>00709 <span class="comment">    ** following pseudocode (template 4):</span>
<a name="l00710"></a>00710 <span class="comment">    **</span>
<a name="l00711"></a>00711 <span class="comment">    **         rewind temp table</span>
<a name="l00712"></a>00712 <span class="comment">    **      C: loop over rows of intermediate table</span>
<a name="l00713"></a>00713 <span class="comment">    **           transfer values form intermediate table into &lt;table&gt;</span>
<a name="l00714"></a>00714 <span class="comment">    **         end loop</span>
<a name="l00715"></a>00715 <span class="comment">    **      D: ...</span>
<a name="l00716"></a>00716 <span class="comment">    */</span>
<a name="l00717"></a>00717     addrInsTop = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>, srcTab);
<a name="l00718"></a>00718     addrCont = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l00719"></a>00719   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pSelect ){
<a name="l00720"></a>00720     <span class="comment">/* This block codes the top of loop only.  The complete loop is the</span>
<a name="l00721"></a>00721 <span class="comment">    ** following pseudocode (template 3):</span>
<a name="l00722"></a>00722 <span class="comment">    **</span>
<a name="l00723"></a>00723 <span class="comment">    **      C: yield X</span>
<a name="l00724"></a>00724 <span class="comment">    **         if EOF goto D</span>
<a name="l00725"></a>00725 <span class="comment">    **         insert the select result into &lt;table&gt; from R..R+n</span>
<a name="l00726"></a>00726 <span class="comment">    **         goto C</span>
<a name="l00727"></a>00727 <span class="comment">    **      D: ...</span>
<a name="l00728"></a>00728 <span class="comment">    */</span>
<a name="l00729"></a>00729     addrCont = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a7ebd9b3f2515a2a3787fcb78265ec036">OP_Yield</a>, dest.<a class="code" href="structSelectDest.html#a6ca726a6f8054df61baa150c5010c53f">iParm</a>);
<a name="l00730"></a>00730     addrInsTop = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#ac2b8b882b701cfbad6bfca4ac6db76bc">OP_If</a>, regEof);
<a name="l00731"></a>00731   }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733   <span class="comment">/* Allocate registers for holding the rowid of the new row,</span>
<a name="l00734"></a>00734 <span class="comment">  ** the content of the new row, and the assemblied row record.</span>
<a name="l00735"></a>00735 <span class="comment">  */</span>
<a name="l00736"></a>00736   regRecord = ++pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>;
<a name="l00737"></a>00737   regRowid = regIns = pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>+1;
<a name="l00738"></a>00738   pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a> += pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a> + 1;
<a name="l00739"></a>00739   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) ){
<a name="l00740"></a>00740     regRowid++;
<a name="l00741"></a>00741     pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>++;
<a name="l00742"></a>00742   }
<a name="l00743"></a>00743   regData = regRowid+1;
<a name="l00744"></a>00744 
<a name="l00745"></a>00745   <span class="comment">/* Run the BEFORE and INSTEAD OF triggers, if there are any</span>
<a name="l00746"></a>00746 <span class="comment">  */</span>
<a name="l00747"></a>00747   endOfLoop = <a class="code" href="vdbe_8h.html#a5279e16a2acad1e72ba58ae938d385bd">sqlite3VdbeMakeLabel</a>(v);
<a name="l00748"></a>00748   <span class="keywordflow">if</span>( triggers_exist &amp; <a class="code" href="sqliteInt_8h.html#a0d954f7307c3332200ea5df0243e871a">TRIGGER_BEFORE</a> ){
<a name="l00749"></a>00749     <span class="keywordtype">int</span> regRowid;
<a name="l00750"></a>00750     <span class="keywordtype">int</span> regCols;
<a name="l00751"></a>00751     <span class="keywordtype">int</span> regRec;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753     <span class="comment">/* build the NEW.* reference row.  Note that if there is an INTEGER</span>
<a name="l00754"></a>00754 <span class="comment">    ** PRIMARY KEY into which a NULL is being inserted, that NULL will be</span>
<a name="l00755"></a>00755 <span class="comment">    ** translated into a unique ID for the row.  But on a BEFORE trigger,</span>
<a name="l00756"></a>00756 <span class="comment">    ** we do not know what the unique ID will be (because the insert has</span>
<a name="l00757"></a>00757 <span class="comment">    ** not happened yet) so we substitute a rowid of -1</span>
<a name="l00758"></a>00758 <span class="comment">    */</span>
<a name="l00759"></a>00759     regRowid = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l00760"></a>00760     <span class="keywordflow">if</span>( keyColumn&lt;0 ){
<a name="l00761"></a>00761       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, -1, regRowid);
<a name="l00762"></a>00762     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( useTempTable ){
<a name="l00763"></a>00763       <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a>, srcTab, keyColumn, regRowid);
<a name="l00764"></a>00764     }<span class="keywordflow">else</span>{
<a name="l00765"></a>00765       <span class="keywordtype">int</span> j1;
<a name="l00766"></a>00766       assert( pSelect==0 );  <span class="comment">/* Otherwise useTempTable is true */</span>
<a name="l00767"></a>00767       <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[keyColumn].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>, regRowid);
<a name="l00768"></a>00768       j1 = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a2c2d69757c7bf41ae12092a80b04c088">OP_NotNull</a>, regRowid);
<a name="l00769"></a>00769       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, -1, regRowid);
<a name="l00770"></a>00770       <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, j1);
<a name="l00771"></a>00771       <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a580e3f6ffe3e1d44076cdc3ae56f05dc">OP_MustBeInt</a>, regRowid);
<a name="l00772"></a>00772     }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774     <span class="comment">/* Cannot have triggers on a virtual table. If it were possible,</span>
<a name="l00775"></a>00775 <span class="comment">    ** this block would have to account for hidden column.</span>
<a name="l00776"></a>00776 <span class="comment">    */</span>
<a name="l00777"></a>00777     assert(!<a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab));
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     <span class="comment">/* Create the new column data</span>
<a name="l00780"></a>00780 <span class="comment">    */</span>
<a name="l00781"></a>00781     regCols = <a class="code" href="expr_8c.html#aa8d79db03e9903a3c056652eea2df234">sqlite3GetTempRange</a>(pParse, pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>);
<a name="l00782"></a>00782     <span class="keywordflow">for</span>(i=0; i&lt;pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>; i++){
<a name="l00783"></a>00783       <span class="keywordflow">if</span>( pColumn==0 ){
<a name="l00784"></a>00784         j = i;
<a name="l00785"></a>00785       }<span class="keywordflow">else</span>{
<a name="l00786"></a>00786         <span class="keywordflow">for</span>(j=0; j&lt;pColumn-&gt;<a class="code" href="structIdList.html#afb785717796d8b3c72d1ae682dcb6ff0">nId</a>; j++){
<a name="l00787"></a>00787           <span class="keywordflow">if</span>( pColumn-&gt;<a class="code" href="structIdList.html#ad33082fd71286c1159711a1a3e979763">a</a>[j].<a class="code" href="structIdList_1_1IdList__item.html#a869d1a5ee03bcb018e38fae6c9ac0572">idx</a>==i ) <span class="keywordflow">break</span>;
<a name="l00788"></a>00788         }
<a name="l00789"></a>00789       }
<a name="l00790"></a>00790       <span class="keywordflow">if</span>( pColumn &amp;&amp; j&gt;=pColumn-&gt;<a class="code" href="structIdList.html#afb785717796d8b3c72d1ae682dcb6ff0">nId</a> ){
<a name="l00791"></a>00791         <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#ac4178f302df70048235660979f84ffe4">pDflt</a>, regCols+i);
<a name="l00792"></a>00792       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( useTempTable ){
<a name="l00793"></a>00793         <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a>, srcTab, j, regCols+i); 
<a name="l00794"></a>00794       }<span class="keywordflow">else</span>{
<a name="l00795"></a>00795         assert( pSelect==0 ); <span class="comment">/* Otherwise useTempTable is true */</span>
<a name="l00796"></a>00796         <a class="code" href="expr_8c.html#a7fc57a2d1705309dbf7d051616c7d451">sqlite3ExprCodeAndCache</a>(pParse, pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[j].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>, regCols+i);
<a name="l00797"></a>00797       }
<a name="l00798"></a>00798     }
<a name="l00799"></a>00799     regRec = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l00800"></a>00800     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#aaa8701055972e3d38e2f9801708cd9fc">OP_MakeRecord</a>, regCols, pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>, regRec);
<a name="l00801"></a>00801 
<a name="l00802"></a>00802     <span class="comment">/* If this is an INSERT on a view with an INSTEAD OF INSERT trigger,</span>
<a name="l00803"></a>00803 <span class="comment">    ** do not attempt any conversions before assembling the record.</span>
<a name="l00804"></a>00804 <span class="comment">    ** If this is a real table, attempt conversions as required by the</span>
<a name="l00805"></a>00805 <span class="comment">    ** table column affinities.</span>
<a name="l00806"></a>00806 <span class="comment">    */</span>
<a name="l00807"></a>00807     <span class="keywordflow">if</span>( !isView ){
<a name="l00808"></a>00808       <a class="code" href="insert_8c.html#ad89a146ebc8b75355716cb0f2fd513c6">sqlite3TableAffinityStr</a>(v, pTab);
<a name="l00809"></a>00809     }
<a name="l00810"></a>00810     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#af8ec5cb3f4bce8e904b41f713c2c7d86">OP_Insert</a>, newIdx, regRec, regRowid);
<a name="l00811"></a>00811     <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, regRec);
<a name="l00812"></a>00812     <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, regRowid);
<a name="l00813"></a>00813     <a class="code" href="expr_8c.html#a6fa2fbefc3cf05be866029e9a5eb6361">sqlite3ReleaseTempRange</a>(pParse, regCols, pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>);
<a name="l00814"></a>00814 
<a name="l00815"></a>00815     <span class="comment">/* Fire BEFORE or INSTEAD OF triggers */</span>
<a name="l00816"></a>00816     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a45a7b8aeea2ac7fd2e6d3804c7811045">sqlite3CodeRowTrigger</a>(pParse, <a class="code" href="parse_8h.html#a407a8abe71ab89c3d8e5d4ddc2328cc7">TK_INSERT</a>, 0, TRIGGER_BEFORE, pTab, 
<a name="l00817"></a>00817         newIdx, -1, onError, endOfLoop, 0, 0) ){
<a name="l00818"></a>00818       <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00819"></a>00819     }
<a name="l00820"></a>00820   }
<a name="l00821"></a>00821 
<a name="l00822"></a>00822   <span class="comment">/* Push the record number for the new entry onto the stack.  The</span>
<a name="l00823"></a>00823 <span class="comment">  ** record number is a randomly generate integer created by NewRowid</span>
<a name="l00824"></a>00824 <span class="comment">  ** except when the table has an INTEGER PRIMARY KEY column, in which</span>
<a name="l00825"></a>00825 <span class="comment">  ** case the record number is the same as that column. </span>
<a name="l00826"></a>00826 <span class="comment">  */</span>
<a name="l00827"></a>00827   <span class="keywordflow">if</span>( !isView ){
<a name="l00828"></a>00828     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) ){
<a name="l00829"></a>00829       <span class="comment">/* The row that the VUpdate opcode will delete: none */</span>
<a name="l00830"></a>00830       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a9fa8760362f8ea197ca11e99b186206b">OP_Null</a>, 0, regIns);
<a name="l00831"></a>00831     }
<a name="l00832"></a>00832     <span class="keywordflow">if</span>( keyColumn&gt;=0 ){
<a name="l00833"></a>00833       <span class="keywordflow">if</span>( useTempTable ){
<a name="l00834"></a>00834         <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a>, srcTab, keyColumn, regRowid);
<a name="l00835"></a>00835       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pSelect ){
<a name="l00836"></a>00836         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af9e5064dc7159d38276860049da8b3b0">OP_SCopy</a>, regFromSelect+keyColumn, regRowid);
<a name="l00837"></a>00837       }<span class="keywordflow">else</span>{
<a name="l00838"></a>00838         <a class="code" href="structVdbeOp.html">VdbeOp</a> *pOp;
<a name="l00839"></a>00839         <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[keyColumn].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>, regRowid);
<a name="l00840"></a>00840         pOp = <a class="code" href="vdbe_8h.html#a1badd052381dc9cd17422bcc7e09db43">sqlite3VdbeGetOp</a>(v, <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v) - 1);
<a name="l00841"></a>00841         <span class="keywordflow">if</span>( pOp &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a9fa8760362f8ea197ca11e99b186206b">OP_Null</a> &amp;&amp; !<a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) ){
<a name="l00842"></a>00842           appendFlag = 1;
<a name="l00843"></a>00843           pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> = <a class="code" href="opcodes_8h.html#aebc7e3a304f9b4b81abce298ff9704ec">OP_NewRowid</a>;
<a name="l00844"></a>00844           pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> = baseCur;
<a name="l00845"></a>00845           pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> = regRowid;
<a name="l00846"></a>00846           pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a> = regAutoinc;
<a name="l00847"></a>00847         }
<a name="l00848"></a>00848       }
<a name="l00849"></a>00849       <span class="comment">/* If the PRIMARY KEY expression is NULL, then use OP_NewRowid</span>
<a name="l00850"></a>00850 <span class="comment">      ** to generate a unique primary key value.</span>
<a name="l00851"></a>00851 <span class="comment">      */</span>
<a name="l00852"></a>00852       <span class="keywordflow">if</span>( !appendFlag ){
<a name="l00853"></a>00853         <span class="keywordtype">int</span> j1;
<a name="l00854"></a>00854         <span class="keywordflow">if</span>( !<a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) ){
<a name="l00855"></a>00855           j1 = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a2c2d69757c7bf41ae12092a80b04c088">OP_NotNull</a>, regRowid);
<a name="l00856"></a>00856           <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#aebc7e3a304f9b4b81abce298ff9704ec">OP_NewRowid</a>, baseCur, regRowid, regAutoinc);
<a name="l00857"></a>00857           <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, j1);
<a name="l00858"></a>00858         }<span class="keywordflow">else</span>{
<a name="l00859"></a>00859           j1 = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l00860"></a>00860           <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#aa94eede07c1e2c3fcb96239fa368a3d2">OP_IsNull</a>, regRowid, j1+2);
<a name="l00861"></a>00861         }
<a name="l00862"></a>00862         <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a580e3f6ffe3e1d44076cdc3ae56f05dc">OP_MustBeInt</a>, regRowid);
<a name="l00863"></a>00863       }
<a name="l00864"></a>00864     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) ){
<a name="l00865"></a>00865       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a9fa8760362f8ea197ca11e99b186206b">OP_Null</a>, 0, regRowid);
<a name="l00866"></a>00866     }<span class="keywordflow">else</span>{
<a name="l00867"></a>00867       <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#aebc7e3a304f9b4b81abce298ff9704ec">OP_NewRowid</a>, baseCur, regRowid, regAutoinc);
<a name="l00868"></a>00868       appendFlag = 1;
<a name="l00869"></a>00869     }
<a name="l00870"></a>00870     <a class="code" href="insert_8c.html#af9b0d0bb1338fe4bf074901ad8f6eb1b">autoIncStep</a>(pParse, regAutoinc, regRowid);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872     <span class="comment">/* Push onto the stack, data for all columns of the new entry, beginning</span>
<a name="l00873"></a>00873 <span class="comment">    ** with the first column.</span>
<a name="l00874"></a>00874 <span class="comment">    */</span>
<a name="l00875"></a>00875     nHidden = 0;
<a name="l00876"></a>00876     <span class="keywordflow">for</span>(i=0; i&lt;pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>; i++){
<a name="l00877"></a>00877       <span class="keywordtype">int</span> iRegStore = regRowid+1+i;
<a name="l00878"></a>00878       <span class="keywordflow">if</span>( i==pTab-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a> ){
<a name="l00879"></a>00879         <span class="comment">/* The value of the INTEGER PRIMARY KEY column is always a NULL.</span>
<a name="l00880"></a>00880 <span class="comment">        ** Whenever this column is read, the record number will be substituted</span>
<a name="l00881"></a>00881 <span class="comment">        ** in its place.  So will fill this column with a NULL to avoid</span>
<a name="l00882"></a>00882 <span class="comment">        ** taking up data space with information that will never be used. */</span>
<a name="l00883"></a>00883         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a9fa8760362f8ea197ca11e99b186206b">OP_Null</a>, 0, iRegStore);
<a name="l00884"></a>00884         <span class="keywordflow">continue</span>;
<a name="l00885"></a>00885       }
<a name="l00886"></a>00886       <span class="keywordflow">if</span>( pColumn==0 ){
<a name="l00887"></a>00887         <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a9fd2abca84f1958348fd71cd0bbe672a">IsHiddenColumn</a>(&amp;pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i]) ){
<a name="l00888"></a>00888           assert( <a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) );
<a name="l00889"></a>00889           j = -1;
<a name="l00890"></a>00890           nHidden++;
<a name="l00891"></a>00891         }<span class="keywordflow">else</span>{
<a name="l00892"></a>00892           j = i - nHidden;
<a name="l00893"></a>00893         }
<a name="l00894"></a>00894       }<span class="keywordflow">else</span>{
<a name="l00895"></a>00895         <span class="keywordflow">for</span>(j=0; j&lt;pColumn-&gt;<a class="code" href="structIdList.html#afb785717796d8b3c72d1ae682dcb6ff0">nId</a>; j++){
<a name="l00896"></a>00896           <span class="keywordflow">if</span>( pColumn-&gt;<a class="code" href="structIdList.html#ad33082fd71286c1159711a1a3e979763">a</a>[j].<a class="code" href="structIdList_1_1IdList__item.html#a869d1a5ee03bcb018e38fae6c9ac0572">idx</a>==i ) <span class="keywordflow">break</span>;
<a name="l00897"></a>00897         }
<a name="l00898"></a>00898       }
<a name="l00899"></a>00899       <span class="keywordflow">if</span>( j&lt;0 || nColumn==0 || (pColumn &amp;&amp; j&gt;=pColumn-&gt;<a class="code" href="structIdList.html#afb785717796d8b3c72d1ae682dcb6ff0">nId</a>) ){
<a name="l00900"></a>00900         <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#ac4178f302df70048235660979f84ffe4">pDflt</a>, iRegStore);
<a name="l00901"></a>00901       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( useTempTable ){
<a name="l00902"></a>00902         <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a>, srcTab, j, iRegStore); 
<a name="l00903"></a>00903       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pSelect ){
<a name="l00904"></a>00904         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af9e5064dc7159d38276860049da8b3b0">OP_SCopy</a>, regFromSelect+j, iRegStore);
<a name="l00905"></a>00905       }<span class="keywordflow">else</span>{
<a name="l00906"></a>00906         <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[j].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>, iRegStore);
<a name="l00907"></a>00907       }
<a name="l00908"></a>00908     }
<a name="l00909"></a>00909 
<a name="l00910"></a>00910     <span class="comment">/* Generate code to check constraints and generate index keys and</span>
<a name="l00911"></a>00911 <span class="comment">    ** do the insertion.</span>
<a name="l00912"></a>00912 <span class="comment">    */</span>
<a name="l00913"></a>00913 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l00914"></a>00914 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) ){
<a name="l00915"></a>00915       <a class="code" href="sqliteInt_8h.html#acdaaf5dbcf0f65c36d821a9b126e0230">sqlite3VtabMakeWritable</a>(pParse, pTab);
<a name="l00916"></a>00916       <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#aca34cb921c1d7e1998a2a3c78b29c831">OP_VUpdate</a>, 1, pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>+2, regIns,
<a name="l00917"></a>00917                      (<span class="keyword">const</span> <span class="keywordtype">char</span>*)pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a>, <a class="code" href="vdbe_8h.html#a7a5cdd538a2cb9cf421f7e2f14b3947f">P4_VTAB</a>);
<a name="l00918"></a>00918     }<span class="keywordflow">else</span>
<a name="l00919"></a>00919 <span class="preprocessor">#endif</span>
<a name="l00920"></a>00920 <span class="preprocessor"></span>    {
<a name="l00921"></a>00921       <a class="code" href="insert_8c.html#a047682906ce5713afad443984ff9b9e6">sqlite3GenerateConstraintChecks</a>(
<a name="l00922"></a>00922           pParse,
<a name="l00923"></a>00923           pTab,
<a name="l00924"></a>00924           baseCur,
<a name="l00925"></a>00925           regIns,
<a name="l00926"></a>00926           aRegIdx,
<a name="l00927"></a>00927           keyColumn&gt;=0,
<a name="l00928"></a>00928           0,
<a name="l00929"></a>00929           onError,
<a name="l00930"></a>00930           endOfLoop
<a name="l00931"></a>00931       );
<a name="l00932"></a>00932       <a class="code" href="insert_8c.html#a1bb06838d234ed5a743031c4e342c7a3">sqlite3CompleteInsertion</a>(
<a name="l00933"></a>00933           pParse,
<a name="l00934"></a>00934           pTab,
<a name="l00935"></a>00935           baseCur,
<a name="l00936"></a>00936           regIns,
<a name="l00937"></a>00937           aRegIdx,
<a name="l00938"></a>00938           0,
<a name="l00939"></a>00939           0,
<a name="l00940"></a>00940           (triggers_exist &amp; <a class="code" href="sqliteInt_8h.html#ad18fafb431e8f65027569857b6550f20">TRIGGER_AFTER</a>)!=0 ? newIdx : -1,
<a name="l00941"></a>00941           appendFlag
<a name="l00942"></a>00942        );
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944   }
<a name="l00945"></a>00945 
<a name="l00946"></a>00946   <span class="comment">/* Update the count of rows that are inserted</span>
<a name="l00947"></a>00947 <span class="comment">  */</span>
<a name="l00948"></a>00948   <span class="keywordflow">if</span>( (db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a8a0782a46f20beb040aeac0e89435d53">SQLITE_CountRows</a>)!=0 ){
<a name="l00949"></a>00949     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a7714cbc92ac65a80b5b1b7513f17d9b0">OP_AddImm</a>, regRowCount, 1);
<a name="l00950"></a>00950   }
<a name="l00951"></a>00951 
<a name="l00952"></a>00952   <span class="keywordflow">if</span>( triggers_exist ){
<a name="l00953"></a>00953     <span class="comment">/* Code AFTER triggers */</span>
<a name="l00954"></a>00954     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a45a7b8aeea2ac7fd2e6d3804c7811045">sqlite3CodeRowTrigger</a>(pParse, <a class="code" href="parse_8h.html#a407a8abe71ab89c3d8e5d4ddc2328cc7">TK_INSERT</a>, 0, <a class="code" href="sqliteInt_8h.html#ad18fafb431e8f65027569857b6550f20">TRIGGER_AFTER</a>, pTab,
<a name="l00955"></a>00955           newIdx, -1, onError, endOfLoop, 0, 0) ){
<a name="l00956"></a>00956       <span class="keywordflow">goto</span> insert_cleanup;
<a name="l00957"></a>00957     }
<a name="l00958"></a>00958   }
<a name="l00959"></a>00959 
<a name="l00960"></a>00960   <span class="comment">/* The bottom of the main insertion loop, if the data source</span>
<a name="l00961"></a>00961 <span class="comment">  ** is a SELECT statement.</span>
<a name="l00962"></a>00962 <span class="comment">  */</span>
<a name="l00963"></a>00963   <a class="code" href="vdbe_8h.html#aea27581f782aaa7e14ae22a3c061f483">sqlite3VdbeResolveLabel</a>(v, endOfLoop);
<a name="l00964"></a>00964   <span class="keywordflow">if</span>( useTempTable ){
<a name="l00965"></a>00965     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a>, srcTab, addrCont);
<a name="l00966"></a>00966     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, addrInsTop);
<a name="l00967"></a>00967     <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, srcTab);
<a name="l00968"></a>00968   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pSelect ){
<a name="l00969"></a>00969     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, addrCont);
<a name="l00970"></a>00970     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, addrInsTop);
<a name="l00971"></a>00971   }
<a name="l00972"></a>00972 
<a name="l00973"></a>00973   <span class="keywordflow">if</span>( !<a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) &amp;&amp; !isView ){
<a name="l00974"></a>00974     <span class="comment">/* Close all tables opened */</span>
<a name="l00975"></a>00975     <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, baseCur);
<a name="l00976"></a>00976     <span class="keywordflow">for</span>(idx=1, pIdx=pTab-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>; pIdx; pIdx=pIdx-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>, idx++){
<a name="l00977"></a>00977       <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, idx+baseCur);
<a name="l00978"></a>00978     }
<a name="l00979"></a>00979   }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981   <span class="comment">/* Update the sqlite_sequence table by storing the content of the</span>
<a name="l00982"></a>00982 <span class="comment">  ** counter value in memory regAutoinc back into the sqlite_sequence</span>
<a name="l00983"></a>00983 <span class="comment">  ** table.</span>
<a name="l00984"></a>00984 <span class="comment">  */</span>
<a name="l00985"></a>00985   <a class="code" href="insert_8c.html#a00c877d23537fbd22de156afc6c52f9d">autoIncEnd</a>(pParse, iDb, pTab, regAutoinc);
<a name="l00986"></a>00986 
<a name="l00987"></a>00987   <span class="comment">/*</span>
<a name="l00988"></a>00988 <span class="comment">  ** Return the number of rows inserted. If this routine is </span>
<a name="l00989"></a>00989 <span class="comment">  ** generating code because of a call to sqlite3NestedParse(), do not</span>
<a name="l00990"></a>00990 <span class="comment">  ** invoke the callback function.</span>
<a name="l00991"></a>00991 <span class="comment">  */</span>
<a name="l00992"></a>00992   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a8a0782a46f20beb040aeac0e89435d53">SQLITE_CountRows</a> &amp;&amp; pParse-&gt;<a class="code" href="structParse.html#a33d62687b6d368acf94e954490358819">nested</a>==0 &amp;&amp; !pParse-&gt;<a class="code" href="structParse.html#a1ae8776978de122f725acd37784522ed">trigStack</a> ){
<a name="l00993"></a>00993     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a4a151d57c367806cd9e8a75f4865fd1b">OP_ResultRow</a>, regRowCount, 1);
<a name="l00994"></a>00994     <a class="code" href="vdbe_8h.html#adbf4be46f9152eb8e9be03ad52453b3e">sqlite3VdbeSetNumCols</a>(v, 1);
<a name="l00995"></a>00995     <a class="code" href="vdbe_8h.html#a3501a072f6a015567c0ce5ed683bf31f">sqlite3VdbeSetColName</a>(v, 0, <a class="code" href="vdbe_8h.html#af2998f82dd52035cb28538e1ecde4e7b">COLNAME_NAME</a>, <span class="stringliteral">&quot;rows inserted&quot;</span>, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l00996"></a>00996   }
<a name="l00997"></a>00997 
<a name="l00998"></a>00998 insert_cleanup:
<a name="l00999"></a>00999   <a class="code" href="build_8c.html#abe713de54d4038bcf0dba2d4f24ef8f0">sqlite3SrcListDelete</a>(db, pTabList);
<a name="l01000"></a>01000   <a class="code" href="expr_8c.html#a98a67aead81716e47859051ede821a41">sqlite3ExprListDelete</a>(db, pList);
<a name="l01001"></a>01001   <a class="code" href="select_8c.html#a953c070f3878ded50cf4ddb8322ddc9d">sqlite3SelectDelete</a>(db, pSelect);
<a name="l01002"></a>01002   <a class="code" href="build_8c.html#a05dc848a12030178f6e80d9b5a6698a6">sqlite3IdListDelete</a>(db, pColumn);
<a name="l01003"></a>01003   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, aRegIdx);
<a name="l01004"></a>01004 }
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 <span class="comment">/*</span>
<a name="l01007"></a>01007 <span class="comment">** Generate code to do constraint checks prior to an INSERT or an UPDATE.</span>
<a name="l01008"></a>01008 <span class="comment">**</span>
<a name="l01009"></a>01009 <span class="comment">** The input is a range of consecutive registers as follows:</span>
<a name="l01010"></a>01010 <span class="comment">**</span>
<a name="l01011"></a>01011 <span class="comment">**    1.  The rowid of the row to be updated before the update.  This</span>
<a name="l01012"></a>01012 <span class="comment">**        value is omitted unless we are doing an UPDATE that involves a</span>
<a name="l01013"></a>01013 <span class="comment">**        change to the record number or writing to a virtual table.</span>
<a name="l01014"></a>01014 <span class="comment">**</span>
<a name="l01015"></a>01015 <span class="comment">**    2.  The rowid of the row after the update.</span>
<a name="l01016"></a>01016 <span class="comment">**</span>
<a name="l01017"></a>01017 <span class="comment">**    3.  The data in the first column of the entry after the update.</span>
<a name="l01018"></a>01018 <span class="comment">**</span>
<a name="l01019"></a>01019 <span class="comment">**    i.  Data from middle columns...</span>
<a name="l01020"></a>01020 <span class="comment">**</span>
<a name="l01021"></a>01021 <span class="comment">**    N.  The data in the last column of the entry after the update.</span>
<a name="l01022"></a>01022 <span class="comment">**</span>
<a name="l01023"></a>01023 <span class="comment">** The regRowid parameter is the index of the register containing (2).</span>
<a name="l01024"></a>01024 <span class="comment">**</span>
<a name="l01025"></a>01025 <span class="comment">** The old rowid shown as entry (1) above is omitted unless both isUpdate</span>
<a name="l01026"></a>01026 <span class="comment">** and rowidChng are 1.  isUpdate is true for UPDATEs and false for</span>
<a name="l01027"></a>01027 <span class="comment">** INSERTs.  RowidChng means that the new rowid is explicitly specified by</span>
<a name="l01028"></a>01028 <span class="comment">** the update or insert statement.  If rowidChng is false, it means that</span>
<a name="l01029"></a>01029 <span class="comment">** the rowid is computed automatically in an insert or that the rowid value</span>
<a name="l01030"></a>01030 <span class="comment">** is not modified by the update.</span>
<a name="l01031"></a>01031 <span class="comment">**</span>
<a name="l01032"></a>01032 <span class="comment">** The code generated by this routine store new index entries into</span>
<a name="l01033"></a>01033 <span class="comment">** registers identified by aRegIdx[].  No index entry is created for</span>
<a name="l01034"></a>01034 <span class="comment">** indices where aRegIdx[i]==0.  The order of indices in aRegIdx[] is</span>
<a name="l01035"></a>01035 <span class="comment">** the same as the order of indices on the linked list of indices</span>
<a name="l01036"></a>01036 <span class="comment">** attached to the table.</span>
<a name="l01037"></a>01037 <span class="comment">**</span>
<a name="l01038"></a>01038 <span class="comment">** This routine also generates code to check constraints.  NOT NULL,</span>
<a name="l01039"></a>01039 <span class="comment">** CHECK, and UNIQUE constraints are all checked.  If a constraint fails,</span>
<a name="l01040"></a>01040 <span class="comment">** then the appropriate action is performed.  There are five possible</span>
<a name="l01041"></a>01041 <span class="comment">** actions: ROLLBACK, ABORT, FAIL, REPLACE, and IGNORE.</span>
<a name="l01042"></a>01042 <span class="comment">**</span>
<a name="l01043"></a>01043 <span class="comment">**  Constraint type  Action       What Happens</span>
<a name="l01044"></a>01044 <span class="comment">**  ---------------  ----------   ----------------------------------------</span>
<a name="l01045"></a>01045 <span class="comment">**  any              ROLLBACK     The current transaction is rolled back and</span>
<a name="l01046"></a>01046 <span class="comment">**                                sqlite3_exec() returns immediately with a</span>
<a name="l01047"></a>01047 <span class="comment">**                                return code of SQLITE_CONSTRAINT.</span>
<a name="l01048"></a>01048 <span class="comment">**</span>
<a name="l01049"></a>01049 <span class="comment">**  any              ABORT        Back out changes from the current command</span>
<a name="l01050"></a>01050 <span class="comment">**                                only (do not do a complete rollback) then</span>
<a name="l01051"></a>01051 <span class="comment">**                                cause sqlite3_exec() to return immediately</span>
<a name="l01052"></a>01052 <span class="comment">**                                with SQLITE_CONSTRAINT.</span>
<a name="l01053"></a>01053 <span class="comment">**</span>
<a name="l01054"></a>01054 <span class="comment">**  any              FAIL         Sqlite_exec() returns immediately with a</span>
<a name="l01055"></a>01055 <span class="comment">**                                return code of SQLITE_CONSTRAINT.  The</span>
<a name="l01056"></a>01056 <span class="comment">**                                transaction is not rolled back and any</span>
<a name="l01057"></a>01057 <span class="comment">**                                prior changes are retained.</span>
<a name="l01058"></a>01058 <span class="comment">**</span>
<a name="l01059"></a>01059 <span class="comment">**  any              IGNORE       The record number and data is popped from</span>
<a name="l01060"></a>01060 <span class="comment">**                                the stack and there is an immediate jump</span>
<a name="l01061"></a>01061 <span class="comment">**                                to label ignoreDest.</span>
<a name="l01062"></a>01062 <span class="comment">**</span>
<a name="l01063"></a>01063 <span class="comment">**  NOT NULL         REPLACE      The NULL value is replace by the default</span>
<a name="l01064"></a>01064 <span class="comment">**                                value for that column.  If the default value</span>
<a name="l01065"></a>01065 <span class="comment">**                                is NULL, the action is the same as ABORT.</span>
<a name="l01066"></a>01066 <span class="comment">**</span>
<a name="l01067"></a>01067 <span class="comment">**  UNIQUE           REPLACE      The other row that conflicts with the row</span>
<a name="l01068"></a>01068 <span class="comment">**                                being inserted is removed.</span>
<a name="l01069"></a>01069 <span class="comment">**</span>
<a name="l01070"></a>01070 <span class="comment">**  CHECK            REPLACE      Illegal.  The results in an exception.</span>
<a name="l01071"></a>01071 <span class="comment">**</span>
<a name="l01072"></a>01072 <span class="comment">** Which action to take is determined by the overrideError parameter.</span>
<a name="l01073"></a>01073 <span class="comment">** Or if overrideError==OE_Default, then the pParse-&gt;onError parameter</span>
<a name="l01074"></a>01074 <span class="comment">** is used.  Or if pParse-&gt;onError==OE_Default then the onError value</span>
<a name="l01075"></a>01075 <span class="comment">** for the constraint is used.</span>
<a name="l01076"></a>01076 <span class="comment">**</span>
<a name="l01077"></a>01077 <span class="comment">** The calling routine must open a read/write cursor for pTab with</span>
<a name="l01078"></a>01078 <span class="comment">** cursor number &quot;baseCur&quot;.  All indices of pTab must also have open</span>
<a name="l01079"></a>01079 <span class="comment">** read/write cursors with cursor number baseCur+i for the i-th cursor.</span>
<a name="l01080"></a>01080 <span class="comment">** Except, if there is no possibility of a REPLACE action then</span>
<a name="l01081"></a>01081 <span class="comment">** cursors do not need to be open for indices where aRegIdx[i]==0.</span>
<a name="l01082"></a>01082 <span class="comment">*/</span>
<a name="l01083"></a><a class="code" href="sqliteInt_8h.html#af6093ca347ac94378d2af20bd3cf1b24">01083</a> <span class="keywordtype">void</span> <a class="code" href="insert_8c.html#a047682906ce5713afad443984ff9b9e6">sqlite3GenerateConstraintChecks</a>(
<a name="l01084"></a>01084   <a class="code" href="structParse.html">Parse</a> *pParse,      <span class="comment">/* The parser context */</span>
<a name="l01085"></a>01085   <a class="code" href="structTable.html">Table</a> *pTab,        <span class="comment">/* the table into which we are inserting */</span>
<a name="l01086"></a>01086   <span class="keywordtype">int</span> baseCur,        <span class="comment">/* Index of a read/write cursor pointing at pTab */</span>
<a name="l01087"></a>01087   <span class="keywordtype">int</span> regRowid,       <span class="comment">/* Index of the range of input registers */</span>
<a name="l01088"></a>01088   <span class="keywordtype">int</span> *aRegIdx,       <span class="comment">/* Register used by each index.  0 for unused indices */</span>
<a name="l01089"></a>01089   <span class="keywordtype">int</span> rowidChng,      <span class="comment">/* True if the rowid might collide with existing entry */</span>
<a name="l01090"></a>01090   <span class="keywordtype">int</span> isUpdate,       <span class="comment">/* True for UPDATE, False for INSERT */</span>
<a name="l01091"></a>01091   <span class="keywordtype">int</span> overrideError,  <span class="comment">/* Override onError to this if not OE_Default */</span>
<a name="l01092"></a>01092   <span class="keywordtype">int</span> ignoreDest      <span class="comment">/* Jump to this label on an OE_Ignore resolution */</span>
<a name="l01093"></a>01093 ){
<a name="l01094"></a>01094   <span class="keywordtype">int</span> i;
<a name="l01095"></a>01095   <a class="code" href="structVdbe.html">Vdbe</a> *v;
<a name="l01096"></a>01096   <span class="keywordtype">int</span> nCol;
<a name="l01097"></a>01097   <span class="keywordtype">int</span> onError;
<a name="l01098"></a>01098   <span class="keywordtype">int</span> j1, j2, j3;     <span class="comment">/* Addresses of jump instructions */</span>
<a name="l01099"></a>01099   <span class="keywordtype">int</span> regData;        <span class="comment">/* Register containing first data column */</span>
<a name="l01100"></a>01100   <span class="keywordtype">int</span> iCur;
<a name="l01101"></a>01101   <a class="code" href="structIndex.html">Index</a> *pIdx;
<a name="l01102"></a>01102   <span class="keywordtype">int</span> seenReplace = 0;
<a name="l01103"></a>01103   <span class="keywordtype">int</span> hasTwoRowids = (isUpdate &amp;&amp; rowidChng);
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   v = <a class="code" href="select_8c.html#a5a1f85a5a6bef8f820dddfcb407b61dc">sqlite3GetVdbe</a>(pParse);
<a name="l01106"></a>01106   assert( v!=0 );
<a name="l01107"></a>01107   assert( pTab-&gt;<a class="code" href="structTable.html#a39d620182fe2174fc97d04094421fa60">pSelect</a>==0 );  <span class="comment">/* This table is not a VIEW */</span>
<a name="l01108"></a>01108   nCol = pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>;
<a name="l01109"></a>01109   regData = regRowid + 1;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 
<a name="l01112"></a>01112   <span class="comment">/* Test all NOT NULL constraints.</span>
<a name="l01113"></a>01113 <span class="comment">  */</span>
<a name="l01114"></a>01114   <span class="keywordflow">for</span>(i=0; i&lt;nCol; i++){
<a name="l01115"></a>01115     <span class="keywordflow">if</span>( i==pTab-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a> ){
<a name="l01116"></a>01116       <span class="keywordflow">continue</span>;
<a name="l01117"></a>01117     }
<a name="l01118"></a>01118     onError = pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#a852e9a4c1c327a64d9b051dcafda3841">notNull</a>;
<a name="l01119"></a>01119     <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#a203b18293bcbd8c1809ef96bd0663064">OE_None</a> ) <span class="keywordflow">continue</span>;
<a name="l01120"></a>01120     <span class="keywordflow">if</span>( overrideError!=<a class="code" href="sqliteInt_8h.html#a441157ed9e5281d1cc521bbc60a69bf3">OE_Default</a> ){
<a name="l01121"></a>01121       onError = overrideError;
<a name="l01122"></a>01122     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#a441157ed9e5281d1cc521bbc60a69bf3">OE_Default</a> ){
<a name="l01123"></a>01123       onError = <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125     <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#ae9eba478b251f79e998bd6165ef18708">OE_Replace</a> &amp;&amp; pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#ac4178f302df70048235660979f84ffe4">pDflt</a>==0 ){
<a name="l01126"></a>01126       onError = <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l01127"></a>01127     }
<a name="l01128"></a>01128     j1 = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a2c2d69757c7bf41ae12092a80b04c088">OP_NotNull</a>, regData+i);
<a name="l01129"></a>01129     assert( onError==<a class="code" href="sqliteInt_8h.html#ad6594efbb2416f9b07662afaa64d2a67">OE_Rollback</a> || onError==<a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a> || onError==<a class="code" href="sqliteInt_8h.html#ac892e798ddea994b1d2ea1fdb4100c69">OE_Fail</a>
<a name="l01130"></a>01130         || onError==<a class="code" href="sqliteInt_8h.html#a57d60846b8df331e8290f1966a26ca1f">OE_Ignore</a> || onError==<a class="code" href="sqliteInt_8h.html#ae9eba478b251f79e998bd6165ef18708">OE_Replace</a> );
<a name="l01131"></a>01131     <span class="keywordflow">switch</span>( onError ){
<a name="l01132"></a>01132       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#ad6594efbb2416f9b07662afaa64d2a67">OE_Rollback</a>:
<a name="l01133"></a>01133       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>:
<a name="l01134"></a>01134       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#ac892e798ddea994b1d2ea1fdb4100c69">OE_Fail</a>: {
<a name="l01135"></a>01135         <span class="keywordtype">char</span> *zMsg;
<a name="l01136"></a>01136         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af1020441d30e76aa4d065ac2ec56c23d">OP_Halt</a>, <a class="code" href="sqlite3_8h.html#a60b2b65ad97f771203e26733f870af57">SQLITE_CONSTRAINT</a>, onError);
<a name="l01137"></a>01137         zMsg = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>, <span class="stringliteral">&quot;%s.%s may not be NULL&quot;</span>,
<a name="l01138"></a>01138                               pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>, pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#a6450a4e9fde68b3a2d79425d826eccc3">zName</a>);
<a name="l01139"></a>01139         <a class="code" href="vdbe_8h.html#a0417c7b01c7f0c8d93910a5dc00965ce">sqlite3VdbeChangeP4</a>(v, -1, zMsg, <a class="code" href="vdbe_8h.html#ae0cac143cf868ae8ec55be2ea9b13e7c">P4_DYNAMIC</a>);
<a name="l01140"></a>01140         <span class="keywordflow">break</span>;
<a name="l01141"></a>01141       }
<a name="l01142"></a>01142       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#a57d60846b8df331e8290f1966a26ca1f">OE_Ignore</a>: {
<a name="l01143"></a>01143         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, ignoreDest);
<a name="l01144"></a>01144         <span class="keywordflow">break</span>;
<a name="l01145"></a>01145       }
<a name="l01146"></a>01146       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#ae9eba478b251f79e998bd6165ef18708">OE_Replace</a>: {
<a name="l01147"></a>01147         <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#ac4178f302df70048235660979f84ffe4">pDflt</a>, regData+i);
<a name="l01148"></a>01148         <span class="keywordflow">break</span>;
<a name="l01149"></a>01149       }
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, j1);
<a name="l01152"></a>01152   }
<a name="l01153"></a>01153 
<a name="l01154"></a>01154   <span class="comment">/* Test all CHECK constraints</span>
<a name="l01155"></a>01155 <span class="comment">  */</span>
<a name="l01156"></a>01156 <span class="preprocessor">#ifndef SQLITE_OMIT_CHECK</span>
<a name="l01157"></a>01157 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pTab-&gt;<a class="code" href="structTable.html#af1f659d88810fcd5813c2b415a4e0167">pCheck</a> &amp;&amp; (pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a745a82618ed28151a76deaf51ea911f8">SQLITE_IgnoreChecks</a>)==0 ){
<a name="l01158"></a>01158     <span class="keywordtype">int</span> allOk = <a class="code" href="vdbe_8h.html#a5279e16a2acad1e72ba58ae938d385bd">sqlite3VdbeMakeLabel</a>(v);
<a name="l01159"></a>01159     pParse-&gt;<a class="code" href="structParse.html#a07e8e916fb569a86acfa5f380afaaf77">ckBase</a> = regData;
<a name="l01160"></a>01160     <a class="code" href="expr_8c.html#a32b44a7130e9624fd88db9781154eb83">sqlite3ExprIfTrue</a>(pParse, pTab-&gt;<a class="code" href="structTable.html#af1f659d88810fcd5813c2b415a4e0167">pCheck</a>, allOk, <a class="code" href="sqliteInt_8h.html#ae3bc696255d4fc2767f872371662bcd1">SQLITE_JUMPIFNULL</a>);
<a name="l01161"></a>01161     onError = overrideError!=<a class="code" href="sqliteInt_8h.html#a441157ed9e5281d1cc521bbc60a69bf3">OE_Default</a> ? overrideError : <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l01162"></a>01162     <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#a57d60846b8df331e8290f1966a26ca1f">OE_Ignore</a> ){
<a name="l01163"></a>01163       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, ignoreDest);
<a name="l01164"></a>01164     }<span class="keywordflow">else</span>{
<a name="l01165"></a>01165       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af1020441d30e76aa4d065ac2ec56c23d">OP_Halt</a>, <a class="code" href="sqlite3_8h.html#a60b2b65ad97f771203e26733f870af57">SQLITE_CONSTRAINT</a>, onError);
<a name="l01166"></a>01166     }
<a name="l01167"></a>01167     <a class="code" href="vdbe_8h.html#aea27581f782aaa7e14ae22a3c061f483">sqlite3VdbeResolveLabel</a>(v, allOk);
<a name="l01168"></a>01168   }
<a name="l01169"></a>01169 <span class="preprocessor">#endif </span><span class="comment">/* !defined(SQLITE_OMIT_CHECK) */</span>
<a name="l01170"></a>01170 
<a name="l01171"></a>01171   <span class="comment">/* If we have an INTEGER PRIMARY KEY, make sure the primary key</span>
<a name="l01172"></a>01172 <span class="comment">  ** of the new record does not previously exist.  Except, if this</span>
<a name="l01173"></a>01173 <span class="comment">  ** is an UPDATE and the primary key is not changing, that is OK.</span>
<a name="l01174"></a>01174 <span class="comment">  */</span>
<a name="l01175"></a>01175   <span class="keywordflow">if</span>( rowidChng ){
<a name="l01176"></a>01176     onError = pTab-&gt;<a class="code" href="structTable.html#add1b22425db781d976d25b4465a2965a">keyConf</a>;
<a name="l01177"></a>01177     <span class="keywordflow">if</span>( overrideError!=<a class="code" href="sqliteInt_8h.html#a441157ed9e5281d1cc521bbc60a69bf3">OE_Default</a> ){
<a name="l01178"></a>01178       onError = overrideError;
<a name="l01179"></a>01179     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#a441157ed9e5281d1cc521bbc60a69bf3">OE_Default</a> ){
<a name="l01180"></a>01180       onError = <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l01181"></a>01181     }
<a name="l01182"></a>01182     
<a name="l01183"></a>01183     <span class="keywordflow">if</span>( onError!=<a class="code" href="sqliteInt_8h.html#ae9eba478b251f79e998bd6165ef18708">OE_Replace</a> || pTab-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a> ){
<a name="l01184"></a>01184       <span class="keywordflow">if</span>( isUpdate ){
<a name="l01185"></a>01185         j2 = <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#acf73fed9b37e6b94d3fdc05156314674">OP_Eq</a>, regRowid, 0, regRowid-1);
<a name="l01186"></a>01186       }
<a name="l01187"></a>01187       j3 = <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a52cd591f2f66a915ef7549c215806357">OP_NotExists</a>, baseCur, 0, regRowid);
<a name="l01188"></a>01188       <span class="keywordflow">switch</span>( onError ){
<a name="l01189"></a>01189         <span class="keywordflow">default</span>: {
<a name="l01190"></a>01190           onError = <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l01191"></a>01191           <span class="comment">/* Fall thru into the next case */</span>
<a name="l01192"></a>01192         }
<a name="l01193"></a>01193         <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#ad6594efbb2416f9b07662afaa64d2a67">OE_Rollback</a>:
<a name="l01194"></a>01194         <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>:
<a name="l01195"></a>01195         <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#ac892e798ddea994b1d2ea1fdb4100c69">OE_Fail</a>: {
<a name="l01196"></a>01196           <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#af1020441d30e76aa4d065ac2ec56c23d">OP_Halt</a>, <a class="code" href="sqlite3_8h.html#a60b2b65ad97f771203e26733f870af57">SQLITE_CONSTRAINT</a>, onError, 0,
<a name="l01197"></a>01197                            <span class="stringliteral">&quot;PRIMARY KEY must be unique&quot;</span>, <a class="code" href="vdbe_8h.html#a016db195c237884a5c6a593a36956297">P4_STATIC</a>);
<a name="l01198"></a>01198           <span class="keywordflow">break</span>;
<a name="l01199"></a>01199         }
<a name="l01200"></a>01200         <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#ae9eba478b251f79e998bd6165ef18708">OE_Replace</a>: {
<a name="l01201"></a>01201           <a class="code" href="delete_8c.html#a870439197a72b7895d93f3ba232ab2ad">sqlite3GenerateRowIndexDelete</a>(pParse, pTab, baseCur, 0);
<a name="l01202"></a>01202           seenReplace = 1;
<a name="l01203"></a>01203           <span class="keywordflow">break</span>;
<a name="l01204"></a>01204         }
<a name="l01205"></a>01205         <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#a57d60846b8df331e8290f1966a26ca1f">OE_Ignore</a>: {
<a name="l01206"></a>01206           assert( seenReplace==0 );
<a name="l01207"></a>01207           <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, ignoreDest);
<a name="l01208"></a>01208           <span class="keywordflow">break</span>;
<a name="l01209"></a>01209         }
<a name="l01210"></a>01210       }
<a name="l01211"></a>01211       <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, j3);
<a name="l01212"></a>01212       <span class="keywordflow">if</span>( isUpdate ){
<a name="l01213"></a>01213         <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, j2);
<a name="l01214"></a>01214       }
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216   }
<a name="l01217"></a>01217 
<a name="l01218"></a>01218   <span class="comment">/* Test all UNIQUE constraints by creating entries for each UNIQUE</span>
<a name="l01219"></a>01219 <span class="comment">  ** index and making sure that duplicate entries do not already exist.</span>
<a name="l01220"></a>01220 <span class="comment">  ** Add the new records to the indices as we go.</span>
<a name="l01221"></a>01221 <span class="comment">  */</span>
<a name="l01222"></a>01222   <span class="keywordflow">for</span>(iCur=0, pIdx=pTab-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>; pIdx; pIdx=pIdx-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>, iCur++){
<a name="l01223"></a>01223     <span class="keywordtype">int</span> regIdx;
<a name="l01224"></a>01224     <span class="keywordtype">int</span> regR;
<a name="l01225"></a>01225 
<a name="l01226"></a>01226     <span class="keywordflow">if</span>( aRegIdx[iCur]==0 ) <span class="keywordflow">continue</span>;  <span class="comment">/* Skip unused indices */</span>
<a name="l01227"></a>01227 
<a name="l01228"></a>01228     <span class="comment">/* Create a key for accessing the index entry */</span>
<a name="l01229"></a>01229     regIdx = <a class="code" href="expr_8c.html#aa8d79db03e9903a3c056652eea2df234">sqlite3GetTempRange</a>(pParse, pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>+1);
<a name="l01230"></a>01230     <span class="keywordflow">for</span>(i=0; i&lt;pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>; i++){
<a name="l01231"></a>01231       <span class="keywordtype">int</span> idx = pIdx-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[i];
<a name="l01232"></a>01232       <span class="keywordflow">if</span>( idx==pTab-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a> ){
<a name="l01233"></a>01233         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af9e5064dc7159d38276860049da8b3b0">OP_SCopy</a>, regRowid, regIdx+i);
<a name="l01234"></a>01234       }<span class="keywordflow">else</span>{
<a name="l01235"></a>01235         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af9e5064dc7159d38276860049da8b3b0">OP_SCopy</a>, regData+idx, regIdx+i);
<a name="l01236"></a>01236       }
<a name="l01237"></a>01237     }
<a name="l01238"></a>01238     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af9e5064dc7159d38276860049da8b3b0">OP_SCopy</a>, regRowid, regIdx+i);
<a name="l01239"></a>01239     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#aaa8701055972e3d38e2f9801708cd9fc">OP_MakeRecord</a>, regIdx, pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>+1, aRegIdx[iCur]);
<a name="l01240"></a>01240     <a class="code" href="insert_8c.html#ad02fc8bcec6054484efe92ff3cd6ab34">sqlite3IndexAffinityStr</a>(v, pIdx);
<a name="l01241"></a>01241     <a class="code" href="expr_8c.html#a34ec8a969b416e209e9dd2d77c674ddf">sqlite3ExprCacheAffinityChange</a>(pParse, regIdx, pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>+1);
<a name="l01242"></a>01242     <a class="code" href="expr_8c.html#a6fa2fbefc3cf05be866029e9a5eb6361">sqlite3ReleaseTempRange</a>(pParse, regIdx, pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>+1);
<a name="l01243"></a>01243 
<a name="l01244"></a>01244     <span class="comment">/* Find out what action to take in case there is an indexing conflict */</span>
<a name="l01245"></a>01245     onError = pIdx-&gt;<a class="code" href="structIndex.html#ae8bf87d0414e5c46b86192cfbdd271a7">onError</a>;
<a name="l01246"></a>01246     <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#a203b18293bcbd8c1809ef96bd0663064">OE_None</a> ) <span class="keywordflow">continue</span>;  <span class="comment">/* pIdx is not a UNIQUE index */</span>
<a name="l01247"></a>01247     <span class="keywordflow">if</span>( overrideError!=<a class="code" href="sqliteInt_8h.html#a441157ed9e5281d1cc521bbc60a69bf3">OE_Default</a> ){
<a name="l01248"></a>01248       onError = overrideError;
<a name="l01249"></a>01249     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#a441157ed9e5281d1cc521bbc60a69bf3">OE_Default</a> ){
<a name="l01250"></a>01250       onError = <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l01251"></a>01251     }
<a name="l01252"></a>01252     <span class="keywordflow">if</span>( seenReplace ){
<a name="l01253"></a>01253       <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#a57d60846b8df331e8290f1966a26ca1f">OE_Ignore</a> ) onError = <a class="code" href="sqliteInt_8h.html#ae9eba478b251f79e998bd6165ef18708">OE_Replace</a>;
<a name="l01254"></a>01254       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#ac892e798ddea994b1d2ea1fdb4100c69">OE_Fail</a> ) onError = <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l01255"></a>01255     }
<a name="l01256"></a>01256     
<a name="l01257"></a>01257 
<a name="l01258"></a>01258     <span class="comment">/* Check to see if the new index entry will be unique */</span>
<a name="l01259"></a>01259     j2 = <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#aa94eede07c1e2c3fcb96239fa368a3d2">OP_IsNull</a>, regIdx, 0, pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>);
<a name="l01260"></a>01260     regR = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l01261"></a>01261     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af9e5064dc7159d38276860049da8b3b0">OP_SCopy</a>, regRowid-hasTwoRowids, regR);
<a name="l01262"></a>01262     j3 = <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a3036524146b8ad9e7f603b27502e3f4a">OP_IsUnique</a>, baseCur+iCur+1, 0,
<a name="l01263"></a>01263                            regR, <a class="code" href="sqliteInt_8h.html#aa723bebdcf79bbac5b54d6e8c378672a">SQLITE_INT_TO_PTR</a>(aRegIdx[iCur]),
<a name="l01264"></a>01264                            <a class="code" href="vdbe_8h.html#a985d1d22c0d0a5ceb7546b09e60d31ef">P4_INT32</a>);
<a name="l01265"></a>01265 
<a name="l01266"></a>01266     <span class="comment">/* Generate code that executes if the new index entry is not unique */</span>
<a name="l01267"></a>01267     assert( onError==<a class="code" href="sqliteInt_8h.html#ad6594efbb2416f9b07662afaa64d2a67">OE_Rollback</a> || onError==<a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a> || onError==<a class="code" href="sqliteInt_8h.html#ac892e798ddea994b1d2ea1fdb4100c69">OE_Fail</a>
<a name="l01268"></a>01268         || onError==<a class="code" href="sqliteInt_8h.html#a57d60846b8df331e8290f1966a26ca1f">OE_Ignore</a> || onError==<a class="code" href="sqliteInt_8h.html#ae9eba478b251f79e998bd6165ef18708">OE_Replace</a> );
<a name="l01269"></a>01269     <span class="keywordflow">switch</span>( onError ){
<a name="l01270"></a>01270       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#ad6594efbb2416f9b07662afaa64d2a67">OE_Rollback</a>:
<a name="l01271"></a>01271       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>:
<a name="l01272"></a>01272       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#ac892e798ddea994b1d2ea1fdb4100c69">OE_Fail</a>: {
<a name="l01273"></a>01273         <span class="keywordtype">int</span> j, n1, n2;
<a name="l01274"></a>01274         <span class="keywordtype">char</span> zErrMsg[200];
<a name="l01275"></a>01275         <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zErrMsg), zErrMsg,
<a name="l01276"></a>01276                          pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>&gt;1 ? <span class="stringliteral">&quot;columns &quot;</span> : <span class="stringliteral">&quot;column &quot;</span>);
<a name="l01277"></a>01277         n1 = strlen(zErrMsg);
<a name="l01278"></a>01278         <span class="keywordflow">for</span>(j=0; j&lt;pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a> &amp;&amp; n1&lt;<span class="keyword">sizeof</span>(zErrMsg)-30; j++){
<a name="l01279"></a>01279           <span class="keywordtype">char</span> *zCol = pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[pIdx-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[j]].<a class="code" href="structColumn.html#a6450a4e9fde68b3a2d79425d826eccc3">zName</a>;
<a name="l01280"></a>01280           n2 = strlen(zCol);
<a name="l01281"></a>01281           <span class="keywordflow">if</span>( j&gt;0 ){
<a name="l01282"></a>01282             <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zErrMsg)-n1, &amp;zErrMsg[n1], <span class="stringliteral">&quot;, &quot;</span>);
<a name="l01283"></a>01283             n1 += 2;
<a name="l01284"></a>01284           }
<a name="l01285"></a>01285           <span class="keywordflow">if</span>( n1+n2&gt;<span class="keyword">sizeof</span>(zErrMsg)-30 ){
<a name="l01286"></a>01286             <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zErrMsg)-n1, &amp;zErrMsg[n1], <span class="stringliteral">&quot;...&quot;</span>);
<a name="l01287"></a>01287             n1 += 3;
<a name="l01288"></a>01288             <span class="keywordflow">break</span>;
<a name="l01289"></a>01289           }<span class="keywordflow">else</span>{
<a name="l01290"></a>01290             <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zErrMsg)-n1, &amp;zErrMsg[n1], <span class="stringliteral">&quot;%s&quot;</span>, zCol);
<a name="l01291"></a>01291             n1 += n2;
<a name="l01292"></a>01292           }
<a name="l01293"></a>01293         }
<a name="l01294"></a>01294         <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zErrMsg)-n1, &amp;zErrMsg[n1], 
<a name="l01295"></a>01295             pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>&gt;1 ? <span class="stringliteral">&quot; are not unique&quot;</span> : <span class="stringliteral">&quot; is not unique&quot;</span>);
<a name="l01296"></a>01296         <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#af1020441d30e76aa4d065ac2ec56c23d">OP_Halt</a>, <a class="code" href="sqlite3_8h.html#a60b2b65ad97f771203e26733f870af57">SQLITE_CONSTRAINT</a>, onError, 0, zErrMsg,0);
<a name="l01297"></a>01297         <span class="keywordflow">break</span>;
<a name="l01298"></a>01298       }
<a name="l01299"></a>01299       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#a57d60846b8df331e8290f1966a26ca1f">OE_Ignore</a>: {
<a name="l01300"></a>01300         assert( seenReplace==0 );
<a name="l01301"></a>01301         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, ignoreDest);
<a name="l01302"></a>01302         <span class="keywordflow">break</span>;
<a name="l01303"></a>01303       }
<a name="l01304"></a>01304       <span class="keywordflow">case</span> <a class="code" href="sqliteInt_8h.html#ae9eba478b251f79e998bd6165ef18708">OE_Replace</a>: {
<a name="l01305"></a>01305         <a class="code" href="delete_8c.html#a26f2af4d4f30e81c50886807d0076c33">sqlite3GenerateRowDelete</a>(pParse, pTab, baseCur, regR, 0);
<a name="l01306"></a>01306         seenReplace = 1;
<a name="l01307"></a>01307         <span class="keywordflow">break</span>;
<a name="l01308"></a>01308       }
<a name="l01309"></a>01309     }
<a name="l01310"></a>01310     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, j2);
<a name="l01311"></a>01311     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, j3);
<a name="l01312"></a>01312     <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, regR);
<a name="l01313"></a>01313   }
<a name="l01314"></a>01314 }
<a name="l01315"></a>01315 
<a name="l01316"></a>01316 <span class="comment">/*</span>
<a name="l01317"></a>01317 <span class="comment">** This routine generates code to finish the INSERT or UPDATE operation</span>
<a name="l01318"></a>01318 <span class="comment">** that was started by a prior call to sqlite3GenerateConstraintChecks.</span>
<a name="l01319"></a>01319 <span class="comment">** A consecutive range of registers starting at regRowid contains the</span>
<a name="l01320"></a>01320 <span class="comment">** rowid and the content to be inserted.</span>
<a name="l01321"></a>01321 <span class="comment">**</span>
<a name="l01322"></a>01322 <span class="comment">** The arguments to this routine should be the same as the first six</span>
<a name="l01323"></a>01323 <span class="comment">** arguments to sqlite3GenerateConstraintChecks.</span>
<a name="l01324"></a>01324 <span class="comment">*/</span>
<a name="l01325"></a><a class="code" href="sqliteInt_8h.html#a66371cf434b5b9db7416dfd7b123827a">01325</a> <span class="keywordtype">void</span> <a class="code" href="insert_8c.html#a1bb06838d234ed5a743031c4e342c7a3">sqlite3CompleteInsertion</a>(
<a name="l01326"></a>01326   <a class="code" href="structParse.html">Parse</a> *pParse,      <span class="comment">/* The parser context */</span>
<a name="l01327"></a>01327   <a class="code" href="structTable.html">Table</a> *pTab,        <span class="comment">/* the table into which we are inserting */</span>
<a name="l01328"></a>01328   <span class="keywordtype">int</span> baseCur,        <span class="comment">/* Index of a read/write cursor pointing at pTab */</span>
<a name="l01329"></a>01329   <span class="keywordtype">int</span> regRowid,       <span class="comment">/* Range of content */</span>
<a name="l01330"></a>01330   <span class="keywordtype">int</span> *aRegIdx,       <span class="comment">/* Register used by each index.  0 for unused indices */</span>
<a name="l01331"></a>01331   <span class="keywordtype">int</span> rowidChng,      <span class="comment">/* True if the record number will change */</span>
<a name="l01332"></a>01332   <span class="keywordtype">int</span> isUpdate,       <span class="comment">/* True for UPDATE, False for INSERT */</span>
<a name="l01333"></a>01333   <span class="keywordtype">int</span> newIdx,         <span class="comment">/* Index of NEW table for triggers.  -1 if none */</span>
<a name="l01334"></a>01334   <span class="keywordtype">int</span> appendBias      <span class="comment">/* True if this is likely to be an append */</span>
<a name="l01335"></a>01335 ){
<a name="l01336"></a>01336   <span class="keywordtype">int</span> i;
<a name="l01337"></a>01337   <a class="code" href="structVdbe.html">Vdbe</a> *v;
<a name="l01338"></a>01338   <span class="keywordtype">int</span> nIdx;
<a name="l01339"></a>01339   <a class="code" href="structIndex.html">Index</a> *pIdx;
<a name="l01340"></a>01340   <span class="keywordtype">int</span> pik_flags;
<a name="l01341"></a>01341   <span class="keywordtype">int</span> regData;
<a name="l01342"></a>01342   <span class="keywordtype">int</span> regRec;
<a name="l01343"></a>01343 
<a name="l01344"></a>01344   v = <a class="code" href="select_8c.html#a5a1f85a5a6bef8f820dddfcb407b61dc">sqlite3GetVdbe</a>(pParse);
<a name="l01345"></a>01345   assert( v!=0 );
<a name="l01346"></a>01346   assert( pTab-&gt;<a class="code" href="structTable.html#a39d620182fe2174fc97d04094421fa60">pSelect</a>==0 );  <span class="comment">/* This table is not a VIEW */</span>
<a name="l01347"></a>01347   <span class="keywordflow">for</span>(nIdx=0, pIdx=pTab-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>; pIdx; pIdx=pIdx-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>, nIdx++){}
<a name="l01348"></a>01348   <span class="keywordflow">for</span>(i=nIdx-1; i&gt;=0; i--){
<a name="l01349"></a>01349     <span class="keywordflow">if</span>( aRegIdx[i]==0 ) <span class="keywordflow">continue</span>;
<a name="l01350"></a>01350     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8459d42180c78f800cee8d98dc8fe3ea">OP_IdxInsert</a>, baseCur+i+1, aRegIdx[i]);
<a name="l01351"></a>01351   }
<a name="l01352"></a>01352   regData = regRowid + 1;
<a name="l01353"></a>01353   regRec = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l01354"></a>01354   <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#aaa8701055972e3d38e2f9801708cd9fc">OP_MakeRecord</a>, regData, pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>, regRec);
<a name="l01355"></a>01355   <a class="code" href="insert_8c.html#ad89a146ebc8b75355716cb0f2fd513c6">sqlite3TableAffinityStr</a>(v, pTab);
<a name="l01356"></a>01356   <a class="code" href="expr_8c.html#a34ec8a969b416e209e9dd2d77c674ddf">sqlite3ExprCacheAffinityChange</a>(pParse, regData, pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>);
<a name="l01357"></a>01357 <span class="preprocessor">#ifndef SQLITE_OMIT_TRIGGER</span>
<a name="l01358"></a>01358 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( newIdx&gt;=0 ){
<a name="l01359"></a>01359     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#af8ec5cb3f4bce8e904b41f713c2c7d86">OP_Insert</a>, newIdx, regRec, regRowid);
<a name="l01360"></a>01360   }
<a name="l01361"></a>01361 <span class="preprocessor">#endif</span>
<a name="l01362"></a>01362 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pParse-&gt;<a class="code" href="structParse.html#a33d62687b6d368acf94e954490358819">nested</a> ){
<a name="l01363"></a>01363     pik_flags = 0;
<a name="l01364"></a>01364   }<span class="keywordflow">else</span>{
<a name="l01365"></a>01365     pik_flags = <a class="code" href="sqliteInt_8h.html#ab2b23e0c009e6f489e6fae4bc0f84ddf">OPFLAG_NCHANGE</a>;
<a name="l01366"></a>01366     pik_flags |= (isUpdate?<a class="code" href="sqliteInt_8h.html#ad5739cc164787601efa915c0bd0a8426">OPFLAG_ISUPDATE</a>:<a class="code" href="sqliteInt_8h.html#a8d4d2b610d66b579ce21b2f4b2b68e97">OPFLAG_LASTROWID</a>);
<a name="l01367"></a>01367   }
<a name="l01368"></a>01368   <span class="keywordflow">if</span>( appendBias ){
<a name="l01369"></a>01369     pik_flags |= <a class="code" href="sqliteInt_8h.html#a2402d52d244d3dcbc0bb4d6a796194a0">OPFLAG_APPEND</a>;
<a name="l01370"></a>01370   }
<a name="l01371"></a>01371   <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#af8ec5cb3f4bce8e904b41f713c2c7d86">OP_Insert</a>, baseCur, regRec, regRowid);
<a name="l01372"></a>01372   <span class="keywordflow">if</span>( !pParse-&gt;<a class="code" href="structParse.html#a33d62687b6d368acf94e954490358819">nested</a> ){
<a name="l01373"></a>01373     <a class="code" href="vdbe_8h.html#a0417c7b01c7f0c8d93910a5dc00965ce">sqlite3VdbeChangeP4</a>(v, -1, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>, <a class="code" href="vdbe_8h.html#a016db195c237884a5c6a593a36956297">P4_STATIC</a>);
<a name="l01374"></a>01374   }
<a name="l01375"></a>01375   <a class="code" href="vdbe_8h.html#adb56646cb8d4e3ef524755e857b0f702">sqlite3VdbeChangeP5</a>(v, pik_flags);
<a name="l01376"></a>01376 }
<a name="l01377"></a>01377 
<a name="l01378"></a>01378 <span class="comment">/*</span>
<a name="l01379"></a>01379 <span class="comment">** Generate code that will open cursors for a table and for all</span>
<a name="l01380"></a>01380 <span class="comment">** indices of that table.  The &quot;baseCur&quot; parameter is the cursor number used</span>
<a name="l01381"></a>01381 <span class="comment">** for the table.  Indices are opened on subsequent cursors.</span>
<a name="l01382"></a>01382 <span class="comment">**</span>
<a name="l01383"></a>01383 <span class="comment">** Return the number of indices on the table.</span>
<a name="l01384"></a>01384 <span class="comment">*/</span>
<a name="l01385"></a><a class="code" href="sqliteInt_8h.html#a83bc037c5f28868be61458ccfd065593">01385</a> <span class="keywordtype">int</span> <a class="code" href="insert_8c.html#a89b08e161706d849be60bc38e892021a">sqlite3OpenTableAndIndices</a>(
<a name="l01386"></a>01386   <a class="code" href="structParse.html">Parse</a> *pParse,   <span class="comment">/* Parsing context */</span>
<a name="l01387"></a>01387   <a class="code" href="structTable.html">Table</a> *pTab,     <span class="comment">/* Table to be opened */</span>
<a name="l01388"></a>01388   <span class="keywordtype">int</span> baseCur,     <span class="comment">/* Cursor number assigned to the table */</span>
<a name="l01389"></a>01389   <span class="keywordtype">int</span> op           <span class="comment">/* OP_OpenRead or OP_OpenWrite */</span>
<a name="l01390"></a>01390 ){
<a name="l01391"></a>01391   <span class="keywordtype">int</span> i;
<a name="l01392"></a>01392   <span class="keywordtype">int</span> iDb;
<a name="l01393"></a>01393   <a class="code" href="structIndex.html">Index</a> *pIdx;
<a name="l01394"></a>01394   <a class="code" href="structVdbe.html">Vdbe</a> *v;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTab) ) <span class="keywordflow">return</span> 0;
<a name="l01397"></a>01397   iDb = <a class="code" href="prepare_8c.html#aecd8922611e561d76d5e9f16655e8a7c">sqlite3SchemaToIndex</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>, pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>);
<a name="l01398"></a>01398   v = <a class="code" href="select_8c.html#a5a1f85a5a6bef8f820dddfcb407b61dc">sqlite3GetVdbe</a>(pParse);
<a name="l01399"></a>01399   assert( v!=0 );
<a name="l01400"></a>01400   <a class="code" href="delete_8c.html#a45432dea9b811619b910763795b476f3">sqlite3OpenTable</a>(pParse, baseCur, iDb, pTab, op);
<a name="l01401"></a>01401   <span class="keywordflow">for</span>(i=1, pIdx=pTab-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>; pIdx; pIdx=pIdx-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>, i++){
<a name="l01402"></a>01402     <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKey = <a class="code" href="build_8c.html#aa7138838f73483fbf702e0e295dca2fe">sqlite3IndexKeyinfo</a>(pParse, pIdx);
<a name="l01403"></a>01403     assert( pIdx-&gt;<a class="code" href="structIndex.html#af14f5ddd57eab2aba63dcb5db2aa92af">pSchema</a>==pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a> );
<a name="l01404"></a>01404     <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, op, i+baseCur, pIdx-&gt;<a class="code" href="structIndex.html#af895a09c01701021c3e36362c04a1ae6">tnum</a>, iDb,
<a name="l01405"></a>01405                       (<span class="keywordtype">char</span>*)pKey, <a class="code" href="vdbe_8h.html#a5a10f433c58f3ce20eb100fa29025e8d">P4_KEYINFO_HANDOFF</a>);
<a name="l01406"></a>01406     <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;%s&quot;</span>, pIdx-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a>));
<a name="l01407"></a>01407   }
<a name="l01408"></a>01408   <span class="keywordflow">if</span>( pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>&lt;=baseCur+i ){
<a name="l01409"></a>01409     pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a> = baseCur+i;
<a name="l01410"></a>01410   }
<a name="l01411"></a>01411   <span class="keywordflow">return</span> i-1;
<a name="l01412"></a>01412 }
<a name="l01413"></a>01413 
<a name="l01414"></a>01414 
<a name="l01415"></a>01415 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l01416"></a>01416 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01417"></a>01417 <span class="comment">** The following global variable is incremented whenever the</span>
<a name="l01418"></a>01418 <span class="comment">** transfer optimization is used.  This is used for testing</span>
<a name="l01419"></a>01419 <span class="comment">** purposes only - to make sure the transfer optimization really</span>
<a name="l01420"></a>01420 <span class="comment">** is happening when it is suppose to.</span>
<a name="l01421"></a>01421 <span class="comment">*/</span>
<a name="l01422"></a>01422 <span class="keywordtype">int</span> sqlite3_xferopt_count;
<a name="l01423"></a>01423 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_TEST */</span>
<a name="l01424"></a>01424 
<a name="l01425"></a>01425 
<a name="l01426"></a>01426 <span class="preprocessor">#ifndef SQLITE_OMIT_XFER_OPT</span>
<a name="l01427"></a>01427 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01428"></a>01428 <span class="comment">** Check to collation names to see if they are compatible.</span>
<a name="l01429"></a>01429 <span class="comment">*/</span>
<a name="l01430"></a><a class="code" href="insert_8c.html#a90cd70abe4e9f9757480ae3ead7a1bbd">01430</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="insert_8c.html#a90cd70abe4e9f9757480ae3ead7a1bbd">xferCompatibleCollation</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *z1, <span class="keyword">const</span> <span class="keywordtype">char</span> *z2){
<a name="l01431"></a>01431   <span class="keywordflow">if</span>( z1==0 ){
<a name="l01432"></a>01432     <span class="keywordflow">return</span> z2==0;
<a name="l01433"></a>01433   }
<a name="l01434"></a>01434   <span class="keywordflow">if</span>( z2==0 ){
<a name="l01435"></a>01435     <span class="keywordflow">return</span> 0;
<a name="l01436"></a>01436   }
<a name="l01437"></a>01437   <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(z1, z2)==0;
<a name="l01438"></a>01438 }
<a name="l01439"></a>01439 
<a name="l01440"></a>01440 
<a name="l01441"></a>01441 <span class="comment">/*</span>
<a name="l01442"></a>01442 <span class="comment">** Check to see if index pSrc is compatible as a source of data</span>
<a name="l01443"></a>01443 <span class="comment">** for index pDest in an insert transfer optimization.  The rules</span>
<a name="l01444"></a>01444 <span class="comment">** for a compatible index:</span>
<a name="l01445"></a>01445 <span class="comment">**</span>
<a name="l01446"></a>01446 <span class="comment">**    *   The index is over the same set of columns</span>
<a name="l01447"></a>01447 <span class="comment">**    *   The same DESC and ASC markings occurs on all columns</span>
<a name="l01448"></a>01448 <span class="comment">**    *   The same onError processing (OE_Abort, OE_Ignore, etc)</span>
<a name="l01449"></a>01449 <span class="comment">**    *   The same collating sequence on each column</span>
<a name="l01450"></a>01450 <span class="comment">*/</span>
<a name="l01451"></a><a class="code" href="insert_8c.html#ab575125542540f8b67a3b4beb3e02d06">01451</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="insert_8c.html#ab575125542540f8b67a3b4beb3e02d06">xferCompatibleIndex</a>(<a class="code" href="structIndex.html">Index</a> *pDest, <a class="code" href="structIndex.html">Index</a> *pSrc){
<a name="l01452"></a>01452   <span class="keywordtype">int</span> i;
<a name="l01453"></a>01453   assert( pDest &amp;&amp; pSrc );
<a name="l01454"></a>01454   assert( pDest-&gt;<a class="code" href="structIndex.html#a01c6d4da27cba325ca58f333f87a6f44">pTable</a>!=pSrc-&gt;<a class="code" href="structIndex.html#a01c6d4da27cba325ca58f333f87a6f44">pTable</a> );
<a name="l01455"></a>01455   <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>!=pSrc-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a> ){
<a name="l01456"></a>01456     <span class="keywordflow">return</span> 0;   <span class="comment">/* Different number of columns */</span>
<a name="l01457"></a>01457   }
<a name="l01458"></a>01458   <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structIndex.html#ae8bf87d0414e5c46b86192cfbdd271a7">onError</a>!=pSrc-&gt;<a class="code" href="structIndex.html#ae8bf87d0414e5c46b86192cfbdd271a7">onError</a> ){
<a name="l01459"></a>01459     <span class="keywordflow">return</span> 0;   <span class="comment">/* Different conflict resolution strategies */</span>
<a name="l01460"></a>01460   }
<a name="l01461"></a>01461   <span class="keywordflow">for</span>(i=0; i&lt;pSrc-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>; i++){
<a name="l01462"></a>01462     <span class="keywordflow">if</span>( pSrc-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[i]!=pDest-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[i] ){
<a name="l01463"></a>01463       <span class="keywordflow">return</span> 0;   <span class="comment">/* Different columns indexed */</span>
<a name="l01464"></a>01464     }
<a name="l01465"></a>01465     <span class="keywordflow">if</span>( pSrc-&gt;<a class="code" href="structIndex.html#a0a3fc87b53193995f59c9657443e9a99">aSortOrder</a>[i]!=pDest-&gt;<a class="code" href="structIndex.html#a0a3fc87b53193995f59c9657443e9a99">aSortOrder</a>[i] ){
<a name="l01466"></a>01466       <span class="keywordflow">return</span> 0;   <span class="comment">/* Different sort orders */</span>
<a name="l01467"></a>01467     }
<a name="l01468"></a>01468     <span class="keywordflow">if</span>( pSrc-&gt;<a class="code" href="structIndex.html#ab690ebb96c0329896b0fe2ab56813b88">azColl</a>[i]!=pDest-&gt;<a class="code" href="structIndex.html#ab690ebb96c0329896b0fe2ab56813b88">azColl</a>[i] ){
<a name="l01469"></a>01469       <span class="keywordflow">return</span> 0;   <span class="comment">/* Different collating sequences */</span>
<a name="l01470"></a>01470     }
<a name="l01471"></a>01471   }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473   <span class="comment">/* If no test above fails then the indices must be compatible */</span>
<a name="l01474"></a>01474   <span class="keywordflow">return</span> 1;
<a name="l01475"></a>01475 }
<a name="l01476"></a>01476 
<a name="l01477"></a>01477 <span class="comment">/*</span>
<a name="l01478"></a>01478 <span class="comment">** Attempt the transfer optimization on INSERTs of the form</span>
<a name="l01479"></a>01479 <span class="comment">**</span>
<a name="l01480"></a>01480 <span class="comment">**     INSERT INTO tab1 SELECT * FROM tab2;</span>
<a name="l01481"></a>01481 <span class="comment">**</span>
<a name="l01482"></a>01482 <span class="comment">** This optimization is only attempted if</span>
<a name="l01483"></a>01483 <span class="comment">**</span>
<a name="l01484"></a>01484 <span class="comment">**    (1)  tab1 and tab2 have identical schemas including all the</span>
<a name="l01485"></a>01485 <span class="comment">**         same indices and constraints</span>
<a name="l01486"></a>01486 <span class="comment">**</span>
<a name="l01487"></a>01487 <span class="comment">**    (2)  tab1 and tab2 are different tables</span>
<a name="l01488"></a>01488 <span class="comment">**</span>
<a name="l01489"></a>01489 <span class="comment">**    (3)  There must be no triggers on tab1</span>
<a name="l01490"></a>01490 <span class="comment">**</span>
<a name="l01491"></a>01491 <span class="comment">**    (4)  The result set of the SELECT statement is &quot;*&quot;</span>
<a name="l01492"></a>01492 <span class="comment">**</span>
<a name="l01493"></a>01493 <span class="comment">**    (5)  The SELECT statement has no WHERE, HAVING, ORDER BY, GROUP BY,</span>
<a name="l01494"></a>01494 <span class="comment">**         or LIMIT clause.</span>
<a name="l01495"></a>01495 <span class="comment">**</span>
<a name="l01496"></a>01496 <span class="comment">**    (6)  The SELECT statement is a simple (not a compound) select that</span>
<a name="l01497"></a>01497 <span class="comment">**         contains only tab2 in its FROM clause</span>
<a name="l01498"></a>01498 <span class="comment">**</span>
<a name="l01499"></a>01499 <span class="comment">** This method for implementing the INSERT transfers raw records from</span>
<a name="l01500"></a>01500 <span class="comment">** tab2 over to tab1.  The columns are not decoded.  Raw records from</span>
<a name="l01501"></a>01501 <span class="comment">** the indices of tab2 are transfered to tab1 as well.  In so doing,</span>
<a name="l01502"></a>01502 <span class="comment">** the resulting tab1 has much less fragmentation.</span>
<a name="l01503"></a>01503 <span class="comment">**</span>
<a name="l01504"></a>01504 <span class="comment">** This routine returns TRUE if the optimization is attempted.  If any</span>
<a name="l01505"></a>01505 <span class="comment">** of the conditions above fail so that the optimization should not</span>
<a name="l01506"></a>01506 <span class="comment">** be attempted, then this routine returns FALSE.</span>
<a name="l01507"></a>01507 <span class="comment">*/</span>
<a name="l01508"></a><a class="code" href="insert_8c.html#ae85c90f7d064fe83f4ed930e708855d2">01508</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="insert_8c.html#ae85c90f7d064fe83f4ed930e708855d2">xferOptimization</a>(
<a name="l01509"></a>01509   <a class="code" href="structParse.html">Parse</a> *pParse,        <span class="comment">/* Parser context */</span>
<a name="l01510"></a>01510   <a class="code" href="structTable.html">Table</a> *pDest,         <span class="comment">/* The table we are inserting into */</span>
<a name="l01511"></a>01511   <a class="code" href="structSelect.html">Select</a> *pSelect,      <span class="comment">/* A SELECT statement to use as the data source */</span>
<a name="l01512"></a>01512   <span class="keywordtype">int</span> onError,          <span class="comment">/* How to handle constraint errors */</span>
<a name="l01513"></a>01513   <span class="keywordtype">int</span> iDbDest           <span class="comment">/* The database of pDest */</span>
<a name="l01514"></a>01514 ){
<a name="l01515"></a>01515   <a class="code" href="structExprList.html">ExprList</a> *pEList;                <span class="comment">/* The result set of the SELECT */</span>
<a name="l01516"></a>01516   <a class="code" href="structTable.html">Table</a> *pSrc;                     <span class="comment">/* The table in the FROM clause of SELECT */</span>
<a name="l01517"></a>01517   <a class="code" href="structIndex.html">Index</a> *pSrcIdx, *pDestIdx;       <span class="comment">/* Source and destination indices */</span>
<a name="l01518"></a>01518   <span class="keyword">struct </span>SrcList_item *pItem;      <span class="comment">/* An element of pSelect-&gt;pSrc */</span>
<a name="l01519"></a>01519   <span class="keywordtype">int</span> i;                           <span class="comment">/* Loop counter */</span>
<a name="l01520"></a>01520   <span class="keywordtype">int</span> iDbSrc;                      <span class="comment">/* The database of pSrc */</span>
<a name="l01521"></a>01521   <span class="keywordtype">int</span> iSrc, iDest;                 <span class="comment">/* Cursors from source and destination */</span>
<a name="l01522"></a>01522   <span class="keywordtype">int</span> addr1, addr2;                <span class="comment">/* Loop addresses */</span>
<a name="l01523"></a>01523   <span class="keywordtype">int</span> emptyDestTest;               <span class="comment">/* Address of test for empty pDest */</span>
<a name="l01524"></a>01524   <span class="keywordtype">int</span> emptySrcTest;                <span class="comment">/* Address of test for empty pSrc */</span>
<a name="l01525"></a>01525   <a class="code" href="structVdbe.html">Vdbe</a> *v;                         <span class="comment">/* The VDBE we are building */</span>
<a name="l01526"></a>01526   <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKey;                   <span class="comment">/* Key information for an index */</span>
<a name="l01527"></a>01527   <span class="keywordtype">int</span> regAutoinc;                  <span class="comment">/* Memory register used by AUTOINC */</span>
<a name="l01528"></a>01528   <span class="keywordtype">int</span> destHasUniqueIdx = 0;        <span class="comment">/* True if pDest has a UNIQUE index */</span>
<a name="l01529"></a>01529   <span class="keywordtype">int</span> regData, regRowid;           <span class="comment">/* Registers holding data and rowid */</span>
<a name="l01530"></a>01530 
<a name="l01531"></a>01531   <span class="keywordflow">if</span>( pSelect==0 ){
<a name="l01532"></a>01532     <span class="keywordflow">return</span> 0;   <span class="comment">/* Must be of the form  INSERT INTO ... SELECT ... */</span>
<a name="l01533"></a>01533   }
<a name="l01534"></a>01534   <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structTable.html#aca61c40bb0164f2c6fc3406c28988660">pTrigger</a> ){
<a name="l01535"></a>01535     <span class="keywordflow">return</span> 0;   <span class="comment">/* tab1 must not have triggers */</span>
<a name="l01536"></a>01536   }
<a name="l01537"></a>01537 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l01538"></a>01538 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a350a16ec7aacc6d6eb749ab327e7b4f1">TF_Virtual</a> ){
<a name="l01539"></a>01539     <span class="keywordflow">return</span> 0;   <span class="comment">/* tab1 must not be a virtual table */</span>
<a name="l01540"></a>01540   }
<a name="l01541"></a>01541 <span class="preprocessor">#endif</span>
<a name="l01542"></a>01542 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( onError==<a class="code" href="sqliteInt_8h.html#a441157ed9e5281d1cc521bbc60a69bf3">OE_Default</a> ){
<a name="l01543"></a>01543     onError = <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l01544"></a>01544   }
<a name="l01545"></a>01545   <span class="keywordflow">if</span>( onError!=<a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a> &amp;&amp; onError!=<a class="code" href="sqliteInt_8h.html#ad6594efbb2416f9b07662afaa64d2a67">OE_Rollback</a> ){
<a name="l01546"></a>01546     <span class="keywordflow">return</span> 0;   <span class="comment">/* Cannot do OR REPLACE or OR IGNORE or OR FAIL */</span>
<a name="l01547"></a>01547   }
<a name="l01548"></a>01548   assert(pSelect-&gt;<a class="code" href="structSelect.html#a4e3b9b176a8e1b4af988405ff1f090db">pSrc</a>);   <span class="comment">/* allocated even if there is no FROM clause */</span>
<a name="l01549"></a>01549   <span class="keywordflow">if</span>( pSelect-&gt;<a class="code" href="structSelect.html#a4e3b9b176a8e1b4af988405ff1f090db">pSrc</a>-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>!=1 ){
<a name="l01550"></a>01550     <span class="keywordflow">return</span> 0;   <span class="comment">/* FROM clause must have exactly one term */</span>
<a name="l01551"></a>01551   }
<a name="l01552"></a>01552   <span class="keywordflow">if</span>( pSelect-&gt;<a class="code" href="structSelect.html#a4e3b9b176a8e1b4af988405ff1f090db">pSrc</a>-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[0].<a class="code" href="structSrcList_1_1SrcList__item.html#ab44822fca7618c4f41f4f770ad41425b">pSelect</a> ){
<a name="l01553"></a>01553     <span class="keywordflow">return</span> 0;   <span class="comment">/* FROM clause cannot contain a subquery */</span>
<a name="l01554"></a>01554   }
<a name="l01555"></a>01555   <span class="keywordflow">if</span>( pSelect-&gt;<a class="code" href="structSelect.html#a0562c1e19acde263a04af015611d8ce8">pWhere</a> ){
<a name="l01556"></a>01556     <span class="keywordflow">return</span> 0;   <span class="comment">/* SELECT may not have a WHERE clause */</span>
<a name="l01557"></a>01557   }
<a name="l01558"></a>01558   <span class="keywordflow">if</span>( pSelect-&gt;<a class="code" href="structSelect.html#a73c474cd4a9a9b9aa4e3187d8bf2d886">pOrderBy</a> ){
<a name="l01559"></a>01559     <span class="keywordflow">return</span> 0;   <span class="comment">/* SELECT may not have an ORDER BY clause */</span>
<a name="l01560"></a>01560   }
<a name="l01561"></a>01561   <span class="comment">/* Do not need to test for a HAVING clause.  If HAVING is present but</span>
<a name="l01562"></a>01562 <span class="comment">  ** there is no ORDER BY, we will get an error. */</span>
<a name="l01563"></a>01563   <span class="keywordflow">if</span>( pSelect-&gt;<a class="code" href="structSelect.html#a5b625c7495468ae56ca2f214a76231a0">pGroupBy</a> ){
<a name="l01564"></a>01564     <span class="keywordflow">return</span> 0;   <span class="comment">/* SELECT may not have a GROUP BY clause */</span>
<a name="l01565"></a>01565   }
<a name="l01566"></a>01566   <span class="keywordflow">if</span>( pSelect-&gt;<a class="code" href="structSelect.html#a11d3b48d04d58be818cdefb10aa061a0">pLimit</a> ){
<a name="l01567"></a>01567     <span class="keywordflow">return</span> 0;   <span class="comment">/* SELECT may not have a LIMIT clause */</span>
<a name="l01568"></a>01568   }
<a name="l01569"></a>01569   assert( pSelect-&gt;<a class="code" href="structSelect.html#aeaf016a10203b911000354122562fb46">pOffset</a>==0 );  <span class="comment">/* Must be so if pLimit==0 */</span>
<a name="l01570"></a>01570   <span class="keywordflow">if</span>( pSelect-&gt;<a class="code" href="structSelect.html#a51d1a253b0aba5a54b11b3bf3896d056">pPrior</a> ){
<a name="l01571"></a>01571     <span class="keywordflow">return</span> 0;   <span class="comment">/* SELECT may not be a compound query */</span>
<a name="l01572"></a>01572   }
<a name="l01573"></a>01573   <span class="keywordflow">if</span>( pSelect-&gt;<a class="code" href="structSelect.html#a1c445561ea66d48573c8d8751108c743">selFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#ae80a11c8ffd538599b7753bf96de1624">SF_Distinct</a> ){
<a name="l01574"></a>01574     <span class="keywordflow">return</span> 0;   <span class="comment">/* SELECT may not be DISTINCT */</span>
<a name="l01575"></a>01575   }
<a name="l01576"></a>01576   pEList = pSelect-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>;
<a name="l01577"></a>01577   assert( pEList!=0 );
<a name="l01578"></a>01578   <span class="keywordflow">if</span>( pEList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>!=1 ){
<a name="l01579"></a>01579     <span class="keywordflow">return</span> 0;   <span class="comment">/* The result set must have exactly one column */</span>
<a name="l01580"></a>01580   }
<a name="l01581"></a>01581   assert( pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[0].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a> );
<a name="l01582"></a>01582   <span class="keywordflow">if</span>( pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[0].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#a8251611d21967280b7936f4b1ff70e68">TK_ALL</a> ){
<a name="l01583"></a>01583     <span class="keywordflow">return</span> 0;   <span class="comment">/* The result set must be the special operator &quot;*&quot; */</span>
<a name="l01584"></a>01584   }
<a name="l01585"></a>01585 
<a name="l01586"></a>01586   <span class="comment">/* At this point we have established that the statement is of the</span>
<a name="l01587"></a>01587 <span class="comment">  ** correct syntactic form to participate in this optimization.  Now</span>
<a name="l01588"></a>01588 <span class="comment">  ** we have to check the semantics.</span>
<a name="l01589"></a>01589 <span class="comment">  */</span>
<a name="l01590"></a>01590   pItem = pSelect-&gt;<a class="code" href="structSelect.html#a4e3b9b176a8e1b4af988405ff1f090db">pSrc</a>-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>;
<a name="l01591"></a>01591   pSrc = <a class="code" href="build_8c.html#a6368fd982cd0827e830b850ec74f6ac8">sqlite3LocateTable</a>(pParse, 0, pItem-&gt;zName, pItem-&gt;zDatabase);
<a name="l01592"></a>01592   <span class="keywordflow">if</span>( pSrc==0 ){
<a name="l01593"></a>01593     <span class="keywordflow">return</span> 0;   <span class="comment">/* FROM clause does not contain a real table */</span>
<a name="l01594"></a>01594   }
<a name="l01595"></a>01595   <span class="keywordflow">if</span>( pSrc==pDest ){
<a name="l01596"></a>01596     <span class="keywordflow">return</span> 0;   <span class="comment">/* tab1 and tab2 may not be the same table */</span>
<a name="l01597"></a>01597   }
<a name="l01598"></a>01598 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l01599"></a>01599 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pSrc-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a350a16ec7aacc6d6eb749ab327e7b4f1">TF_Virtual</a> ){
<a name="l01600"></a>01600     <span class="keywordflow">return</span> 0;   <span class="comment">/* tab2 must not be a virtual table */</span>
<a name="l01601"></a>01601   }
<a name="l01602"></a>01602 <span class="preprocessor">#endif</span>
<a name="l01603"></a>01603 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pSrc-&gt;<a class="code" href="structTable.html#a39d620182fe2174fc97d04094421fa60">pSelect</a> ){
<a name="l01604"></a>01604     <span class="keywordflow">return</span> 0;   <span class="comment">/* tab2 may not be a view */</span>
<a name="l01605"></a>01605   }
<a name="l01606"></a>01606   <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>!=pSrc-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a> ){
<a name="l01607"></a>01607     <span class="keywordflow">return</span> 0;   <span class="comment">/* Number of columns must be the same in tab1 and tab2 */</span>
<a name="l01608"></a>01608   }
<a name="l01609"></a>01609   <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a>!=pSrc-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a> ){
<a name="l01610"></a>01610     <span class="keywordflow">return</span> 0;   <span class="comment">/* Both tables must have the same INTEGER PRIMARY KEY */</span>
<a name="l01611"></a>01611   }
<a name="l01612"></a>01612   <span class="keywordflow">for</span>(i=0; i&lt;pDest-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>; i++){
<a name="l01613"></a>01613     <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#ac9d6fe31c45888cecaf3f5ad5b93bf23">affinity</a>!=pSrc-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#ac9d6fe31c45888cecaf3f5ad5b93bf23">affinity</a> ){
<a name="l01614"></a>01614       <span class="keywordflow">return</span> 0;    <span class="comment">/* Affinity must be the same on all columns */</span>
<a name="l01615"></a>01615     }
<a name="l01616"></a>01616     <span class="keywordflow">if</span>( !<a class="code" href="insert_8c.html#a90cd70abe4e9f9757480ae3ead7a1bbd">xferCompatibleCollation</a>(pDest-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#aa95909d5c77b321258622ed28d7b96eb">zColl</a>, pSrc-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#aa95909d5c77b321258622ed28d7b96eb">zColl</a>) ){
<a name="l01617"></a>01617       <span class="keywordflow">return</span> 0;    <span class="comment">/* Collating sequence must be the same on all columns */</span>
<a name="l01618"></a>01618     }
<a name="l01619"></a>01619     <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#a852e9a4c1c327a64d9b051dcafda3841">notNull</a> &amp;&amp; !pSrc-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[i].<a class="code" href="structColumn.html#a852e9a4c1c327a64d9b051dcafda3841">notNull</a> ){
<a name="l01620"></a>01620       <span class="keywordflow">return</span> 0;    <span class="comment">/* tab2 must be NOT NULL if tab1 is */</span>
<a name="l01621"></a>01621     }
<a name="l01622"></a>01622   }
<a name="l01623"></a>01623   <span class="keywordflow">for</span>(pDestIdx=pDest-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>; pDestIdx; pDestIdx=pDestIdx-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>){
<a name="l01624"></a>01624     <span class="keywordflow">if</span>( pDestIdx-&gt;<a class="code" href="structIndex.html#ae8bf87d0414e5c46b86192cfbdd271a7">onError</a>!=<a class="code" href="sqliteInt_8h.html#a203b18293bcbd8c1809ef96bd0663064">OE_None</a> ){
<a name="l01625"></a>01625       destHasUniqueIdx = 1;
<a name="l01626"></a>01626     }
<a name="l01627"></a>01627     <span class="keywordflow">for</span>(pSrcIdx=pSrc-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>; pSrcIdx; pSrcIdx=pSrcIdx-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>){
<a name="l01628"></a>01628       <span class="keywordflow">if</span>( <a class="code" href="insert_8c.html#ab575125542540f8b67a3b4beb3e02d06">xferCompatibleIndex</a>(pDestIdx, pSrcIdx) ) <span class="keywordflow">break</span>;
<a name="l01629"></a>01629     }
<a name="l01630"></a>01630     <span class="keywordflow">if</span>( pSrcIdx==0 ){
<a name="l01631"></a>01631       <span class="keywordflow">return</span> 0;    <span class="comment">/* pDestIdx has no corresponding index in pSrc */</span>
<a name="l01632"></a>01632     }
<a name="l01633"></a>01633   }
<a name="l01634"></a>01634 <span class="preprocessor">#ifndef SQLITE_OMIT_CHECK</span>
<a name="l01635"></a>01635 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structTable.html#af1f659d88810fcd5813c2b415a4e0167">pCheck</a> &amp;&amp; !<a class="code" href="expr_8c.html#a936b53013e4bc0ff2e46d7def7acb9e4">sqlite3ExprCompare</a>(pSrc-&gt;<a class="code" href="structTable.html#af1f659d88810fcd5813c2b415a4e0167">pCheck</a>, pDest-&gt;<a class="code" href="structTable.html#af1f659d88810fcd5813c2b415a4e0167">pCheck</a>) ){
<a name="l01636"></a>01636     <span class="keywordflow">return</span> 0;   <span class="comment">/* Tables have different CHECK constraints.  Ticket #2252 */</span>
<a name="l01637"></a>01637   }
<a name="l01638"></a>01638 <span class="preprocessor">#endif</span>
<a name="l01639"></a>01639 <span class="preprocessor"></span>
<a name="l01640"></a>01640   <span class="comment">/* If we get this far, it means either:</span>
<a name="l01641"></a>01641 <span class="comment">  **</span>
<a name="l01642"></a>01642 <span class="comment">  **    *   We can always do the transfer if the table contains an</span>
<a name="l01643"></a>01643 <span class="comment">  **        an integer primary key</span>
<a name="l01644"></a>01644 <span class="comment">  **</span>
<a name="l01645"></a>01645 <span class="comment">  **    *   We can conditionally do the transfer if the destination</span>
<a name="l01646"></a>01646 <span class="comment">  **        table is empty.</span>
<a name="l01647"></a>01647 <span class="comment">  */</span>
<a name="l01648"></a>01648 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l01649"></a>01649 <span class="preprocessor"></span>  sqlite3_xferopt_count++;
<a name="l01650"></a>01650 <span class="preprocessor">#endif</span>
<a name="l01651"></a>01651 <span class="preprocessor"></span>  iDbSrc = <a class="code" href="prepare_8c.html#aecd8922611e561d76d5e9f16655e8a7c">sqlite3SchemaToIndex</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>, pSrc-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>);
<a name="l01652"></a>01652   v = <a class="code" href="select_8c.html#a5a1f85a5a6bef8f820dddfcb407b61dc">sqlite3GetVdbe</a>(pParse);
<a name="l01653"></a>01653   <a class="code" href="build_8c.html#a51b29407b457575a6d04897e7a19d0b6">sqlite3CodeVerifySchema</a>(pParse, iDbSrc);
<a name="l01654"></a>01654   iSrc = pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>++;
<a name="l01655"></a>01655   iDest = pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>++;
<a name="l01656"></a>01656   regAutoinc = <a class="code" href="insert_8c.html#ace6be0edf9dfebbb8a650d2f4728b885">autoIncBegin</a>(pParse, iDbDest, pDest);
<a name="l01657"></a>01657   <a class="code" href="delete_8c.html#a45432dea9b811619b910763795b476f3">sqlite3OpenTable</a>(pParse, iDest, iDbDest, pDest, <a class="code" href="opcodes_8h.html#a98af8f9fca78ddf04bbc472cf2761f10">OP_OpenWrite</a>);
<a name="l01658"></a>01658   <span class="keywordflow">if</span>( (pDest-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a>&lt;0 &amp;&amp; pDest-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>!=0) || destHasUniqueIdx ){
<a name="l01659"></a>01659     <span class="comment">/* If tables do not have an INTEGER PRIMARY KEY and there</span>
<a name="l01660"></a>01660 <span class="comment">    ** are indices to be copied and the destination is not empty,</span>
<a name="l01661"></a>01661 <span class="comment">    ** we have to disallow the transfer optimization because the</span>
<a name="l01662"></a>01662 <span class="comment">    ** the rowids might change which will mess up indexing.</span>
<a name="l01663"></a>01663 <span class="comment">    **</span>
<a name="l01664"></a>01664 <span class="comment">    ** Or if the destination has a UNIQUE index and is not empty,</span>
<a name="l01665"></a>01665 <span class="comment">    ** we also disallow the transfer optimization because we cannot</span>
<a name="l01666"></a>01666 <span class="comment">    ** insure that all entries in the union of DEST and SRC will be</span>
<a name="l01667"></a>01667 <span class="comment">    ** unique.</span>
<a name="l01668"></a>01668 <span class="comment">    */</span>
<a name="l01669"></a>01669     addr1 = <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>, iDest, 0);
<a name="l01670"></a>01670     emptyDestTest = <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, 0);
<a name="l01671"></a>01671     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, addr1);
<a name="l01672"></a>01672   }<span class="keywordflow">else</span>{
<a name="l01673"></a>01673     emptyDestTest = 0;
<a name="l01674"></a>01674   }
<a name="l01675"></a>01675   <a class="code" href="delete_8c.html#a45432dea9b811619b910763795b476f3">sqlite3OpenTable</a>(pParse, iSrc, iDbSrc, pSrc, <a class="code" href="opcodes_8h.html#a0c72fbe4989449cdc9a69e1bbb2e91c2">OP_OpenRead</a>);
<a name="l01676"></a>01676   emptySrcTest = <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>, iSrc, 0);
<a name="l01677"></a>01677   regData = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l01678"></a>01678   regRowid = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l01679"></a>01679   <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a>&gt;=0 ){
<a name="l01680"></a>01680     addr1 = <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a5a05393545770c35a6071b83679e6be7">OP_Rowid</a>, iSrc, regRowid);
<a name="l01681"></a>01681     addr2 = <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a52cd591f2f66a915ef7549c215806357">OP_NotExists</a>, iDest, 0, regRowid);
<a name="l01682"></a>01682     <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#af1020441d30e76aa4d065ac2ec56c23d">OP_Halt</a>, <a class="code" href="sqlite3_8h.html#a60b2b65ad97f771203e26733f870af57">SQLITE_CONSTRAINT</a>, onError, 0,
<a name="l01683"></a>01683                       <span class="stringliteral">&quot;PRIMARY KEY must be unique&quot;</span>, <a class="code" href="vdbe_8h.html#a016db195c237884a5c6a593a36956297">P4_STATIC</a>);
<a name="l01684"></a>01684     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, addr2);
<a name="l01685"></a>01685     <a class="code" href="insert_8c.html#af9b0d0bb1338fe4bf074901ad8f6eb1b">autoIncStep</a>(pParse, regAutoinc, regRowid);
<a name="l01686"></a>01686   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pDest-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>==0 ){
<a name="l01687"></a>01687     addr1 = <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#aebc7e3a304f9b4b81abce298ff9704ec">OP_NewRowid</a>, iDest, regRowid);
<a name="l01688"></a>01688   }<span class="keywordflow">else</span>{
<a name="l01689"></a>01689     addr1 = <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a5a05393545770c35a6071b83679e6be7">OP_Rowid</a>, iSrc, regRowid);
<a name="l01690"></a>01690     assert( (pDest-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#ae917a67699dcdc0ef1930f64df96d57c">TF_Autoincrement</a>)==0 );
<a name="l01691"></a>01691   }
<a name="l01692"></a>01692   <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a0b79ef76a9edf3c8132fa4cb96d842ef">OP_RowData</a>, iSrc, regData);
<a name="l01693"></a>01693   <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#af8ec5cb3f4bce8e904b41f713c2c7d86">OP_Insert</a>, iDest, regData, regRowid);
<a name="l01694"></a>01694   <a class="code" href="vdbe_8h.html#adb56646cb8d4e3ef524755e857b0f702">sqlite3VdbeChangeP5</a>(v, <a class="code" href="sqliteInt_8h.html#ab2b23e0c009e6f489e6fae4bc0f84ddf">OPFLAG_NCHANGE</a>|<a class="code" href="sqliteInt_8h.html#a8d4d2b610d66b579ce21b2f4b2b68e97">OPFLAG_LASTROWID</a>|<a class="code" href="sqliteInt_8h.html#a2402d52d244d3dcbc0bb4d6a796194a0">OPFLAG_APPEND</a>);
<a name="l01695"></a>01695   <a class="code" href="vdbe_8h.html#a0417c7b01c7f0c8d93910a5dc00965ce">sqlite3VdbeChangeP4</a>(v, -1, pDest-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>, 0);
<a name="l01696"></a>01696   <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a>, iSrc, addr1);
<a name="l01697"></a>01697   <a class="code" href="insert_8c.html#a00c877d23537fbd22de156afc6c52f9d">autoIncEnd</a>(pParse, iDbDest, pDest, regAutoinc);
<a name="l01698"></a>01698   <span class="keywordflow">for</span>(pDestIdx=pDest-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>; pDestIdx; pDestIdx=pDestIdx-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>){
<a name="l01699"></a>01699     <span class="keywordflow">for</span>(pSrcIdx=pSrc-&gt;<a class="code" href="structTable.html#a5dffd0c9e8f0265d6a47b32bd0e6d59f">pIndex</a>; pSrcIdx; pSrcIdx=pSrcIdx-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>){
<a name="l01700"></a>01700       <span class="keywordflow">if</span>( <a class="code" href="insert_8c.html#ab575125542540f8b67a3b4beb3e02d06">xferCompatibleIndex</a>(pDestIdx, pSrcIdx) ) <span class="keywordflow">break</span>;
<a name="l01701"></a>01701     }
<a name="l01702"></a>01702     assert( pSrcIdx );
<a name="l01703"></a>01703     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, iSrc, 0);
<a name="l01704"></a>01704     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, iDest, 0);
<a name="l01705"></a>01705     pKey = <a class="code" href="build_8c.html#aa7138838f73483fbf702e0e295dca2fe">sqlite3IndexKeyinfo</a>(pParse, pSrcIdx);
<a name="l01706"></a>01706     <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a0c72fbe4989449cdc9a69e1bbb2e91c2">OP_OpenRead</a>, iSrc, pSrcIdx-&gt;<a class="code" href="structIndex.html#af895a09c01701021c3e36362c04a1ae6">tnum</a>, iDbSrc,
<a name="l01707"></a>01707                       (<span class="keywordtype">char</span>*)pKey, <a class="code" href="vdbe_8h.html#a5a10f433c58f3ce20eb100fa29025e8d">P4_KEYINFO_HANDOFF</a>);
<a name="l01708"></a>01708     <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;%s&quot;</span>, pSrcIdx-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a>));
<a name="l01709"></a>01709     pKey = <a class="code" href="build_8c.html#aa7138838f73483fbf702e0e295dca2fe">sqlite3IndexKeyinfo</a>(pParse, pDestIdx);
<a name="l01710"></a>01710     <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a98af8f9fca78ddf04bbc472cf2761f10">OP_OpenWrite</a>, iDest, pDestIdx-&gt;<a class="code" href="structIndex.html#af895a09c01701021c3e36362c04a1ae6">tnum</a>, iDbDest,
<a name="l01711"></a>01711                       (<span class="keywordtype">char</span>*)pKey, <a class="code" href="vdbe_8h.html#a5a10f433c58f3ce20eb100fa29025e8d">P4_KEYINFO_HANDOFF</a>);
<a name="l01712"></a>01712     <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;%s&quot;</span>, pDestIdx-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a>));
<a name="l01713"></a>01713     addr1 = <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>, iSrc, 0);
<a name="l01714"></a>01714     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ac1f5032a0dca76f4035f5b5fb993c6a6">OP_RowKey</a>, iSrc, regData);
<a name="l01715"></a>01715     <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a8459d42180c78f800cee8d98dc8fe3ea">OP_IdxInsert</a>, iDest, regData, 1);
<a name="l01716"></a>01716     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a>, iSrc, addr1+1);
<a name="l01717"></a>01717     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, addr1);
<a name="l01718"></a>01718   }
<a name="l01719"></a>01719   <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, emptySrcTest);
<a name="l01720"></a>01720   <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, regRowid);
<a name="l01721"></a>01721   <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, regData);
<a name="l01722"></a>01722   <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, iSrc, 0);
<a name="l01723"></a>01723   <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, iDest, 0);
<a name="l01724"></a>01724   <span class="keywordflow">if</span>( emptyDestTest ){
<a name="l01725"></a>01725     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af1020441d30e76aa4d065ac2ec56c23d">OP_Halt</a>, <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>, 0);
<a name="l01726"></a>01726     <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, emptyDestTest);
<a name="l01727"></a>01727     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, iDest, 0);
<a name="l01728"></a>01728     <span class="keywordflow">return</span> 0;
<a name="l01729"></a>01729   }<span class="keywordflow">else</span>{
<a name="l01730"></a>01730     <span class="keywordflow">return</span> 1;
<a name="l01731"></a>01731   }
<a name="l01732"></a>01732 }
<a name="l01733"></a>01733 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_XFER_OPT */</span>
<a name="l01734"></a>01734 
<a name="l01735"></a>01735 <span class="comment">/* Make sure &quot;isView&quot; gets undefined in case this file becomes part of</span>
<a name="l01736"></a>01736 <span class="comment">** the amalgamation - so that subsequent files do not see isView as a</span>
<a name="l01737"></a>01737 <span class="comment">** macro. */</span>
<a name="l01738"></a>01738 <span class="preprocessor">#undef isView</span>
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:54 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
