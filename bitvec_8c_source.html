<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: bitvec.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>bitvec.c</h1><a href="bitvec_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">** 2008 February 16</span>
<a name="l00003"></a>00003 <span class="comment">**</span>
<a name="l00004"></a>00004 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00005"></a>00005 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00006"></a>00006 <span class="comment">**</span>
<a name="l00007"></a>00007 <span class="comment">**    May you do good and not evil.</span>
<a name="l00008"></a>00008 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00009"></a>00009 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">*************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment">** This file implements an object that represents a fixed-length</span>
<a name="l00013"></a>00013 <span class="comment">** bitmap.  Bits are numbered starting with 1.</span>
<a name="l00014"></a>00014 <span class="comment">**</span>
<a name="l00015"></a>00015 <span class="comment">** A bitmap is used to record which pages of a database file have been</span>
<a name="l00016"></a>00016 <span class="comment">** journalled during a transaction, or which pages have the &quot;dont-write&quot;</span>
<a name="l00017"></a>00017 <span class="comment">** property.  Usually only a few pages are meet either condition.</span>
<a name="l00018"></a>00018 <span class="comment">** So the bitmap is usually sparse and has low cardinality.</span>
<a name="l00019"></a>00019 <span class="comment">** But sometimes (for example when during a DROP of a large table) most</span>
<a name="l00020"></a>00020 <span class="comment">** or all of the pages in a database can get journalled.  In those cases, </span>
<a name="l00021"></a>00021 <span class="comment">** the bitmap becomes dense with high cardinality.  The algorithm needs </span>
<a name="l00022"></a>00022 <span class="comment">** to handle both cases well.</span>
<a name="l00023"></a>00023 <span class="comment">**</span>
<a name="l00024"></a>00024 <span class="comment">** The size of the bitmap is fixed when the object is created.</span>
<a name="l00025"></a>00025 <span class="comment">**</span>
<a name="l00026"></a>00026 <span class="comment">** All bits are clear when the bitmap is created.  Individual bits</span>
<a name="l00027"></a>00027 <span class="comment">** may be set or cleared one at a time.</span>
<a name="l00028"></a>00028 <span class="comment">**</span>
<a name="l00029"></a>00029 <span class="comment">** Test operations are about 100 times more common that set operations.</span>
<a name="l00030"></a>00030 <span class="comment">** Clear operations are exceedingly rare.  There are usually between</span>
<a name="l00031"></a>00031 <span class="comment">** 5 and 500 set operations per Bitvec object, though the number of sets can</span>
<a name="l00032"></a>00032 <span class="comment">** sometimes grow into tens of thousands or larger.  The size of the</span>
<a name="l00033"></a>00033 <span class="comment">** Bitvec object is the number of pages in the database file at the</span>
<a name="l00034"></a>00034 <span class="comment">** start of a transaction, and is thus usually less than a few thousand,</span>
<a name="l00035"></a>00035 <span class="comment">** but can be as large as 2 billion for a really big database.</span>
<a name="l00036"></a>00036 <span class="comment">**</span>
<a name="l00037"></a>00037 <span class="comment">** @(#) $Id: bitvec.c,v 1.8 2008/11/11 15:48:48 drh Exp $</span>
<a name="l00038"></a>00038 <span class="comment">*/</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="sqliteInt_8h.html">sqliteInt.h</a>&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="bitvec_8c.html#ae76cb4101f90dcee248a2872b7b55df8">00041</a> <span class="preprocessor">#define BITVEC_SZ        512</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="comment">/* Round the union size down to the nearest pointer boundary, since that&apos;s how </span>
<a name="l00043"></a>00043 <span class="comment">** it will be aligned within the Bitvec struct. */</span>
<a name="l00044"></a><a class="code" href="bitvec_8c.html#ae4615dac0bc0127695119b814f5acedb">00044</a> <span class="preprocessor">#define BITVEC_USIZE     (((BITVEC_SZ-12)/sizeof(Bitvec*))*sizeof(Bitvec*))</span>
<a name="l00045"></a><a class="code" href="bitvec_8c.html#aa24fa9c4413b35d27d5ac3fa534a7761">00045</a> <span class="preprocessor"></span><span class="preprocessor">#define BITVEC_NCHAR     BITVEC_USIZE</span>
<a name="l00046"></a><a class="code" href="bitvec_8c.html#aa013a0569f52bbd39150a007a1e79813">00046</a> <span class="preprocessor"></span><span class="preprocessor">#define BITVEC_NBIT      (BITVEC_NCHAR*8)</span>
<a name="l00047"></a><a class="code" href="bitvec_8c.html#a6631a81736378abeb3cd82ff1d373c7f">00047</a> <span class="preprocessor"></span><span class="preprocessor">#define BITVEC_NINT      (BITVEC_USIZE/4)</span>
<a name="l00048"></a><a class="code" href="bitvec_8c.html#aa881360ad1dc19bfa19680fc46b0c03f">00048</a> <span class="preprocessor"></span><span class="preprocessor">#define BITVEC_MXHASH    (BITVEC_NINT/2)</span>
<a name="l00049"></a><a class="code" href="bitvec_8c.html#ac3a46fc9cd900e383c175cdd5eb3f633">00049</a> <span class="preprocessor"></span><span class="preprocessor">#define BITVEC_NPTR      (BITVEC_USIZE/sizeof(Bitvec *))</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a><a class="code" href="bitvec_8c.html#acafd640a93aa5ce95fbfe213eb048327">00051</a> <span class="preprocessor">#define BITVEC_HASH(X)   (((X)*37)%BITVEC_NINT)</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>
<a name="l00053"></a>00053 <span class="comment">/*</span>
<a name="l00054"></a>00054 <span class="comment">** A bitmap is an instance of the following structure.</span>
<a name="l00055"></a>00055 <span class="comment">**</span>
<a name="l00056"></a>00056 <span class="comment">** This bitmap records the existance of zero or more bits</span>
<a name="l00057"></a>00057 <span class="comment">** with values between 1 and iSize, inclusive.</span>
<a name="l00058"></a>00058 <span class="comment">**</span>
<a name="l00059"></a>00059 <span class="comment">** There are three possible representations of the bitmap.</span>
<a name="l00060"></a>00060 <span class="comment">** If iSize&lt;=BITVEC_NBIT, then Bitvec.u.aBitmap[] is a straight</span>
<a name="l00061"></a>00061 <span class="comment">** bitmap.  The least significant bit is bit 1.</span>
<a name="l00062"></a>00062 <span class="comment">**</span>
<a name="l00063"></a>00063 <span class="comment">** If iSize&gt;BITVEC_NBIT and iDivisor==0 then Bitvec.u.aHash[] is</span>
<a name="l00064"></a>00064 <span class="comment">** a hash table that will hold up to BITVEC_MXHASH distinct values.</span>
<a name="l00065"></a>00065 <span class="comment">**</span>
<a name="l00066"></a>00066 <span class="comment">** Otherwise, the value i is redirected into one of BITVEC_NPTR</span>
<a name="l00067"></a>00067 <span class="comment">** sub-bitmaps pointed to by Bitvec.u.apSub[].  Each subbitmap</span>
<a name="l00068"></a>00068 <span class="comment">** handles up to iDivisor separate values of i.  apSub[0] holds</span>
<a name="l00069"></a>00069 <span class="comment">** values between 1 and iDivisor.  apSub[1] holds values between</span>
<a name="l00070"></a>00070 <span class="comment">** iDivisor+1 and 2*iDivisor.  apSub[N] holds values between</span>
<a name="l00071"></a>00071 <span class="comment">** N*iDivisor+1 and (N+1)*iDivisor.  Each subbitmap is normalized</span>
<a name="l00072"></a>00072 <span class="comment">** to hold deal with values between 1 and iDivisor.</span>
<a name="l00073"></a>00073 <span class="comment">*/</span>
<a name="l00074"></a><a class="code" href="structBitvec.html">00074</a> <span class="keyword">struct </span><a class="code" href="structBitvec.html">Bitvec</a> {
<a name="l00075"></a><a class="code" href="structBitvec.html#ab36df8ece98aee080bae6de28c237de8">00075</a>   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> <a class="code" href="structBitvec.html#ab36df8ece98aee080bae6de28c237de8">iSize</a>;      <span class="comment">/* Maximum bit index */</span>
<a name="l00076"></a><a class="code" href="structBitvec.html#ad6811debae9b972f2d94d667e994e3f6">00076</a>   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> <a class="code" href="structBitvec.html#ad6811debae9b972f2d94d667e994e3f6">nSet</a>;       <span class="comment">/* Number of bits that are set */</span>
<a name="l00077"></a><a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">00077</a>   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> <a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a>;   <span class="comment">/* Number of bits handled by each apSub[] entry */</span>
<a name="l00078"></a>00078   <span class="keyword">union </span>{
<a name="l00079"></a><a class="code" href="structBitvec.html#af2330316a0e0f620409237b19103913c">00079</a>     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> <a class="code" href="structBitvec.html#af2330316a0e0f620409237b19103913c">aBitmap</a>[<a class="code" href="bitvec_8c.html#aa24fa9c4413b35d27d5ac3fa534a7761">BITVEC_NCHAR</a>];    <span class="comment">/* Bitmap representation */</span>
<a name="l00080"></a><a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">00080</a>     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> <a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>[<a class="code" href="bitvec_8c.html#a6631a81736378abeb3cd82ff1d373c7f">BITVEC_NINT</a>];      <span class="comment">/* Hash table representation */</span>
<a name="l00081"></a><a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">00081</a>     <a class="code" href="structBitvec.html">Bitvec</a> *<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[<a class="code" href="bitvec_8c.html#ac3a46fc9cd900e383c175cdd5eb3f633">BITVEC_NPTR</a>];  <span class="comment">/* Recursive representation */</span>
<a name="l00082"></a>00082   } <a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>;
<a name="l00083"></a>00083 };
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">/*</span>
<a name="l00086"></a>00086 <span class="comment">** Create a new bitmap object able to handle bits between 0 and iSize,</span>
<a name="l00087"></a>00087 <span class="comment">** inclusive.  Return a pointer to the new object.  Return NULL if </span>
<a name="l00088"></a>00088 <span class="comment">** malloc fails.</span>
<a name="l00089"></a>00089 <span class="comment">*/</span>
<a name="l00090"></a><a class="code" href="sqliteInt_8h.html#a6a69f23868f044158360753215d511d1">00090</a> <a class="code" href="structBitvec.html">Bitvec</a> *<a class="code" href="bitvec_8c.html#ab3a396c13ff216b7ca564feff51d44e8">sqlite3BitvecCreate</a>(<a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> iSize){
<a name="l00091"></a>00091   <a class="code" href="structBitvec.html">Bitvec</a> *p;
<a name="l00092"></a>00092   assert( <span class="keyword">sizeof</span>(*p)==<a class="code" href="bitvec_8c.html#ae76cb4101f90dcee248a2872b7b55df8">BITVEC_SZ</a> );
<a name="l00093"></a>00093   p = <a class="code" href="malloc_8c.html#aa88ccfc5604fb4bd9b60b3ca4f9f58d4">sqlite3MallocZero</a>( <span class="keyword">sizeof</span>(*p) );
<a name="l00094"></a>00094   <span class="keywordflow">if</span>( p ){
<a name="l00095"></a>00095     p-&gt;<a class="code" href="structBitvec.html#ab36df8ece98aee080bae6de28c237de8">iSize</a> = iSize;
<a name="l00096"></a>00096   }
<a name="l00097"></a>00097   <span class="keywordflow">return</span> p;
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="comment">/*</span>
<a name="l00101"></a>00101 <span class="comment">** Check to see if the i-th bit is set.  Return true or false.</span>
<a name="l00102"></a>00102 <span class="comment">** If p is NULL (if the bitmap has not been created) or if</span>
<a name="l00103"></a>00103 <span class="comment">** i is out of range, then return false.</span>
<a name="l00104"></a>00104 <span class="comment">*/</span>
<a name="l00105"></a><a class="code" href="sqliteInt_8h.html#a372b66c20e69f26a33513027adec2529">00105</a> <span class="keywordtype">int</span> <a class="code" href="bitvec_8c.html#accaed4ce56d7061670a5e63e1706d4b5">sqlite3BitvecTest</a>(<a class="code" href="structBitvec.html">Bitvec</a> *p, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> i){
<a name="l00106"></a>00106   <span class="keywordflow">if</span>( p==0 ) <span class="keywordflow">return</span> 0;
<a name="l00107"></a>00107   <span class="keywordflow">if</span>( i&gt;p-&gt;<a class="code" href="structBitvec.html#ab36df8ece98aee080bae6de28c237de8">iSize</a> || i==0 ) <span class="keywordflow">return</span> 0;
<a name="l00108"></a>00108   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#ab36df8ece98aee080bae6de28c237de8">iSize</a>&lt;=<a class="code" href="bitvec_8c.html#aa013a0569f52bbd39150a007a1e79813">BITVEC_NBIT</a> ){
<a name="l00109"></a>00109     i--;
<a name="l00110"></a>00110     <span class="keywordflow">return</span> (p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#af2330316a0e0f620409237b19103913c">aBitmap</a>[i/8] &amp; (1&lt;&lt;(i&amp;7)))!=0;
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a>&gt;0 ){
<a name="l00113"></a>00113     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> bin = (i-1)/p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a>;
<a name="l00114"></a>00114     i = (i-1)%p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a> + 1;
<a name="l00115"></a>00115     <span class="keywordflow">return</span> <a class="code" href="bitvec_8c.html#accaed4ce56d7061670a5e63e1706d4b5">sqlite3BitvecTest</a>(p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[bin], i);
<a name="l00116"></a>00116   }<span class="keywordflow">else</span>{
<a name="l00117"></a>00117     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> h = <a class="code" href="bitvec_8c.html#acafd640a93aa5ce95fbfe213eb048327">BITVEC_HASH</a>(i);
<a name="l00118"></a>00118     <span class="keywordflow">while</span>( p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>[h] ){
<a name="l00119"></a>00119       <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>[h]==i ) <span class="keywordflow">return</span> 1;
<a name="l00120"></a>00120       h++;
<a name="l00121"></a>00121       <span class="keywordflow">if</span>( h&gt;=<a class="code" href="bitvec_8c.html#a6631a81736378abeb3cd82ff1d373c7f">BITVEC_NINT</a> ) h = 0;
<a name="l00122"></a>00122     }
<a name="l00123"></a>00123     <span class="keywordflow">return</span> 0;
<a name="l00124"></a>00124   }
<a name="l00125"></a>00125 }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="comment">/*</span>
<a name="l00128"></a>00128 <span class="comment">** Set the i-th bit.  Return 0 on success and an error code if</span>
<a name="l00129"></a>00129 <span class="comment">** anything goes wrong.</span>
<a name="l00130"></a>00130 <span class="comment">**</span>
<a name="l00131"></a>00131 <span class="comment">** This routine might cause sub-bitmaps to be allocated.  Failing</span>
<a name="l00132"></a>00132 <span class="comment">** to get the memory needed to hold the sub-bitmap is the only</span>
<a name="l00133"></a>00133 <span class="comment">** that can go wrong with an insert, assuming p and i are valid.</span>
<a name="l00134"></a>00134 <span class="comment">**</span>
<a name="l00135"></a>00135 <span class="comment">** The calling function must ensure that p is a valid Bitvec object</span>
<a name="l00136"></a>00136 <span class="comment">** and that the value for &quot;i&quot; is within range of the Bitvec object.</span>
<a name="l00137"></a>00137 <span class="comment">** Otherwise the behavior is undefined.</span>
<a name="l00138"></a>00138 <span class="comment">*/</span>
<a name="l00139"></a><a class="code" href="sqliteInt_8h.html#a2430c6d3eb9166443a398fb4e21228c7">00139</a> <span class="keywordtype">int</span> <a class="code" href="bitvec_8c.html#a91c2e9efaa9426a814af61edae64cf1e">sqlite3BitvecSet</a>(<a class="code" href="structBitvec.html">Bitvec</a> *p, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> i){
<a name="l00140"></a>00140   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> h;
<a name="l00141"></a>00141   assert( p!=0 );
<a name="l00142"></a>00142   assert( i&gt;0 );
<a name="l00143"></a>00143   assert( i&lt;=p-&gt;iSize );
<a name="l00144"></a>00144   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#ab36df8ece98aee080bae6de28c237de8">iSize</a>&lt;=<a class="code" href="bitvec_8c.html#aa013a0569f52bbd39150a007a1e79813">BITVEC_NBIT</a> ){
<a name="l00145"></a>00145     i--;
<a name="l00146"></a>00146     p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#af2330316a0e0f620409237b19103913c">aBitmap</a>[i/8] |= 1 &lt;&lt; (i&amp;7);
<a name="l00147"></a>00147     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00148"></a>00148   }
<a name="l00149"></a>00149   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a> ){
<a name="l00150"></a>00150     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> bin = (i-1)/p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a>;
<a name="l00151"></a>00151     i = (i-1)%p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a> + 1;
<a name="l00152"></a>00152     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[bin]==0 ){
<a name="l00153"></a>00153       <a class="code" href="fault_8c.html#abd9e16e72d950da81603ebdf72ed4d5c">sqlite3BeginBenignMalloc</a>();
<a name="l00154"></a>00154       p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[bin] = <a class="code" href="bitvec_8c.html#ab3a396c13ff216b7ca564feff51d44e8">sqlite3BitvecCreate</a>( p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a> );
<a name="l00155"></a>00155       <a class="code" href="fault_8c.html#ab9784f82977599f15fc02ea3ce1a770a">sqlite3EndBenignMalloc</a>();
<a name="l00156"></a>00156       <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[bin]==0 ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l00157"></a>00157     }
<a name="l00158"></a>00158     <span class="keywordflow">return</span> <a class="code" href="bitvec_8c.html#a91c2e9efaa9426a814af61edae64cf1e">sqlite3BitvecSet</a>(p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[bin], i);
<a name="l00159"></a>00159   }
<a name="l00160"></a>00160   h = <a class="code" href="bitvec_8c.html#acafd640a93aa5ce95fbfe213eb048327">BITVEC_HASH</a>(i);
<a name="l00161"></a>00161   <span class="keywordflow">while</span>( p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>[h] ){
<a name="l00162"></a>00162     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>[h]==i ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00163"></a>00163     h++;
<a name="l00164"></a>00164     <span class="keywordflow">if</span>( h==<a class="code" href="bitvec_8c.html#a6631a81736378abeb3cd82ff1d373c7f">BITVEC_NINT</a> ) h = 0;
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166   p-&gt;<a class="code" href="structBitvec.html#ad6811debae9b972f2d94d667e994e3f6">nSet</a>++;
<a name="l00167"></a>00167   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#ad6811debae9b972f2d94d667e994e3f6">nSet</a>&gt;=<a class="code" href="bitvec_8c.html#aa881360ad1dc19bfa19680fc46b0c03f">BITVEC_MXHASH</a> ){
<a name="l00168"></a>00168     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j;
<a name="l00169"></a>00169     <span class="keywordtype">int</span> rc;
<a name="l00170"></a>00170     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> aiValues[<a class="code" href="bitvec_8c.html#a6631a81736378abeb3cd82ff1d373c7f">BITVEC_NINT</a>];
<a name="l00171"></a>00171     memcpy(aiValues, p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>, <span class="keyword">sizeof</span>(aiValues));
<a name="l00172"></a>00172     memset(p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>, 0, <span class="keyword">sizeof</span>(p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[0])*<a class="code" href="bitvec_8c.html#ac3a46fc9cd900e383c175cdd5eb3f633">BITVEC_NPTR</a>);
<a name="l00173"></a>00173     p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a> = (p-&gt;<a class="code" href="structBitvec.html#ab36df8ece98aee080bae6de28c237de8">iSize</a> + <a class="code" href="bitvec_8c.html#ac3a46fc9cd900e383c175cdd5eb3f633">BITVEC_NPTR</a> - 1)/<a class="code" href="bitvec_8c.html#ac3a46fc9cd900e383c175cdd5eb3f633">BITVEC_NPTR</a>;
<a name="l00174"></a>00174     rc = <a class="code" href="bitvec_8c.html#a91c2e9efaa9426a814af61edae64cf1e">sqlite3BitvecSet</a>(p, i);
<a name="l00175"></a>00175     <span class="keywordflow">for</span>(j=0; j&lt;<a class="code" href="bitvec_8c.html#a6631a81736378abeb3cd82ff1d373c7f">BITVEC_NINT</a>; j++){
<a name="l00176"></a>00176       <span class="keywordflow">if</span>( aiValues[j] ) rc |= <a class="code" href="bitvec_8c.html#a91c2e9efaa9426a814af61edae64cf1e">sqlite3BitvecSet</a>(p, aiValues[j]);
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178     <span class="keywordflow">return</span> rc;
<a name="l00179"></a>00179   }
<a name="l00180"></a>00180   p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>[h] = i;
<a name="l00181"></a>00181   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="comment">/*</span>
<a name="l00185"></a>00185 <span class="comment">** Clear the i-th bit.  Return 0 on success and an error code if</span>
<a name="l00186"></a>00186 <span class="comment">** anything goes wrong.</span>
<a name="l00187"></a>00187 <span class="comment">*/</span>
<a name="l00188"></a><a class="code" href="sqliteInt_8h.html#af1e98dc8e0a98ba059f2b8fb7060488c">00188</a> <span class="keywordtype">void</span> <a class="code" href="bitvec_8c.html#a49c46fcda6d66f00e1cdf3e402872ead">sqlite3BitvecClear</a>(<a class="code" href="structBitvec.html">Bitvec</a> *p, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> i){
<a name="l00189"></a>00189   assert( p!=0 );
<a name="l00190"></a>00190   assert( i&gt;0 );
<a name="l00191"></a>00191   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#ab36df8ece98aee080bae6de28c237de8">iSize</a>&lt;=<a class="code" href="bitvec_8c.html#aa013a0569f52bbd39150a007a1e79813">BITVEC_NBIT</a> ){
<a name="l00192"></a>00192     i--;
<a name="l00193"></a>00193     p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#af2330316a0e0f620409237b19103913c">aBitmap</a>[i/8] &amp;= ~(1 &lt;&lt; (i&amp;7));
<a name="l00194"></a>00194   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a> ){
<a name="l00195"></a>00195     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> bin = (i-1)/p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a>;
<a name="l00196"></a>00196     i = (i-1)%p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a> + 1;
<a name="l00197"></a>00197     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[bin] ){
<a name="l00198"></a>00198       <a class="code" href="bitvec_8c.html#a49c46fcda6d66f00e1cdf3e402872ead">sqlite3BitvecClear</a>(p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[bin], i);
<a name="l00199"></a>00199     }
<a name="l00200"></a>00200   }<span class="keywordflow">else</span>{
<a name="l00201"></a>00201     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j;
<a name="l00202"></a>00202     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> aiValues[<a class="code" href="bitvec_8c.html#a6631a81736378abeb3cd82ff1d373c7f">BITVEC_NINT</a>];
<a name="l00203"></a>00203     memcpy(aiValues, p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>, <span class="keyword">sizeof</span>(aiValues));
<a name="l00204"></a>00204     memset(p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>, 0, <span class="keyword">sizeof</span>(p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#adcaa47179c109270041bf59f8fe9f8ff">aHash</a>[0])*<a class="code" href="bitvec_8c.html#a6631a81736378abeb3cd82ff1d373c7f">BITVEC_NINT</a>);
<a name="l00205"></a>00205     p-&gt;<a class="code" href="structBitvec.html#ad6811debae9b972f2d94d667e994e3f6">nSet</a> = 0;
<a name="l00206"></a>00206     <span class="keywordflow">for</span>(j=0; j&lt;<a class="code" href="bitvec_8c.html#a6631a81736378abeb3cd82ff1d373c7f">BITVEC_NINT</a>; j++){
<a name="l00207"></a>00207       <span class="keywordflow">if</span>( aiValues[j] &amp;&amp; aiValues[j]!=i ){
<a name="l00208"></a>00208         <a class="code" href="bitvec_8c.html#a91c2e9efaa9426a814af61edae64cf1e">sqlite3BitvecSet</a>(p, aiValues[j]);
<a name="l00209"></a>00209       }
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211   }
<a name="l00212"></a>00212 }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="comment">/*</span>
<a name="l00215"></a>00215 <span class="comment">** Destroy a bitmap object.  Reclaim all memory used.</span>
<a name="l00216"></a>00216 <span class="comment">*/</span>
<a name="l00217"></a><a class="code" href="sqliteInt_8h.html#a8460ef80d4c16c7b0ead653055382a59">00217</a> <span class="keywordtype">void</span> <a class="code" href="bitvec_8c.html#ab00129e9ec0c562a8f0047b8c1404ab1">sqlite3BitvecDestroy</a>(<a class="code" href="structBitvec.html">Bitvec</a> *p){
<a name="l00218"></a>00218   <span class="keywordflow">if</span>( p==0 ) <span class="keywordflow">return</span>;
<a name="l00219"></a>00219   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBitvec.html#a22cdb23eb424e07b6ce922de018a83d9">iDivisor</a> ){
<a name="l00220"></a>00220     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00221"></a>00221     <span class="keywordflow">for</span>(i=0; i&lt;<a class="code" href="bitvec_8c.html#ac3a46fc9cd900e383c175cdd5eb3f633">BITVEC_NPTR</a>; i++){
<a name="l00222"></a>00222       <a class="code" href="bitvec_8c.html#ab00129e9ec0c562a8f0047b8c1404ab1">sqlite3BitvecDestroy</a>(p-&gt;<a class="code" href="structBitvec.html#a2ef3423696109b6b699aee3e736c4ed6">u</a>.<a class="code" href="structBitvec.html#ab4942527f1862bbd8e1ffe45486d1541">apSub</a>[i]);
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224   }
<a name="l00225"></a>00225   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p);
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="preprocessor">#ifndef SQLITE_OMIT_BUILTIN_TEST</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00230"></a>00230 <span class="comment">** Let V[] be an array of unsigned characters sufficient to hold</span>
<a name="l00231"></a>00231 <span class="comment">** up to N bits.  Let I be an integer between 0 and N.  0&lt;=I&lt;N.</span>
<a name="l00232"></a>00232 <span class="comment">** Then the following macros can be used to set, clear, or test</span>
<a name="l00233"></a>00233 <span class="comment">** individual bits within V.</span>
<a name="l00234"></a>00234 <span class="comment">*/</span>
<a name="l00235"></a><a class="code" href="bitvec_8c.html#aae6cf9d0a4b3beb6aeee9a337f2f0e83">00235</a> <span class="preprocessor">#define SETBIT(V,I)      V[I&gt;&gt;3] |= (1&lt;&lt;(I&amp;7))</span>
<a name="l00236"></a><a class="code" href="bitvec_8c.html#a05a011448e916c87fd6798f8a92c4c2c">00236</a> <span class="preprocessor"></span><span class="preprocessor">#define CLEARBIT(V,I)    V[I&gt;&gt;3] &amp;= ~(1&lt;&lt;(I&amp;7))</span>
<a name="l00237"></a><a class="code" href="bitvec_8c.html#af84d873fa3f95dbee6734022ddd2bc4e">00237</a> <span class="preprocessor"></span><span class="preprocessor">#define TESTBIT(V,I)     (V[I&gt;&gt;3]&amp;(1&lt;&lt;(I&amp;7)))!=0</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span>
<a name="l00239"></a>00239 <span class="comment">/*</span>
<a name="l00240"></a>00240 <span class="comment">** This routine runs an extensive test of the Bitvec code.</span>
<a name="l00241"></a>00241 <span class="comment">**</span>
<a name="l00242"></a>00242 <span class="comment">** The input is an array of integers that acts as a program</span>
<a name="l00243"></a>00243 <span class="comment">** to test the Bitvec.  The integers are opcodes followed</span>
<a name="l00244"></a>00244 <span class="comment">** by 0, 1, or 3 operands, depending on the opcode.  Another</span>
<a name="l00245"></a>00245 <span class="comment">** opcode follows immediately after the last operand.</span>
<a name="l00246"></a>00246 <span class="comment">**</span>
<a name="l00247"></a>00247 <span class="comment">** There are 6 opcodes numbered from 0 through 5.  0 is the</span>
<a name="l00248"></a>00248 <span class="comment">** &quot;halt&quot; opcode and causes the test to end.</span>
<a name="l00249"></a>00249 <span class="comment">**</span>
<a name="l00250"></a>00250 <span class="comment">**    0          Halt and return the number of errors</span>
<a name="l00251"></a>00251 <span class="comment">**    1 N S X    Set N bits beginning with S and incrementing by X</span>
<a name="l00252"></a>00252 <span class="comment">**    2 N S X    Clear N bits beginning with S and incrementing by X</span>
<a name="l00253"></a>00253 <span class="comment">**    3 N        Set N randomly chosen bits</span>
<a name="l00254"></a>00254 <span class="comment">**    4 N        Clear N randomly chosen bits</span>
<a name="l00255"></a>00255 <span class="comment">**    5 N S X    Set N bits from S increment X in array only, not in bitvec</span>
<a name="l00256"></a>00256 <span class="comment">**</span>
<a name="l00257"></a>00257 <span class="comment">** The opcodes 1 through 4 perform set and clear operations are performed</span>
<a name="l00258"></a>00258 <span class="comment">** on both a Bitvec object and on a linear array of bits obtained from malloc.</span>
<a name="l00259"></a>00259 <span class="comment">** Opcode 5 works on the linear array only, not on the Bitvec.</span>
<a name="l00260"></a>00260 <span class="comment">** Opcode 5 is used to deliberately induce a fault in order to</span>
<a name="l00261"></a>00261 <span class="comment">** confirm that error detection works.</span>
<a name="l00262"></a>00262 <span class="comment">**</span>
<a name="l00263"></a>00263 <span class="comment">** At the conclusion of the test the linear array is compared</span>
<a name="l00264"></a>00264 <span class="comment">** against the Bitvec object.  If there are any differences,</span>
<a name="l00265"></a>00265 <span class="comment">** an error is returned.  If they are the same, zero is returned.</span>
<a name="l00266"></a>00266 <span class="comment">**</span>
<a name="l00267"></a>00267 <span class="comment">** If a memory allocation error occurs, return -1.</span>
<a name="l00268"></a>00268 <span class="comment">*/</span>
<a name="l00269"></a><a class="code" href="sqliteInt_8h.html#a8045a42093129c9e86c902dd140afdc4">00269</a> <span class="keywordtype">int</span> <a class="code" href="bitvec_8c.html#aacaf4c8443dbd8af21c27586a02814ed">sqlite3BitvecBuiltinTest</a>(<span class="keywordtype">int</span> sz, <span class="keywordtype">int</span> *aOp){
<a name="l00270"></a>00270   <a class="code" href="structBitvec.html">Bitvec</a> *pBitvec = 0;
<a name="l00271"></a>00271   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pV = 0;
<a name="l00272"></a>00272   <span class="keywordtype">int</span> rc = -1;
<a name="l00273"></a>00273   <span class="keywordtype">int</span> i, nx, pc, op;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275   <span class="comment">/* Allocate the Bitvec to be tested and a linear array of</span>
<a name="l00276"></a>00276 <span class="comment">  ** bits to act as the reference */</span>
<a name="l00277"></a>00277   pBitvec = <a class="code" href="bitvec_8c.html#ab3a396c13ff216b7ca564feff51d44e8">sqlite3BitvecCreate</a>( sz );
<a name="l00278"></a>00278   pV = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>( (sz+7)/8 + 1 );
<a name="l00279"></a>00279   <span class="keywordflow">if</span>( pBitvec==0 || pV==0 ) <span class="keywordflow">goto</span> bitvec_end;
<a name="l00280"></a>00280   memset(pV, 0, (sz+7)/8 + 1);
<a name="l00281"></a>00281 
<a name="l00282"></a>00282   <span class="comment">/* Run the program */</span>
<a name="l00283"></a>00283   pc = 0;
<a name="l00284"></a>00284   <span class="keywordflow">while</span>( (op = aOp[pc])!=0 ){
<a name="l00285"></a>00285     <span class="keywordflow">switch</span>( op ){
<a name="l00286"></a>00286       <span class="keywordflow">case</span> 1:
<a name="l00287"></a>00287       <span class="keywordflow">case</span> 2:
<a name="l00288"></a>00288       <span class="keywordflow">case</span> 5: {
<a name="l00289"></a>00289         nx = 4;
<a name="l00290"></a>00290         i = aOp[pc+2] - 1;
<a name="l00291"></a>00291         aOp[pc+2] += aOp[pc+3];
<a name="l00292"></a>00292         <span class="keywordflow">break</span>;
<a name="l00293"></a>00293       }
<a name="l00294"></a>00294       <span class="keywordflow">case</span> 3:
<a name="l00295"></a>00295       <span class="keywordflow">case</span> 4: 
<a name="l00296"></a>00296       <span class="keywordflow">default</span>: {
<a name="l00297"></a>00297         nx = 2;
<a name="l00298"></a>00298         <a class="code" href="random_8c.html#a1431cd360c32f40da9dec267d29eb998">sqlite3_randomness</a>(<span class="keyword">sizeof</span>(i), &amp;i);
<a name="l00299"></a>00299         <span class="keywordflow">break</span>;
<a name="l00300"></a>00300       }
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302     <span class="keywordflow">if</span>( (--aOp[pc+1]) &gt; 0 ) nx = 0;
<a name="l00303"></a>00303     pc += nx;
<a name="l00304"></a>00304     i = (i &amp; 0x7fffffff)%sz;
<a name="l00305"></a>00305     <span class="keywordflow">if</span>( (op &amp; 1)!=0 ){
<a name="l00306"></a>00306       <a class="code" href="bitvec_8c.html#aae6cf9d0a4b3beb6aeee9a337f2f0e83">SETBIT</a>(pV, (i+1));
<a name="l00307"></a>00307       <span class="keywordflow">if</span>( op!=5 ){
<a name="l00308"></a>00308         <span class="keywordflow">if</span>( <a class="code" href="bitvec_8c.html#a91c2e9efaa9426a814af61edae64cf1e">sqlite3BitvecSet</a>(pBitvec, i+1) ) <span class="keywordflow">goto</span> bitvec_end;
<a name="l00309"></a>00309       }
<a name="l00310"></a>00310     }<span class="keywordflow">else</span>{
<a name="l00311"></a>00311       <a class="code" href="bitvec_8c.html#a05a011448e916c87fd6798f8a92c4c2c">CLEARBIT</a>(pV, (i+1));
<a name="l00312"></a>00312       <a class="code" href="bitvec_8c.html#a49c46fcda6d66f00e1cdf3e402872ead">sqlite3BitvecClear</a>(pBitvec, i+1);
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314   }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="comment">/* Test to make sure the linear array exactly matches the</span>
<a name="l00317"></a>00317 <span class="comment">  ** Bitvec object.  Start with the assumption that they do</span>
<a name="l00318"></a>00318 <span class="comment">  ** match (rc==0).  Change rc to non-zero if a discrepancy</span>
<a name="l00319"></a>00319 <span class="comment">  ** is found.</span>
<a name="l00320"></a>00320 <span class="comment">  */</span>
<a name="l00321"></a>00321   rc = <a class="code" href="bitvec_8c.html#accaed4ce56d7061670a5e63e1706d4b5">sqlite3BitvecTest</a>(0,0) + <a class="code" href="bitvec_8c.html#accaed4ce56d7061670a5e63e1706d4b5">sqlite3BitvecTest</a>(pBitvec, sz+1)
<a name="l00322"></a>00322           + <a class="code" href="bitvec_8c.html#accaed4ce56d7061670a5e63e1706d4b5">sqlite3BitvecTest</a>(pBitvec, 0);
<a name="l00323"></a>00323   <span class="keywordflow">for</span>(i=1; i&lt;=sz; i++){
<a name="l00324"></a>00324     <span class="keywordflow">if</span>(  (<a class="code" href="bitvec_8c.html#af84d873fa3f95dbee6734022ddd2bc4e">TESTBIT</a>(pV,i))!=<a class="code" href="bitvec_8c.html#accaed4ce56d7061670a5e63e1706d4b5">sqlite3BitvecTest</a>(pBitvec,i) ){
<a name="l00325"></a>00325       rc = i;
<a name="l00326"></a>00326       <span class="keywordflow">break</span>;
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328   }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   <span class="comment">/* Free allocated structure */</span>
<a name="l00331"></a>00331 bitvec_end:
<a name="l00332"></a>00332   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pV);
<a name="l00333"></a>00333   <a class="code" href="bitvec_8c.html#ab00129e9ec0c562a8f0047b8c1404ab1">sqlite3BitvecDestroy</a>(pBitvec);
<a name="l00334"></a>00334   <span class="keywordflow">return</span> rc;
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_BUILTIN_TEST */</span>
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:51 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
