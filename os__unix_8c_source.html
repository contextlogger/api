<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: os_unix.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>os_unix.c</h1><a href="os__unix_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">** 2004 May 22</span>
<a name="l00003"></a>00003 <span class="comment">**</span>
<a name="l00004"></a>00004 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00005"></a>00005 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00006"></a>00006 <span class="comment">**</span>
<a name="l00007"></a>00007 <span class="comment">**    May you do good and not evil.</span>
<a name="l00008"></a>00008 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00009"></a>00009 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">******************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment">**</span>
<a name="l00013"></a>00013 <span class="comment">** This file contains code that is specific to Unix systems.</span>
<a name="l00014"></a>00014 <span class="comment">**</span>
<a name="l00015"></a>00015 <span class="comment">** $Id: os_unix.c,v 1.209 2008/11/11 18:34:35 danielk1977 Exp $</span>
<a name="l00016"></a>00016 <span class="comment">*/</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;<a class="code" href="sqliteInt_8h.html">sqliteInt.h</a>&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#if SQLITE_OS_UNIX              </span><span class="comment">/* This file is used on unix only */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/*</span>
<a name="l00021"></a>00021 <span class="comment">** If SQLITE_ENABLE_LOCKING_STYLE is defined and is non-zero, then several</span>
<a name="l00022"></a>00022 <span class="comment">** alternative locking implementations are provided:</span>
<a name="l00023"></a>00023 <span class="comment">**</span>
<a name="l00024"></a>00024 <span class="comment">**   * POSIX locking (the default),</span>
<a name="l00025"></a>00025 <span class="comment">**   * No locking,</span>
<a name="l00026"></a>00026 <span class="comment">**   * Dot-file locking,</span>
<a name="l00027"></a>00027 <span class="comment">**   * flock() locking,</span>
<a name="l00028"></a>00028 <span class="comment">**   * AFP locking (OSX only).</span>
<a name="l00029"></a>00029 <span class="comment">**</span>
<a name="l00030"></a>00030 <span class="comment">** SQLITE_ENABLE_LOCKING_STYLE only works on a Mac. It is turned on by</span>
<a name="l00031"></a>00031 <span class="comment">** default on a Mac and disabled on all other posix platforms.</span>
<a name="l00032"></a>00032 <span class="comment">*/</span>
<a name="l00033"></a>00033 <span class="preprocessor">#if !defined(SQLITE_ENABLE_LOCKING_STYLE)</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#  if defined(__DARWIN__)</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#    define SQLITE_ENABLE_LOCKING_STYLE 1</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
<a name="l00037"></a><a class="code" href="os__unix_8c.html#a8b123acd3401827e0d5bd75e7a46e5c0">00037</a> <span class="preprocessor"></span><span class="preprocessor">#    define SQLITE_ENABLE_LOCKING_STYLE 0</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 <span class="comment">/*</span>
<a name="l00042"></a>00042 <span class="comment">** These #defines should enable &gt;2GB file support on Posix if the</span>
<a name="l00043"></a>00043 <span class="comment">** underlying operating system supports it.  If the OS lacks</span>
<a name="l00044"></a>00044 <span class="comment">** large file support, these should be no-ops.</span>
<a name="l00045"></a>00045 <span class="comment">**</span>
<a name="l00046"></a>00046 <span class="comment">** Large file support can be disabled using the -DSQLITE_DISABLE_LFS switch</span>
<a name="l00047"></a>00047 <span class="comment">** on the compiler command line.  This is necessary if you are compiling</span>
<a name="l00048"></a>00048 <span class="comment">** on a recent machine (ex: RedHat 7.2) but you want your code to work</span>
<a name="l00049"></a>00049 <span class="comment">** on an older machine (ex: RedHat 6.0).  If you compile on RedHat 7.2</span>
<a name="l00050"></a>00050 <span class="comment">** without this option, LFS is enable.  But LFS does not exist in the kernel</span>
<a name="l00051"></a>00051 <span class="comment">** in RedHat 6.0, so the code won&apos;t work.  Hence, for maximum binary</span>
<a name="l00052"></a>00052 <span class="comment">** portability you should omit LFS.</span>
<a name="l00053"></a>00053 <span class="comment">*/</span>
<a name="l00054"></a>00054 <span class="preprocessor">#ifndef SQLITE_DISABLE_LFS</span>
<a name="l00055"></a><a class="code" href="os__unix_8c.html#a8776ea0e6f826f2b3a962986b3868582">00055</a> <span class="preprocessor"></span><span class="preprocessor"># define _LARGE_FILE       1</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor"># ifndef _FILE_OFFSET_BITS</span>
<a name="l00057"></a><a class="code" href="os__unix_8c.html#a44d01ba0a136b8e27ad362f5a823d14e">00057</a> <span class="preprocessor"></span><span class="preprocessor">#   define _FILE_OFFSET_BITS 64</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00059"></a><a class="code" href="os__unix_8c.html#a0cdbd4d0545340d33dfe595811475ccd">00059</a> <span class="preprocessor"></span><span class="preprocessor"># define _LARGEFILE_SOURCE 1</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span>
<a name="l00062"></a>00062 <span class="comment">/*</span>
<a name="l00063"></a>00063 <span class="comment">** standard include files.</span>
<a name="l00064"></a>00064 <span class="comment">*/</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="preprocessor">#if SQLITE_ENABLE_LOCKING_STYLE</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &lt;sys/mount.h&gt;</span>
<a name="l00077"></a>00077 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_ENABLE_LOCKING_STYLE */</span>
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">/*</span>
<a name="l00080"></a>00080 <span class="comment">** If we are to be thread-safe, include the pthreads header and define</span>
<a name="l00081"></a>00081 <span class="comment">** the SQLITE_UNIX_THREADS macro.</span>
<a name="l00082"></a>00082 <span class="comment">*/</span>
<a name="l00083"></a>00083 <span class="preprocessor">#if SQLITE_THREADSAFE</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor"># include &lt;pthread.h&gt;</span>
<a name="l00085"></a>00085 <span class="preprocessor"># define SQLITE_UNIX_THREADS 1</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a>00088 <span class="comment">/*</span>
<a name="l00089"></a>00089 <span class="comment">** Default permissions when creating a new file</span>
<a name="l00090"></a>00090 <span class="comment">*/</span>
<a name="l00091"></a>00091 <span class="preprocessor">#ifndef SQLITE_DEFAULT_FILE_PERMISSIONS</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor"># define SQLITE_DEFAULT_FILE_PERMISSIONS 0644</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>
<a name="l00095"></a>00095 <span class="comment">/*</span>
<a name="l00096"></a>00096 <span class="comment">** Maximum supported path-length.</span>
<a name="l00097"></a>00097 <span class="comment">*/</span>
<a name="l00098"></a><a class="code" href="os__unix_8c.html#aa4e5ca47d52a8be522912705c27e0d1c">00098</a> <span class="preprocessor">#define MAX_PATHNAME 512</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span>
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">/*</span>
<a name="l00102"></a>00102 <span class="comment">** The unixFile structure is subclass of sqlite3_file specific for the unix</span>
<a name="l00103"></a>00103 <span class="comment">** protability layer.</span>
<a name="l00104"></a>00104 <span class="comment">*/</span>
<a name="l00105"></a><a class="code" href="os__unix_8c.html#a9b0a4a49351944af6c47ea0dd7f144b7">00105</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structunixFile.html">unixFile</a> <a class="code" href="structunixFile.html">unixFile</a>;
<a name="l00106"></a>00106 <span class="keyword">struct </span><a class="code" href="structunixFile.html">unixFile</a> {
<a name="l00107"></a>00107   <a class="code" href="structsqlite3__io__methods.html">sqlite3_io_methods</a> <span class="keyword">const</span> *<a class="code" href="structunixFile.html#a7eb75fcb2f3395045cb4f836df52ecc1">pMethod</a>;  <span class="comment">/* Always the first entry */</span>
<a name="l00108"></a>00108 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>  <span class="comment">/* In test mode, increase the size of this structure a bit so that </span>
<a name="l00110"></a>00110 <span class="comment">  ** it is larger than the struct CrashFile defined in test6.c.</span>
<a name="l00111"></a>00111 <span class="comment">  */</span>
<a name="l00112"></a>00112   <span class="keywordtype">char</span> aPadding[32];
<a name="l00113"></a>00113 <span class="preprocessor">#endif</span>
<a name="l00114"></a><a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">00114</a> <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structopenCnt.html">openCnt</a> *<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a>;    <span class="comment">/* Info about all open fd&apos;s on this inode */</span>
<a name="l00115"></a><a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">00115</a>   <span class="keyword">struct </span><a class="code" href="structlockInfo.html">lockInfo</a> *<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>;   <span class="comment">/* Info about locks on this inode */</span>
<a name="l00116"></a>00116 <span class="preprocessor">#if SQLITE_ENABLE_LOCKING_STYLE</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>  <span class="keywordtype">void</span> *lockingContext;     <span class="comment">/* Locking style specific state */</span>
<a name="l00118"></a>00118 <span class="preprocessor">#endif</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>  <span class="keywordtype">int</span> <a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>;                    <span class="comment">/* The file descriptor */</span>
<a name="l00120"></a><a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">00120</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>;   <span class="comment">/* The type of lock held on this fd */</span>
<a name="l00121"></a><a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">00121</a>   <span class="keywordtype">int</span> <a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">dirfd</a>;                <span class="comment">/* File descriptor for the directory */</span>
<a name="l00122"></a>00122 <span class="preprocessor">#if SQLITE_THREADSAFE</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span>  pthread_t tid;            <span class="comment">/* The thread that &quot;owns&quot; this unixFile */</span>
<a name="l00124"></a>00124 <span class="preprocessor">#endif</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span>  <span class="keywordtype">int</span> <a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a>;            <span class="comment">/* The unix errno from the last I/O error */</span>
<a name="l00126"></a>00126 };
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="comment">/*</span>
<a name="l00129"></a>00129 <span class="comment">** Include code that is common to all os_*.c files</span>
<a name="l00130"></a>00130 <span class="comment">*/</span>
<a name="l00131"></a>00131 <span class="preprocessor">#include &quot;<a class="code" href="os__common_8h.html">os_common.h</a>&quot;</span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="comment">/*</span>
<a name="l00134"></a>00134 <span class="comment">** Define various macros that are missing from some systems.</span>
<a name="l00135"></a>00135 <span class="comment">*/</span>
<a name="l00136"></a>00136 <span class="preprocessor">#ifndef O_LARGEFILE</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor"># define O_LARGEFILE 0</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor">#ifdef SQLITE_DISABLE_LFS</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor"># undef O_LARGEFILE</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="preprocessor"># define O_LARGEFILE 0</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span><span class="preprocessor">#ifndef O_NOFOLLOW</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span><span class="preprocessor"># define O_NOFOLLOW 0</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span><span class="preprocessor">#ifndef O_BINARY</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span><span class="preprocessor"># define O_BINARY 0</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span>
<a name="l00150"></a>00150 <span class="comment">/*</span>
<a name="l00151"></a>00151 <span class="comment">** The DJGPP compiler environment looks mostly like Unix, but it</span>
<a name="l00152"></a>00152 <span class="comment">** lacks the fcntl() system call.  So redefine fcntl() to be something</span>
<a name="l00153"></a>00153 <span class="comment">** that always succeeds.  This means that locking does not occur under</span>
<a name="l00154"></a>00154 <span class="comment">** DJGPP.  But it is DOS - what did you expect?</span>
<a name="l00155"></a>00155 <span class="comment">*/</span>
<a name="l00156"></a>00156 <span class="preprocessor">#ifdef __DJGPP__</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span><span class="preprocessor"># define fcntl(A,B,C) 0</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a>00160 <span class="comment">/*</span>
<a name="l00161"></a>00161 <span class="comment">** The threadid macro resolves to the thread-id or to 0.  Used for</span>
<a name="l00162"></a>00162 <span class="comment">** testing and debugging only.</span>
<a name="l00163"></a>00163 <span class="comment">*/</span>
<a name="l00164"></a>00164 <span class="preprocessor">#if SQLITE_THREADSAFE</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="preprocessor">#define threadid pthread_self()</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00167"></a><a class="code" href="os__unix_8c.html#afa8ef032e5cdbbbc7df8cc41bdfc865f">00167</a> <span class="preprocessor"></span><span class="preprocessor">#define threadid 0</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span>
<a name="l00170"></a>00170 <span class="comment">/*</span>
<a name="l00171"></a>00171 <span class="comment">** Set or check the unixFile.tid field.  This field is set when an unixFile</span>
<a name="l00172"></a>00172 <span class="comment">** is first opened.  All subsequent uses of the unixFile verify that the</span>
<a name="l00173"></a>00173 <span class="comment">** same thread is operating on the unixFile.  Some operating systems do</span>
<a name="l00174"></a>00174 <span class="comment">** not allow locks to be overridden by other threads and that restriction</span>
<a name="l00175"></a>00175 <span class="comment">** means that sqlite3* database handles cannot be moved from one thread</span>
<a name="l00176"></a>00176 <span class="comment">** to another.  This logic makes sure a user does not try to do that</span>
<a name="l00177"></a>00177 <span class="comment">** by mistake.</span>
<a name="l00178"></a>00178 <span class="comment">**</span>
<a name="l00179"></a>00179 <span class="comment">** Version 3.3.1 (2006-01-15):  unixFile can be moved from one thread to</span>
<a name="l00180"></a>00180 <span class="comment">** another as long as we are running on a system that supports threads</span>
<a name="l00181"></a>00181 <span class="comment">** overriding each others locks (which now the most common behavior)</span>
<a name="l00182"></a>00182 <span class="comment">** or if no locks are held.  But the unixFile.pLock field needs to be</span>
<a name="l00183"></a>00183 <span class="comment">** recomputed because its key includes the thread-id.  See the </span>
<a name="l00184"></a>00184 <span class="comment">** transferOwnership() function below for additional information</span>
<a name="l00185"></a>00185 <span class="comment">*/</span>
<a name="l00186"></a>00186 <span class="preprocessor">#if SQLITE_THREADSAFE</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="preprocessor"># define SET_THREADID(X)   (X)-&gt;tid = pthread_self()</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span><span class="preprocessor"># define CHECK_THREADID(X) (threadsOverrideEachOthersLocks==0 &amp;&amp; \</span>
<a name="l00189"></a>00189 <span class="preprocessor">                            !pthread_equal((X)-&gt;tid, pthread_self()))</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00191"></a><a class="code" href="os__unix_8c.html#a65fed10875316dfdb55e1fc73eef71dc">00191</a> <span class="preprocessor"></span><span class="preprocessor"># define SET_THREADID(X)</span>
<a name="l00192"></a><a class="code" href="os__unix_8c.html#a6fab1db0dc95bfe9c7d2910c3da2eb97">00192</a> <span class="preprocessor"></span><span class="preprocessor"># define CHECK_THREADID(X) 0</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>
<a name="l00195"></a>00195 <span class="comment">/*</span>
<a name="l00196"></a>00196 <span class="comment">** Here is the dirt on POSIX advisory locks:  ANSI STD 1003.1 (1996)</span>
<a name="l00197"></a>00197 <span class="comment">** section 6.5.2.2 lines 483 through 490 specify that when a process</span>
<a name="l00198"></a>00198 <span class="comment">** sets or clears a lock, that operation overrides any prior locks set</span>
<a name="l00199"></a>00199 <span class="comment">** by the same process.  It does not explicitly say so, but this implies</span>
<a name="l00200"></a>00200 <span class="comment">** that it overrides locks set by the same process using a different</span>
<a name="l00201"></a>00201 <span class="comment">** file descriptor.  Consider this test case:</span>
<a name="l00202"></a>00202 <span class="comment">**       int fd2 = open(&quot;./file2&quot;, O_RDWR|O_CREAT, 0644);</span>
<a name="l00203"></a>00203 <span class="comment">**</span>
<a name="l00204"></a>00204 <span class="comment">** Suppose ./file1 and ./file2 are really the same file (because</span>
<a name="l00205"></a>00205 <span class="comment">** one is a hard or symbolic link to the other) then if you set</span>
<a name="l00206"></a>00206 <span class="comment">** an exclusive lock on fd1, then try to get an exclusive lock</span>
<a name="l00207"></a>00207 <span class="comment">** on fd2, it works.  I would have expected the second lock to</span>
<a name="l00208"></a>00208 <span class="comment">** fail since there was already a lock on the file due to fd1.</span>
<a name="l00209"></a>00209 <span class="comment">** But not so.  Since both locks came from the same process, the</span>
<a name="l00210"></a>00210 <span class="comment">** second overrides the first, even though they were on different</span>
<a name="l00211"></a>00211 <span class="comment">** file descriptors opened on different file names.</span>
<a name="l00212"></a>00212 <span class="comment">**</span>
<a name="l00213"></a>00213 <span class="comment">** Bummer.  If you ask me, this is broken.  Badly broken.  It means</span>
<a name="l00214"></a>00214 <span class="comment">** that we cannot use POSIX locks to synchronize file access among</span>
<a name="l00215"></a>00215 <span class="comment">** competing threads of the same process.  POSIX locks will work fine</span>
<a name="l00216"></a>00216 <span class="comment">** to synchronize access for threads in separate processes, but not</span>
<a name="l00217"></a>00217 <span class="comment">** threads within the same process.</span>
<a name="l00218"></a>00218 <span class="comment">**</span>
<a name="l00219"></a>00219 <span class="comment">** To work around the problem, SQLite has to manage file locks internally</span>
<a name="l00220"></a>00220 <span class="comment">** on its own.  Whenever a new database is opened, we have to find the</span>
<a name="l00221"></a>00221 <span class="comment">** specific inode of the database file (the inode is determined by the</span>
<a name="l00222"></a>00222 <span class="comment">** st_dev and st_ino fields of the stat structure that fstat() fills in)</span>
<a name="l00223"></a>00223 <span class="comment">** and check for locks already existing on that inode.  When locks are</span>
<a name="l00224"></a>00224 <span class="comment">** created or removed, we have to look at our own internal record of the</span>
<a name="l00225"></a>00225 <span class="comment">** locks to see if another thread has previously set a lock on that same</span>
<a name="l00226"></a>00226 <span class="comment">** inode.</span>
<a name="l00227"></a>00227 <span class="comment">**</span>
<a name="l00228"></a>00228 <span class="comment">** The sqlite3_file structure for POSIX is no longer just an integer file</span>
<a name="l00229"></a>00229 <span class="comment">** descriptor.  It is now a structure that holds the integer file</span>
<a name="l00230"></a>00230 <span class="comment">** descriptor and a pointer to a structure that describes the internal</span>
<a name="l00231"></a>00231 <span class="comment">** locks on the corresponding inode.  There is one locking structure</span>
<a name="l00232"></a>00232 <span class="comment">** per inode, so if the same inode is opened twice, both unixFile structures</span>
<a name="l00233"></a>00233 <span class="comment">** point to the same locking structure.  The locking structure keeps</span>
<a name="l00234"></a>00234 <span class="comment">** a reference count (so we will know when to delete it) and a &quot;cnt&quot;</span>
<a name="l00235"></a>00235 <span class="comment">** field that tells us its internal lock status.  cnt==0 means the</span>
<a name="l00236"></a>00236 <span class="comment">** file is unlocked.  cnt==-1 means the file has an exclusive lock.</span>
<a name="l00237"></a>00237 <span class="comment">** cnt&gt;0 means there are cnt shared locks on the file.</span>
<a name="l00238"></a>00238 <span class="comment">**</span>
<a name="l00239"></a>00239 <span class="comment">** Any attempt to lock or unlock a file first checks the locking</span>
<a name="l00240"></a>00240 <span class="comment">** structure.  The fcntl() system call is only invoked to set a </span>
<a name="l00241"></a>00241 <span class="comment">** POSIX lock if the internal lock structure transitions between</span>
<a name="l00242"></a>00242 <span class="comment">** a locked and an unlocked state.</span>
<a name="l00243"></a>00243 <span class="comment">**</span>
<a name="l00244"></a>00244 <span class="comment">** 2004-Jan-11:</span>
<a name="l00245"></a>00245 <span class="comment">** More recent discoveries about POSIX advisory locks.  (The more</span>
<a name="l00246"></a>00246 <span class="comment">** I discover, the more I realize the a POSIX advisory locks are</span>
<a name="l00247"></a>00247 <span class="comment">** an abomination.)</span>
<a name="l00248"></a>00248 <span class="comment">**</span>
<a name="l00249"></a>00249 <span class="comment">** If you close a file descriptor that points to a file that has locks,</span>
<a name="l00250"></a>00250 <span class="comment">** all locks on that file that are owned by the current process are</span>
<a name="l00251"></a>00251 <span class="comment">** released.  To work around this problem, each unixFile structure contains</span>
<a name="l00252"></a>00252 <span class="comment">** a pointer to an openCnt structure.  There is one openCnt structure</span>
<a name="l00253"></a>00253 <span class="comment">** per open inode, which means that multiple unixFile can point to a single</span>
<a name="l00254"></a>00254 <span class="comment">** openCnt.  When an attempt is made to close an unixFile, if there are</span>
<a name="l00255"></a>00255 <span class="comment">** other unixFile open on the same inode that are holding locks, the call</span>
<a name="l00256"></a>00256 <span class="comment">** to close() the file descriptor is deferred until all of the locks clear.</span>
<a name="l00257"></a>00257 <span class="comment">** The openCnt structure keeps a list of file descriptors that need to</span>
<a name="l00258"></a>00258 <span class="comment">** be closed and that list is walked (and cleared) when the last lock</span>
<a name="l00259"></a>00259 <span class="comment">** clears.</span>
<a name="l00260"></a>00260 <span class="comment">**</span>
<a name="l00261"></a>00261 <span class="comment">** First, under Linux threads, because each thread has a separate</span>
<a name="l00262"></a>00262 <span class="comment">** process ID, lock operations in one thread do not override locks</span>
<a name="l00263"></a>00263 <span class="comment">** to the same file in other threads.  Linux threads behave like</span>
<a name="l00264"></a>00264 <span class="comment">** separate processes in this respect.  But, if you close a file</span>
<a name="l00265"></a>00265 <span class="comment">** descriptor in linux threads, all locks are cleared, even locks</span>
<a name="l00266"></a>00266 <span class="comment">** on other threads and even though the other threads have different</span>
<a name="l00267"></a>00267 <span class="comment">** process IDs.  Linux threads is inconsistent in this respect.</span>
<a name="l00268"></a>00268 <span class="comment">** (I&apos;m beginning to think that linux threads is an abomination too.)</span>
<a name="l00269"></a>00269 <span class="comment">** The consequence of this all is that the hash table for the lockInfo</span>
<a name="l00270"></a>00270 <span class="comment">** structure has to include the process id as part of its key because</span>
<a name="l00271"></a>00271 <span class="comment">** locks in different threads are treated as distinct.  But the </span>
<a name="l00272"></a>00272 <span class="comment">** openCnt structure should not include the process id in its</span>
<a name="l00273"></a>00273 <span class="comment">** key because close() clears lock on all threads, not just the current</span>
<a name="l00274"></a>00274 <span class="comment">** thread.  Were it not for this goofiness in linux threads, we could</span>
<a name="l00275"></a>00275 <span class="comment">** combine the lockInfo and openCnt structures into a single structure.</span>
<a name="l00276"></a>00276 <span class="comment">**</span>
<a name="l00277"></a>00277 <span class="comment">** 2004-Jun-28:</span>
<a name="l00278"></a>00278 <span class="comment">** On some versions of linux, threads can override each others locks.</span>
<a name="l00279"></a>00279 <span class="comment">** On others not.  Sometimes you can change the behavior on the same</span>
<a name="l00280"></a>00280 <span class="comment">** system by setting the LD_ASSUME_KERNEL environment variable.  The</span>
<a name="l00281"></a>00281 <span class="comment">** POSIX standard is silent as to which behavior is correct, as far</span>
<a name="l00282"></a>00282 <span class="comment">** as I can tell, so other versions of unix might show the same</span>
<a name="l00283"></a>00283 <span class="comment">** inconsistency.  There is no little doubt in my mind that posix</span>
<a name="l00284"></a>00284 <span class="comment">** advisory locks and linux threads are profoundly broken.</span>
<a name="l00285"></a>00285 <span class="comment">**</span>
<a name="l00286"></a>00286 <span class="comment">** To work around the inconsistencies, we have to test at runtime </span>
<a name="l00287"></a>00287 <span class="comment">** whether or not threads can override each others locks.  This test</span>
<a name="l00288"></a>00288 <span class="comment">** is run once, the first time any lock is attempted.  A static </span>
<a name="l00289"></a>00289 <span class="comment">** variable is set to record the results of this test for future</span>
<a name="l00290"></a>00290 <span class="comment">** use.</span>
<a name="l00291"></a>00291 <span class="comment">*/</span>
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="comment">/*</span>
<a name="l00294"></a>00294 <span class="comment">** An instance of the following structure serves as the key used</span>
<a name="l00295"></a>00295 <span class="comment">** to locate a particular lockInfo structure given its inode.</span>
<a name="l00296"></a>00296 <span class="comment">**</span>
<a name="l00297"></a>00297 <span class="comment">** If threads cannot override each others locks, then we set the</span>
<a name="l00298"></a>00298 <span class="comment">** lockKey.tid field to the thread ID.  If threads can override</span>
<a name="l00299"></a>00299 <span class="comment">** each others locks then tid is always set to zero.  tid is omitted</span>
<a name="l00300"></a>00300 <span class="comment">** if we compile without threading support.</span>
<a name="l00301"></a>00301 <span class="comment">*/</span>
<a name="l00302"></a><a class="code" href="structlockKey.html">00302</a> <span class="keyword">struct </span><a class="code" href="structlockKey.html">lockKey</a> {
<a name="l00303"></a><a class="code" href="structlockKey.html#ac50fbf97f8f9b870a7ef442ee4727d7c">00303</a>   dev_t <a class="code" href="structlockKey.html#ac50fbf97f8f9b870a7ef442ee4727d7c">dev</a>;       <span class="comment">/* Device number */</span>
<a name="l00304"></a><a class="code" href="structlockKey.html#aa242b1238c98b333328ddf09e822eb2e">00304</a>   ino_t <a class="code" href="structlockKey.html#aa242b1238c98b333328ddf09e822eb2e">ino</a>;       <span class="comment">/* Inode number */</span>
<a name="l00305"></a>00305 <span class="preprocessor">#if SQLITE_THREADSAFE</span>
<a name="l00306"></a>00306 <span class="preprocessor"></span>  pthread_t tid;   <span class="comment">/* Thread ID or zero if threads can override each other */</span>
<a name="l00307"></a>00307 <span class="preprocessor">#endif</span>
<a name="l00308"></a>00308 <span class="preprocessor"></span>};
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="comment">/*</span>
<a name="l00311"></a>00311 <span class="comment">** An instance of the following structure is allocated for each open</span>
<a name="l00312"></a>00312 <span class="comment">** inode on each thread with a different process ID.  (Threads have</span>
<a name="l00313"></a>00313 <span class="comment">** different process IDs on linux, but not on most other unixes.)</span>
<a name="l00314"></a>00314 <span class="comment">**</span>
<a name="l00315"></a>00315 <span class="comment">** A single inode can have multiple file descriptors, so each unixFile</span>
<a name="l00316"></a>00316 <span class="comment">** structure contains a pointer to an instance of this object and this</span>
<a name="l00317"></a>00317 <span class="comment">** object keeps a count of the number of unixFile pointing to it.</span>
<a name="l00318"></a>00318 <span class="comment">*/</span>
<a name="l00319"></a><a class="code" href="structlockInfo.html">00319</a> <span class="keyword">struct </span><a class="code" href="structlockInfo.html">lockInfo</a> {
<a name="l00320"></a><a class="code" href="structlockInfo.html#a58e753f7a7344e3662f3dcc730edbdfd">00320</a>   <span class="keyword">struct </span><a class="code" href="structlockKey.html">lockKey</a> <a class="code" href="structlockInfo.html#a58e753f7a7344e3662f3dcc730edbdfd">key</a>;  <span class="comment">/* The lookup key */</span>
<a name="l00321"></a><a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">00321</a>   <span class="keywordtype">int</span> <a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>;             <span class="comment">/* Number of SHARED locks held */</span>
<a name="l00322"></a><a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">00322</a>   <span class="keywordtype">int</span> <a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>;        <span class="comment">/* One of SHARED_LOCK, RESERVED_LOCK etc. */</span>
<a name="l00323"></a><a class="code" href="structlockInfo.html#ae78394746f20d53ac34ff0f34585f975">00323</a>   <span class="keywordtype">int</span> <a class="code" href="structlockInfo.html#ae78394746f20d53ac34ff0f34585f975">nRef</a>;            <span class="comment">/* Number of pointers to this structure */</span>
<a name="l00324"></a><a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">00324</a>   <span class="keyword">struct </span><a class="code" href="structlockInfo.html">lockInfo</a> *<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a>, *<a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">pPrev</a>;   <span class="comment">/* List of all lockInfo objects */</span>
<a name="l00325"></a>00325 };
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="comment">/*</span>
<a name="l00328"></a>00328 <span class="comment">** An instance of the following structure serves as the key used</span>
<a name="l00329"></a>00329 <span class="comment">** to locate a particular openCnt structure given its inode.  This</span>
<a name="l00330"></a>00330 <span class="comment">** is the same as the lockKey except that the thread ID is omitted.</span>
<a name="l00331"></a>00331 <span class="comment">*/</span>
<a name="l00332"></a><a class="code" href="structopenKey.html">00332</a> <span class="keyword">struct </span><a class="code" href="structopenKey.html">openKey</a> {
<a name="l00333"></a><a class="code" href="structopenKey.html#ad5728be24ffe79a23b3b10ae4c8f52a4">00333</a>   dev_t <a class="code" href="structopenKey.html#ad5728be24ffe79a23b3b10ae4c8f52a4">dev</a>;   <span class="comment">/* Device number */</span>
<a name="l00334"></a><a class="code" href="structopenKey.html#a4984148887d5b5a63a3f760e0bf22b31">00334</a>   ino_t <a class="code" href="structopenKey.html#a4984148887d5b5a63a3f760e0bf22b31">ino</a>;   <span class="comment">/* Inode number */</span>
<a name="l00335"></a>00335 };
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="comment">/*</span>
<a name="l00338"></a>00338 <span class="comment">** An instance of the following structure is allocated for each open</span>
<a name="l00339"></a>00339 <span class="comment">** inode.  This structure keeps track of the number of locks on that</span>
<a name="l00340"></a>00340 <span class="comment">** inode.  If a close is attempted against an inode that is holding</span>
<a name="l00341"></a>00341 <span class="comment">** locks, the close is deferred until all locks clear by adding the</span>
<a name="l00342"></a>00342 <span class="comment">** file descriptor to be closed to the pending list.</span>
<a name="l00343"></a>00343 <span class="comment">*/</span>
<a name="l00344"></a><a class="code" href="structopenCnt.html">00344</a> <span class="keyword">struct </span><a class="code" href="structopenCnt.html">openCnt</a> {
<a name="l00345"></a><a class="code" href="structopenCnt.html#a5cea50d22b6c0293fa4c4f0ffaf696b0">00345</a>   <span class="keyword">struct </span><a class="code" href="structopenKey.html">openKey</a> <a class="code" href="structopenCnt.html#a5cea50d22b6c0293fa4c4f0ffaf696b0">key</a>;   <span class="comment">/* The lookup key */</span>
<a name="l00346"></a><a class="code" href="structopenCnt.html#a819a7fe3ca93f8c9a10ae4410c5e29df">00346</a>   <span class="keywordtype">int</span> <a class="code" href="structopenCnt.html#a819a7fe3ca93f8c9a10ae4410c5e29df">nRef</a>;             <span class="comment">/* Number of pointers to this structure */</span>
<a name="l00347"></a><a class="code" href="structopenCnt.html#a5e983b497cde9da853ac084f37671672">00347</a>   <span class="keywordtype">int</span> <a class="code" href="structopenCnt.html#a5e983b497cde9da853ac084f37671672">nLock</a>;            <span class="comment">/* Number of outstanding locks */</span>
<a name="l00348"></a><a class="code" href="structopenCnt.html#ade6bde37c50b252302236be3417bfd1a">00348</a>   <span class="keywordtype">int</span> <a class="code" href="structopenCnt.html#ade6bde37c50b252302236be3417bfd1a">nPending</a>;         <span class="comment">/* Number of pending close() operations */</span>
<a name="l00349"></a><a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">00349</a>   <span class="keywordtype">int</span> *<a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">aPending</a>;        <span class="comment">/* Malloced space holding fd&apos;s awaiting a close() */</span>
<a name="l00350"></a><a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">00350</a>   <span class="keyword">struct </span><a class="code" href="structopenCnt.html">openCnt</a> *<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a>, *<a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">pPrev</a>;   <span class="comment">/* List of all openCnt objects */</span>
<a name="l00351"></a>00351 };
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="comment">/*</span>
<a name="l00354"></a>00354 <span class="comment">** List of all lockInfo and openCnt objects.  This used to be a hash</span>
<a name="l00355"></a>00355 <span class="comment">** table.  But the number of objects is rarely more than a dozen and</span>
<a name="l00356"></a>00356 <span class="comment">** never exceeds a few thousand.  And lookup is not on a critical</span>
<a name="l00357"></a>00357 <span class="comment">** path oo a simple linked list will suffice.</span>
<a name="l00358"></a>00358 <span class="comment">*/</span>
<a name="l00359"></a><a class="code" href="os__unix_8c.html#a9cad6aca8cfc868a4d64c77619323e70">00359</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlockInfo.html">lockInfo</a> *<a class="code" href="os__unix_8c.html#a9cad6aca8cfc868a4d64c77619323e70">lockList</a> = 0;
<a name="l00360"></a><a class="code" href="os__unix_8c.html#a6f59cf9a1fee243648555e30a87f6308">00360</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structopenCnt.html">openCnt</a> *<a class="code" href="os__unix_8c.html#a6f59cf9a1fee243648555e30a87f6308">openList</a> = 0;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="comment">/*</span>
<a name="l00363"></a>00363 <span class="comment">** The locking styles are associated with the different file locking</span>
<a name="l00364"></a>00364 <span class="comment">** capabilities supported by different file systems.  </span>
<a name="l00365"></a>00365 <span class="comment">**</span>
<a name="l00366"></a>00366 <span class="comment">** POSIX locking style fully supports shared and exclusive byte-range locks </span>
<a name="l00367"></a>00367 <span class="comment">** AFP locking only supports exclusive byte-range locks</span>
<a name="l00368"></a>00368 <span class="comment">** FLOCK only supports a single file-global exclusive lock</span>
<a name="l00369"></a>00369 <span class="comment">** DOTLOCK isn&apos;t a true locking style, it refers to the use of a special</span>
<a name="l00370"></a>00370 <span class="comment">**   file named the same as the database file with a &apos;.lock&apos; extension, this</span>
<a name="l00371"></a>00371 <span class="comment">**   can be used on file systems that do not offer any reliable file locking</span>
<a name="l00372"></a>00372 <span class="comment">** NO locking means that no locking will be attempted, this is only used for</span>
<a name="l00373"></a>00373 <span class="comment">**   read-only file systems currently</span>
<a name="l00374"></a>00374 <span class="comment">** UNSUPPORTED means that no locking will be attempted, this is only used for</span>
<a name="l00375"></a>00375 <span class="comment">**   file systems that are known to be unsupported</span>
<a name="l00376"></a>00376 <span class="comment">*/</span>
<a name="l00377"></a><a class="code" href="os__unix_8c.html#ab9b6ea85c2889dcd69eff1e8bd68356c">00377</a> <span class="preprocessor">#define LOCKING_STYLE_POSIX        1</span>
<a name="l00378"></a><a class="code" href="os__unix_8c.html#aabd10577b2d58c00dc8bf1541bab46e7">00378</a> <span class="preprocessor"></span><span class="preprocessor">#define LOCKING_STYLE_NONE         2</span>
<a name="l00379"></a><a class="code" href="os__unix_8c.html#afec800c31b854518e9548d55921e6eee">00379</a> <span class="preprocessor"></span><span class="preprocessor">#define LOCKING_STYLE_DOTFILE      3</span>
<a name="l00380"></a><a class="code" href="os__unix_8c.html#a6bc7290dc781332aa31f3d8daae9772f">00380</a> <span class="preprocessor"></span><span class="preprocessor">#define LOCKING_STYLE_FLOCK        4</span>
<a name="l00381"></a><a class="code" href="os__unix_8c.html#aa540763b2d32dabe7148496c6f42997c">00381</a> <span class="preprocessor"></span><span class="preprocessor">#define LOCKING_STYLE_AFP          5</span>
<a name="l00382"></a>00382 <span class="preprocessor"></span>
<a name="l00383"></a>00383 <span class="comment">/*</span>
<a name="l00384"></a>00384 <span class="comment">** Only set the lastErrno if the error code is a real error and not </span>
<a name="l00385"></a>00385 <span class="comment">** a normal expected return code of SQLITE_BUSY or SQLITE_OK</span>
<a name="l00386"></a>00386 <span class="comment">*/</span>
<a name="l00387"></a><a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">00387</a> <span class="preprocessor">#define IS_LOCK_ERROR(x)  ((x != SQLITE_OK) &amp;&amp; (x != SQLITE_BUSY))</span>
<a name="l00388"></a>00388 <span class="preprocessor"></span>
<a name="l00389"></a>00389 <span class="comment">/*</span>
<a name="l00390"></a>00390 <span class="comment">** Helper functions to obtain and relinquish the global mutex.</span>
<a name="l00391"></a>00391 <span class="comment">*/</span>
<a name="l00392"></a><a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">00392</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">enterMutex</a>(<span class="keywordtype">void</span>){
<a name="l00393"></a>00393   <a class="code" href="mutex_8h.html#afbab5dc0108b65678f2fa579473041ac">sqlite3_mutex_enter</a>(<a class="code" href="mutex_8h.html#a35e6a158f17df4b319462d26685c345f">sqlite3MutexAlloc</a>(<a class="code" href="sqlite3_8h.html#a182cdcec7ab77f67221af68bcd805cc6">SQLITE_MUTEX_STATIC_MASTER</a>));
<a name="l00394"></a>00394 }
<a name="l00395"></a><a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">00395</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>(<span class="keywordtype">void</span>){
<a name="l00396"></a>00396   <a class="code" href="mutex_8h.html#aba06556afc1a17868af4675ba856701c">sqlite3_mutex_leave</a>(<a class="code" href="mutex_8h.html#a35e6a158f17df4b319462d26685c345f">sqlite3MutexAlloc</a>(<a class="code" href="sqlite3_8h.html#a182cdcec7ab77f67221af68bcd805cc6">SQLITE_MUTEX_STATIC_MASTER</a>));
<a name="l00397"></a>00397 }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="preprocessor">#if SQLITE_THREADSAFE</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00401"></a>00401 <span class="comment">** This variable records whether or not threads can override each others</span>
<a name="l00402"></a>00402 <span class="comment">** locks.</span>
<a name="l00403"></a>00403 <span class="comment">**</span>
<a name="l00404"></a>00404 <span class="comment">**    0:  No.  Threads cannot override each others locks.</span>
<a name="l00405"></a>00405 <span class="comment">**    1:  Yes.  Threads can override each others locks.</span>
<a name="l00406"></a>00406 <span class="comment">**   -1:  We don&apos;t know yet.</span>
<a name="l00407"></a>00407 <span class="comment">**</span>
<a name="l00408"></a>00408 <span class="comment">** On some systems, we know at compile-time if threads can override each</span>
<a name="l00409"></a>00409 <span class="comment">** others locks.  On those systems, the SQLITE_THREAD_OVERRIDE_LOCK macro</span>
<a name="l00410"></a>00410 <span class="comment">** will be set appropriately.  On other systems, we have to check at</span>
<a name="l00411"></a>00411 <span class="comment">** runtime.  On these latter systems, SQLTIE_THREAD_OVERRIDE_LOCK is</span>
<a name="l00412"></a>00412 <span class="comment">** undefined.</span>
<a name="l00413"></a>00413 <span class="comment">**</span>
<a name="l00414"></a>00414 <span class="comment">** This variable normally has file scope only.  But during testing, we make</span>
<a name="l00415"></a>00415 <span class="comment">** it a global so that the test code can change its value in order to verify</span>
<a name="l00416"></a>00416 <span class="comment">** that the right stuff happens in either case.</span>
<a name="l00417"></a>00417 <span class="comment">*/</span>
<a name="l00418"></a>00418 <span class="preprocessor">#ifndef SQLITE_THREAD_OVERRIDE_LOCK</span>
<a name="l00419"></a>00419 <span class="preprocessor"></span><span class="preprocessor"># define SQLITE_THREAD_OVERRIDE_LOCK -1</span>
<a name="l00420"></a>00420 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span><span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00422"></a>00422 <span class="preprocessor"></span><span class="keywordtype">int</span> threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK;
<a name="l00423"></a>00423 <span class="preprocessor">#else</span>
<a name="l00424"></a>00424 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK;
<a name="l00425"></a>00425 <span class="preprocessor">#endif</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>
<a name="l00427"></a>00427 <span class="comment">/*</span>
<a name="l00428"></a>00428 <span class="comment">** This structure holds information passed into individual test</span>
<a name="l00429"></a>00429 <span class="comment">** threads by the testThreadLockingBehavior() routine.</span>
<a name="l00430"></a>00430 <span class="comment">*/</span>
<a name="l00431"></a>00431 <span class="keyword">struct </span>threadTestData {
<a name="l00432"></a>00432   <span class="keywordtype">int</span> fd;                <span class="comment">/* File to be locked */</span>
<a name="l00433"></a>00433   <span class="keyword">struct </span>flock lock;     <span class="comment">/* The locking operation */</span>
<a name="l00434"></a>00434   <span class="keywordtype">int</span> result;            <span class="comment">/* Result of the locking operation */</span>
<a name="l00435"></a>00435 };
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="preprocessor">#ifdef SQLITE_LOCK_TRACE</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00439"></a>00439 <span class="comment">** Print out information about all locking operations.</span>
<a name="l00440"></a>00440 <span class="comment">**</span>
<a name="l00441"></a>00441 <span class="comment">** This routine is used for troubleshooting locks on multithreaded</span>
<a name="l00442"></a>00442 <span class="comment">** platforms.  Enable by compiling with the -DSQLITE_LOCK_TRACE</span>
<a name="l00443"></a>00443 <span class="comment">** command-line option on the compiler.  This code is normally</span>
<a name="l00444"></a>00444 <span class="comment">** turned off.</span>
<a name="l00445"></a>00445 <span class="comment">*/</span>
<a name="l00446"></a>00446 <span class="keyword">static</span> <span class="keywordtype">int</span> lockTrace(<span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> op, <span class="keyword">struct</span> flock *p){
<a name="l00447"></a>00447   <span class="keywordtype">char</span> *zOpName, *zType;
<a name="l00448"></a>00448   <span class="keywordtype">int</span> s;
<a name="l00449"></a>00449   <span class="keywordtype">int</span> savedErrno;
<a name="l00450"></a>00450   <span class="keywordflow">if</span>( op==F_GETLK ){
<a name="l00451"></a>00451     zOpName = <span class="stringliteral">&quot;GETLK&quot;</span>;
<a name="l00452"></a>00452   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( op==F_SETLK ){
<a name="l00453"></a>00453     zOpName = <span class="stringliteral">&quot;SETLK&quot;</span>;
<a name="l00454"></a>00454   }<span class="keywordflow">else</span>{
<a name="l00455"></a>00455     s = fcntl(fd, op, p);
<a name="l00456"></a>00456     sqlite3DebugPrintf(<span class="stringliteral">&quot;fcntl unknown %d %d %d\n&quot;</span>, fd, op, s);
<a name="l00457"></a>00457     <span class="keywordflow">return</span> s;
<a name="l00458"></a>00458   }
<a name="l00459"></a>00459   <span class="keywordflow">if</span>( p-&gt;l_type==F_RDLCK ){
<a name="l00460"></a>00460     zType = <span class="stringliteral">&quot;RDLCK&quot;</span>;
<a name="l00461"></a>00461   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;l_type==F_WRLCK ){
<a name="l00462"></a>00462     zType = <span class="stringliteral">&quot;WRLCK&quot;</span>;
<a name="l00463"></a>00463   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;l_type==F_UNLCK ){
<a name="l00464"></a>00464     zType = <span class="stringliteral">&quot;UNLCK&quot;</span>;
<a name="l00465"></a>00465   }<span class="keywordflow">else</span>{
<a name="l00466"></a>00466     assert( 0 );
<a name="l00467"></a>00467   }
<a name="l00468"></a>00468   assert( p-&gt;l_whence==SEEK_SET );
<a name="l00469"></a>00469   s = fcntl(fd, op, p);
<a name="l00470"></a>00470   savedErrno = errno;
<a name="l00471"></a>00471   sqlite3DebugPrintf(<span class="stringliteral">&quot;fcntl %d %d %s %s %d %d %d %d\n&quot;</span>,
<a name="l00472"></a>00472      <a class="code" href="os__unix_8c.html#afa8ef032e5cdbbbc7df8cc41bdfc865f">threadid</a>, fd, zOpName, zType, (<span class="keywordtype">int</span>)p-&gt;l_start, (<span class="keywordtype">int</span>)p-&gt;l_len,
<a name="l00473"></a>00473      (<span class="keywordtype">int</span>)p-&gt;l_pid, s);
<a name="l00474"></a>00474   <span class="keywordflow">if</span>( s==(-1) &amp;&amp; op==F_SETLK &amp;&amp; (p-&gt;l_type==F_RDLCK || p-&gt;l_type==F_WRLCK) ){
<a name="l00475"></a>00475     <span class="keyword">struct </span>flock l2;
<a name="l00476"></a>00476     l2 = *p;
<a name="l00477"></a>00477     fcntl(fd, F_GETLK, &amp;l2);
<a name="l00478"></a>00478     <span class="keywordflow">if</span>( l2.l_type==F_RDLCK ){
<a name="l00479"></a>00479       zType = <span class="stringliteral">&quot;RDLCK&quot;</span>;
<a name="l00480"></a>00480     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( l2.l_type==F_WRLCK ){
<a name="l00481"></a>00481       zType = <span class="stringliteral">&quot;WRLCK&quot;</span>;
<a name="l00482"></a>00482     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( l2.l_type==F_UNLCK ){
<a name="l00483"></a>00483       zType = <span class="stringliteral">&quot;UNLCK&quot;</span>;
<a name="l00484"></a>00484     }<span class="keywordflow">else</span>{
<a name="l00485"></a>00485       assert( 0 );
<a name="l00486"></a>00486     }
<a name="l00487"></a>00487     sqlite3DebugPrintf(<span class="stringliteral">&quot;fcntl-failure-reason: %s %d %d %d\n&quot;</span>,
<a name="l00488"></a>00488        zType, (<span class="keywordtype">int</span>)l2.l_start, (<span class="keywordtype">int</span>)l2.l_len, (<span class="keywordtype">int</span>)l2.l_pid);
<a name="l00489"></a>00489   }
<a name="l00490"></a>00490   errno = savedErrno;
<a name="l00491"></a>00491   <span class="keywordflow">return</span> s;
<a name="l00492"></a>00492 }
<a name="l00493"></a>00493 <span class="preprocessor">#define fcntl lockTrace</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* SQLITE_LOCK_TRACE */</span>
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 <span class="preprocessor">#ifdef __linux__</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00498"></a>00498 <span class="comment">** This function is used as the main routine for a thread launched by</span>
<a name="l00499"></a>00499 <span class="comment">** testThreadLockingBehavior(). It tests whether the shared-lock obtained</span>
<a name="l00500"></a>00500 <span class="comment">** by the main thread in testThreadLockingBehavior() conflicts with a</span>
<a name="l00501"></a>00501 <span class="comment">** hypothetical write-lock obtained by this thread on the same file.</span>
<a name="l00502"></a>00502 <span class="comment">**</span>
<a name="l00503"></a>00503 <span class="comment">** The write-lock is not actually acquired, as this is not possible if </span>
<a name="l00504"></a>00504 <span class="comment">** the file is open in read-only mode (see ticket #3472).</span>
<a name="l00505"></a>00505 <span class="comment">*/</span> 
<a name="l00506"></a>00506 <span class="keyword">static</span> <span class="keywordtype">void</span> *threadLockingTest(<span class="keywordtype">void</span> *pArg){
<a name="l00507"></a>00507   <span class="keyword">struct </span>threadTestData *pData = (<span class="keyword">struct </span>threadTestData*)pArg;
<a name="l00508"></a>00508   pData-&gt;result = fcntl(pData-&gt;fd, F_GETLK, &amp;pData-&gt;lock);
<a name="l00509"></a>00509   <span class="keywordflow">return</span> pArg;
<a name="l00510"></a>00510 }
<a name="l00511"></a>00511 
<a name="l00512"></a>00512 <span class="comment">/*</span>
<a name="l00513"></a>00513 <span class="comment">** This procedure attempts to determine whether or not threads</span>
<a name="l00514"></a>00514 <span class="comment">** can override each others locks then sets the </span>
<a name="l00515"></a>00515 <span class="comment">** threadsOverrideEachOthersLocks variable appropriately.</span>
<a name="l00516"></a>00516 <span class="comment">*/</span>
<a name="l00517"></a>00517 <span class="keyword">static</span> <span class="keywordtype">void</span> testThreadLockingBehavior(<span class="keywordtype">int</span> fd_orig){
<a name="l00518"></a>00518   <span class="keywordtype">int</span> fd;
<a name="l00519"></a>00519   <span class="keywordtype">int</span> rc;
<a name="l00520"></a>00520   <span class="keyword">struct </span>threadTestData <a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>;
<a name="l00521"></a>00521   <span class="keyword">struct </span>flock l;
<a name="l00522"></a>00522   pthread_t t;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524   fd = dup(fd_orig);
<a name="l00525"></a>00525   <span class="keywordflow">if</span>( fd&lt;0 ) <span class="keywordflow">return</span>;
<a name="l00526"></a>00526   memset(&amp;l, 0, <span class="keyword">sizeof</span>(l));
<a name="l00527"></a>00527   l.l_type = F_RDLCK;
<a name="l00528"></a>00528   l.l_len = 1;
<a name="l00529"></a>00529   l.l_start = 0;
<a name="l00530"></a>00530   l.l_whence = SEEK_SET;
<a name="l00531"></a>00531   rc = fcntl(fd_orig, F_SETLK, &amp;l);
<a name="l00532"></a>00532   <span class="keywordflow">if</span>( rc!=0 ) <span class="keywordflow">return</span>;
<a name="l00533"></a>00533   memset(&amp;<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>));
<a name="l00534"></a>00534   <a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>.fd = fd;
<a name="l00535"></a>00535   <a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>.lock = l;
<a name="l00536"></a>00536   <a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>.lock.l_type = F_WRLCK;
<a name="l00537"></a>00537   pthread_create(&amp;t, 0, threadLockingTest, &amp;<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>);
<a name="l00538"></a>00538   pthread_join(t, 0);
<a name="l00539"></a>00539   close(fd);
<a name="l00540"></a>00540   <span class="keywordflow">if</span>( <a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>.result!=0 ) <span class="keywordflow">return</span>;
<a name="l00541"></a>00541   threadsOverrideEachOthersLocks = (<a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>.lock.l_type==F_UNLCK);
<a name="l00542"></a>00542 }
<a name="l00543"></a>00543 <span class="preprocessor">#else</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00545"></a>00545 <span class="comment">** On anything other than linux, assume threads override each others locks.</span>
<a name="l00546"></a>00546 <span class="comment">*/</span>
<a name="l00547"></a>00547 <span class="keyword">static</span> <span class="keywordtype">void</span> testThreadLockingBehavior(<span class="keywordtype">int</span> fd_orig){
<a name="l00548"></a>00548   threadsOverrideEachOthersLocks = 1;
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 <span class="preprocessor">#endif </span><span class="comment">/* __linux__ */</span>
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_THREADSAFE */</span>
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="comment">/*</span>
<a name="l00555"></a>00555 <span class="comment">** Release a lockInfo structure previously allocated by findLockInfo().</span>
<a name="l00556"></a>00556 <span class="comment">*/</span>
<a name="l00557"></a><a class="code" href="os__unix_8c.html#acfe59f061bfafcd4816ff5710188dabd">00557</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="os__unix_8c.html#acfe59f061bfafcd4816ff5710188dabd">releaseLockInfo</a>(<span class="keyword">struct</span> <a class="code" href="structlockInfo.html">lockInfo</a> *pLock){
<a name="l00558"></a>00558   <span class="keywordflow">if</span>( pLock ){
<a name="l00559"></a>00559     pLock-&gt;<a class="code" href="structlockInfo.html#ae78394746f20d53ac34ff0f34585f975">nRef</a>--;
<a name="l00560"></a>00560     <span class="keywordflow">if</span>( pLock-&gt;<a class="code" href="structlockInfo.html#ae78394746f20d53ac34ff0f34585f975">nRef</a>==0 ){
<a name="l00561"></a>00561       <span class="keywordflow">if</span>( pLock-&gt;<a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">pPrev</a> ){
<a name="l00562"></a>00562         assert( pLock-&gt;<a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">pPrev</a>-&gt;<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a>==pLock );
<a name="l00563"></a>00563         pLock-&gt;<a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">pPrev</a>-&gt;<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a> = pLock-&gt;<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a>;
<a name="l00564"></a>00564       }<span class="keywordflow">else</span>{
<a name="l00565"></a>00565         assert( lockList==pLock );
<a name="l00566"></a>00566         lockList = pLock-&gt;<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a>;
<a name="l00567"></a>00567       }
<a name="l00568"></a>00568       <span class="keywordflow">if</span>( pLock-&gt;<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a> ){
<a name="l00569"></a>00569         assert( pLock-&gt;<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a>-&gt;<a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">pPrev</a>==pLock );
<a name="l00570"></a>00570         pLock-&gt;<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a>-&gt;<a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">pPrev</a> = pLock-&gt;<a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">pPrev</a>;
<a name="l00571"></a>00571       }
<a name="l00572"></a>00572       <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pLock);
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574   }
<a name="l00575"></a>00575 }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 <span class="comment">/*</span>
<a name="l00578"></a>00578 <span class="comment">** Release a openCnt structure previously allocated by findLockInfo().</span>
<a name="l00579"></a>00579 <span class="comment">*/</span>
<a name="l00580"></a><a class="code" href="os__unix_8c.html#a7ec308b95f37ed455660ac843ff7c7a6">00580</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="os__unix_8c.html#a7ec308b95f37ed455660ac843ff7c7a6">releaseOpenCnt</a>(<span class="keyword">struct</span> <a class="code" href="structopenCnt.html">openCnt</a> *pOpen){
<a name="l00581"></a>00581   <span class="keywordflow">if</span>( pOpen ){
<a name="l00582"></a>00582     pOpen-&gt;<a class="code" href="structopenCnt.html#a819a7fe3ca93f8c9a10ae4410c5e29df">nRef</a>--;
<a name="l00583"></a>00583     <span class="keywordflow">if</span>( pOpen-&gt;<a class="code" href="structopenCnt.html#a819a7fe3ca93f8c9a10ae4410c5e29df">nRef</a>==0 ){
<a name="l00584"></a>00584       <span class="keywordflow">if</span>( pOpen-&gt;<a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">pPrev</a> ){
<a name="l00585"></a>00585         assert( pOpen-&gt;<a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">pPrev</a>-&gt;<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a>==pOpen );
<a name="l00586"></a>00586         pOpen-&gt;<a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">pPrev</a>-&gt;<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a> = pOpen-&gt;<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a>;
<a name="l00587"></a>00587       }<span class="keywordflow">else</span>{
<a name="l00588"></a>00588         assert( openList==pOpen );
<a name="l00589"></a>00589         openList = pOpen-&gt;<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a>;
<a name="l00590"></a>00590       }
<a name="l00591"></a>00591       <span class="keywordflow">if</span>( pOpen-&gt;<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a> ){
<a name="l00592"></a>00592         assert( pOpen-&gt;<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a>-&gt;<a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">pPrev</a>==pOpen );
<a name="l00593"></a>00593         pOpen-&gt;<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a>-&gt;<a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">pPrev</a> = pOpen-&gt;<a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">pPrev</a>;
<a name="l00594"></a>00594       }
<a name="l00595"></a>00595       <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pOpen-&gt;<a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">aPending</a>);
<a name="l00596"></a>00596       <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pOpen);
<a name="l00597"></a>00597     }
<a name="l00598"></a>00598   }
<a name="l00599"></a>00599 }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="preprocessor">#if SQLITE_ENABLE_LOCKING_STYLE</span>
<a name="l00602"></a>00602 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00603"></a>00603 <span class="comment">** Tests a byte-range locking query to see if byte range locks are </span>
<a name="l00604"></a>00604 <span class="comment">** supported, if not we fall back to dotlockLockingStyle.</span>
<a name="l00605"></a>00605 <span class="comment">*/</span>
<a name="l00606"></a>00606 <span class="keyword">static</span> <span class="keywordtype">int</span> testLockingStyle(<span class="keywordtype">int</span> fd){
<a name="l00607"></a>00607   <span class="keyword">struct </span>flock <a class="code" href="structlockInfo.html">lockInfo</a>;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   <span class="comment">/* Test byte-range lock using fcntl(). If the call succeeds, </span>
<a name="l00610"></a>00610 <span class="comment">  ** assume that the file-system supports POSIX style locks. </span>
<a name="l00611"></a>00611 <span class="comment">  */</span>
<a name="l00612"></a>00612   <a class="code" href="structlockInfo.html">lockInfo</a>.l_len = 1;
<a name="l00613"></a>00613   <a class="code" href="structlockInfo.html">lockInfo</a>.l_start = 0;
<a name="l00614"></a>00614   <a class="code" href="structlockInfo.html">lockInfo</a>.l_whence = SEEK_SET;
<a name="l00615"></a>00615   <a class="code" href="structlockInfo.html">lockInfo</a>.l_type = F_RDLCK;
<a name="l00616"></a>00616   <span class="keywordflow">if</span>( fcntl(fd, F_GETLK, &amp;<a class="code" href="structlockInfo.html">lockInfo</a>)!=-1 ) {
<a name="l00617"></a>00617     <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#ab9b6ea85c2889dcd69eff1e8bd68356c">LOCKING_STYLE_POSIX</a>;
<a name="l00618"></a>00618   }
<a name="l00619"></a>00619   
<a name="l00620"></a>00620   <span class="comment">/* Testing for flock() can give false positives.  So if if the above </span>
<a name="l00621"></a>00621 <span class="comment">  ** test fails, then we fall back to using dot-file style locking.</span>
<a name="l00622"></a>00622 <span class="comment">  */</span>  
<a name="l00623"></a>00623   <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#afec800c31b854518e9548d55921e6eee">LOCKING_STYLE_DOTFILE</a>;
<a name="l00624"></a>00624 }
<a name="l00625"></a>00625 <span class="preprocessor">#endif</span>
<a name="l00626"></a>00626 <span class="preprocessor"></span>
<a name="l00627"></a>00627 <span class="comment">/* </span>
<a name="l00628"></a>00628 <span class="comment">** If SQLITE_ENABLE_LOCKING_STYLE is defined, this function Examines the </span>
<a name="l00629"></a>00629 <span class="comment">** f_fstypename entry in the statfs structure as returned by stat() for </span>
<a name="l00630"></a>00630 <span class="comment">** the file system hosting the database file and selects  the appropriate</span>
<a name="l00631"></a>00631 <span class="comment">** locking style based on its value.  These values and assignments are </span>
<a name="l00632"></a>00632 <span class="comment">** based on Darwin/OSX behavior and have not been thoroughly tested on </span>
<a name="l00633"></a>00633 <span class="comment">** other systems.</span>
<a name="l00634"></a>00634 <span class="comment">**</span>
<a name="l00635"></a>00635 <span class="comment">** If SQLITE_ENABLE_LOCKING_STYLE is not defined, this function always</span>
<a name="l00636"></a>00636 <span class="comment">** returns LOCKING_STYLE_POSIX.</span>
<a name="l00637"></a>00637 <span class="comment">*/</span>
<a name="l00638"></a><a class="code" href="os__unix_8c.html#a1e12ff6c4b28a9c1b180d9d5edd1ab2c">00638</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a1e12ff6c4b28a9c1b180d9d5edd1ab2c">detectLockingStyle</a>(
<a name="l00639"></a>00639   <a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs,
<a name="l00640"></a>00640   <span class="keyword">const</span> <span class="keywordtype">char</span> *filePath, 
<a name="l00641"></a>00641   <span class="keywordtype">int</span> fd
<a name="l00642"></a>00642 ){
<a name="l00643"></a>00643 <span class="preprocessor">#if SQLITE_ENABLE_LOCKING_STYLE</span>
<a name="l00644"></a>00644 <span class="preprocessor"></span>  <span class="keyword">struct </span>Mapping {
<a name="l00645"></a>00645     <span class="keyword">const</span> <span class="keywordtype">char</span> *zFilesystem;
<a name="l00646"></a>00646     <span class="keywordtype">int</span> eLockingStyle;
<a name="l00647"></a>00647   } aMap[] = {
<a name="l00648"></a>00648     { <span class="stringliteral">&quot;hfs&quot;</span>,    <a class="code" href="os__unix_8c.html#ab9b6ea85c2889dcd69eff1e8bd68356c">LOCKING_STYLE_POSIX</a> },
<a name="l00649"></a>00649     { <span class="stringliteral">&quot;ufs&quot;</span>,    <a class="code" href="os__unix_8c.html#ab9b6ea85c2889dcd69eff1e8bd68356c">LOCKING_STYLE_POSIX</a> },
<a name="l00650"></a>00650     { <span class="stringliteral">&quot;afpfs&quot;</span>,  <a class="code" href="os__unix_8c.html#aa540763b2d32dabe7148496c6f42997c">LOCKING_STYLE_AFP</a> },
<a name="l00651"></a>00651 <span class="preprocessor">#ifdef SQLITE_ENABLE_AFP_LOCKING_SMB</span>
<a name="l00652"></a>00652 <span class="preprocessor"></span>    { <span class="stringliteral">&quot;smbfs&quot;</span>,  <a class="code" href="os__unix_8c.html#aa540763b2d32dabe7148496c6f42997c">LOCKING_STYLE_AFP</a> },
<a name="l00653"></a>00653 <span class="preprocessor">#else</span>
<a name="l00654"></a>00654 <span class="preprocessor"></span>    { <span class="stringliteral">&quot;smbfs&quot;</span>,  <a class="code" href="os__unix_8c.html#a6bc7290dc781332aa31f3d8daae9772f">LOCKING_STYLE_FLOCK</a> },
<a name="l00655"></a>00655 <span class="preprocessor">#endif</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span>    { <span class="stringliteral">&quot;msdos&quot;</span>,  <a class="code" href="os__unix_8c.html#afec800c31b854518e9548d55921e6eee">LOCKING_STYLE_DOTFILE</a> },
<a name="l00657"></a>00657     { <span class="stringliteral">&quot;webdav&quot;</span>, <a class="code" href="os__unix_8c.html#aabd10577b2d58c00dc8bf1541bab46e7">LOCKING_STYLE_NONE</a> },
<a name="l00658"></a>00658     { 0, 0 }
<a name="l00659"></a>00659   };
<a name="l00660"></a>00660   <span class="keywordtype">int</span> i;
<a name="l00661"></a>00661   <span class="keyword">struct </span>statfs fsInfo;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   <span class="keywordflow">if</span>( !filePath ){
<a name="l00664"></a>00664     <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#aabd10577b2d58c00dc8bf1541bab46e7">LOCKING_STYLE_NONE</a>;
<a name="l00665"></a>00665   }
<a name="l00666"></a>00666   <span class="keywordflow">if</span>( pVfs-&gt;<a class="code" href="structsqlite3__vfs.html#a1ba832cf207fe59c1fc8eb436524bc35">pAppData</a> ){
<a name="l00667"></a>00667     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a1138dada988085d42630ce3b332bf550">SQLITE_PTR_TO_INT</a>(pVfs-&gt;<a class="code" href="structsqlite3__vfs.html#a1ba832cf207fe59c1fc8eb436524bc35">pAppData</a>);
<a name="l00668"></a>00668   }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670   <span class="keywordflow">if</span>( statfs(filePath, &amp;fsInfo) != -1 ){
<a name="l00671"></a>00671     <span class="keywordflow">if</span>( fsInfo.f_flags &amp; MNT_RDONLY ){
<a name="l00672"></a>00672       <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#aabd10577b2d58c00dc8bf1541bab46e7">LOCKING_STYLE_NONE</a>;
<a name="l00673"></a>00673     }
<a name="l00674"></a>00674     <span class="keywordflow">for</span>(i=0; aMap[i].zFilesystem; i++){
<a name="l00675"></a>00675       <span class="keywordflow">if</span>( strcmp(fsInfo.f_fstypename, aMap[i].zFilesystem)==0 ){
<a name="l00676"></a>00676         <span class="keywordflow">return</span> aMap[i].eLockingStyle;
<a name="l00677"></a>00677       }
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679   }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <span class="comment">/* Default case. Handles, amongst others, &quot;nfs&quot;. */</span>
<a name="l00682"></a>00682   <span class="keywordflow">return</span> testLockingStyle(fd);  
<a name="l00683"></a>00683 <span class="preprocessor">#endif</span>
<a name="l00684"></a>00684 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#ab9b6ea85c2889dcd69eff1e8bd68356c">LOCKING_STYLE_POSIX</a>;
<a name="l00685"></a>00685 }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687 <span class="comment">/*</span>
<a name="l00688"></a>00688 <span class="comment">** Given a file descriptor, locate lockInfo and openCnt structures that</span>
<a name="l00689"></a>00689 <span class="comment">** describes that file descriptor.  Create new ones if necessary.  The</span>
<a name="l00690"></a>00690 <span class="comment">** return values might be uninitialized if an error occurs.</span>
<a name="l00691"></a>00691 <span class="comment">**</span>
<a name="l00692"></a>00692 <span class="comment">** Return an appropriate error code.</span>
<a name="l00693"></a>00693 <span class="comment">*/</span>
<a name="l00694"></a><a class="code" href="os__unix_8c.html#a21455ae20850627129c0a343d95a24f8">00694</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a21455ae20850627129c0a343d95a24f8">findLockInfo</a>(
<a name="l00695"></a>00695   <span class="keywordtype">int</span> fd,                      <span class="comment">/* The file descriptor used in the key */</span>
<a name="l00696"></a>00696   <span class="keyword">struct</span> <a class="code" href="structlockInfo.html">lockInfo</a> **ppLock,    <span class="comment">/* Return the lockInfo structure here */</span>
<a name="l00697"></a>00697   <span class="keyword">struct</span> <a class="code" href="structopenCnt.html">openCnt</a> **ppOpen      <span class="comment">/* Return the openCnt structure here */</span>
<a name="l00698"></a>00698 ){
<a name="l00699"></a>00699   <span class="keywordtype">int</span> rc;
<a name="l00700"></a>00700   <span class="keyword">struct </span><a class="code" href="structlockKey.html">lockKey</a> key1;
<a name="l00701"></a>00701   <span class="keyword">struct </span><a class="code" href="structopenKey.html">openKey</a> key2;
<a name="l00702"></a>00702   <span class="keyword">struct </span>stat statbuf;
<a name="l00703"></a>00703   <span class="keyword">struct </span><a class="code" href="structlockInfo.html">lockInfo</a> *pLock;
<a name="l00704"></a>00704   <span class="keyword">struct </span><a class="code" href="structopenCnt.html">openCnt</a> *pOpen;
<a name="l00705"></a>00705   rc = fstat(fd, &amp;statbuf);
<a name="l00706"></a>00706   <span class="keywordflow">if</span>( rc!=0 ){
<a name="l00707"></a>00707 <span class="preprocessor">#ifdef EOVERFLOW</span>
<a name="l00708"></a>00708 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( errno==EOVERFLOW ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a667d508a9af9e6a08e18abfc81c986ee">SQLITE_NOLFS</a>;
<a name="l00709"></a>00709 <span class="preprocessor">#endif</span>
<a name="l00710"></a>00710 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a45a4718698f155ae3b45d37d3b94d9a2">SQLITE_IOERR</a>;
<a name="l00711"></a>00711   }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713   <span class="comment">/* On OS X on an msdos filesystem, the inode number is reported</span>
<a name="l00714"></a>00714 <span class="comment">  ** incorrectly for zero-size files.  See ticket #3260.  To work</span>
<a name="l00715"></a>00715 <span class="comment">  ** around this problem (we consider it a bug in OS X, not SQLite)</span>
<a name="l00716"></a>00716 <span class="comment">  ** we always increase the file size to 1 by writing a single byte</span>
<a name="l00717"></a>00717 <span class="comment">  ** prior to accessing the inode number.  The one byte written is</span>
<a name="l00718"></a>00718 <span class="comment">  ** an ASCII &apos;S&apos; character which also happens to be the first byte</span>
<a name="l00719"></a>00719 <span class="comment">  ** in the header of every SQLite database.  In this way, if there</span>
<a name="l00720"></a>00720 <span class="comment">  ** is a race condition such that another thread has already populated</span>
<a name="l00721"></a>00721 <span class="comment">  ** the first page of the database, no damage is done.</span>
<a name="l00722"></a>00722 <span class="comment">  */</span>
<a name="l00723"></a>00723   <span class="keywordflow">if</span>( statbuf.st_size==0 ){
<a name="l00724"></a>00724     write(fd, <span class="stringliteral">&quot;S&quot;</span>, 1);
<a name="l00725"></a>00725     rc = fstat(fd, &amp;statbuf);
<a name="l00726"></a>00726     <span class="keywordflow">if</span>( rc!=0 ){
<a name="l00727"></a>00727       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a45a4718698f155ae3b45d37d3b94d9a2">SQLITE_IOERR</a>;
<a name="l00728"></a>00728     }
<a name="l00729"></a>00729   }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731   memset(&amp;key1, 0, <span class="keyword">sizeof</span>(key1));
<a name="l00732"></a>00732   key1.<a class="code" href="structlockKey.html#ac50fbf97f8f9b870a7ef442ee4727d7c">dev</a> = statbuf.st_dev;
<a name="l00733"></a>00733   key1.<a class="code" href="structlockKey.html#aa242b1238c98b333328ddf09e822eb2e">ino</a> = statbuf.st_ino;
<a name="l00734"></a>00734 <span class="preprocessor">#if SQLITE_THREADSAFE</span>
<a name="l00735"></a>00735 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( threadsOverrideEachOthersLocks&lt;0 ){
<a name="l00736"></a>00736     testThreadLockingBehavior(fd);
<a name="l00737"></a>00737   }
<a name="l00738"></a>00738   key1.tid = threadsOverrideEachOthersLocks ? 0 : pthread_self();
<a name="l00739"></a>00739 <span class="preprocessor">#endif</span>
<a name="l00740"></a>00740 <span class="preprocessor"></span>  memset(&amp;key2, 0, <span class="keyword">sizeof</span>(key2));
<a name="l00741"></a>00741   key2.<a class="code" href="structopenKey.html#ad5728be24ffe79a23b3b10ae4c8f52a4">dev</a> = statbuf.st_dev;
<a name="l00742"></a>00742   key2.<a class="code" href="structopenKey.html#a4984148887d5b5a63a3f760e0bf22b31">ino</a> = statbuf.st_ino;
<a name="l00743"></a>00743   pLock = lockList;
<a name="l00744"></a>00744   <span class="keywordflow">while</span>( pLock &amp;&amp; memcmp(&amp;key1, &amp;pLock-&gt;<a class="code" href="structlockInfo.html#a58e753f7a7344e3662f3dcc730edbdfd">key</a>, <span class="keyword">sizeof</span>(key1)) ){
<a name="l00745"></a>00745     pLock = pLock-&gt;<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a>;
<a name="l00746"></a>00746   }
<a name="l00747"></a>00747   <span class="keywordflow">if</span>( pLock==0 ){
<a name="l00748"></a>00748     pLock = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>( <span class="keyword">sizeof</span>(*pLock) );
<a name="l00749"></a>00749     <span class="keywordflow">if</span>( pLock==0 ){
<a name="l00750"></a>00750       rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l00751"></a>00751       <span class="keywordflow">goto</span> exit_findlockinfo;
<a name="l00752"></a>00752     }
<a name="l00753"></a>00753     pLock-&gt;<a class="code" href="structlockInfo.html#a58e753f7a7344e3662f3dcc730edbdfd">key</a> = key1;
<a name="l00754"></a>00754     pLock-&gt;<a class="code" href="structlockInfo.html#ae78394746f20d53ac34ff0f34585f975">nRef</a> = 1;
<a name="l00755"></a>00755     pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a> = 0;
<a name="l00756"></a>00756     pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a> = 0;
<a name="l00757"></a>00757     pLock-&gt;<a class="code" href="structlockInfo.html#ad37a84138d8b10a311a2903c28908fbb">pNext</a> = lockList;
<a name="l00758"></a>00758     pLock-&gt;<a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">pPrev</a> = 0;
<a name="l00759"></a>00759     <span class="keywordflow">if</span>( lockList ) lockList-&gt;<a class="code" href="structlockInfo.html#a01e77767b920ca7695bf4291ddee6e51">pPrev</a> = pLock;
<a name="l00760"></a>00760     lockList = pLock;
<a name="l00761"></a>00761   }<span class="keywordflow">else</span>{
<a name="l00762"></a>00762     pLock-&gt;<a class="code" href="structlockInfo.html#ae78394746f20d53ac34ff0f34585f975">nRef</a>++;
<a name="l00763"></a>00763   }
<a name="l00764"></a>00764   *ppLock = pLock;
<a name="l00765"></a>00765   <span class="keywordflow">if</span>( ppOpen!=0 ){
<a name="l00766"></a>00766     pOpen = openList;
<a name="l00767"></a>00767     <span class="keywordflow">while</span>( pOpen &amp;&amp; memcmp(&amp;key2, &amp;pOpen-&gt;<a class="code" href="structopenCnt.html#a5cea50d22b6c0293fa4c4f0ffaf696b0">key</a>, <span class="keyword">sizeof</span>(key2)) ){
<a name="l00768"></a>00768       pOpen = pOpen-&gt;<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a>;
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770     <span class="keywordflow">if</span>( pOpen==0 ){
<a name="l00771"></a>00771       pOpen = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>( <span class="keyword">sizeof</span>(*pOpen) );
<a name="l00772"></a>00772       <span class="keywordflow">if</span>( pOpen==0 ){
<a name="l00773"></a>00773         <a class="code" href="os__unix_8c.html#acfe59f061bfafcd4816ff5710188dabd">releaseLockInfo</a>(pLock);
<a name="l00774"></a>00774         rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l00775"></a>00775         <span class="keywordflow">goto</span> exit_findlockinfo;
<a name="l00776"></a>00776       }
<a name="l00777"></a>00777       pOpen-&gt;<a class="code" href="structopenCnt.html#a5cea50d22b6c0293fa4c4f0ffaf696b0">key</a> = key2;
<a name="l00778"></a>00778       pOpen-&gt;<a class="code" href="structopenCnt.html#a819a7fe3ca93f8c9a10ae4410c5e29df">nRef</a> = 1;
<a name="l00779"></a>00779       pOpen-&gt;<a class="code" href="structopenCnt.html#a5e983b497cde9da853ac084f37671672">nLock</a> = 0;
<a name="l00780"></a>00780       pOpen-&gt;<a class="code" href="structopenCnt.html#ade6bde37c50b252302236be3417bfd1a">nPending</a> = 0;
<a name="l00781"></a>00781       pOpen-&gt;<a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">aPending</a> = 0;
<a name="l00782"></a>00782       pOpen-&gt;<a class="code" href="structopenCnt.html#a9285bf9bf67b79718725dabdb57470d4">pNext</a> = openList;
<a name="l00783"></a>00783       pOpen-&gt;<a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">pPrev</a> = 0;
<a name="l00784"></a>00784       <span class="keywordflow">if</span>( openList ) openList-&gt;<a class="code" href="structopenCnt.html#a24f10eb7b876c0afe932fbf2487bc0f0">pPrev</a> = pOpen;
<a name="l00785"></a>00785       openList = pOpen;
<a name="l00786"></a>00786     }<span class="keywordflow">else</span>{
<a name="l00787"></a>00787       pOpen-&gt;<a class="code" href="structopenCnt.html#a819a7fe3ca93f8c9a10ae4410c5e29df">nRef</a>++;
<a name="l00788"></a>00788     }
<a name="l00789"></a>00789     *ppOpen = pOpen;
<a name="l00790"></a>00790   }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 exit_findlockinfo:
<a name="l00793"></a>00793   <span class="keywordflow">return</span> rc;
<a name="l00794"></a>00794 }
<a name="l00795"></a>00795 
<a name="l00796"></a>00796 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00797"></a>00797 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00798"></a>00798 <span class="comment">** Helper function for printing out trace information from debugging</span>
<a name="l00799"></a>00799 <span class="comment">** binaries. This returns the string represetation of the supplied</span>
<a name="l00800"></a>00800 <span class="comment">** integer lock-type.</span>
<a name="l00801"></a>00801 <span class="comment">*/</span>
<a name="l00802"></a>00802 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *locktypeName(<span class="keywordtype">int</span> locktype){
<a name="l00803"></a>00803   <span class="keywordflow">switch</span>( locktype ){
<a name="l00804"></a>00804   <span class="keywordflow">case</span> <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;NONE&quot;</span>;
<a name="l00805"></a>00805   <span class="keywordflow">case</span> <a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;SHARED&quot;</span>;
<a name="l00806"></a>00806   <span class="keywordflow">case</span> <a class="code" href="os_8h.html#a4fec7ca081b31fb9e121208e2b57fe3f">RESERVED_LOCK</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;RESERVED&quot;</span>;
<a name="l00807"></a>00807   <span class="keywordflow">case</span> <a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;PENDING&quot;</span>;
<a name="l00808"></a>00808   <span class="keywordflow">case</span> <a class="code" href="os_8h.html#ae17e1f5c17b52ec543aefca2a0b6b0f2">EXCLUSIVE_LOCK</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;EXCLUSIVE&quot;</span>;
<a name="l00809"></a>00809   }
<a name="l00810"></a>00810   <span class="keywordflow">return</span> <span class="stringliteral">&quot;ERROR&quot;</span>;
<a name="l00811"></a>00811 }
<a name="l00812"></a>00812 <span class="preprocessor">#endif</span>
<a name="l00813"></a>00813 <span class="preprocessor"></span>
<a name="l00814"></a>00814 <span class="comment">/*</span>
<a name="l00815"></a>00815 <span class="comment">** If we are currently in a different thread than the thread that the</span>
<a name="l00816"></a>00816 <span class="comment">** unixFile argument belongs to, then transfer ownership of the unixFile</span>
<a name="l00817"></a>00817 <span class="comment">** over to the current thread.</span>
<a name="l00818"></a>00818 <span class="comment">**</span>
<a name="l00819"></a>00819 <span class="comment">** A unixFile is only owned by a thread on systems where one thread is</span>
<a name="l00820"></a>00820 <span class="comment">** unable to override locks created by a different thread.  RedHat9 is</span>
<a name="l00821"></a>00821 <span class="comment">** an example of such a system.</span>
<a name="l00822"></a>00822 <span class="comment">**</span>
<a name="l00823"></a>00823 <span class="comment">** Ownership transfer is only allowed if the unixFile is currently unlocked.</span>
<a name="l00824"></a>00824 <span class="comment">** If the unixFile is locked and an ownership is wrong, then return</span>
<a name="l00825"></a>00825 <span class="comment">** SQLITE_MISUSE.  SQLITE_OK is returned if everything works.</span>
<a name="l00826"></a>00826 <span class="comment">*/</span>
<a name="l00827"></a>00827 <span class="preprocessor">#if SQLITE_THREADSAFE</span>
<a name="l00828"></a>00828 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#aa2937e958de961aa2fa5498b73f01bdd">transferOwnership</a>(<a class="code" href="structunixFile.html">unixFile</a> *pFile){
<a name="l00829"></a>00829   <span class="keywordtype">int</span> rc;
<a name="l00830"></a>00830   pthread_t hSelf;
<a name="l00831"></a>00831   <span class="keywordflow">if</span>( threadsOverrideEachOthersLocks ){
<a name="l00832"></a>00832     <span class="comment">/* Ownership transfers not needed on this system */</span>
<a name="l00833"></a>00833     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00834"></a>00834   }
<a name="l00835"></a>00835   hSelf = pthread_self();
<a name="l00836"></a>00836   <span class="keywordflow">if</span>( pthread_equal(pFile-&gt;tid, hSelf) ){
<a name="l00837"></a>00837     <span class="comment">/* We are still in the same thread */</span>
<a name="l00838"></a>00838     <a class="code" href="os__common_8h.html#a9543b4e2d9a54f11e789d3a07eb45f7d">OSTRACE1</a>(<span class="stringliteral">&quot;No-transfer, same thread\n&quot;</span>);
<a name="l00839"></a>00839     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00840"></a>00840   }
<a name="l00841"></a>00841   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>!=<a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a> ){
<a name="l00842"></a>00842     <span class="comment">/* We cannot change ownership while we are holding a lock! */</span>
<a name="l00843"></a>00843     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a34f01e4ee909e6b68be040868f7503bc">SQLITE_MISUSE</a>;
<a name="l00844"></a>00844   }
<a name="l00845"></a>00845   <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;Transfer ownership of %d from %d to %d\n&quot;</span>,
<a name="l00846"></a>00846             pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, pFile-&gt;tid, hSelf);
<a name="l00847"></a>00847   pFile-&gt;tid = hSelf;
<a name="l00848"></a>00848   <span class="keywordflow">if</span> (pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a> != NULL) {
<a name="l00849"></a>00849     <a class="code" href="os__unix_8c.html#acfe59f061bfafcd4816ff5710188dabd">releaseLockInfo</a>(pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>);
<a name="l00850"></a>00850     rc = <a class="code" href="os__unix_8c.html#a21455ae20850627129c0a343d95a24f8">findLockInfo</a>(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, &amp;pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>, 0);
<a name="l00851"></a>00851     <a class="code" href="os__common_8h.html#a0353521cd993c4ca92f8bb3d7a8f4d53">OSTRACE5</a>(<span class="stringliteral">&quot;LOCK    %d is now %s(%s,%d)\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>,
<a name="l00852"></a>00852            locktypeName(pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>),
<a name="l00853"></a>00853            locktypeName(pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>), pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>);
<a name="l00854"></a>00854     <span class="keywordflow">return</span> rc;
<a name="l00855"></a>00855   } <span class="keywordflow">else</span> {
<a name="l00856"></a>00856     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00857"></a>00857   }
<a name="l00858"></a>00858 }
<a name="l00859"></a>00859 <span class="preprocessor">#else</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span>  <span class="comment">/* On single-threaded builds, ownership transfer is a no-op */</span>
<a name="l00861"></a><a class="code" href="os__unix_8c.html#aa2937e958de961aa2fa5498b73f01bdd">00861</a> <span class="preprocessor"># define transferOwnership(X) SQLITE_OK</span>
<a name="l00862"></a>00862 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00863"></a>00863 <span class="preprocessor"></span>
<a name="l00864"></a>00864 <span class="comment">/*</span>
<a name="l00865"></a>00865 <span class="comment">** Seek to the offset passed as the second argument, then read cnt </span>
<a name="l00866"></a>00866 <span class="comment">** bytes into pBuf. Return the number of bytes actually read.</span>
<a name="l00867"></a>00867 <span class="comment">**</span>
<a name="l00868"></a>00868 <span class="comment">** NB:  If you define USE_PREAD or USE_PREAD64, then it might also</span>
<a name="l00869"></a>00869 <span class="comment">** be necessary to define _XOPEN_SOURCE to be 500.  This varies from</span>
<a name="l00870"></a>00870 <span class="comment">** one system to another.  Since SQLite does not define USE_PREAD</span>
<a name="l00871"></a>00871 <span class="comment">** any any form by default, we will not attempt to define _XOPEN_SOURCE.</span>
<a name="l00872"></a>00872 <span class="comment">** See tickets #2741 and #2681.</span>
<a name="l00873"></a>00873 <span class="comment">*/</span>
<a name="l00874"></a><a class="code" href="os__unix_8c.html#a12a82854284c159ec47d1e5bb38d63bf">00874</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a12a82854284c159ec47d1e5bb38d63bf">seekAndRead</a>(<a class="code" href="structunixFile.html">unixFile</a> *<span class="keywordtype">id</span>, <a class="code" href="sqlite3_8h.html#a0a4d3e6c1ad46f90e746b920ab6ca0d2">sqlite3_int64</a> offset, <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">int</span> cnt){
<a name="l00875"></a>00875   <span class="keywordtype">int</span> got;
<a name="l00876"></a>00876   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> newOffset;
<a name="l00877"></a>00877   <a class="code" href="os__common_8h.html#a0534322773d9344f3d4c858e409ef175">TIMER_START</a>;
<a name="l00878"></a>00878 <span class="preprocessor">#if defined(USE_PREAD)</span>
<a name="l00879"></a>00879 <span class="preprocessor"></span>  got = pread(id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, pBuf, cnt, offset);
<a name="l00880"></a>00880   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( got = -1 );
<a name="l00881"></a>00881 <span class="preprocessor">#elif defined(USE_PREAD64)</span>
<a name="l00882"></a>00882 <span class="preprocessor"></span>  got = pread64(id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, pBuf, cnt, offset);
<a name="l00883"></a>00883   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( got = -1 );
<a name="l00884"></a>00884 <span class="preprocessor">#else</span>
<a name="l00885"></a>00885 <span class="preprocessor"></span>  newOffset = lseek(id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, offset, SEEK_SET);
<a name="l00886"></a>00886   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( newOffset-- );
<a name="l00887"></a>00887   <span class="keywordflow">if</span>( newOffset!=offset ){
<a name="l00888"></a>00888     <span class="keywordflow">return</span> -1;
<a name="l00889"></a>00889   }
<a name="l00890"></a>00890   got = read(id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, pBuf, cnt);
<a name="l00891"></a>00891 <span class="preprocessor">#endif</span>
<a name="l00892"></a>00892 <span class="preprocessor"></span>  <a class="code" href="os__common_8h.html#a35bf8095a86e8a5a2cab8a49cedb3107">TIMER_END</a>;
<a name="l00893"></a>00893   <a class="code" href="os__common_8h.html#a0353521cd993c4ca92f8bb3d7a8f4d53">OSTRACE5</a>(<span class="stringliteral">&quot;READ    %-3d %5d %7lld %llu\n&quot;</span>, id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, got, offset, <a class="code" href="os__common_8h.html#a34f541257f1fa74468d2a951317f6c28">TIMER_ELAPSED</a>);
<a name="l00894"></a>00894   <span class="keywordflow">return</span> got;
<a name="l00895"></a>00895 }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897 <span class="comment">/*</span>
<a name="l00898"></a>00898 <span class="comment">** Read data from a file into a buffer.  Return SQLITE_OK if all</span>
<a name="l00899"></a>00899 <span class="comment">** bytes were read successfully and SQLITE_IOERR if anything goes</span>
<a name="l00900"></a>00900 <span class="comment">** wrong.</span>
<a name="l00901"></a>00901 <span class="comment">*/</span>
<a name="l00902"></a><a class="code" href="os__unix_8c.html#a1e51bba47404d5518a136bbc5ab6e21b">00902</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a1e51bba47404d5518a136bbc5ab6e21b">unixRead</a>(
<a name="l00903"></a>00903   <a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, 
<a name="l00904"></a>00904   <span class="keywordtype">void</span> *pBuf, 
<a name="l00905"></a>00905   <span class="keywordtype">int</span> amt,
<a name="l00906"></a>00906   <a class="code" href="sqlite3_8h.html#a0a4d3e6c1ad46f90e746b920ab6ca0d2">sqlite3_int64</a> offset
<a name="l00907"></a>00907 ){
<a name="l00908"></a>00908   <span class="keywordtype">int</span> got;
<a name="l00909"></a>00909   assert( <span class="keywordtype">id</span> );
<a name="l00910"></a>00910   got = <a class="code" href="os__unix_8c.html#a12a82854284c159ec47d1e5bb38d63bf">seekAndRead</a>((<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>, offset, pBuf, amt);
<a name="l00911"></a>00911   <span class="keywordflow">if</span>( got==amt ){
<a name="l00912"></a>00912     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00913"></a>00913   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( got&lt;0 ){
<a name="l00914"></a>00914     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#aa3e8a9a3975c2752b10e5273d2a582c8">SQLITE_IOERR_READ</a>;
<a name="l00915"></a>00915   }<span class="keywordflow">else</span>{
<a name="l00916"></a>00916     <span class="comment">/* Unread parts of the buffer must be zero-filled */</span>
<a name="l00917"></a>00917     memset(&amp;((<span class="keywordtype">char</span>*)pBuf)[got], 0, amt-got);
<a name="l00918"></a>00918     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a51153b55e23c0d650cf4271e6a26e6e0">SQLITE_IOERR_SHORT_READ</a>;
<a name="l00919"></a>00919   }
<a name="l00920"></a>00920 }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922 <span class="comment">/*</span>
<a name="l00923"></a>00923 <span class="comment">** Seek to the offset in id-&gt;offset then read cnt bytes into pBuf.</span>
<a name="l00924"></a>00924 <span class="comment">** Return the number of bytes actually read.  Update the offset.</span>
<a name="l00925"></a>00925 <span class="comment">*/</span>
<a name="l00926"></a><a class="code" href="os__unix_8c.html#ad863c78df6608ad70a90ca625c97f772">00926</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#ad863c78df6608ad70a90ca625c97f772">seekAndWrite</a>(<a class="code" href="structunixFile.html">unixFile</a> *<span class="keywordtype">id</span>, <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> offset, <span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">int</span> cnt){
<a name="l00927"></a>00927   <span class="keywordtype">int</span> got;
<a name="l00928"></a>00928   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> newOffset;
<a name="l00929"></a>00929   <a class="code" href="os__common_8h.html#a0534322773d9344f3d4c858e409ef175">TIMER_START</a>;
<a name="l00930"></a>00930 <span class="preprocessor">#if defined(USE_PREAD)</span>
<a name="l00931"></a>00931 <span class="preprocessor"></span>  got = pwrite(id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, pBuf, cnt, offset);
<a name="l00932"></a>00932 <span class="preprocessor">#elif defined(USE_PREAD64)</span>
<a name="l00933"></a>00933 <span class="preprocessor"></span>  got = pwrite64(id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, pBuf, cnt, offset);
<a name="l00934"></a>00934 <span class="preprocessor">#else</span>
<a name="l00935"></a>00935 <span class="preprocessor"></span>  newOffset = lseek(id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, offset, SEEK_SET);
<a name="l00936"></a>00936   <span class="keywordflow">if</span>( newOffset!=offset ){
<a name="l00937"></a>00937     <span class="keywordflow">return</span> -1;
<a name="l00938"></a>00938   }
<a name="l00939"></a>00939   got = write(id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, pBuf, cnt);
<a name="l00940"></a>00940 <span class="preprocessor">#endif</span>
<a name="l00941"></a>00941 <span class="preprocessor"></span>  <a class="code" href="os__common_8h.html#a35bf8095a86e8a5a2cab8a49cedb3107">TIMER_END</a>;
<a name="l00942"></a>00942   <a class="code" href="os__common_8h.html#a0353521cd993c4ca92f8bb3d7a8f4d53">OSTRACE5</a>(<span class="stringliteral">&quot;WRITE   %-3d %5d %7lld %llu\n&quot;</span>, id-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, got, offset, <a class="code" href="os__common_8h.html#a34f541257f1fa74468d2a951317f6c28">TIMER_ELAPSED</a>);
<a name="l00943"></a>00943   <span class="keywordflow">return</span> got;
<a name="l00944"></a>00944 }
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 <span class="comment">/*</span>
<a name="l00948"></a>00948 <span class="comment">** Write data from a buffer into a file.  Return SQLITE_OK on success</span>
<a name="l00949"></a>00949 <span class="comment">** or some other error code on failure.</span>
<a name="l00950"></a>00950 <span class="comment">*/</span>
<a name="l00951"></a><a class="code" href="os__unix_8c.html#a4385beabc5689db595bbe5a18b3c619a">00951</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a4385beabc5689db595bbe5a18b3c619a">unixWrite</a>(
<a name="l00952"></a>00952   <a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, 
<a name="l00953"></a>00953   <span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, 
<a name="l00954"></a>00954   <span class="keywordtype">int</span> amt,
<a name="l00955"></a>00955   <a class="code" href="sqlite3_8h.html#a0a4d3e6c1ad46f90e746b920ab6ca0d2">sqlite3_int64</a> offset 
<a name="l00956"></a>00956 ){
<a name="l00957"></a>00957   <span class="keywordtype">int</span> wrote = 0;
<a name="l00958"></a>00958   assert( <span class="keywordtype">id</span> );
<a name="l00959"></a>00959   assert( amt&gt;0 );
<a name="l00960"></a>00960   <span class="keywordflow">while</span>( amt&gt;0 &amp;&amp; (wrote = <a class="code" href="os__unix_8c.html#ad863c78df6608ad70a90ca625c97f772">seekAndWrite</a>((<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>, offset, pBuf, amt))&gt;0 ){
<a name="l00961"></a>00961     amt -= wrote;
<a name="l00962"></a>00962     offset += wrote;
<a name="l00963"></a>00963     pBuf = &amp;((<span class="keywordtype">char</span>*)pBuf)[wrote];
<a name="l00964"></a>00964   }
<a name="l00965"></a>00965   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>(( wrote=(-1), amt=1 ));
<a name="l00966"></a>00966   <a class="code" href="os__common_8h.html#ad4aac997e5f0eac3fd9f626f5ac5dff8">SimulateDiskfullError</a>(( wrote=0, amt=1 ));
<a name="l00967"></a>00967   <span class="keywordflow">if</span>( amt&gt;0 ){
<a name="l00968"></a>00968     <span class="keywordflow">if</span>( wrote&lt;0 ){
<a name="l00969"></a>00969       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a263697c78f4810978528fc94ccce5cb8">SQLITE_IOERR_WRITE</a>;
<a name="l00970"></a>00970     }<span class="keywordflow">else</span>{
<a name="l00971"></a>00971       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a0e968a73ba9e13561c5dbf38f6ac7402">SQLITE_FULL</a>;
<a name="l00972"></a>00972     }
<a name="l00973"></a>00973   }
<a name="l00974"></a>00974   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00975"></a>00975 }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00979"></a>00979 <span class="comment">** Count the number of fullsyncs and normal syncs.  This is used to test</span>
<a name="l00980"></a>00980 <span class="comment">** that syncs and fullsyncs are occuring at the right times.</span>
<a name="l00981"></a>00981 <span class="comment">*/</span>
<a name="l00982"></a>00982 <span class="keywordtype">int</span> sqlite3_sync_count = 0;
<a name="l00983"></a>00983 <span class="keywordtype">int</span> sqlite3_fullsync_count = 0;
<a name="l00984"></a>00984 <span class="preprocessor">#endif</span>
<a name="l00985"></a>00985 <span class="preprocessor"></span>
<a name="l00986"></a>00986 <span class="comment">/*</span>
<a name="l00987"></a>00987 <span class="comment">** Use the fdatasync() API only if the HAVE_FDATASYNC macro is defined.</span>
<a name="l00988"></a>00988 <span class="comment">** Otherwise use fsync() in its place.</span>
<a name="l00989"></a>00989 <span class="comment">*/</span>
<a name="l00990"></a>00990 <span class="preprocessor">#ifndef HAVE_FDATASYNC</span>
<a name="l00991"></a><a class="code" href="os__unix_8c.html#a71be186076d9c018df61d695a82c6edb">00991</a> <span class="preprocessor"></span><span class="preprocessor"># define fdatasync fsync</span>
<a name="l00992"></a>00992 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00993"></a>00993 <span class="preprocessor"></span>
<a name="l00994"></a>00994 <span class="comment">/*</span>
<a name="l00995"></a>00995 <span class="comment">** Define HAVE_FULLFSYNC to 0 or 1 depending on whether or not</span>
<a name="l00996"></a>00996 <span class="comment">** the F_FULLFSYNC macro is defined.  F_FULLFSYNC is currently</span>
<a name="l00997"></a>00997 <span class="comment">** only available on Mac OS X.  But that could change.</span>
<a name="l00998"></a>00998 <span class="comment">*/</span>
<a name="l00999"></a>00999 <span class="preprocessor">#ifdef F_FULLFSYNC</span>
<a name="l01000"></a>01000 <span class="preprocessor"></span><span class="preprocessor"># define HAVE_FULLFSYNC 1</span>
<a name="l01001"></a>01001 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01002"></a><a class="code" href="os__unix_8c.html#a120b40ecf240bca85acab0c7fa204852">01002</a> <span class="preprocessor"></span><span class="preprocessor"># define HAVE_FULLFSYNC 0</span>
<a name="l01003"></a>01003 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span>
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 <span class="comment">/*</span>
<a name="l01007"></a>01007 <span class="comment">** The fsync() system call does not work as advertised on many</span>
<a name="l01008"></a>01008 <span class="comment">** unix systems.  The following procedure is an attempt to make</span>
<a name="l01009"></a>01009 <span class="comment">** it work better.</span>
<a name="l01010"></a>01010 <span class="comment">**</span>
<a name="l01011"></a>01011 <span class="comment">** The SQLITE_NO_SYNC macro disables all fsync()s.  This is useful</span>
<a name="l01012"></a>01012 <span class="comment">** for testing when we want to run through the test suite quickly.</span>
<a name="l01013"></a>01013 <span class="comment">** You are strongly advised *not* to deploy with SQLITE_NO_SYNC</span>
<a name="l01014"></a>01014 <span class="comment">** enabled, however, since with SQLITE_NO_SYNC enabled, an OS crash</span>
<a name="l01015"></a>01015 <span class="comment">** or power failure will likely corrupt the database file.</span>
<a name="l01016"></a>01016 <span class="comment">*/</span>
<a name="l01017"></a><a class="code" href="os__unix_8c.html#aba53411fd87749e2ed670ea40e60c18d">01017</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#aba53411fd87749e2ed670ea40e60c18d">full_fsync</a>(<span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> fullSync, <span class="keywordtype">int</span> dataOnly){
<a name="l01018"></a>01018   <span class="keywordtype">int</span> rc;
<a name="l01019"></a>01019 
<a name="l01020"></a>01020   <span class="comment">/* Record the number of times that we do a normal fsync() and </span>
<a name="l01021"></a>01021 <span class="comment">  ** FULLSYNC.  This is used during testing to verify that this procedure</span>
<a name="l01022"></a>01022 <span class="comment">  ** gets called with the correct arguments.</span>
<a name="l01023"></a>01023 <span class="comment">  */</span>
<a name="l01024"></a>01024 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l01025"></a>01025 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( fullSync ) sqlite3_fullsync_count++;
<a name="l01026"></a>01026   sqlite3_sync_count++;
<a name="l01027"></a>01027 <span class="preprocessor">#endif</span>
<a name="l01028"></a>01028 <span class="preprocessor"></span>
<a name="l01029"></a>01029   <span class="comment">/* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a</span>
<a name="l01030"></a>01030 <span class="comment">  ** no-op</span>
<a name="l01031"></a>01031 <span class="comment">  */</span>
<a name="l01032"></a>01032 <span class="preprocessor">#ifdef SQLITE_NO_SYNC</span>
<a name="l01033"></a>01033 <span class="preprocessor"></span>  rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01034"></a>01034 <span class="preprocessor">#else</span>
<a name="l01035"></a>01035 <span class="preprocessor"></span>
<a name="l01036"></a>01036 <span class="preprocessor">#if HAVE_FULLFSYNC</span>
<a name="l01037"></a>01037 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( fullSync ){
<a name="l01038"></a>01038     rc = fcntl(fd, F_FULLFSYNC, 0);
<a name="l01039"></a>01039   }<span class="keywordflow">else</span>{
<a name="l01040"></a>01040     rc = 1;
<a name="l01041"></a>01041   }
<a name="l01042"></a>01042   <span class="comment">/* If the FULLFSYNC failed, fall back to attempting an fsync().</span>
<a name="l01043"></a>01043 <span class="comment">   * It shouldn&apos;t be possible for fullfsync to fail on the local </span>
<a name="l01044"></a>01044 <span class="comment">   * file system (on OSX), so failure indicates that FULLFSYNC</span>
<a name="l01045"></a>01045 <span class="comment">   * isn&apos;t supported for this file system. So, attempt an fsync </span>
<a name="l01046"></a>01046 <span class="comment">   * and (for now) ignore the overhead of a superfluous fcntl call.  </span>
<a name="l01047"></a>01047 <span class="comment">   * It&apos;d be better to detect fullfsync support once and avoid </span>
<a name="l01048"></a>01048 <span class="comment">   * the fcntl call every time sync is called.</span>
<a name="l01049"></a>01049 <span class="comment">   */</span>
<a name="l01050"></a>01050   <span class="keywordflow">if</span>( rc ) rc = fsync(fd);
<a name="l01051"></a>01051 
<a name="l01052"></a>01052 <span class="preprocessor">#else </span>
<a name="l01053"></a>01053 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( dataOnly ){
<a name="l01054"></a>01054     rc = <a class="code" href="os__symbian_8c.html#a71be186076d9c018df61d695a82c6edb">fdatasync</a>(fd);
<a name="l01055"></a>01055   }<span class="keywordflow">else</span>{
<a name="l01056"></a>01056     rc = fsync(fd);
<a name="l01057"></a>01057   }
<a name="l01058"></a>01058 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_FULLFSYNC */</span>
<a name="l01059"></a>01059 <span class="preprocessor">#endif </span><span class="comment">/* defined(SQLITE_NO_SYNC) */</span>
<a name="l01060"></a>01060 
<a name="l01061"></a>01061   <span class="keywordflow">return</span> rc;
<a name="l01062"></a>01062 }
<a name="l01063"></a>01063 
<a name="l01064"></a>01064 <span class="comment">/*</span>
<a name="l01065"></a>01065 <span class="comment">** Make sure all writes to a particular file are committed to disk.</span>
<a name="l01066"></a>01066 <span class="comment">**</span>
<a name="l01067"></a>01067 <span class="comment">** If dataOnly==0 then both the file itself and its metadata (file</span>
<a name="l01068"></a>01068 <span class="comment">** size, access time, etc) are synced.  If dataOnly!=0 then only the</span>
<a name="l01069"></a>01069 <span class="comment">** file data is synced.</span>
<a name="l01070"></a>01070 <span class="comment">**</span>
<a name="l01071"></a>01071 <span class="comment">** Under Unix, also make sure that the directory entry for the file</span>
<a name="l01072"></a>01072 <span class="comment">** has been created by fsync-ing the directory that contains the file.</span>
<a name="l01073"></a>01073 <span class="comment">** If we do not do this and we encounter a power failure, the directory</span>
<a name="l01074"></a>01074 <span class="comment">** entry for the journal might not exist after we reboot.  The next</span>
<a name="l01075"></a>01075 <span class="comment">** SQLite to access the file will not know that the journal exists (because</span>
<a name="l01076"></a>01076 <span class="comment">** the directory entry for the journal was never created) and the transaction</span>
<a name="l01077"></a>01077 <span class="comment">** will not roll back - possibly leading to database corruption.</span>
<a name="l01078"></a>01078 <span class="comment">*/</span>
<a name="l01079"></a><a class="code" href="os__unix_8c.html#aceafdac666eb94923ee90064b3934299">01079</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#aceafdac666eb94923ee90064b3934299">unixSync</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> flags){
<a name="l01080"></a>01080   <span class="keywordtype">int</span> rc;
<a name="l01081"></a>01081   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083   <span class="keywordtype">int</span> isDataOnly = (flags&amp;<a class="code" href="sqlite3_8h.html#ad3d1953550f3571a45ba936893721d63">SQLITE_SYNC_DATAONLY</a>);
<a name="l01084"></a>01084   <span class="keywordtype">int</span> isFullsync = (flags&amp;0x0F)==<a class="code" href="sqlite3_8h.html#aad72cd4375f6e4097bc2ec72e1129373">SQLITE_SYNC_FULL</a>;
<a name="l01085"></a>01085 
<a name="l01086"></a>01086   <span class="comment">/* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */</span>
<a name="l01087"></a>01087   assert((flags&amp;0x0F)==<a class="code" href="sqlite3_8h.html#a2cea9e1af38eddd7730c51c98692f2cd">SQLITE_SYNC_NORMAL</a>
<a name="l01088"></a>01088       || (flags&amp;0x0F)==<a class="code" href="sqlite3_8h.html#aad72cd4375f6e4097bc2ec72e1129373">SQLITE_SYNC_FULL</a>
<a name="l01089"></a>01089   );
<a name="l01090"></a>01090 
<a name="l01091"></a>01091   <span class="comment">/* Unix cannot, but some systems may return SQLITE_FULL from here. This</span>
<a name="l01092"></a>01092 <span class="comment">  ** line is to test that doing so does not cause any problems.</span>
<a name="l01093"></a>01093 <span class="comment">  */</span>
<a name="l01094"></a>01094   <a class="code" href="os__common_8h.html#ad4aac997e5f0eac3fd9f626f5ac5dff8">SimulateDiskfullError</a>( <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a0e968a73ba9e13561c5dbf38f6ac7402">SQLITE_FULL</a> );
<a name="l01095"></a>01095 
<a name="l01096"></a>01096   assert( pFile );
<a name="l01097"></a>01097   <a class="code" href="os__common_8h.html#ae032fbc19c8939ba2570640ebdf847d7">OSTRACE2</a>(<span class="stringliteral">&quot;SYNC    %-3d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>);
<a name="l01098"></a>01098   rc = <a class="code" href="os__unix_8c.html#aba53411fd87749e2ed670ea40e60c18d">full_fsync</a>(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, isFullsync, isDataOnly);
<a name="l01099"></a>01099   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( rc=1 );
<a name="l01100"></a>01100   <span class="keywordflow">if</span>( rc ){
<a name="l01101"></a>01101     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#af0870a337316756ef9b91fef1ac1d91e">SQLITE_IOERR_FSYNC</a>;
<a name="l01102"></a>01102   }
<a name="l01103"></a>01103   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">dirfd</a>&gt;=0 ){
<a name="l01104"></a>01104     <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;DIRSYNC %-3d (have_fullfsync=%d fullsync=%d)\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">dirfd</a>,
<a name="l01105"></a>01105             <a class="code" href="os__symbian_8c.html#a120b40ecf240bca85acab0c7fa204852">HAVE_FULLFSYNC</a>, isFullsync);
<a name="l01106"></a>01106 <span class="preprocessor">#ifndef SQLITE_DISABLE_DIRSYNC</span>
<a name="l01107"></a>01107 <span class="preprocessor"></span>    <span class="comment">/* The directory sync is only attempted if full_fsync is</span>
<a name="l01108"></a>01108 <span class="comment">    ** turned off or unavailable.  If a full_fsync occurred above,</span>
<a name="l01109"></a>01109 <span class="comment">    ** then the directory sync is superfluous.</span>
<a name="l01110"></a>01110 <span class="comment">    */</span>
<a name="l01111"></a>01111     <span class="keywordflow">if</span>( (!<a class="code" href="os__symbian_8c.html#a120b40ecf240bca85acab0c7fa204852">HAVE_FULLFSYNC</a> || !isFullsync) &amp;&amp; <a class="code" href="os__unix_8c.html#aba53411fd87749e2ed670ea40e60c18d">full_fsync</a>(pFile-&gt;<a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">dirfd</a>,0,0) ){
<a name="l01112"></a>01112        <span class="comment">/*</span>
<a name="l01113"></a>01113 <span class="comment">       ** We have received multiple reports of fsync() returning</span>
<a name="l01114"></a>01114 <span class="comment">       ** errors when applied to directories on certain file systems.</span>
<a name="l01115"></a>01115 <span class="comment">       ** A failed directory sync is not a big deal.  So it seems</span>
<a name="l01116"></a>01116 <span class="comment">       ** better to ignore the error.  Ticket #1657</span>
<a name="l01117"></a>01117 <span class="comment">       */</span>
<a name="l01118"></a>01118        <span class="comment">/* return SQLITE_IOERR; */</span>
<a name="l01119"></a>01119     }
<a name="l01120"></a>01120 <span class="preprocessor">#endif</span>
<a name="l01121"></a>01121 <span class="preprocessor"></span>    close(pFile-&gt;<a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">dirfd</a>);  <span class="comment">/* Only need to sync once, so close the directory */</span>
<a name="l01122"></a>01122     pFile-&gt;<a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">dirfd</a> = -1;    <span class="comment">/* when we are done. */</span>
<a name="l01123"></a>01123   }
<a name="l01124"></a>01124   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01125"></a>01125 }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="comment">/*</span>
<a name="l01128"></a>01128 <span class="comment">** Truncate an open file to a specified size</span>
<a name="l01129"></a>01129 <span class="comment">*/</span>
<a name="l01130"></a><a class="code" href="os__unix_8c.html#a0d55220865a8e1c4604e78e16666fe11">01130</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a0d55220865a8e1c4604e78e16666fe11">unixTruncate</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> nByte){
<a name="l01131"></a>01131   <span class="keywordtype">int</span> rc;
<a name="l01132"></a>01132   assert( <span class="keywordtype">id</span> );
<a name="l01133"></a>01133   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a4242985ac3059fd0310496a9b0264566">SQLITE_IOERR_TRUNCATE</a> );
<a name="l01134"></a>01134   rc = ftruncate(((<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>)-&gt;h, (off_t)nByte);
<a name="l01135"></a>01135   <span class="keywordflow">if</span>( rc ){
<a name="l01136"></a>01136     <span class="keywordflow">return</span> SQLITE_IOERR_TRUNCATE;
<a name="l01137"></a>01137   }<span class="keywordflow">else</span>{
<a name="l01138"></a>01138     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01139"></a>01139   }
<a name="l01140"></a>01140 }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142 <span class="comment">/*</span>
<a name="l01143"></a>01143 <span class="comment">** Determine the current size of a file in bytes</span>
<a name="l01144"></a>01144 <span class="comment">*/</span>
<a name="l01145"></a><a class="code" href="os__unix_8c.html#abc8d72bbfe4b40dbd115b40f74eb88fb">01145</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#abc8d72bbfe4b40dbd115b40f74eb88fb">unixFileSize</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> *pSize){
<a name="l01146"></a>01146   <span class="keywordtype">int</span> rc;
<a name="l01147"></a>01147   <span class="keyword">struct </span>stat buf;
<a name="l01148"></a>01148   assert( <span class="keywordtype">id</span> );
<a name="l01149"></a>01149   rc = fstat(((<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>)-&gt;h, &amp;buf);
<a name="l01150"></a>01150   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( rc=1 );
<a name="l01151"></a>01151   <span class="keywordflow">if</span>( rc!=0 ){
<a name="l01152"></a>01152     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a96c453633e8c67531f90bf7509e2644c">SQLITE_IOERR_FSTAT</a>;
<a name="l01153"></a>01153   }
<a name="l01154"></a>01154   *pSize = buf.st_size;
<a name="l01155"></a>01155 
<a name="l01156"></a>01156   <span class="comment">/* When opening a zero-size database, the findLockInfo() procedure</span>
<a name="l01157"></a>01157 <span class="comment">  ** writes a single byte into that file in order to work around a bug</span>
<a name="l01158"></a>01158 <span class="comment">  ** in the OS-X msdos filesystem.  In order to avoid problems with upper</span>
<a name="l01159"></a>01159 <span class="comment">  ** layers, we need to report this file size as zero even though it is</span>
<a name="l01160"></a>01160 <span class="comment">  ** really 1.   Ticket #3260.</span>
<a name="l01161"></a>01161 <span class="comment">  */</span>
<a name="l01162"></a>01162   <span class="keywordflow">if</span>( *pSize==1 ) *pSize = 0;
<a name="l01163"></a>01163 
<a name="l01164"></a>01164 
<a name="l01165"></a>01165   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01166"></a>01166 }
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <span class="comment">/*</span>
<a name="l01169"></a>01169 <span class="comment">** This routine translates a standard POSIX errno code into something</span>
<a name="l01170"></a>01170 <span class="comment">** useful to the clients of the sqlite3 functions.  Specifically, it is</span>
<a name="l01171"></a>01171 <span class="comment">** intended to translate a variety of &quot;try again&quot; errors into SQLITE_BUSY</span>
<a name="l01172"></a>01172 <span class="comment">** and a variety of &quot;please close the file descriptor NOW&quot; errors into </span>
<a name="l01173"></a>01173 <span class="comment">** SQLITE_IOERR</span>
<a name="l01174"></a>01174 <span class="comment">** </span>
<a name="l01175"></a>01175 <span class="comment">** Errors during initialization of locks, or file system support for locks,</span>
<a name="l01176"></a>01176 <span class="comment">** should handle ENOLCK, ENOTSUP, EOPNOTSUPP separately.</span>
<a name="l01177"></a>01177 <span class="comment">*/</span>
<a name="l01178"></a><a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">01178</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(<span class="keywordtype">int</span> posixError, <span class="keywordtype">int</span> sqliteIOErr) {
<a name="l01179"></a>01179   <span class="keywordflow">switch</span> (posixError) {
<a name="l01180"></a>01180   <span class="keywordflow">case</span> 0: 
<a name="l01181"></a>01181     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01182"></a>01182     
<a name="l01183"></a>01183   <span class="keywordflow">case</span> EAGAIN:
<a name="l01184"></a>01184   <span class="keywordflow">case</span> ETIMEDOUT:
<a name="l01185"></a>01185   <span class="keywordflow">case</span> EBUSY:
<a name="l01186"></a>01186   <span class="keywordflow">case</span> EINTR:
<a name="l01187"></a>01187   <span class="keywordflow">case</span> ENOLCK:  
<a name="l01188"></a>01188     <span class="comment">/* random NFS retry error, unless during file system support </span>
<a name="l01189"></a>01189 <span class="comment">     * introspection, in which it actually means what it says */</span>
<a name="l01190"></a>01190     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l01191"></a>01191     
<a name="l01192"></a>01192   <span class="keywordflow">case</span> EACCES: 
<a name="l01193"></a>01193     <span class="comment">/* EACCES is like EAGAIN during locking operations, but not any other time*/</span>
<a name="l01194"></a>01194     <span class="keywordflow">if</span>( (sqliteIOErr == <a class="code" href="sqlite3_8h.html#a77ac56b2a8025538d73aa6379c82b4af">SQLITE_IOERR_LOCK</a>) || 
<a name="l01195"></a>01195   (sqliteIOErr == <a class="code" href="sqlite3_8h.html#a820929b6588051fa0eefaf4639bd8536">SQLITE_IOERR_UNLOCK</a>) || 
<a name="l01196"></a>01196   (sqliteIOErr == <a class="code" href="sqlite3_8h.html#ac77b3fcb607278f465c223580601b5cc">SQLITE_IOERR_RDLOCK</a>) ||
<a name="l01197"></a>01197   (sqliteIOErr == <a class="code" href="sqlite3_8h.html#af165990c0a93e69d7e66f5f0cb7fd7bb">SQLITE_IOERR_CHECKRESERVEDLOCK</a>) ){
<a name="l01198"></a>01198       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l01199"></a>01199     }
<a name="l01200"></a>01200     <span class="comment">/* else fall through */</span>
<a name="l01201"></a>01201   <span class="keywordflow">case</span> EPERM: 
<a name="l01202"></a>01202     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#af2561d6fe38a527e46e24db1952ee53a">SQLITE_PERM</a>;
<a name="l01203"></a>01203     
<a name="l01204"></a>01204   <span class="keywordflow">case</span> EDEADLK:
<a name="l01205"></a>01205     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a7bccb0ab5af74f1d05c0c0356083d820">SQLITE_IOERR_BLOCKED</a>;
<a name="l01206"></a>01206     
<a name="l01207"></a>01207 <span class="preprocessor">#if EOPNOTSUPP!=ENOTSUP</span>
<a name="l01208"></a>01208 <span class="preprocessor"></span>  <span class="keywordflow">case</span> EOPNOTSUPP: 
<a name="l01209"></a>01209     <span class="comment">/* something went terribly awry, unless during file system support </span>
<a name="l01210"></a>01210 <span class="comment">     * introspection, in which it actually means what it says */</span>
<a name="l01211"></a>01211 <span class="preprocessor">#endif</span>
<a name="l01212"></a>01212 <span class="preprocessor"></span><span class="preprocessor">#ifdef ENOTSUP</span>
<a name="l01213"></a>01213 <span class="preprocessor"></span>  <span class="keywordflow">case</span> ENOTSUP: 
<a name="l01214"></a>01214     <span class="comment">/* invalid fd, unless during file system support introspection, in which </span>
<a name="l01215"></a>01215 <span class="comment">     * it actually means what it says */</span>
<a name="l01216"></a>01216 <span class="preprocessor">#endif</span>
<a name="l01217"></a>01217 <span class="preprocessor"></span>  <span class="keywordflow">case</span> EIO:
<a name="l01218"></a>01218   <span class="keywordflow">case</span> EBADF:
<a name="l01219"></a>01219   <span class="keywordflow">case</span> EINVAL:
<a name="l01220"></a>01220   <span class="keywordflow">case</span> ENOTCONN:
<a name="l01221"></a>01221   <span class="keywordflow">case</span> ENODEV:
<a name="l01222"></a>01222   <span class="keywordflow">case</span> ENXIO:
<a name="l01223"></a>01223   <span class="keywordflow">case</span> ENOENT:
<a name="l01224"></a>01224   <span class="keywordflow">case</span> ESTALE:
<a name="l01225"></a>01225   <span class="keywordflow">case</span> ENOSYS:
<a name="l01226"></a>01226     <span class="comment">/* these should force the client to close the file and reconnect */</span>
<a name="l01227"></a>01227     
<a name="l01228"></a>01228   <span class="keywordflow">default</span>: 
<a name="l01229"></a>01229     <span class="keywordflow">return</span> sqliteIOErr;
<a name="l01230"></a>01230   }
<a name="l01231"></a>01231 }
<a name="l01232"></a>01232 
<a name="l01233"></a>01233 <span class="comment">/*</span>
<a name="l01234"></a>01234 <span class="comment">** This routine checks if there is a RESERVED lock held on the specified</span>
<a name="l01235"></a>01235 <span class="comment">** file by this or any other process. If such a lock is held, set *pResOut</span>
<a name="l01236"></a>01236 <span class="comment">** to a non-zero value otherwise *pResOut is set to zero.  The return value</span>
<a name="l01237"></a>01237 <span class="comment">** is set to SQLITE_OK unless an I/O error occurs during lock checking.</span>
<a name="l01238"></a>01238 <span class="comment">*/</span>
<a name="l01239"></a><a class="code" href="os__unix_8c.html#ac56c26ce18878ed5357de493678969fc">01239</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#ac56c26ce18878ed5357de493678969fc">unixCheckReservedLock</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> *pResOut){
<a name="l01240"></a>01240   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01241"></a>01241   <span class="keywordtype">int</span> reserved = 0;
<a name="l01242"></a>01242   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l01243"></a>01243 
<a name="l01244"></a>01244   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#af165990c0a93e69d7e66f5f0cb7fd7bb">SQLITE_IOERR_CHECKRESERVEDLOCK</a>; );
<a name="l01245"></a>01245 
<a name="l01246"></a>01246   assert( pFile );
<a name="l01247"></a>01247   <a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">enterMutex</a>(); <span class="comment">/* Because pFile-&gt;pLock is shared across threads */</span>
<a name="l01248"></a>01248 
<a name="l01249"></a>01249   <span class="comment">/* Check if a thread in this process holds such a lock */</span>
<a name="l01250"></a>01250   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>&gt;<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l01251"></a>01251     reserved = 1;
<a name="l01252"></a>01252   }
<a name="l01253"></a>01253 
<a name="l01254"></a>01254   <span class="comment">/* Otherwise see if some other process holds it.</span>
<a name="l01255"></a>01255 <span class="comment">  */</span>
<a name="l01256"></a>01256   <span class="keywordflow">if</span>( !reserved ){
<a name="l01257"></a>01257     <span class="keyword">struct </span>flock lock;
<a name="l01258"></a>01258     lock.l_whence = SEEK_SET;
<a name="l01259"></a>01259     lock.l_start = <a class="code" href="os_8h.html#a8ac9fa3da7151dc5ffd9fbf0563a9417">RESERVED_BYTE</a>;
<a name="l01260"></a>01260     lock.l_len = 1;
<a name="l01261"></a>01261     lock.l_type = F_WRLCK;
<a name="l01262"></a>01262     <span class="keywordflow">if</span> (-1 == fcntl(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, F_GETLK, &amp;lock)) {
<a name="l01263"></a>01263       <span class="keywordtype">int</span> tErrno = errno;
<a name="l01264"></a>01264       rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#af165990c0a93e69d7e66f5f0cb7fd7bb">SQLITE_IOERR_CHECKRESERVEDLOCK</a>);
<a name="l01265"></a>01265       pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l01266"></a>01266     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( lock.l_type!=F_UNLCK ){
<a name="l01267"></a>01267       reserved = 1;
<a name="l01268"></a>01268     }
<a name="l01269"></a>01269   }
<a name="l01270"></a>01270   
<a name="l01271"></a>01271   <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l01272"></a>01272   <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;TEST WR-LOCK %d %d %d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, rc, reserved);
<a name="l01273"></a>01273 
<a name="l01274"></a>01274   *pResOut = reserved;
<a name="l01275"></a>01275   <span class="keywordflow">return</span> rc;
<a name="l01276"></a>01276 }
<a name="l01277"></a>01277 
<a name="l01278"></a>01278 <span class="comment">/*</span>
<a name="l01279"></a>01279 <span class="comment">** Lock the file with the lock specified by parameter locktype - one</span>
<a name="l01280"></a>01280 <span class="comment">** of the following:</span>
<a name="l01281"></a>01281 <span class="comment">**</span>
<a name="l01282"></a>01282 <span class="comment">**     (1) SHARED_LOCK</span>
<a name="l01283"></a>01283 <span class="comment">**     (2) RESERVED_LOCK</span>
<a name="l01284"></a>01284 <span class="comment">**     (3) PENDING_LOCK</span>
<a name="l01285"></a>01285 <span class="comment">**     (4) EXCLUSIVE_LOCK</span>
<a name="l01286"></a>01286 <span class="comment">**</span>
<a name="l01287"></a>01287 <span class="comment">** Sometimes when requesting one lock state, additional lock states</span>
<a name="l01288"></a>01288 <span class="comment">** are inserted in between.  The locking might fail on one of the later</span>
<a name="l01289"></a>01289 <span class="comment">** transitions leaving the lock state different from what it started but</span>
<a name="l01290"></a>01290 <span class="comment">** still short of its goal.  The following chart shows the allowed</span>
<a name="l01291"></a>01291 <span class="comment">** transitions and the inserted intermediate states:</span>
<a name="l01292"></a>01292 <span class="comment">**</span>
<a name="l01293"></a>01293 <span class="comment">**    UNLOCKED -&gt; SHARED</span>
<a name="l01294"></a>01294 <span class="comment">**    SHARED -&gt; RESERVED</span>
<a name="l01295"></a>01295 <span class="comment">**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE</span>
<a name="l01296"></a>01296 <span class="comment">**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE</span>
<a name="l01297"></a>01297 <span class="comment">**    PENDING -&gt; EXCLUSIVE</span>
<a name="l01298"></a>01298 <span class="comment">**</span>
<a name="l01299"></a>01299 <span class="comment">** This routine will only increase a lock.  Use the sqlite3OsUnlock()</span>
<a name="l01300"></a>01300 <span class="comment">** routine to lower a locking level.</span>
<a name="l01301"></a>01301 <span class="comment">*/</span>
<a name="l01302"></a><a class="code" href="os__unix_8c.html#abe3ca9997aafdc0835387f0c1cee0750">01302</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#abe3ca9997aafdc0835387f0c1cee0750">unixLock</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype){
<a name="l01303"></a>01303   <span class="comment">/* The following describes the implementation of the various locks and</span>
<a name="l01304"></a>01304 <span class="comment">  ** lock transitions in terms of the POSIX advisory shared and exclusive</span>
<a name="l01305"></a>01305 <span class="comment">  ** lock primitives (called read-locks and write-locks below, to avoid</span>
<a name="l01306"></a>01306 <span class="comment">  ** confusion with SQLite lock names). The algorithms are complicated</span>
<a name="l01307"></a>01307 <span class="comment">  ** slightly in order to be compatible with windows systems simultaneously</span>
<a name="l01308"></a>01308 <span class="comment">  ** accessing the same database file, in case that is ever required.</span>
<a name="l01309"></a>01309 <span class="comment">  **</span>
<a name="l01310"></a>01310 <span class="comment">  ** Symbols defined in os.h indentify the &apos;pending byte&apos; and the &apos;reserved</span>
<a name="l01311"></a>01311 <span class="comment">  ** byte&apos;, each single bytes at well known offsets, and the &apos;shared byte</span>
<a name="l01312"></a>01312 <span class="comment">  ** range&apos;, a range of 510 bytes at a well known offset.</span>
<a name="l01313"></a>01313 <span class="comment">  **</span>
<a name="l01314"></a>01314 <span class="comment">  ** To obtain a SHARED lock, a read-lock is obtained on the &apos;pending</span>
<a name="l01315"></a>01315 <span class="comment">  ** byte&apos;.  If this is successful, a random byte from the &apos;shared byte</span>
<a name="l01316"></a>01316 <span class="comment">  ** range&apos; is read-locked and the lock on the &apos;pending byte&apos; released.</span>
<a name="l01317"></a>01317 <span class="comment">  **</span>
<a name="l01318"></a>01318 <span class="comment">  ** A process may only obtain a RESERVED lock after it has a SHARED lock.</span>
<a name="l01319"></a>01319 <span class="comment">  ** A RESERVED lock is implemented by grabbing a write-lock on the</span>
<a name="l01320"></a>01320 <span class="comment">  ** &apos;reserved byte&apos;. </span>
<a name="l01321"></a>01321 <span class="comment">  **</span>
<a name="l01322"></a>01322 <span class="comment">  ** A process may only obtain a PENDING lock after it has obtained a</span>
<a name="l01323"></a>01323 <span class="comment">  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lock</span>
<a name="l01324"></a>01324 <span class="comment">  ** on the &apos;pending byte&apos;. This ensures that no new SHARED locks can be</span>
<a name="l01325"></a>01325 <span class="comment">  ** obtained, but existing SHARED locks are allowed to persist. A process</span>
<a name="l01326"></a>01326 <span class="comment">  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.</span>
<a name="l01327"></a>01327 <span class="comment">  ** This property is used by the algorithm for rolling back a journal file</span>
<a name="l01328"></a>01328 <span class="comment">  ** after a crash.</span>
<a name="l01329"></a>01329 <span class="comment">  **</span>
<a name="l01330"></a>01330 <span class="comment">  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, is</span>
<a name="l01331"></a>01331 <span class="comment">  ** implemented by obtaining a write-lock on the entire &apos;shared byte</span>
<a name="l01332"></a>01332 <span class="comment">  ** range&apos;. Since all other locks require a read-lock on one of the bytes</span>
<a name="l01333"></a>01333 <span class="comment">  ** within this range, this ensures that no other locks are held on the</span>
<a name="l01334"></a>01334 <span class="comment">  ** database. </span>
<a name="l01335"></a>01335 <span class="comment">  **</span>
<a name="l01336"></a>01336 <span class="comment">  ** The reason a single byte cannot be used instead of the &apos;shared byte</span>
<a name="l01337"></a>01337 <span class="comment">  ** range&apos; is that some versions of windows do not support read-locks. By</span>
<a name="l01338"></a>01338 <span class="comment">  ** locking a random byte from a range, concurrent SHARED locks may exist</span>
<a name="l01339"></a>01339 <span class="comment">  ** even if the locking primitive used is always a write-lock.</span>
<a name="l01340"></a>01340 <span class="comment">  */</span>
<a name="l01341"></a>01341   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01342"></a>01342   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l01343"></a>01343   <span class="keyword">struct </span><a class="code" href="structlockInfo.html">lockInfo</a> *pLock = pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>;
<a name="l01344"></a>01344   <span class="keyword">struct </span>flock lock;
<a name="l01345"></a>01345   <span class="keywordtype">int</span> s;
<a name="l01346"></a>01346 
<a name="l01347"></a>01347   assert( pFile );
<a name="l01348"></a>01348   <a class="code" href="os__common_8h.html#ab43d0c360030f1674520760dec562472">OSTRACE7</a>(<span class="stringliteral">&quot;LOCK    %d %s was %s(%s,%d) pid=%d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>,
<a name="l01349"></a>01349       locktypeName(locktype), locktypeName(pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>),
<a name="l01350"></a>01350       locktypeName(pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>), pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a> , getpid());
<a name="l01351"></a>01351 
<a name="l01352"></a>01352   <span class="comment">/* If there is already a lock of this type or more restrictive on the</span>
<a name="l01353"></a>01353 <span class="comment">  ** unixFile, do nothing. Don&apos;t use the end_lock: exit path, as</span>
<a name="l01354"></a>01354 <span class="comment">  ** enterMutex() hasn&apos;t been called yet.</span>
<a name="l01355"></a>01355 <span class="comment">  */</span>
<a name="l01356"></a>01356   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&gt;=locktype ){
<a name="l01357"></a>01357     <a class="code" href="os__common_8h.html#ae313dfb2a2a4e2f558bdde36da4f1f53">OSTRACE3</a>(<span class="stringliteral">&quot;LOCK    %d %s ok (already held)\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>,
<a name="l01358"></a>01358             locktypeName(locktype));
<a name="l01359"></a>01359     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01360"></a>01360   }
<a name="l01361"></a>01361 
<a name="l01362"></a>01362   <span class="comment">/* Make sure the locking sequence is correct</span>
<a name="l01363"></a>01363 <span class="comment">  */</span>
<a name="l01364"></a>01364   assert( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>!=<a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a> || locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> );
<a name="l01365"></a>01365   assert( locktype!=<a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a> );
<a name="l01366"></a>01366   assert( locktype!=<a class="code" href="os_8h.html#a4fec7ca081b31fb9e121208e2b57fe3f">RESERVED_LOCK</a> || pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> );
<a name="l01367"></a>01367 
<a name="l01368"></a>01368   <span class="comment">/* This mutex is needed because pFile-&gt;pLock is shared across threads</span>
<a name="l01369"></a>01369 <span class="comment">  */</span>
<a name="l01370"></a>01370   <a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">enterMutex</a>();
<a name="l01371"></a>01371 
<a name="l01372"></a>01372   <span class="comment">/* Make sure the current thread owns the pFile.</span>
<a name="l01373"></a>01373 <span class="comment">  */</span>
<a name="l01374"></a>01374   rc = <a class="code" href="os__unix_8c.html#aa2937e958de961aa2fa5498b73f01bdd">transferOwnership</a>(pFile);
<a name="l01375"></a>01375   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01376"></a>01376     <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l01377"></a>01377     <span class="keywordflow">return</span> rc;
<a name="l01378"></a>01378   }
<a name="l01379"></a>01379   pLock = pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>;
<a name="l01380"></a>01380 
<a name="l01381"></a>01381   <span class="comment">/* If some thread using this PID has a lock via a different unixFile*</span>
<a name="l01382"></a>01382 <span class="comment">  ** handle that precludes the requested lock, return BUSY.</span>
<a name="l01383"></a>01383 <span class="comment">  */</span>
<a name="l01384"></a>01384   <span class="keywordflow">if</span>( (pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>!=pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a> &amp;&amp; 
<a name="l01385"></a>01385           (pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>&gt;=<a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a> || locktype&gt;<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a>))
<a name="l01386"></a>01386   ){
<a name="l01387"></a>01387     rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l01388"></a>01388     <span class="keywordflow">goto</span> end_lock;
<a name="l01389"></a>01389   }
<a name="l01390"></a>01390 
<a name="l01391"></a>01391   <span class="comment">/* If a SHARED lock is requested, and some thread using this PID already</span>
<a name="l01392"></a>01392 <span class="comment">  ** has a SHARED or RESERVED lock, then increment reference counts and</span>
<a name="l01393"></a>01393 <span class="comment">  ** return SQLITE_OK.</span>
<a name="l01394"></a>01394 <span class="comment">  */</span>
<a name="l01395"></a>01395   <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> &amp;&amp; 
<a name="l01396"></a>01396       (pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> || pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>==<a class="code" href="os_8h.html#a4fec7ca081b31fb9e121208e2b57fe3f">RESERVED_LOCK</a>) ){
<a name="l01397"></a>01397     assert( locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> );
<a name="l01398"></a>01398     assert( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>==0 );
<a name="l01399"></a>01399     assert( pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>&gt;0 );
<a name="l01400"></a>01400     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = <a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a>;
<a name="l01401"></a>01401     pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>++;
<a name="l01402"></a>01402     pFile-&gt;<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a>-&gt;<a class="code" href="structopenCnt.html#a5e983b497cde9da853ac084f37671672">nLock</a>++;
<a name="l01403"></a>01403     <span class="keywordflow">goto</span> end_lock;
<a name="l01404"></a>01404   }
<a name="l01405"></a>01405 
<a name="l01406"></a>01406   lock.l_len = 1L;
<a name="l01407"></a>01407 
<a name="l01408"></a>01408   lock.l_whence = SEEK_SET;
<a name="l01409"></a>01409 
<a name="l01410"></a>01410   <span class="comment">/* A PENDING lock is needed before acquiring a SHARED lock and before</span>
<a name="l01411"></a>01411 <span class="comment">  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will</span>
<a name="l01412"></a>01412 <span class="comment">  ** be released.</span>
<a name="l01413"></a>01413 <span class="comment">  */</span>
<a name="l01414"></a>01414   <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> 
<a name="l01415"></a>01415       || (locktype==<a class="code" href="os_8h.html#ae17e1f5c17b52ec543aefca2a0b6b0f2">EXCLUSIVE_LOCK</a> &amp;&amp; pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&lt;<a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a>)
<a name="l01416"></a>01416   ){
<a name="l01417"></a>01417     lock.l_type = (locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a>?F_RDLCK:F_WRLCK);
<a name="l01418"></a>01418     lock.l_start = <a class="code" href="os_8h.html#a8cca202223a66c75a8bea6dabf8de43b">PENDING_BYTE</a>;
<a name="l01419"></a>01419     s = fcntl(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, F_SETLK, &amp;lock);
<a name="l01420"></a>01420     <span class="keywordflow">if</span>( s==(-1) ){
<a name="l01421"></a>01421       <span class="keywordtype">int</span> tErrno = errno;
<a name="l01422"></a>01422       rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a77ac56b2a8025538d73aa6379c82b4af">SQLITE_IOERR_LOCK</a>);
<a name="l01423"></a>01423       <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l01424"></a>01424         pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l01425"></a>01425       }
<a name="l01426"></a>01426       <span class="keywordflow">goto</span> end_lock;
<a name="l01427"></a>01427     }
<a name="l01428"></a>01428   }
<a name="l01429"></a>01429 
<a name="l01430"></a>01430 
<a name="l01431"></a>01431   <span class="comment">/* If control gets to this point, then actually go ahead and make</span>
<a name="l01432"></a>01432 <span class="comment">  ** operating system calls for the specified lock.</span>
<a name="l01433"></a>01433 <span class="comment">  */</span>
<a name="l01434"></a>01434   <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l01435"></a>01435     <span class="keywordtype">int</span> tErrno = 0;
<a name="l01436"></a>01436     assert( pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>==0 );
<a name="l01437"></a>01437     assert( pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>==0 );
<a name="l01438"></a>01438 
<a name="l01439"></a>01439     <span class="comment">/* Now get the read-lock */</span>
<a name="l01440"></a>01440     lock.l_start = <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a>;
<a name="l01441"></a>01441     lock.l_len = <a class="code" href="os_8h.html#a232fb4f165a3ecb4a9e5f2a7f1f45a19">SHARED_SIZE</a>;
<a name="l01442"></a>01442     <span class="keywordflow">if</span>( (s = fcntl(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, F_SETLK, &amp;lock))==(-1) ){
<a name="l01443"></a>01443       tErrno = errno;
<a name="l01444"></a>01444     }
<a name="l01445"></a>01445     <span class="comment">/* Drop the temporary PENDING lock */</span>
<a name="l01446"></a>01446     lock.l_start = <a class="code" href="os_8h.html#a8cca202223a66c75a8bea6dabf8de43b">PENDING_BYTE</a>;
<a name="l01447"></a>01447     lock.l_len = 1L;
<a name="l01448"></a>01448     lock.l_type = F_UNLCK;
<a name="l01449"></a>01449     <span class="keywordflow">if</span>( fcntl(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, F_SETLK, &amp;lock)!=0 ){
<a name="l01450"></a>01450       <span class="keywordflow">if</span>( s != -1 ){
<a name="l01451"></a>01451         <span class="comment">/* This could happen with a network mount */</span>
<a name="l01452"></a>01452         tErrno = errno; 
<a name="l01453"></a>01453         rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a820929b6588051fa0eefaf4639bd8536">SQLITE_IOERR_UNLOCK</a>); 
<a name="l01454"></a>01454         <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l01455"></a>01455           pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l01456"></a>01456         }
<a name="l01457"></a>01457         <span class="keywordflow">goto</span> end_lock;
<a name="l01458"></a>01458       }
<a name="l01459"></a>01459     }
<a name="l01460"></a>01460     <span class="keywordflow">if</span>( s==(-1) ){
<a name="l01461"></a>01461       rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a77ac56b2a8025538d73aa6379c82b4af">SQLITE_IOERR_LOCK</a>);
<a name="l01462"></a>01462       <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l01463"></a>01463         pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l01464"></a>01464       }
<a name="l01465"></a>01465     }<span class="keywordflow">else</span>{
<a name="l01466"></a>01466       pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = <a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a>;
<a name="l01467"></a>01467       pFile-&gt;<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a>-&gt;<a class="code" href="structopenCnt.html#a5e983b497cde9da853ac084f37671672">nLock</a>++;
<a name="l01468"></a>01468       pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a> = 1;
<a name="l01469"></a>01469     }
<a name="l01470"></a>01470   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#ae17e1f5c17b52ec543aefca2a0b6b0f2">EXCLUSIVE_LOCK</a> &amp;&amp; pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>&gt;1 ){
<a name="l01471"></a>01471     <span class="comment">/* We are trying for an exclusive lock but another thread in this</span>
<a name="l01472"></a>01472 <span class="comment">    ** same process is still holding a shared lock. */</span>
<a name="l01473"></a>01473     rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l01474"></a>01474   }<span class="keywordflow">else</span>{
<a name="l01475"></a>01475     <span class="comment">/* The request was for a RESERVED or EXCLUSIVE lock.  It is</span>
<a name="l01476"></a>01476 <span class="comment">    ** assumed that there is a SHARED or greater lock on the file</span>
<a name="l01477"></a>01477 <span class="comment">    ** already.</span>
<a name="l01478"></a>01478 <span class="comment">    */</span>
<a name="l01479"></a>01479     assert( 0!=pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> );
<a name="l01480"></a>01480     lock.l_type = F_WRLCK;
<a name="l01481"></a>01481     <span class="keywordflow">switch</span>( locktype ){
<a name="l01482"></a>01482       <span class="keywordflow">case</span> <a class="code" href="os_8h.html#a4fec7ca081b31fb9e121208e2b57fe3f">RESERVED_LOCK</a>:
<a name="l01483"></a>01483         lock.l_start = <a class="code" href="os_8h.html#a8ac9fa3da7151dc5ffd9fbf0563a9417">RESERVED_BYTE</a>;
<a name="l01484"></a>01484         <span class="keywordflow">break</span>;
<a name="l01485"></a>01485       <span class="keywordflow">case</span> <a class="code" href="os_8h.html#ae17e1f5c17b52ec543aefca2a0b6b0f2">EXCLUSIVE_LOCK</a>:
<a name="l01486"></a>01486         lock.l_start = <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a>;
<a name="l01487"></a>01487         lock.l_len = <a class="code" href="os_8h.html#a232fb4f165a3ecb4a9e5f2a7f1f45a19">SHARED_SIZE</a>;
<a name="l01488"></a>01488         <span class="keywordflow">break</span>;
<a name="l01489"></a>01489       <span class="keywordflow">default</span>:
<a name="l01490"></a>01490         assert(0);
<a name="l01491"></a>01491     }
<a name="l01492"></a>01492     s = fcntl(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, F_SETLK, &amp;lock);
<a name="l01493"></a>01493     <span class="keywordflow">if</span>( s==(-1) ){
<a name="l01494"></a>01494       <span class="keywordtype">int</span> tErrno = errno;
<a name="l01495"></a>01495       rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a77ac56b2a8025538d73aa6379c82b4af">SQLITE_IOERR_LOCK</a>);
<a name="l01496"></a>01496       <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l01497"></a>01497         pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l01498"></a>01498       }
<a name="l01499"></a>01499     }
<a name="l01500"></a>01500   }
<a name="l01501"></a>01501   
<a name="l01502"></a>01502   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01503"></a>01503     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l01504"></a>01504     pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a> = locktype;
<a name="l01505"></a>01505   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#ae17e1f5c17b52ec543aefca2a0b6b0f2">EXCLUSIVE_LOCK</a> ){
<a name="l01506"></a>01506     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = <a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a>;
<a name="l01507"></a>01507     pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a> = <a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a>;
<a name="l01508"></a>01508   }
<a name="l01509"></a>01509 
<a name="l01510"></a>01510 end_lock:
<a name="l01511"></a>01511   <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l01512"></a>01512   <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;LOCK    %d %s %s\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, locktypeName(locktype), 
<a name="l01513"></a>01513       rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ? <span class="stringliteral">&quot;ok&quot;</span> : <span class="stringliteral">&quot;failed&quot;</span>);
<a name="l01514"></a>01514   <span class="keywordflow">return</span> rc;
<a name="l01515"></a>01515 }
<a name="l01516"></a>01516 
<a name="l01517"></a>01517 <span class="comment">/*</span>
<a name="l01518"></a>01518 <span class="comment">** Lower the locking level on file descriptor pFile to locktype.  locktype</span>
<a name="l01519"></a>01519 <span class="comment">** must be either NO_LOCK or SHARED_LOCK.</span>
<a name="l01520"></a>01520 <span class="comment">**</span>
<a name="l01521"></a>01521 <span class="comment">** If the locking level of the file descriptor is already at or below</span>
<a name="l01522"></a>01522 <span class="comment">** the requested locking level, this routine is a no-op.</span>
<a name="l01523"></a>01523 <span class="comment">*/</span>
<a name="l01524"></a><a class="code" href="os__unix_8c.html#a981f68c7151f8de198cdc10f17db9165">01524</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a981f68c7151f8de198cdc10f17db9165">unixUnlock</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype){
<a name="l01525"></a>01525   <span class="keyword">struct </span><a class="code" href="structlockInfo.html">lockInfo</a> *pLock;
<a name="l01526"></a>01526   <span class="keyword">struct </span>flock lock;
<a name="l01527"></a>01527   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01528"></a>01528   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l01529"></a>01529   <span class="keywordtype">int</span> h;
<a name="l01530"></a>01530 
<a name="l01531"></a>01531   assert( pFile );
<a name="l01532"></a>01532   <a class="code" href="os__common_8h.html#ab43d0c360030f1674520760dec562472">OSTRACE7</a>(<span class="stringliteral">&quot;UNLOCK  %d %d was %d(%d,%d) pid=%d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, locktype,
<a name="l01533"></a>01533       pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>, pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>, pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>, getpid());
<a name="l01534"></a>01534 
<a name="l01535"></a>01535   assert( locktype&lt;=<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> );
<a name="l01536"></a>01536   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&lt;=locktype ){
<a name="l01537"></a>01537     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01538"></a>01538   }
<a name="l01539"></a>01539   <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#a6fab1db0dc95bfe9c7d2910c3da2eb97">CHECK_THREADID</a>(pFile) ){
<a name="l01540"></a>01540     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a34f01e4ee909e6b68be040868f7503bc">SQLITE_MISUSE</a>;
<a name="l01541"></a>01541   }
<a name="l01542"></a>01542   <a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">enterMutex</a>();
<a name="l01543"></a>01543   h = pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>;
<a name="l01544"></a>01544   pLock = pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>;
<a name="l01545"></a>01545   assert( pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>!=0 );
<a name="l01546"></a>01546   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&gt;<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l01547"></a>01547     assert( pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a>==pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> );
<a name="l01548"></a>01548     <a class="code" href="os__common_8h.html#a5505f25ad3336193be111a39a3fe533b">SimulateIOErrorBenign</a>(1);
<a name="l01549"></a>01549     <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( h=(-1) )
<a name="l01550"></a>01550     <a class="code" href="os__common_8h.html#a5505f25ad3336193be111a39a3fe533b">SimulateIOErrorBenign</a>(0);
<a name="l01551"></a>01551     <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l01552"></a>01552       lock.l_type = F_RDLCK;
<a name="l01553"></a>01553       lock.l_whence = SEEK_SET;
<a name="l01554"></a>01554       lock.l_start = <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a>;
<a name="l01555"></a>01555       lock.l_len = <a class="code" href="os_8h.html#a232fb4f165a3ecb4a9e5f2a7f1f45a19">SHARED_SIZE</a>;
<a name="l01556"></a>01556       <span class="keywordflow">if</span>( fcntl(h, F_SETLK, &amp;lock)==(-1) ){
<a name="l01557"></a>01557         <span class="keywordtype">int</span> tErrno = errno;
<a name="l01558"></a>01558         rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#ac77b3fcb607278f465c223580601b5cc">SQLITE_IOERR_RDLOCK</a>);
<a name="l01559"></a>01559         <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l01560"></a>01560           pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l01561"></a>01561         }
<a name="l01562"></a>01562         <span class="keywordflow">goto</span> end_unlock;
<a name="l01563"></a>01563       }
<a name="l01564"></a>01564     }
<a name="l01565"></a>01565     lock.l_type = F_UNLCK;
<a name="l01566"></a>01566     lock.l_whence = SEEK_SET;
<a name="l01567"></a>01567     lock.l_start = <a class="code" href="os_8h.html#a8cca202223a66c75a8bea6dabf8de43b">PENDING_BYTE</a>;
<a name="l01568"></a>01568     lock.l_len = 2L;  assert( <a class="code" href="os_8h.html#a8cca202223a66c75a8bea6dabf8de43b">PENDING_BYTE</a>+1==<a class="code" href="os_8h.html#a8ac9fa3da7151dc5ffd9fbf0563a9417">RESERVED_BYTE</a> );
<a name="l01569"></a>01569     <span class="keywordflow">if</span>( fcntl(h, F_SETLK, &amp;lock)!=(-1) ){
<a name="l01570"></a>01570       pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a> = <a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a>;
<a name="l01571"></a>01571     }<span class="keywordflow">else</span>{
<a name="l01572"></a>01572       <span class="keywordtype">int</span> tErrno = errno;
<a name="l01573"></a>01573       rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a820929b6588051fa0eefaf4639bd8536">SQLITE_IOERR_UNLOCK</a>);
<a name="l01574"></a>01574       <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l01575"></a>01575         pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l01576"></a>01576       }
<a name="l01577"></a>01577       <span class="keywordflow">goto</span> end_unlock;
<a name="l01578"></a>01578     }
<a name="l01579"></a>01579   }
<a name="l01580"></a>01580   <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a> ){
<a name="l01581"></a>01581     <span class="keyword">struct </span><a class="code" href="structopenCnt.html">openCnt</a> *pOpen;
<a name="l01582"></a>01582 
<a name="l01583"></a>01583     <span class="comment">/* Decrement the shared lock counter.  Release the lock using an</span>
<a name="l01584"></a>01584 <span class="comment">    ** OS call only when all threads in this same process have released</span>
<a name="l01585"></a>01585 <span class="comment">    ** the lock.</span>
<a name="l01586"></a>01586 <span class="comment">    */</span>
<a name="l01587"></a>01587     pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>--;
<a name="l01588"></a>01588     <span class="keywordflow">if</span>( pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a>==0 ){
<a name="l01589"></a>01589       lock.l_type = F_UNLCK;
<a name="l01590"></a>01590       lock.l_whence = SEEK_SET;
<a name="l01591"></a>01591       lock.l_start = lock.l_len = 0L;
<a name="l01592"></a>01592       <a class="code" href="os__common_8h.html#a5505f25ad3336193be111a39a3fe533b">SimulateIOErrorBenign</a>(1);
<a name="l01593"></a>01593       <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( h=(-1) )
<a name="l01594"></a>01594       <a class="code" href="os__common_8h.html#a5505f25ad3336193be111a39a3fe533b">SimulateIOErrorBenign</a>(0);
<a name="l01595"></a>01595       <span class="keywordflow">if</span>( fcntl(h, F_SETLK, &amp;lock)!=(-1) ){
<a name="l01596"></a>01596         pLock-&gt;<a class="code" href="structlockInfo.html#ae21c769da1ea0a0eb7f513dcc421c20b">locktype</a> = <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>;
<a name="l01597"></a>01597       }<span class="keywordflow">else</span>{
<a name="l01598"></a>01598         <span class="keywordtype">int</span> tErrno = errno;
<a name="l01599"></a>01599         rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a820929b6588051fa0eefaf4639bd8536">SQLITE_IOERR_UNLOCK</a>);
<a name="l01600"></a>01600         <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l01601"></a>01601           pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l01602"></a>01602         }
<a name="l01603"></a>01603         pLock-&gt;<a class="code" href="structlockInfo.html#a56d5dcac8faa44c2fef0b6ea32a049cd">cnt</a> = 1;
<a name="l01604"></a>01604         <span class="keywordflow">goto</span> end_unlock;
<a name="l01605"></a>01605       }
<a name="l01606"></a>01606     }
<a name="l01607"></a>01607 
<a name="l01608"></a>01608     <span class="comment">/* Decrement the count of locks against this same file.  When the</span>
<a name="l01609"></a>01609 <span class="comment">    ** count reaches zero, close any other file descriptors whose close</span>
<a name="l01610"></a>01610 <span class="comment">    ** was deferred because of outstanding locks.</span>
<a name="l01611"></a>01611 <span class="comment">    */</span>
<a name="l01612"></a>01612     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01613"></a>01613       pOpen = pFile-&gt;<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a>;
<a name="l01614"></a>01614       pOpen-&gt;<a class="code" href="structopenCnt.html#a5e983b497cde9da853ac084f37671672">nLock</a>--;
<a name="l01615"></a>01615       assert( pOpen-&gt;<a class="code" href="structopenCnt.html#a5e983b497cde9da853ac084f37671672">nLock</a>&gt;=0 );
<a name="l01616"></a>01616       <span class="keywordflow">if</span>( pOpen-&gt;<a class="code" href="structopenCnt.html#a5e983b497cde9da853ac084f37671672">nLock</a>==0 &amp;&amp; pOpen-&gt;<a class="code" href="structopenCnt.html#ade6bde37c50b252302236be3417bfd1a">nPending</a>&gt;0 ){
<a name="l01617"></a>01617         <span class="keywordtype">int</span> i;
<a name="l01618"></a>01618         <span class="keywordflow">for</span>(i=0; i&lt;pOpen-&gt;<a class="code" href="structopenCnt.html#ade6bde37c50b252302236be3417bfd1a">nPending</a>; i++){
<a name="l01619"></a>01619           close(pOpen-&gt;<a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">aPending</a>[i]);
<a name="l01620"></a>01620         }
<a name="l01621"></a>01621         <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pOpen-&gt;<a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">aPending</a>);
<a name="l01622"></a>01622         pOpen-&gt;<a class="code" href="structopenCnt.html#ade6bde37c50b252302236be3417bfd1a">nPending</a> = 0;
<a name="l01623"></a>01623         pOpen-&gt;<a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">aPending</a> = 0;
<a name="l01624"></a>01624       }
<a name="l01625"></a>01625     }
<a name="l01626"></a>01626   }
<a name="l01627"></a>01627   
<a name="l01628"></a>01628 end_unlock:
<a name="l01629"></a>01629   <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l01630"></a>01630   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l01631"></a>01631   <span class="keywordflow">return</span> rc;
<a name="l01632"></a>01632 }
<a name="l01633"></a>01633 
<a name="l01634"></a>01634 <span class="comment">/*</span>
<a name="l01635"></a>01635 <span class="comment">** This function performs the parts of the &quot;close file&quot; operation </span>
<a name="l01636"></a>01636 <span class="comment">** common to all locking schemes. It closes the directory and file</span>
<a name="l01637"></a>01637 <span class="comment">** handles, if they are valid, and sets all fields of the unixFile</span>
<a name="l01638"></a>01638 <span class="comment">** structure to 0.</span>
<a name="l01639"></a>01639 <span class="comment">*/</span>
<a name="l01640"></a><a class="code" href="os__unix_8c.html#ac11bfe29d9353ee80f95a520e83f997f">01640</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#ac11bfe29d9353ee80f95a520e83f997f">closeUnixFile</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>){
<a name="l01641"></a>01641   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l01642"></a>01642   <span class="keywordflow">if</span>( pFile ){
<a name="l01643"></a>01643     <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">dirfd</a>&gt;=0 ){
<a name="l01644"></a>01644       close(pFile-&gt;<a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">dirfd</a>);
<a name="l01645"></a>01645     }
<a name="l01646"></a>01646     <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>&gt;=0 ){
<a name="l01647"></a>01647       close(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>);
<a name="l01648"></a>01648     }
<a name="l01649"></a>01649     <a class="code" href="os__common_8h.html#ae032fbc19c8939ba2570640ebdf847d7">OSTRACE2</a>(<span class="stringliteral">&quot;CLOSE   %-3d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>);
<a name="l01650"></a>01650     <a class="code" href="os__common_8h.html#ab93b1fae5a1c8274ed324c698aa46f0d">OpenCounter</a>(-1);
<a name="l01651"></a>01651     memset(pFile, 0, <span class="keyword">sizeof</span>(<a class="code" href="structunixFile.html">unixFile</a>));
<a name="l01652"></a>01652   }
<a name="l01653"></a>01653   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01654"></a>01654 }
<a name="l01655"></a>01655 
<a name="l01656"></a>01656 <span class="comment">/*</span>
<a name="l01657"></a>01657 <span class="comment">** Close a file.</span>
<a name="l01658"></a>01658 <span class="comment">*/</span>
<a name="l01659"></a><a class="code" href="os__unix_8c.html#a84cdb6e4ff75f085e8c05dfdec178927">01659</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a84cdb6e4ff75f085e8c05dfdec178927">unixClose</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>){
<a name="l01660"></a>01660   <span class="keywordflow">if</span>( <span class="keywordtype">id</span> ){
<a name="l01661"></a>01661     <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a> *)<span class="keywordtype">id</span>;
<a name="l01662"></a>01662     <a class="code" href="os__unix_8c.html#a981f68c7151f8de198cdc10f17db9165">unixUnlock</a>(<span class="keywordtype">id</span>, <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>);
<a name="l01663"></a>01663     <a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">enterMutex</a>();
<a name="l01664"></a>01664     <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a> &amp;&amp; pFile-&gt;<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a>-&gt;<a class="code" href="structopenCnt.html#a5e983b497cde9da853ac084f37671672">nLock</a> ){
<a name="l01665"></a>01665       <span class="comment">/* If there are outstanding locks, do not actually close the file just</span>
<a name="l01666"></a>01666 <span class="comment">      ** yet because that would clear those locks.  Instead, add the file</span>
<a name="l01667"></a>01667 <span class="comment">      ** descriptor to pOpen-&gt;aPending.  It will be automatically closed when</span>
<a name="l01668"></a>01668 <span class="comment">      ** the last lock is cleared.</span>
<a name="l01669"></a>01669 <span class="comment">      */</span>
<a name="l01670"></a>01670       <span class="keywordtype">int</span> *aNew;
<a name="l01671"></a>01671       <span class="keyword">struct </span><a class="code" href="structopenCnt.html">openCnt</a> *pOpen = pFile-&gt;<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a>;
<a name="l01672"></a>01672       aNew = <a class="code" href="malloc_8c.html#a478028442c2ce4635eac464d47465c8f">sqlite3_realloc</a>(pOpen-&gt;<a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">aPending</a>, (pOpen-&gt;<a class="code" href="structopenCnt.html#ade6bde37c50b252302236be3417bfd1a">nPending</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) );
<a name="l01673"></a>01673       <span class="keywordflow">if</span>( aNew==0 ){
<a name="l01674"></a>01674         <span class="comment">/* If a malloc fails, just leak the file descriptor */</span>
<a name="l01675"></a>01675       }<span class="keywordflow">else</span>{
<a name="l01676"></a>01676         pOpen-&gt;<a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">aPending</a> = aNew;
<a name="l01677"></a>01677         pOpen-&gt;<a class="code" href="structopenCnt.html#a88d25a6290aa527fffd3d810b0b39b6b">aPending</a>[pOpen-&gt;<a class="code" href="structopenCnt.html#ade6bde37c50b252302236be3417bfd1a">nPending</a>] = pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>;
<a name="l01678"></a>01678         pOpen-&gt;<a class="code" href="structopenCnt.html#ade6bde37c50b252302236be3417bfd1a">nPending</a>++;
<a name="l01679"></a>01679         pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a> = -1;
<a name="l01680"></a>01680       }
<a name="l01681"></a>01681     }
<a name="l01682"></a>01682     <a class="code" href="os__unix_8c.html#acfe59f061bfafcd4816ff5710188dabd">releaseLockInfo</a>(pFile-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>);
<a name="l01683"></a>01683     <a class="code" href="os__unix_8c.html#a7ec308b95f37ed455660ac843ff7c7a6">releaseOpenCnt</a>(pFile-&gt;<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a>);
<a name="l01684"></a>01684     <a class="code" href="os__unix_8c.html#ac11bfe29d9353ee80f95a520e83f997f">closeUnixFile</a>(<span class="keywordtype">id</span>);
<a name="l01685"></a>01685     <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l01686"></a>01686   }
<a name="l01687"></a>01687   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01688"></a>01688 }
<a name="l01689"></a>01689 
<a name="l01690"></a>01690 
<a name="l01691"></a>01691 <span class="preprocessor">#if SQLITE_ENABLE_LOCKING_STYLE</span>
<a name="l01692"></a>01692 <span class="preprocessor"></span><span class="preprocessor">#pragma mark AFP Support</span>
<a name="l01693"></a>01693 <span class="preprocessor"></span>
<a name="l01694"></a>01694 <span class="comment">/*</span>
<a name="l01695"></a>01695 <span class="comment"> ** The afpLockingContext structure contains all afp lock specific state</span>
<a name="l01696"></a>01696 <span class="comment"> */</span>
<a name="l01697"></a>01697 <span class="keyword">typedef</span> <span class="keyword">struct </span>afpLockingContext afpLockingContext;
<a name="l01698"></a>01698 <span class="keyword">struct </span>afpLockingContext {
<a name="l01699"></a>01699   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> sharedLockByte;
<a name="l01700"></a>01700   <span class="keyword">const</span> <span class="keywordtype">char</span> *filePath;
<a name="l01701"></a>01701 };
<a name="l01702"></a>01702 
<a name="l01703"></a>01703 <span class="keyword">struct </span>ByteRangeLockPB2
<a name="l01704"></a>01704 {
<a name="l01705"></a>01705   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> offset;        <span class="comment">/* offset to first byte to lock */</span>
<a name="l01706"></a>01706   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> length;        <span class="comment">/* nbr of bytes to lock */</span>
<a name="l01707"></a>01707   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> retRangeStart; <span class="comment">/* nbr of 1st byte locked if successful */</span>
<a name="l01708"></a>01708   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> unLockFlag;         <span class="comment">/* 1 = unlock, 0 = lock */</span>
<a name="l01709"></a>01709   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> startEndFlag;       <span class="comment">/* 1=rel to end of fork, 0=rel to start */</span>
<a name="l01710"></a>01710   <span class="keywordtype">int</span> fd;                           <span class="comment">/* file desc to assoc this lock with */</span>
<a name="l01711"></a>01711 };
<a name="l01712"></a>01712 
<a name="l01713"></a>01713 <span class="preprocessor">#define afpfsByteRangeLock2FSCTL        _IOWR(&apos;z&apos;, 23, struct ByteRangeLockPB2)</span>
<a name="l01714"></a>01714 <span class="preprocessor"></span>
<a name="l01715"></a>01715 <span class="comment">/* </span>
<a name="l01716"></a>01716 <span class="comment"> ** Return SQLITE_OK on success, SQLITE_BUSY on failure.</span>
<a name="l01717"></a>01717 <span class="comment"> */</span>
<a name="l01718"></a>01718 <span class="keyword">static</span> <span class="keywordtype">int</span> _AFPFSSetLock(
<a name="l01719"></a>01719   <span class="keyword">const</span> <span class="keywordtype">char</span> *path, 
<a name="l01720"></a>01720   <a class="code" href="structunixFile.html">unixFile</a> *pFile, 
<a name="l01721"></a>01721   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> offset, 
<a name="l01722"></a>01722   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> length, 
<a name="l01723"></a>01723   <span class="keywordtype">int</span> setLockFlag
<a name="l01724"></a>01724 ){
<a name="l01725"></a>01725   <span class="keyword">struct </span>ByteRangeLockPB2       pb;
<a name="l01726"></a>01726   <span class="keywordtype">int</span>                     err;
<a name="l01727"></a>01727   
<a name="l01728"></a>01728   pb.unLockFlag = setLockFlag ? 0 : 1;
<a name="l01729"></a>01729   pb.startEndFlag = 0;
<a name="l01730"></a>01730   pb.offset = offset;
<a name="l01731"></a>01731   pb.length = length; 
<a name="l01732"></a>01732   pb.fd = pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>;
<a name="l01733"></a>01733   <a class="code" href="os__common_8h.html#a0353521cd993c4ca92f8bb3d7a8f4d53">OSTRACE5</a>(<span class="stringliteral">&quot;AFPLOCK setting lock %s for %d in range %llx:%llx\n&quot;</span>, 
<a name="l01734"></a>01734     (setLockFlag?<span class="stringliteral">&quot;ON&quot;</span>:<span class="stringliteral">&quot;OFF&quot;</span>), pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, offset, length);
<a name="l01735"></a>01735   err = fsctl(path, afpfsByteRangeLock2FSCTL, &amp;pb, 0);
<a name="l01736"></a>01736   <span class="keywordflow">if</span> ( err==-1 ) {
<a name="l01737"></a>01737     <span class="keywordtype">int</span> rc;
<a name="l01738"></a>01738     <span class="keywordtype">int</span> tErrno = errno;
<a name="l01739"></a>01739     <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;AFPLOCK failed to fsctl() &apos;%s&apos; %d %s\n&quot;</span>, path, tErrno, strerror(tErrno));
<a name="l01740"></a>01740     rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, setLockFlag ? <a class="code" href="sqlite3_8h.html#a77ac56b2a8025538d73aa6379c82b4af">SQLITE_IOERR_LOCK</a> : <a class="code" href="sqlite3_8h.html#a820929b6588051fa0eefaf4639bd8536">SQLITE_IOERR_UNLOCK</a>); <span class="comment">/* error */</span>
<a name="l01741"></a>01741     <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l01742"></a>01742       pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l01743"></a>01743     }
<a name="l01744"></a>01744     <span class="keywordflow">return</span> rc;
<a name="l01745"></a>01745   } <span class="keywordflow">else</span> {
<a name="l01746"></a>01746     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01747"></a>01747   }
<a name="l01748"></a>01748 }
<a name="l01749"></a>01749 
<a name="l01750"></a>01750 <span class="comment">/* AFP-style reserved lock checking following the behavior of </span>
<a name="l01751"></a>01751 <span class="comment">** unixCheckReservedLock, see the unixCheckReservedLock function comments */</span>
<a name="l01752"></a>01752 <span class="keyword">static</span> <span class="keywordtype">int</span> afpCheckReservedLock(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> *pResOut){
<a name="l01753"></a>01753   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01754"></a>01754   <span class="keywordtype">int</span> reserved = 0;
<a name="l01755"></a>01755   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l01756"></a>01756   
<a name="l01757"></a>01757   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#af165990c0a93e69d7e66f5f0cb7fd7bb">SQLITE_IOERR_CHECKRESERVEDLOCK</a>; );
<a name="l01758"></a>01758   
<a name="l01759"></a>01759   assert( pFile );
<a name="l01760"></a>01760   afpLockingContext *context = (afpLockingContext *) pFile-&gt;lockingContext;
<a name="l01761"></a>01761   
<a name="l01762"></a>01762   <span class="comment">/* Check if a thread in this process holds such a lock */</span>
<a name="l01763"></a>01763   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&gt;<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l01764"></a>01764     reserved = 1;
<a name="l01765"></a>01765   }
<a name="l01766"></a>01766   
<a name="l01767"></a>01767   <span class="comment">/* Otherwise see if some other process holds it.</span>
<a name="l01768"></a>01768 <span class="comment">   */</span>
<a name="l01769"></a>01769   <span class="keywordflow">if</span>( !reserved ){
<a name="l01770"></a>01770     <span class="comment">/* lock the RESERVED byte */</span>
<a name="l01771"></a>01771     <span class="keywordtype">int</span> lrc = _AFPFSSetLock(context-&gt;filePath, pFile, <a class="code" href="os_8h.html#a8ac9fa3da7151dc5ffd9fbf0563a9417">RESERVED_BYTE</a>, 1,1);  
<a name="l01772"></a>01772     <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==lrc ){
<a name="l01773"></a>01773       <span class="comment">/* if we succeeded in taking the reserved lock, unlock it to restore</span>
<a name="l01774"></a>01774 <span class="comment">      ** the original state */</span>
<a name="l01775"></a>01775       lrc = _AFPFSSetLock(context-&gt;filePath, pFile, <a class="code" href="os_8h.html#a8ac9fa3da7151dc5ffd9fbf0563a9417">RESERVED_BYTE</a>, 1, 0);
<a name="l01776"></a>01776     } <span class="keywordflow">else</span> {
<a name="l01777"></a>01777       <span class="comment">/* if we failed to get the lock then someone else must have it */</span>
<a name="l01778"></a>01778       reserved = 1;
<a name="l01779"></a>01779     }
<a name="l01780"></a>01780     <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(lrc) ){
<a name="l01781"></a>01781       rc=lrc;
<a name="l01782"></a>01782     }
<a name="l01783"></a>01783   }
<a name="l01784"></a>01784   
<a name="l01785"></a>01785   <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;TEST WR-LOCK %d %d %d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, rc, reserved);
<a name="l01786"></a>01786   
<a name="l01787"></a>01787   *pResOut = reserved;
<a name="l01788"></a>01788   <span class="keywordflow">return</span> rc;
<a name="l01789"></a>01789 }
<a name="l01790"></a>01790 
<a name="l01791"></a>01791 <span class="comment">/* AFP-style locking following the behavior of unixLock, see the unixLock </span>
<a name="l01792"></a>01792 <span class="comment">** function comments for details of lock management. */</span>
<a name="l01793"></a>01793 <span class="keyword">static</span> <span class="keywordtype">int</span> afpLock(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype){
<a name="l01794"></a>01794   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01795"></a>01795   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l01796"></a>01796   afpLockingContext *context = (afpLockingContext *) pFile-&gt;lockingContext;
<a name="l01797"></a>01797   
<a name="l01798"></a>01798   assert( pFile );
<a name="l01799"></a>01799   <a class="code" href="os__common_8h.html#a0353521cd993c4ca92f8bb3d7a8f4d53">OSTRACE5</a>(<span class="stringliteral">&quot;LOCK    %d %s was %s pid=%d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>,
<a name="l01800"></a>01800          locktypeName(locktype), locktypeName(pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>), getpid());
<a name="l01801"></a>01801 
<a name="l01802"></a>01802   <span class="comment">/* If there is already a lock of this type or more restrictive on the</span>
<a name="l01803"></a>01803 <span class="comment">  ** unixFile, do nothing. Don&apos;t use the afp_end_lock: exit path, as</span>
<a name="l01804"></a>01804 <span class="comment">  ** enterMutex() hasn&apos;t been called yet.</span>
<a name="l01805"></a>01805 <span class="comment">  */</span>
<a name="l01806"></a>01806   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&gt;=locktype ){
<a name="l01807"></a>01807     <a class="code" href="os__common_8h.html#ae313dfb2a2a4e2f558bdde36da4f1f53">OSTRACE3</a>(<span class="stringliteral">&quot;LOCK    %d %s ok (already held)\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>,
<a name="l01808"></a>01808            locktypeName(locktype));
<a name="l01809"></a>01809     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01810"></a>01810   }
<a name="l01811"></a>01811 
<a name="l01812"></a>01812   <span class="comment">/* Make sure the locking sequence is correct</span>
<a name="l01813"></a>01813 <span class="comment">  */</span>
<a name="l01814"></a>01814   assert( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>!=<a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a> || locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> );
<a name="l01815"></a>01815   assert( locktype!=<a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a> );
<a name="l01816"></a>01816   assert( locktype!=<a class="code" href="os_8h.html#a4fec7ca081b31fb9e121208e2b57fe3f">RESERVED_LOCK</a> || pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> );
<a name="l01817"></a>01817   
<a name="l01818"></a>01818   <span class="comment">/* This mutex is needed because pFile-&gt;pLock is shared across threads</span>
<a name="l01819"></a>01819 <span class="comment">  */</span>
<a name="l01820"></a>01820   <a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">enterMutex</a>();
<a name="l01821"></a>01821 
<a name="l01822"></a>01822   <span class="comment">/* Make sure the current thread owns the pFile.</span>
<a name="l01823"></a>01823 <span class="comment">  */</span>
<a name="l01824"></a>01824   rc = <a class="code" href="os__unix_8c.html#aa2937e958de961aa2fa5498b73f01bdd">transferOwnership</a>(pFile);
<a name="l01825"></a>01825   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01826"></a>01826     <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l01827"></a>01827     <span class="keywordflow">return</span> rc;
<a name="l01828"></a>01828   }
<a name="l01829"></a>01829     
<a name="l01830"></a>01830   <span class="comment">/* A PENDING lock is needed before acquiring a SHARED lock and before</span>
<a name="l01831"></a>01831 <span class="comment">  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will</span>
<a name="l01832"></a>01832 <span class="comment">  ** be released.</span>
<a name="l01833"></a>01833 <span class="comment">  */</span>
<a name="l01834"></a>01834   <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> 
<a name="l01835"></a>01835       || (locktype==<a class="code" href="os_8h.html#ae17e1f5c17b52ec543aefca2a0b6b0f2">EXCLUSIVE_LOCK</a> &amp;&amp; pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&lt;<a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a>)
<a name="l01836"></a>01836   ){
<a name="l01837"></a>01837     <span class="keywordtype">int</span> failed;
<a name="l01838"></a>01838     failed = _AFPFSSetLock(context-&gt;filePath, pFile, <a class="code" href="os_8h.html#a8cca202223a66c75a8bea6dabf8de43b">PENDING_BYTE</a>, 1, 1);
<a name="l01839"></a>01839     <span class="keywordflow">if</span> (failed) {
<a name="l01840"></a>01840       rc = failed;
<a name="l01841"></a>01841       <span class="keywordflow">goto</span> afp_end_lock;
<a name="l01842"></a>01842     }
<a name="l01843"></a>01843   }
<a name="l01844"></a>01844   
<a name="l01845"></a>01845   <span class="comment">/* If control gets to this point, then actually go ahead and make</span>
<a name="l01846"></a>01846 <span class="comment">  ** operating system calls for the specified lock.</span>
<a name="l01847"></a>01847 <span class="comment">  */</span>
<a name="l01848"></a>01848   <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l01849"></a>01849     <span class="keywordtype">int</span> lk, lrc1, lrc2, lrc1Errno;
<a name="l01850"></a>01850     
<a name="l01851"></a>01851     <span class="comment">/* Now get the read-lock SHARED_LOCK */</span>
<a name="l01852"></a>01852     <span class="comment">/* note that the quality of the randomness doesn&apos;t matter that much */</span>
<a name="l01853"></a>01853     lk = random(); 
<a name="l01854"></a>01854     context-&gt;sharedLockByte = (lk &amp; 0x7fffffff)%(<a class="code" href="os_8h.html#a232fb4f165a3ecb4a9e5f2a7f1f45a19">SHARED_SIZE</a> - 1);
<a name="l01855"></a>01855     lrc1 = _AFPFSSetLock(context-&gt;filePath, pFile, 
<a name="l01856"></a>01856           <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a>+context-&gt;sharedLockByte, 1, 1);
<a name="l01857"></a>01857     <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(lrc1) ){
<a name="l01858"></a>01858       lrc1Errno = pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a>;
<a name="l01859"></a>01859     }
<a name="l01860"></a>01860     <span class="comment">/* Drop the temporary PENDING lock */</span>
<a name="l01861"></a>01861     lrc2 = _AFPFSSetLock(context-&gt;filePath, pFile, <a class="code" href="os_8h.html#a8cca202223a66c75a8bea6dabf8de43b">PENDING_BYTE</a>, 1, 0);
<a name="l01862"></a>01862     
<a name="l01863"></a>01863     <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(lrc1) ) {
<a name="l01864"></a>01864       pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = lrc1Errno;
<a name="l01865"></a>01865       rc = lrc1;
<a name="l01866"></a>01866       <span class="keywordflow">goto</span> afp_end_lock;
<a name="l01867"></a>01867     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(lrc2) ){
<a name="l01868"></a>01868       rc = lrc2;
<a name="l01869"></a>01869       <span class="keywordflow">goto</span> afp_end_lock;
<a name="l01870"></a>01870     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( lrc1 != <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) {
<a name="l01871"></a>01871       rc = lrc1;
<a name="l01872"></a>01872     } <span class="keywordflow">else</span> {
<a name="l01873"></a>01873       pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = <a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a>;
<a name="l01874"></a>01874     }
<a name="l01875"></a>01875   }<span class="keywordflow">else</span>{
<a name="l01876"></a>01876     <span class="comment">/* The request was for a RESERVED or EXCLUSIVE lock.  It is</span>
<a name="l01877"></a>01877 <span class="comment">    ** assumed that there is a SHARED or greater lock on the file</span>
<a name="l01878"></a>01878 <span class="comment">    ** already.</span>
<a name="l01879"></a>01879 <span class="comment">    */</span>
<a name="l01880"></a>01880     <span class="keywordtype">int</span> failed = 0;
<a name="l01881"></a>01881     assert( 0!=pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> );
<a name="l01882"></a>01882     <span class="keywordflow">if</span> (locktype &gt;= <a class="code" href="os_8h.html#a4fec7ca081b31fb9e121208e2b57fe3f">RESERVED_LOCK</a> &amp;&amp; pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> &lt; <a class="code" href="os_8h.html#a4fec7ca081b31fb9e121208e2b57fe3f">RESERVED_LOCK</a>) {
<a name="l01883"></a>01883         <span class="comment">/* Acquire a RESERVED lock */</span>
<a name="l01884"></a>01884         failed = _AFPFSSetLock(context-&gt;filePath, pFile, <a class="code" href="os_8h.html#a8ac9fa3da7151dc5ffd9fbf0563a9417">RESERVED_BYTE</a>, 1,1);
<a name="l01885"></a>01885     }
<a name="l01886"></a>01886     <span class="keywordflow">if</span> (!failed &amp;&amp; locktype == <a class="code" href="os_8h.html#ae17e1f5c17b52ec543aefca2a0b6b0f2">EXCLUSIVE_LOCK</a>) {
<a name="l01887"></a>01887       <span class="comment">/* Acquire an EXCLUSIVE lock */</span>
<a name="l01888"></a>01888         
<a name="l01889"></a>01889       <span class="comment">/* Remove the shared lock before trying the range.  we&apos;ll need to </span>
<a name="l01890"></a>01890 <span class="comment">      ** reestablish the shared lock if we can&apos;t get the  afpUnlock</span>
<a name="l01891"></a>01891 <span class="comment">      */</span>
<a name="l01892"></a>01892       <span class="keywordflow">if</span> (!(failed = _AFPFSSetLock(context-&gt;filePath, pFile, <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a> +
<a name="l01893"></a>01893                          context-&gt;sharedLockByte, 1, 0))) {
<a name="l01894"></a>01894         <span class="comment">/* now attemmpt to get the exclusive lock range */</span>
<a name="l01895"></a>01895         failed = _AFPFSSetLock(context-&gt;filePath, pFile, <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a>, 
<a name="l01896"></a>01896                                <a class="code" href="os_8h.html#a232fb4f165a3ecb4a9e5f2a7f1f45a19">SHARED_SIZE</a>, 1);
<a name="l01897"></a>01897         <span class="keywordflow">if</span> (failed &amp;&amp; (failed = _AFPFSSetLock(context-&gt;filePath, pFile, 
<a name="l01898"></a>01898                        <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a> + context-&gt;sharedLockByte, 1, 1))) {
<a name="l01899"></a>01899           rc = failed;
<a name="l01900"></a>01900         }
<a name="l01901"></a>01901       } <span class="keywordflow">else</span> {
<a name="l01902"></a>01902         rc = failed; 
<a name="l01903"></a>01903       }
<a name="l01904"></a>01904     }
<a name="l01905"></a>01905     <span class="keywordflow">if</span>( failed ){
<a name="l01906"></a>01906       rc = failed;
<a name="l01907"></a>01907     }
<a name="l01908"></a>01908   }
<a name="l01909"></a>01909   
<a name="l01910"></a>01910   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01911"></a>01911     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l01912"></a>01912   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#ae17e1f5c17b52ec543aefca2a0b6b0f2">EXCLUSIVE_LOCK</a> ){
<a name="l01913"></a>01913     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = <a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a>;
<a name="l01914"></a>01914   }
<a name="l01915"></a>01915   
<a name="l01916"></a>01916 afp_end_lock:
<a name="l01917"></a>01917   <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l01918"></a>01918   <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;LOCK    %d %s %s\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, locktypeName(locktype), 
<a name="l01919"></a>01919          rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ? <span class="stringliteral">&quot;ok&quot;</span> : <span class="stringliteral">&quot;failed&quot;</span>);
<a name="l01920"></a>01920   <span class="keywordflow">return</span> rc;
<a name="l01921"></a>01921 }
<a name="l01922"></a>01922 
<a name="l01923"></a>01923 <span class="comment">/*</span>
<a name="l01924"></a>01924 <span class="comment">** Lower the locking level on file descriptor pFile to locktype.  locktype</span>
<a name="l01925"></a>01925 <span class="comment">** must be either NO_LOCK or SHARED_LOCK.</span>
<a name="l01926"></a>01926 <span class="comment">**</span>
<a name="l01927"></a>01927 <span class="comment">** If the locking level of the file descriptor is already at or below</span>
<a name="l01928"></a>01928 <span class="comment">** the requested locking level, this routine is a no-op.</span>
<a name="l01929"></a>01929 <span class="comment">*/</span>
<a name="l01930"></a>01930 <span class="keyword">static</span> <span class="keywordtype">int</span> afpUnlock(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype) {
<a name="l01931"></a>01931   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01932"></a>01932   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l01933"></a>01933   afpLockingContext *context = (afpLockingContext *) pFile-&gt;lockingContext;
<a name="l01934"></a>01934 
<a name="l01935"></a>01935   assert( pFile );
<a name="l01936"></a>01936   <a class="code" href="os__common_8h.html#a0353521cd993c4ca92f8bb3d7a8f4d53">OSTRACE5</a>(<span class="stringliteral">&quot;UNLOCK  %d %d was %d pid=%d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, locktype,
<a name="l01937"></a>01937          pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>, getpid());
<a name="l01938"></a>01938 
<a name="l01939"></a>01939   assert( locktype&lt;=<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> );
<a name="l01940"></a>01940   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&lt;=locktype ){
<a name="l01941"></a>01941     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01942"></a>01942   }
<a name="l01943"></a>01943   <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#a6fab1db0dc95bfe9c7d2910c3da2eb97">CHECK_THREADID</a>(pFile) ){
<a name="l01944"></a>01944     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a34f01e4ee909e6b68be040868f7503bc">SQLITE_MISUSE</a>;
<a name="l01945"></a>01945   }
<a name="l01946"></a>01946   <a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">enterMutex</a>();
<a name="l01947"></a>01947   <span class="keywordtype">int</span> failed = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01948"></a>01948   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&gt;<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l01949"></a>01949     <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l01950"></a>01950 
<a name="l01951"></a>01951       <span class="comment">/* unlock the exclusive range - then re-establish the shared lock */</span>
<a name="l01952"></a>01952       <span class="keywordflow">if</span> (pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>==<a class="code" href="os_8h.html#ae17e1f5c17b52ec543aefca2a0b6b0f2">EXCLUSIVE_LOCK</a>) {
<a name="l01953"></a>01953         failed = _AFPFSSetLock(context-&gt;filePath, pFile, <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a>, 
<a name="l01954"></a>01954                                  <a class="code" href="os_8h.html#a232fb4f165a3ecb4a9e5f2a7f1f45a19">SHARED_SIZE</a>, 0);
<a name="l01955"></a>01955         <span class="keywordflow">if</span> (!failed) {
<a name="l01956"></a>01956           <span class="comment">/* successfully removed the exclusive lock */</span>
<a name="l01957"></a>01957           <span class="keywordflow">if</span> ((failed = _AFPFSSetLock(context-&gt;filePath, pFile, <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a>+
<a name="l01958"></a>01958                             context-&gt;sharedLockByte, 1, 1))) {
<a name="l01959"></a>01959             <span class="comment">/* failed to re-establish our shared lock */</span>
<a name="l01960"></a>01960             rc = failed;
<a name="l01961"></a>01961           }
<a name="l01962"></a>01962         } <span class="keywordflow">else</span> {
<a name="l01963"></a>01963           rc = failed;
<a name="l01964"></a>01964         } 
<a name="l01965"></a>01965       }
<a name="l01966"></a>01966     }
<a name="l01967"></a>01967     <span class="keywordflow">if</span> (rc == <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&gt;=<a class="code" href="os_8h.html#a0f7cda5f07b1a172f8cfb8c2266d7189">PENDING_LOCK</a>) {
<a name="l01968"></a>01968       <span class="keywordflow">if</span> ((failed = _AFPFSSetLock(context-&gt;filePath, pFile, 
<a name="l01969"></a>01969                                   <a class="code" href="os_8h.html#a8cca202223a66c75a8bea6dabf8de43b">PENDING_BYTE</a>, 1, 0))){
<a name="l01970"></a>01970         <span class="comment">/* failed to release the pending lock */</span>
<a name="l01971"></a>01971         rc = failed; 
<a name="l01972"></a>01972       }
<a name="l01973"></a>01973     } 
<a name="l01974"></a>01974     <span class="keywordflow">if</span> (rc == <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&gt;=<a class="code" href="os_8h.html#a4fec7ca081b31fb9e121208e2b57fe3f">RESERVED_LOCK</a>) {
<a name="l01975"></a>01975       <span class="keywordflow">if</span> ((failed = _AFPFSSetLock(context-&gt;filePath, pFile, 
<a name="l01976"></a>01976                                   <a class="code" href="os_8h.html#a8ac9fa3da7151dc5ffd9fbf0563a9417">RESERVED_BYTE</a>, 1, 0))) {
<a name="l01977"></a>01977         <span class="comment">/* failed to release the reserved lock */</span>
<a name="l01978"></a>01978         rc = failed;  
<a name="l01979"></a>01979       }
<a name="l01980"></a>01980     } 
<a name="l01981"></a>01981   }
<a name="l01982"></a>01982   <span class="keywordflow">if</span>( locktype==<a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a> ){
<a name="l01983"></a>01983     <span class="keywordtype">int</span> failed = _AFPFSSetLock(context-&gt;filePath, pFile, 
<a name="l01984"></a>01984                                <a class="code" href="os_8h.html#a8360ac8211214cd67bb97719da3b977a">SHARED_FIRST</a> + context-&gt;sharedLockByte, 1, 0);
<a name="l01985"></a>01985     <span class="keywordflow">if</span> (failed) {
<a name="l01986"></a>01986       rc = failed;  
<a name="l01987"></a>01987     }
<a name="l01988"></a>01988   }
<a name="l01989"></a>01989   <span class="keywordflow">if</span> (rc == <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>)
<a name="l01990"></a>01990     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l01991"></a>01991   <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l01992"></a>01992   <span class="keywordflow">return</span> rc;
<a name="l01993"></a>01993 }
<a name="l01994"></a>01994 
<a name="l01995"></a>01995 <span class="comment">/*</span>
<a name="l01996"></a>01996 <span class="comment">** Close a file &amp; cleanup AFP specific locking context </span>
<a name="l01997"></a>01997 <span class="comment">*/</span>
<a name="l01998"></a>01998 <span class="keyword">static</span> <span class="keywordtype">int</span> afpClose(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>) {
<a name="l01999"></a>01999   <span class="keywordflow">if</span>( <span class="keywordtype">id</span> ){
<a name="l02000"></a>02000     <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l02001"></a>02001     afpUnlock(<span class="keywordtype">id</span>, <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>);
<a name="l02002"></a>02002     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pFile-&gt;lockingContext);
<a name="l02003"></a>02003   }
<a name="l02004"></a>02004   <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#ac11bfe29d9353ee80f95a520e83f997f">closeUnixFile</a>(<span class="keywordtype">id</span>);
<a name="l02005"></a>02005 }
<a name="l02006"></a>02006 
<a name="l02007"></a>02007 
<a name="l02008"></a>02008 <span class="preprocessor">#pragma mark flock() style locking</span>
<a name="l02009"></a>02009 <span class="preprocessor"></span>
<a name="l02010"></a>02010 <span class="comment">/*</span>
<a name="l02011"></a>02011 <span class="comment">** The flockLockingContext is not used</span>
<a name="l02012"></a>02012 <span class="comment">*/</span>
<a name="l02013"></a>02013 <span class="keyword">typedef</span> <span class="keywordtype">void</span> flockLockingContext;
<a name="l02014"></a>02014 
<a name="l02015"></a>02015 <span class="comment">/* flock-style reserved lock checking following the behavior of </span>
<a name="l02016"></a>02016 <span class="comment"> ** unixCheckReservedLock, see the unixCheckReservedLock function comments */</span>
<a name="l02017"></a>02017 <span class="keyword">static</span> <span class="keywordtype">int</span> flockCheckReservedLock(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> *pResOut){
<a name="l02018"></a>02018   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02019"></a>02019   <span class="keywordtype">int</span> reserved = 0;
<a name="l02020"></a>02020   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l02021"></a>02021   
<a name="l02022"></a>02022   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#af165990c0a93e69d7e66f5f0cb7fd7bb">SQLITE_IOERR_CHECKRESERVEDLOCK</a>; );
<a name="l02023"></a>02023   
<a name="l02024"></a>02024   assert( pFile );
<a name="l02025"></a>02025   
<a name="l02026"></a>02026   <span class="comment">/* Check if a thread in this process holds such a lock */</span>
<a name="l02027"></a>02027   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&gt;<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l02028"></a>02028     reserved = 1;
<a name="l02029"></a>02029   }
<a name="l02030"></a>02030   
<a name="l02031"></a>02031   <span class="comment">/* Otherwise see if some other process holds it. */</span>
<a name="l02032"></a>02032   <span class="keywordflow">if</span>( !reserved ){
<a name="l02033"></a>02033     <span class="comment">/* attempt to get the lock */</span>
<a name="l02034"></a>02034     <span class="keywordtype">int</span> lrc = flock(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, LOCK_EX | LOCK_NB);
<a name="l02035"></a>02035     <span class="keywordflow">if</span>( !lrc ){
<a name="l02036"></a>02036       <span class="comment">/* got the lock, unlock it */</span>
<a name="l02037"></a>02037       lrc = flock(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, LOCK_UN);
<a name="l02038"></a>02038       <span class="keywordflow">if</span> ( lrc ) {
<a name="l02039"></a>02039         <span class="keywordtype">int</span> tErrno = errno;
<a name="l02040"></a>02040         <span class="comment">/* unlock failed with an error */</span>
<a name="l02041"></a>02041         lrc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a820929b6588051fa0eefaf4639bd8536">SQLITE_IOERR_UNLOCK</a>); 
<a name="l02042"></a>02042         <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(lrc) ){
<a name="l02043"></a>02043           pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l02044"></a>02044           rc = lrc;
<a name="l02045"></a>02045         }
<a name="l02046"></a>02046       }
<a name="l02047"></a>02047     } <span class="keywordflow">else</span> {
<a name="l02048"></a>02048       <span class="keywordtype">int</span> tErrno = errno;
<a name="l02049"></a>02049       reserved = 1;
<a name="l02050"></a>02050       <span class="comment">/* someone else might have it reserved */</span>
<a name="l02051"></a>02051       lrc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a77ac56b2a8025538d73aa6379c82b4af">SQLITE_IOERR_LOCK</a>); 
<a name="l02052"></a>02052       <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(lrc) ){
<a name="l02053"></a>02053         pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l02054"></a>02054         rc = lrc;
<a name="l02055"></a>02055       }
<a name="l02056"></a>02056     }
<a name="l02057"></a>02057   }
<a name="l02058"></a>02058   <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;TEST WR-LOCK %d %d %d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, rc, reserved);
<a name="l02059"></a>02059 
<a name="l02060"></a>02060   *pResOut = reserved;
<a name="l02061"></a>02061   <span class="keywordflow">return</span> rc;
<a name="l02062"></a>02062 }
<a name="l02063"></a>02063 
<a name="l02064"></a>02064 <span class="keyword">static</span> <span class="keywordtype">int</span> flockLock(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype) {
<a name="l02065"></a>02065   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02066"></a>02066   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l02067"></a>02067 
<a name="l02068"></a>02068   assert( pFile );
<a name="l02069"></a>02069 
<a name="l02070"></a>02070   <span class="comment">/* if we already have a lock, it is exclusive.  </span>
<a name="l02071"></a>02071 <span class="comment">  ** Just adjust level and punt on outta here. */</span>
<a name="l02072"></a>02072   <span class="keywordflow">if</span> (pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> &gt; <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>) {
<a name="l02073"></a>02073     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l02074"></a>02074     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02075"></a>02075   }
<a name="l02076"></a>02076   
<a name="l02077"></a>02077   <span class="comment">/* grab an exclusive lock */</span>
<a name="l02078"></a>02078   
<a name="l02079"></a>02079   <span class="keywordflow">if</span> (flock(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, LOCK_EX | LOCK_NB)) {
<a name="l02080"></a>02080     <span class="keywordtype">int</span> tErrno = errno;
<a name="l02081"></a>02081     <span class="comment">/* didn&apos;t get, must be busy */</span>
<a name="l02082"></a>02082     rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a77ac56b2a8025538d73aa6379c82b4af">SQLITE_IOERR_LOCK</a>);
<a name="l02083"></a>02083     <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l02084"></a>02084       pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l02085"></a>02085     }
<a name="l02086"></a>02086   } <span class="keywordflow">else</span> {
<a name="l02087"></a>02087     <span class="comment">/* got it, set the type and return ok */</span>
<a name="l02088"></a>02088     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l02089"></a>02089   }
<a name="l02090"></a>02090   <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;LOCK    %d %s %s\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, locktypeName(locktype), 
<a name="l02091"></a>02091            rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ? <span class="stringliteral">&quot;ok&quot;</span> : <span class="stringliteral">&quot;failed&quot;</span>);
<a name="l02092"></a>02092   <span class="keywordflow">return</span> rc;
<a name="l02093"></a>02093 }
<a name="l02094"></a>02094 
<a name="l02095"></a>02095 <span class="keyword">static</span> <span class="keywordtype">int</span> flockUnlock(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype) {
<a name="l02096"></a>02096   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l02097"></a>02097   
<a name="l02098"></a>02098   assert( pFile );
<a name="l02099"></a>02099   <a class="code" href="os__common_8h.html#a0353521cd993c4ca92f8bb3d7a8f4d53">OSTRACE5</a>(<span class="stringliteral">&quot;UNLOCK  %d %d was %d pid=%d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, locktype,
<a name="l02100"></a>02100            pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>, getpid());
<a name="l02101"></a>02101   assert( locktype&lt;=<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> );
<a name="l02102"></a>02102   
<a name="l02103"></a>02103   <span class="comment">/* no-op if possible */</span>
<a name="l02104"></a>02104   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>==locktype ){
<a name="l02105"></a>02105     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02106"></a>02106   }
<a name="l02107"></a>02107   
<a name="l02108"></a>02108   <span class="comment">/* shared can just be set because we always have an exclusive */</span>
<a name="l02109"></a>02109   <span class="keywordflow">if</span> (locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a>) {
<a name="l02110"></a>02110     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l02111"></a>02111     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02112"></a>02112   }
<a name="l02113"></a>02113   
<a name="l02114"></a>02114   <span class="comment">/* no, really, unlock. */</span>
<a name="l02115"></a>02115   <span class="keywordtype">int</span> rc = flock(pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, LOCK_UN);
<a name="l02116"></a>02116   <span class="keywordflow">if</span> (rc) {
<a name="l02117"></a>02117     <span class="keywordtype">int</span> r, tErrno = errno;
<a name="l02118"></a>02118     r = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a820929b6588051fa0eefaf4639bd8536">SQLITE_IOERR_UNLOCK</a>);
<a name="l02119"></a>02119     <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(r) ){
<a name="l02120"></a>02120       pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l02121"></a>02121     }
<a name="l02122"></a>02122     <span class="keywordflow">return</span> r;
<a name="l02123"></a>02123   } <span class="keywordflow">else</span> {
<a name="l02124"></a>02124     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>;
<a name="l02125"></a>02125     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02126"></a>02126   }
<a name="l02127"></a>02127 }
<a name="l02128"></a>02128 
<a name="l02129"></a>02129 <span class="comment">/*</span>
<a name="l02130"></a>02130 <span class="comment">** Close a file.</span>
<a name="l02131"></a>02131 <span class="comment">*/</span>
<a name="l02132"></a>02132 <span class="keyword">static</span> <span class="keywordtype">int</span> flockClose(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>) {
<a name="l02133"></a>02133   <span class="keywordflow">if</span>( <span class="keywordtype">id</span> ){
<a name="l02134"></a>02134     flockUnlock(<span class="keywordtype">id</span>, <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>);
<a name="l02135"></a>02135   }
<a name="l02136"></a>02136   <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#ac11bfe29d9353ee80f95a520e83f997f">closeUnixFile</a>(<span class="keywordtype">id</span>);
<a name="l02137"></a>02137 }
<a name="l02138"></a>02138 
<a name="l02139"></a>02139 <span class="preprocessor">#pragma mark Old-School .lock file based locking</span>
<a name="l02140"></a>02140 <span class="preprocessor"></span>
<a name="l02141"></a>02141 <span class="comment">/* Dotlock-style reserved lock checking following the behavior of </span>
<a name="l02142"></a>02142 <span class="comment">** unixCheckReservedLock, see the unixCheckReservedLock function comments */</span>
<a name="l02143"></a>02143 <span class="keyword">static</span> <span class="keywordtype">int</span> dotlockCheckReservedLock(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> *pResOut) {
<a name="l02144"></a>02144   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02145"></a>02145   <span class="keywordtype">int</span> reserved = 0;
<a name="l02146"></a>02146   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l02147"></a>02147 
<a name="l02148"></a>02148   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#af165990c0a93e69d7e66f5f0cb7fd7bb">SQLITE_IOERR_CHECKRESERVEDLOCK</a>; );
<a name="l02149"></a>02149   
<a name="l02150"></a>02150   assert( pFile );
<a name="l02151"></a>02151 
<a name="l02152"></a>02152   <span class="comment">/* Check if a thread in this process holds such a lock */</span>
<a name="l02153"></a>02153   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>&gt;<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> ){
<a name="l02154"></a>02154     reserved = 1;
<a name="l02155"></a>02155   }
<a name="l02156"></a>02156   
<a name="l02157"></a>02157   <span class="comment">/* Otherwise see if some other process holds it. */</span>
<a name="l02158"></a>02158   <span class="keywordflow">if</span>( !reserved ){
<a name="l02159"></a>02159     <span class="keywordtype">char</span> *zLockFile = (<span class="keywordtype">char</span> *)pFile-&gt;lockingContext;
<a name="l02160"></a>02160     <span class="keyword">struct</span> stat statBuf;
<a name="l02161"></a>02161     
<a name="l02162"></a>02162     <span class="keywordflow">if</span>( lstat(zLockFile, &amp;statBuf)==0 ){
<a name="l02163"></a>02163       <span class="comment">/* file exists, someone else has the lock */</span>
<a name="l02164"></a>02164       reserved = 1;
<a name="l02165"></a>02165     }<span class="keywordflow">else</span>{
<a name="l02166"></a>02166       <span class="comment">/* file does not exist, we could have it if we want it */</span>
<a name="l02167"></a>02167       <span class="keywordtype">int</span> tErrno = errno;
<a name="l02168"></a>02168       <span class="keywordflow">if</span>( ENOENT != tErrno ){
<a name="l02169"></a>02169         rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#af165990c0a93e69d7e66f5f0cb7fd7bb">SQLITE_IOERR_CHECKRESERVEDLOCK</a>);
<a name="l02170"></a>02170         pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l02171"></a>02171       }
<a name="l02172"></a>02172     }
<a name="l02173"></a>02173   }
<a name="l02174"></a>02174   <a class="code" href="os__common_8h.html#ab79d014027695ed649e111eec831bd41">OSTRACE4</a>(<span class="stringliteral">&quot;TEST WR-LOCK %d %d %d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, rc, reserved);
<a name="l02175"></a>02175 
<a name="l02176"></a>02176   *pResOut = reserved;
<a name="l02177"></a>02177   <span class="keywordflow">return</span> rc;
<a name="l02178"></a>02178 }
<a name="l02179"></a>02179 
<a name="l02180"></a>02180 <span class="keyword">static</span> <span class="keywordtype">int</span> dotlockLock(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype) {
<a name="l02181"></a>02181   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l02182"></a>02182   <span class="keywordtype">int</span> fd;
<a name="l02183"></a>02183   <span class="keywordtype">char</span> *zLockFile = (<span class="keywordtype">char</span> *)pFile-&gt;lockingContext;
<a name="l02184"></a>02184   <span class="keywordtype">int</span> rc=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02185"></a>02185 
<a name="l02186"></a>02186   <span class="comment">/* if we already have a lock, it is exclusive.  </span>
<a name="l02187"></a>02187 <span class="comment">  ** Just adjust level and punt on outta here. */</span>
<a name="l02188"></a>02188   if (pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> &gt; <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>) {
<a name="l02189"></a>02189     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l02190"></a>02190     
<a name="l02191"></a>02191     <span class="comment">/* Always update the timestamp on the old file */</span>
<a name="l02192"></a>02192     utimes(zLockFile, NULL);
<a name="l02193"></a>02193     rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02194"></a>02194     <span class="keywordflow">goto</span> dotlock_end_lock;
<a name="l02195"></a>02195   }
<a name="l02196"></a>02196   
<a name="l02197"></a>02197   <span class="comment">/* check to see if lock file already exists */</span>
<a name="l02198"></a>02198   <span class="keyword">struct </span>stat statBuf;
<a name="l02199"></a>02199   <span class="keywordflow">if</span> (lstat(zLockFile,&amp;statBuf) == 0){
<a name="l02200"></a>02200     rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>; <span class="comment">/* it does, busy */</span>
<a name="l02201"></a>02201     <span class="keywordflow">goto</span> dotlock_end_lock;
<a name="l02202"></a>02202   }
<a name="l02203"></a>02203   
<a name="l02204"></a>02204   <span class="comment">/* grab an exclusive lock */</span>
<a name="l02205"></a>02205   fd = open(zLockFile,O_RDONLY|O_CREAT|O_EXCL,0600);
<a name="l02206"></a>02206   <span class="keywordflow">if</span>( fd&lt;0 ){
<a name="l02207"></a>02207     <span class="comment">/* failed to open/create the file, someone else may have stolen the lock */</span>
<a name="l02208"></a>02208     <span class="keywordtype">int</span> tErrno = errno;
<a name="l02209"></a>02209     <span class="keywordflow">if</span>( EEXIST == tErrno ){
<a name="l02210"></a>02210       rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l02211"></a>02211     } <span class="keywordflow">else</span> {
<a name="l02212"></a>02212       rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a77ac56b2a8025538d73aa6379c82b4af">SQLITE_IOERR_LOCK</a>);
<a name="l02213"></a>02213       <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l02214"></a>02214   pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l02215"></a>02215       }
<a name="l02216"></a>02216     }
<a name="l02217"></a>02217     <span class="keywordflow">goto</span> dotlock_end_lock;
<a name="l02218"></a>02218   } 
<a name="l02219"></a>02219   close(fd);
<a name="l02220"></a>02220   
<a name="l02221"></a>02221   <span class="comment">/* got it, set the type and return ok */</span>
<a name="l02222"></a>02222   pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l02223"></a>02223 
<a name="l02224"></a>02224  dotlock_end_lock:
<a name="l02225"></a>02225   <span class="keywordflow">return</span> rc;
<a name="l02226"></a>02226 }
<a name="l02227"></a>02227 
<a name="l02228"></a>02228 <span class="keyword">static</span> <span class="keywordtype">int</span> dotlockUnlock(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype) {
<a name="l02229"></a>02229   <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l02230"></a>02230   <span class="keywordtype">char</span> *zLockFile = (<span class="keywordtype">char</span> *)pFile-&gt;lockingContext;
<a name="l02231"></a>02231 
<a name="l02232"></a>02232   assert( pFile );
<a name="l02233"></a>02233   <a class="code" href="os__common_8h.html#a0353521cd993c4ca92f8bb3d7a8f4d53">OSTRACE5</a>(<span class="stringliteral">&quot;UNLOCK  %d %d was %d pid=%d\n&quot;</span>, pFile-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a>, locktype,
<a name="l02234"></a>02234      pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>, getpid());
<a name="l02235"></a>02235   assert( locktype&lt;=<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a> );
<a name="l02236"></a>02236   
<a name="l02237"></a>02237   <span class="comment">/* no-op if possible */</span>
<a name="l02238"></a>02238   <span class="keywordflow">if</span>( pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a>==locktype ){
<a name="l02239"></a>02239     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02240"></a>02240   }
<a name="l02241"></a>02241   
<a name="l02242"></a>02242   <span class="comment">/* shared can just be set because we always have an exclusive */</span>
<a name="l02243"></a>02243   <span class="keywordflow">if</span> (locktype==<a class="code" href="os_8h.html#adcf3ef1db1ba24bc5f8933a36831cdf9">SHARED_LOCK</a>) {
<a name="l02244"></a>02244     pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = locktype;
<a name="l02245"></a>02245     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02246"></a>02246   }
<a name="l02247"></a>02247   
<a name="l02248"></a>02248   <span class="comment">/* no, really, unlock. */</span>
<a name="l02249"></a>02249   <span class="keywordflow">if</span> (unlink(zLockFile) ) {
<a name="l02250"></a>02250     <span class="keywordtype">int</span> rc, tErrno = errno;
<a name="l02251"></a>02251     <span class="keywordflow">if</span>( ENOENT != tErrno ){
<a name="l02252"></a>02252       rc = <a class="code" href="os__unix_8c.html#a7b96b9e451b820cf5061400544842387">sqliteErrorFromPosixError</a>(tErrno, <a class="code" href="sqlite3_8h.html#a820929b6588051fa0eefaf4639bd8536">SQLITE_IOERR_UNLOCK</a>);
<a name="l02253"></a>02253     }
<a name="l02254"></a>02254     <span class="keywordflow">if</span>( <a class="code" href="os__unix_8c.html#afb0821692b54dba2d08f035349c74a34">IS_LOCK_ERROR</a>(rc) ){
<a name="l02255"></a>02255       pFile-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = tErrno;
<a name="l02256"></a>02256     }
<a name="l02257"></a>02257     <span class="keywordflow">return</span> rc; 
<a name="l02258"></a>02258   }
<a name="l02259"></a>02259   pFile-&gt;<a class="code" href="structunixFile.html#a827df470922106addde41e3928c010f6">locktype</a> = <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>;
<a name="l02260"></a>02260   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02261"></a>02261 }
<a name="l02262"></a>02262 
<a name="l02263"></a>02263 <span class="comment">/*</span>
<a name="l02264"></a>02264 <span class="comment"> ** Close a file.</span>
<a name="l02265"></a>02265 <span class="comment"> */</span>
<a name="l02266"></a>02266 <span class="keyword">static</span> <span class="keywordtype">int</span> dotlockClose(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>) {
<a name="l02267"></a>02267   <span class="keywordflow">if</span>( <span class="keywordtype">id</span> ){
<a name="l02268"></a>02268     <a class="code" href="structunixFile.html">unixFile</a> *pFile = (<a class="code" href="structunixFile.html">unixFile</a>*)<span class="keywordtype">id</span>;
<a name="l02269"></a>02269     dotlockUnlock(<span class="keywordtype">id</span>, <a class="code" href="os_8h.html#a993c05b6c403f10fb3627e9e4fc30c83">NO_LOCK</a>);
<a name="l02270"></a>02270     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pFile-&gt;lockingContext);
<a name="l02271"></a>02271   }
<a name="l02272"></a>02272   <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#ac11bfe29d9353ee80f95a520e83f997f">closeUnixFile</a>(<span class="keywordtype">id</span>);
<a name="l02273"></a>02273 }
<a name="l02274"></a>02274 
<a name="l02275"></a>02275 
<a name="l02276"></a>02276 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_ENABLE_LOCKING_STYLE */</span>
<a name="l02277"></a>02277 
<a name="l02278"></a>02278 <span class="comment">/*</span>
<a name="l02279"></a>02279 <span class="comment">** The nolockLockingContext is void</span>
<a name="l02280"></a>02280 <span class="comment">*/</span>
<a name="l02281"></a><a class="code" href="os__unix_8c.html#a8447b8b5fd56cfb55c078a585fbddecf">02281</a> <span class="keyword">typedef</span> <span class="keywordtype">void</span> <a class="code" href="os__symbian_8c.html#a8447b8b5fd56cfb55c078a585fbddecf">nolockLockingContext</a>;
<a name="l02282"></a>02282 
<a name="l02283"></a><a class="code" href="os__unix_8c.html#ab2e5ff109e6a23f07962c0d6e607a9c8">02283</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#ab2e5ff109e6a23f07962c0d6e607a9c8">nolockCheckReservedLock</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> *pResOut) {
<a name="l02284"></a>02284   *pResOut = 0;
<a name="l02285"></a>02285   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02286"></a>02286 }
<a name="l02287"></a>02287 
<a name="l02288"></a><a class="code" href="os__unix_8c.html#ab01ba5574ee093ea5ca3638fc06193d2">02288</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#ab01ba5574ee093ea5ca3638fc06193d2">nolockLock</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype) {
<a name="l02289"></a>02289   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02290"></a>02290 }
<a name="l02291"></a>02291 
<a name="l02292"></a><a class="code" href="os__unix_8c.html#a0ca65b5d8b5dda86db51b5ade2f953a6">02292</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a0ca65b5d8b5dda86db51b5ade2f953a6">nolockUnlock</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> locktype) {
<a name="l02293"></a>02293   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02294"></a>02294 }
<a name="l02295"></a>02295 
<a name="l02296"></a>02296 <span class="comment">/*</span>
<a name="l02297"></a>02297 <span class="comment">** Close a file.</span>
<a name="l02298"></a>02298 <span class="comment">*/</span>
<a name="l02299"></a><a class="code" href="os__unix_8c.html#a946bda4aff58be65e29d6222fcc6e3f6">02299</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a946bda4aff58be65e29d6222fcc6e3f6">nolockClose</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>) {
<a name="l02300"></a>02300   <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#ac11bfe29d9353ee80f95a520e83f997f">closeUnixFile</a>(<span class="keywordtype">id</span>);
<a name="l02301"></a>02301 }
<a name="l02302"></a>02302 
<a name="l02303"></a>02303 
<a name="l02304"></a>02304 <span class="comment">/*</span>
<a name="l02305"></a>02305 <span class="comment">** Information and control of an open file handle.</span>
<a name="l02306"></a>02306 <span class="comment">*/</span>
<a name="l02307"></a><a class="code" href="os__unix_8c.html#ad71f213fa385cc58f307cefd953c03ae">02307</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#ad71f213fa385cc58f307cefd953c03ae">unixFileControl</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>, <span class="keywordtype">int</span> op, <span class="keywordtype">void</span> *pArg){
<a name="l02308"></a>02308   <span class="keywordflow">switch</span>( op ){
<a name="l02309"></a>02309     <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#ae173ad67e4014dceb57e5a59b8614415">SQLITE_FCNTL_LOCKSTATE</a>: {
<a name="l02310"></a>02310       *(<span class="keywordtype">int</span>*)pArg = ((<a class="code" href="structunixFile.html">unixFile</a>*)id)-&gt;locktype;
<a name="l02311"></a>02311       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02312"></a>02312     }
<a name="l02313"></a>02313   }
<a name="l02314"></a>02314   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02315"></a>02315 }
<a name="l02316"></a>02316 
<a name="l02317"></a>02317 <span class="comment">/*</span>
<a name="l02318"></a>02318 <span class="comment">** Return the sector size in bytes of the underlying block device for</span>
<a name="l02319"></a>02319 <span class="comment">** the specified file. This is almost always 512 bytes, but may be</span>
<a name="l02320"></a>02320 <span class="comment">** larger for some devices.</span>
<a name="l02321"></a>02321 <span class="comment">**</span>
<a name="l02322"></a>02322 <span class="comment">** SQLite code assumes this function cannot fail. It also assumes that</span>
<a name="l02323"></a>02323 <span class="comment">** if two files are created in the same file-system directory (i.e.</span>
<a name="l02324"></a>02324 <span class="comment">** a database and its journal file) that the sector size will be the</span>
<a name="l02325"></a>02325 <span class="comment">** same for both.</span>
<a name="l02326"></a>02326 <span class="comment">*/</span>
<a name="l02327"></a><a class="code" href="os__unix_8c.html#a6f44d519b728bc30e0723a2ef73aab9e">02327</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a6f44d519b728bc30e0723a2ef73aab9e">unixSectorSize</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>){
<a name="l02328"></a>02328   <span class="keywordflow">return</span> <a class="code" href="os_8h.html#ab35bd9ac959b178e2ce0f7ccd646c557">SQLITE_DEFAULT_SECTOR_SIZE</a>;
<a name="l02329"></a>02329 }
<a name="l02330"></a>02330 
<a name="l02331"></a>02331 <span class="comment">/*</span>
<a name="l02332"></a>02332 <span class="comment">** Return the device characteristics for the file. This is always 0.</span>
<a name="l02333"></a>02333 <span class="comment">*/</span>
<a name="l02334"></a><a class="code" href="os__unix_8c.html#a462f39a4a86a015e2e5daa48656970eb">02334</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a462f39a4a86a015e2e5daa48656970eb">unixDeviceCharacteristics</a>(<a class="code" href="structsqlite3__file.html">sqlite3_file</a> *<span class="keywordtype">id</span>){
<a name="l02335"></a>02335   <span class="keywordflow">return</span> 0;
<a name="l02336"></a>02336 }
<a name="l02337"></a>02337 
<a name="l02338"></a>02338 <span class="comment">/*</span>
<a name="l02339"></a>02339 <span class="comment">** Initialize the contents of the unixFile structure pointed to by pId.</span>
<a name="l02340"></a>02340 <span class="comment">**</span>
<a name="l02341"></a>02341 <span class="comment">** When locking extensions are enabled, the filepath and locking style </span>
<a name="l02342"></a>02342 <span class="comment">** are needed to determine the unixFile pMethod to use for locking operations.</span>
<a name="l02343"></a>02343 <span class="comment">** The locking-style specific lockingContext data structure is created </span>
<a name="l02344"></a>02344 <span class="comment">** and assigned here also.</span>
<a name="l02345"></a>02345 <span class="comment">*/</span>
<a name="l02346"></a><a class="code" href="os__unix_8c.html#a6c00828dfb64e464ad14f3d5ca73c30e">02346</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a6c00828dfb64e464ad14f3d5ca73c30e">fillInUnixFile</a>(
<a name="l02347"></a>02347   <a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs,      <span class="comment">/* Pointer to vfs object */</span>
<a name="l02348"></a>02348   <span class="keywordtype">int</span> h,                  <span class="comment">/* Open file descriptor of file being opened */</span>
<a name="l02349"></a>02349   <span class="keywordtype">int</span> dirfd,              <span class="comment">/* Directory file descriptor */</span>
<a name="l02350"></a>02350   <a class="code" href="structsqlite3__file.html">sqlite3_file</a> *pId,      <span class="comment">/* Write to the unixFile structure here */</span>
<a name="l02351"></a>02351   <span class="keyword">const</span> <span class="keywordtype">char</span> *zFilename,  <span class="comment">/* Name of the file being opened */</span>
<a name="l02352"></a>02352   <span class="keywordtype">int</span> noLock              <span class="comment">/* Omit locking if true */</span>
<a name="l02353"></a>02353 ){
<a name="l02354"></a>02354   <span class="keywordtype">int</span> eLockingStyle;
<a name="l02355"></a>02355   <a class="code" href="structunixFile.html">unixFile</a> *pNew = (<a class="code" href="structunixFile.html">unixFile</a> *)pId;
<a name="l02356"></a>02356   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02357"></a>02357 
<a name="l02358"></a>02358   <span class="comment">/* Macro to define the static contents of an sqlite3_io_methods </span>
<a name="l02359"></a>02359 <span class="comment">  ** structure for a unix backend file. Different locking methods</span>
<a name="l02360"></a>02360 <span class="comment">  ** require different functions for the xClose, xLock, xUnlock and</span>
<a name="l02361"></a>02361 <span class="comment">  ** xCheckReservedLock methods.</span>
<a name="l02362"></a>02362 <span class="comment">  */</span>
<a name="l02363"></a>02363 <span class="preprocessor">  #define IOMETHODS(xClose, xLock, xUnlock, xCheckReservedLock) {    \</span>
<a name="l02364"></a>02364 <span class="preprocessor">    1,                          </span><span class="comment">/* iVersion */</span>                           \
<a name="l02365"></a>02365     xClose,                     <span class="comment">/* xClose */</span>                             \
<a name="l02366"></a>02366     unixRead,                   <span class="comment">/* xRead */</span>                              \
<a name="l02367"></a>02367     unixWrite,                  <span class="comment">/* xWrite */</span>                             \
<a name="l02368"></a>02368     unixTruncate,               <span class="comment">/* xTruncate */</span>                          \
<a name="l02369"></a>02369     unixSync,                   <span class="comment">/* xSync */</span>                              \
<a name="l02370"></a>02370     unixFileSize,               <span class="comment">/* xFileSize */</span>                          \
<a name="l02371"></a>02371     xLock,                      <span class="comment">/* xLock */</span>                              \
<a name="l02372"></a>02372     xUnlock,                    <span class="comment">/* xUnlock */</span>                            \
<a name="l02373"></a>02373     xCheckReservedLock,         <span class="comment">/* xCheckReservedLock */</span>                 \
<a name="l02374"></a>02374     unixFileControl,            <span class="comment">/* xFileControl */</span>                       \
<a name="l02375"></a>02375     unixSectorSize,             <span class="comment">/* xSectorSize */</span>                        \
<a name="l02376"></a>02376     unixDeviceCharacteristics   <span class="comment">/* xDeviceCapabilities */</span>                \
<a name="l02377"></a>02377   }
<a name="l02378"></a>02378   <span class="keyword">static</span> <a class="code" href="structsqlite3__io__methods.html">sqlite3_io_methods</a> aIoMethod[] = {
<a name="l02379"></a>02379     <a class="code" href="os__symbian_8c.html#ae46acafa826c8089a37f2d0da3c71be3">IOMETHODS</a>(<a class="code" href="os__unix_8c.html#a84cdb6e4ff75f085e8c05dfdec178927">unixClose</a>, <a class="code" href="os__unix_8c.html#abe3ca9997aafdc0835387f0c1cee0750">unixLock</a>, <a class="code" href="os__unix_8c.html#a981f68c7151f8de198cdc10f17db9165">unixUnlock</a>, <a class="code" href="os__unix_8c.html#ac56c26ce18878ed5357de493678969fc">unixCheckReservedLock</a>) 
<a name="l02380"></a>02380    ,<a class="code" href="os__symbian_8c.html#ae46acafa826c8089a37f2d0da3c71be3">IOMETHODS</a>(<a class="code" href="os__unix_8c.html#a946bda4aff58be65e29d6222fcc6e3f6">nolockClose</a>, <a class="code" href="os__unix_8c.html#ab01ba5574ee093ea5ca3638fc06193d2">nolockLock</a>, <a class="code" href="os__unix_8c.html#a0ca65b5d8b5dda86db51b5ade2f953a6">nolockUnlock</a>, <a class="code" href="os__unix_8c.html#ab2e5ff109e6a23f07962c0d6e607a9c8">nolockCheckReservedLock</a>)
<a name="l02381"></a>02381 <span class="preprocessor">#if SQLITE_ENABLE_LOCKING_STYLE</span>
<a name="l02382"></a>02382 <span class="preprocessor"></span>   ,<a class="code" href="os__symbian_8c.html#ae46acafa826c8089a37f2d0da3c71be3">IOMETHODS</a>(dotlockClose, dotlockLock, dotlockUnlock,dotlockCheckReservedLock)
<a name="l02383"></a>02383    ,<a class="code" href="os__symbian_8c.html#ae46acafa826c8089a37f2d0da3c71be3">IOMETHODS</a>(flockClose, flockLock, flockUnlock, flockCheckReservedLock)
<a name="l02384"></a>02384    ,<a class="code" href="os__symbian_8c.html#ae46acafa826c8089a37f2d0da3c71be3">IOMETHODS</a>(afpClose, afpLock, afpUnlock, afpCheckReservedLock)
<a name="l02385"></a>02385 <span class="preprocessor">#endif</span>
<a name="l02386"></a>02386 <span class="preprocessor"></span>  };
<a name="l02387"></a>02387   <span class="comment">/* The order of the IOMETHODS macros above is important.  It must be the</span>
<a name="l02388"></a>02388 <span class="comment">  ** same order as the LOCKING_STYLE numbers</span>
<a name="l02389"></a>02389 <span class="comment">  */</span>
<a name="l02390"></a>02390   assert(<a class="code" href="os__unix_8c.html#ab9b6ea85c2889dcd69eff1e8bd68356c">LOCKING_STYLE_POSIX</a>==1);
<a name="l02391"></a>02391   assert(<a class="code" href="os__unix_8c.html#aabd10577b2d58c00dc8bf1541bab46e7">LOCKING_STYLE_NONE</a>==2);
<a name="l02392"></a>02392   assert(<a class="code" href="os__unix_8c.html#afec800c31b854518e9548d55921e6eee">LOCKING_STYLE_DOTFILE</a>==3);
<a name="l02393"></a>02393   assert(<a class="code" href="os__unix_8c.html#a6bc7290dc781332aa31f3d8daae9772f">LOCKING_STYLE_FLOCK</a>==4);
<a name="l02394"></a>02394   assert(<a class="code" href="os__unix_8c.html#aa540763b2d32dabe7148496c6f42997c">LOCKING_STYLE_AFP</a>==5);
<a name="l02395"></a>02395 
<a name="l02396"></a>02396   assert( pNew-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>==NULL );
<a name="l02397"></a>02397   assert( pNew-&gt;<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a>==NULL );
<a name="l02398"></a>02398 
<a name="l02399"></a>02399   <a class="code" href="os__common_8h.html#ae313dfb2a2a4e2f558bdde36da4f1f53">OSTRACE3</a>(<span class="stringliteral">&quot;OPEN    %-3d %s\n&quot;</span>, h, zFilename);    
<a name="l02400"></a>02400   pNew-&gt;<a class="code" href="structunixFile.html#a1c58798d4ff3ac6232765c8b76bb7450">h</a> = h;
<a name="l02401"></a>02401   pNew-&gt;<a class="code" href="structunixFile.html#aa4d81dba57e69451d4bc2c4593faaef6">dirfd</a> = dirfd;
<a name="l02402"></a>02402   <a class="code" href="os__unix_8c.html#a65fed10875316dfdb55e1fc73eef71dc">SET_THREADID</a>(pNew);
<a name="l02403"></a>02403 
<a name="l02404"></a>02404   <span class="keywordflow">if</span>( noLock ){
<a name="l02405"></a>02405     eLockingStyle = <a class="code" href="os__unix_8c.html#aabd10577b2d58c00dc8bf1541bab46e7">LOCKING_STYLE_NONE</a>;
<a name="l02406"></a>02406   }<span class="keywordflow">else</span>{
<a name="l02407"></a>02407     eLockingStyle = <a class="code" href="os__unix_8c.html#a1e12ff6c4b28a9c1b180d9d5edd1ab2c">detectLockingStyle</a>(pVfs, zFilename, h);
<a name="l02408"></a>02408   }
<a name="l02409"></a>02409 
<a name="l02410"></a>02410   <span class="keywordflow">switch</span>( eLockingStyle ){
<a name="l02411"></a>02411 
<a name="l02412"></a>02412     <span class="keywordflow">case</span> <a class="code" href="os__unix_8c.html#ab9b6ea85c2889dcd69eff1e8bd68356c">LOCKING_STYLE_POSIX</a>: {
<a name="l02413"></a>02413       <a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">enterMutex</a>();
<a name="l02414"></a>02414       rc = <a class="code" href="os__unix_8c.html#a21455ae20850627129c0a343d95a24f8">findLockInfo</a>(h, &amp;pNew-&gt;<a class="code" href="structunixFile.html#a316eb00466c91f750862bc958a097b9e">pLock</a>, &amp;pNew-&gt;<a class="code" href="structunixFile.html#a9e553a4e670928294813ed4a984bd5a4">pOpen</a>);
<a name="l02415"></a>02415       <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l02416"></a>02416       <span class="keywordflow">break</span>;
<a name="l02417"></a>02417     }
<a name="l02418"></a>02418 
<a name="l02419"></a>02419 <span class="preprocessor">#if SQLITE_ENABLE_LOCKING_STYLE</span>
<a name="l02420"></a>02420 <span class="preprocessor"></span>    <span class="keywordflow">case</span> <a class="code" href="os__unix_8c.html#aa540763b2d32dabe7148496c6f42997c">LOCKING_STYLE_AFP</a>: {
<a name="l02421"></a>02421       <span class="comment">/* AFP locking uses the file path so it needs to be included in</span>
<a name="l02422"></a>02422 <span class="comment">      ** the afpLockingContext.</span>
<a name="l02423"></a>02423 <span class="comment">      */</span>
<a name="l02424"></a>02424       afpLockingContext *pCtx;
<a name="l02425"></a>02425       pNew-&gt;lockingContext = pCtx = <a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>( <span class="keyword">sizeof</span>(*pCtx) );
<a name="l02426"></a>02426       <span class="keywordflow">if</span>( pCtx==0 ){
<a name="l02427"></a>02427         rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l02428"></a>02428       }<span class="keywordflow">else</span>{
<a name="l02429"></a>02429         <span class="comment">/* NB: zFilename exists and remains valid until the file is closed</span>
<a name="l02430"></a>02430 <span class="comment">        ** according to requirement F11141.  So we do not need to make a</span>
<a name="l02431"></a>02431 <span class="comment">        ** copy of the filename. */</span>
<a name="l02432"></a>02432         pCtx-&gt;filePath = zFilename;
<a name="l02433"></a>02433         srandomdev();
<a name="l02434"></a>02434       }
<a name="l02435"></a>02435       <span class="keywordflow">break</span>;
<a name="l02436"></a>02436     }
<a name="l02437"></a>02437 
<a name="l02438"></a>02438     <span class="keywordflow">case</span> <a class="code" href="os__unix_8c.html#afec800c31b854518e9548d55921e6eee">LOCKING_STYLE_DOTFILE</a>: {
<a name="l02439"></a>02439       <span class="comment">/* Dotfile locking uses the file path so it needs to be included in</span>
<a name="l02440"></a>02440 <span class="comment">      ** the dotlockLockingContext </span>
<a name="l02441"></a>02441 <span class="comment">      */</span>
<a name="l02442"></a>02442       <span class="keywordtype">char</span> *zLockFile;
<a name="l02443"></a>02443       <span class="keywordtype">int</span> nFilename;
<a name="l02444"></a>02444       nFilename = strlen(zFilename) + 6;
<a name="l02445"></a>02445       zLockFile = (<span class="keywordtype">char</span> *)<a class="code" href="malloc_8c.html#a3731cc8aef710794f375db1dc68d0881">sqlite3_malloc</a>(nFilename);
<a name="l02446"></a>02446       <span class="keywordflow">if</span>( zLockFile==0 ){
<a name="l02447"></a>02447         rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l02448"></a>02448       }<span class="keywordflow">else</span>{
<a name="l02449"></a>02449         <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nFilename, zLockFile, <span class="stringliteral">&quot;%s.lock&quot;</span>, zFilename);
<a name="l02450"></a>02450       }
<a name="l02451"></a>02451       pNew-&gt;lockingContext = zLockFile;
<a name="l02452"></a>02452       <span class="keywordflow">break</span>;
<a name="l02453"></a>02453     }
<a name="l02454"></a>02454 
<a name="l02455"></a>02455     <span class="keywordflow">case</span> <a class="code" href="os__unix_8c.html#a6bc7290dc781332aa31f3d8daae9772f">LOCKING_STYLE_FLOCK</a>: 
<a name="l02456"></a>02456     <span class="keywordflow">case</span> <a class="code" href="os__unix_8c.html#aabd10577b2d58c00dc8bf1541bab46e7">LOCKING_STYLE_NONE</a>: 
<a name="l02457"></a>02457       <span class="keywordflow">break</span>;
<a name="l02458"></a>02458 <span class="preprocessor">#endif</span>
<a name="l02459"></a>02459 <span class="preprocessor"></span>  }
<a name="l02460"></a>02460   
<a name="l02461"></a>02461   pNew-&gt;<a class="code" href="structunixFile.html#afde57c2e118fac8041918dac2ee6f7d1">lastErrno</a> = 0;
<a name="l02462"></a>02462   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02463"></a>02463     <span class="keywordflow">if</span>( dirfd&gt;=0 ) close(dirfd);
<a name="l02464"></a>02464     close(h);
<a name="l02465"></a>02465   }<span class="keywordflow">else</span>{
<a name="l02466"></a>02466     pNew-&gt;<a class="code" href="structunixFile.html#a7eb75fcb2f3395045cb4f836df52ecc1">pMethod</a> = &amp;aIoMethod[eLockingStyle-1];
<a name="l02467"></a>02467     <a class="code" href="os__common_8h.html#ab93b1fae5a1c8274ed324c698aa46f0d">OpenCounter</a>(+1);
<a name="l02468"></a>02468   }
<a name="l02469"></a>02469   <span class="keywordflow">return</span> rc;
<a name="l02470"></a>02470 }
<a name="l02471"></a>02471 
<a name="l02472"></a>02472 <span class="comment">/*</span>
<a name="l02473"></a>02473 <span class="comment">** Open a file descriptor to the directory containing file zFilename.</span>
<a name="l02474"></a>02474 <span class="comment">** If successful, *pFd is set to the opened file descriptor and</span>
<a name="l02475"></a>02475 <span class="comment">** SQLITE_OK is returned. If an error occurs, either SQLITE_NOMEM</span>
<a name="l02476"></a>02476 <span class="comment">** or SQLITE_CANTOPEN is returned and *pFd is set to an undefined</span>
<a name="l02477"></a>02477 <span class="comment">** value.</span>
<a name="l02478"></a>02478 <span class="comment">**</span>
<a name="l02479"></a>02479 <span class="comment">** If SQLITE_OK is returned, the caller is responsible for closing</span>
<a name="l02480"></a>02480 <span class="comment">** the file descriptor *pFd using close().</span>
<a name="l02481"></a>02481 <span class="comment">*/</span>
<a name="l02482"></a><a class="code" href="os__unix_8c.html#ad4ba5d254297ce92f291987213d165da">02482</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#ad4ba5d254297ce92f291987213d165da">openDirectory</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *zFilename, <span class="keywordtype">int</span> *pFd){
<a name="l02483"></a>02483   <span class="keywordtype">int</span> ii;
<a name="l02484"></a>02484   <span class="keywordtype">int</span> fd = -1;
<a name="l02485"></a>02485   <span class="keywordtype">char</span> zDirname[<a class="code" href="os__symbian_8c.html#aa4e5ca47d52a8be522912705c27e0d1c">MAX_PATHNAME</a>+1];
<a name="l02486"></a>02486 
<a name="l02487"></a>02487   <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<a class="code" href="os__symbian_8c.html#aa4e5ca47d52a8be522912705c27e0d1c">MAX_PATHNAME</a>, zDirname, <span class="stringliteral">&quot;%s&quot;</span>, zFilename);
<a name="l02488"></a>02488   <span class="keywordflow">for</span>(ii=strlen(zDirname); ii&gt;=0 &amp;&amp; zDirname[ii]!=<span class="charliteral">&apos;/&apos;</span>; ii--);
<a name="l02489"></a>02489   <span class="keywordflow">if</span>( ii&gt;0 ){
<a name="l02490"></a>02490     zDirname[ii] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l02491"></a>02491     fd = open(zDirname, O_RDONLY|<a class="code" href="os__symbian_8c.html#a36fa9b2e726512bc17a7a6d3e39002be">O_BINARY</a>, 0);
<a name="l02492"></a>02492     <span class="keywordflow">if</span>( fd&gt;=0 ){
<a name="l02493"></a>02493 <span class="preprocessor">#ifdef FD_CLOEXEC</span>
<a name="l02494"></a>02494 <span class="preprocessor"></span>      fcntl(fd, F_SETFD, fcntl(fd, F_GETFD, 0) | FD_CLOEXEC);
<a name="l02495"></a>02495 <span class="preprocessor">#endif</span>
<a name="l02496"></a>02496 <span class="preprocessor"></span>      <a class="code" href="os__common_8h.html#ae313dfb2a2a4e2f558bdde36da4f1f53">OSTRACE3</a>(<span class="stringliteral">&quot;OPENDIR %-3d %s\n&quot;</span>, fd, zDirname);
<a name="l02497"></a>02497     }
<a name="l02498"></a>02498   }
<a name="l02499"></a>02499   *pFd = fd;
<a name="l02500"></a>02500   <span class="keywordflow">return</span> (fd&gt;=0?<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>:<a class="code" href="sqlite3_8h.html#afd6b86c2df4363b6d0f18e16b76ff897">SQLITE_CANTOPEN</a>);
<a name="l02501"></a>02501 }
<a name="l02502"></a>02502 
<a name="l02503"></a>02503 <span class="comment">/*</span>
<a name="l02504"></a>02504 <span class="comment">** Create a temporary file name in zBuf.  zBuf must be allocated</span>
<a name="l02505"></a>02505 <span class="comment">** by the calling process and must be big enough to hold at least</span>
<a name="l02506"></a>02506 <span class="comment">** pVfs-&gt;mxPathname bytes.</span>
<a name="l02507"></a>02507 <span class="comment">*/</span>
<a name="l02508"></a><a class="code" href="os__unix_8c.html#af3db87f63e82a07ea1fc857a663ec30f">02508</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#af3db87f63e82a07ea1fc857a663ec30f">getTempname</a>(<span class="keywordtype">int</span> nBuf, <span class="keywordtype">char</span> *zBuf){
<a name="l02509"></a>02509   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *azDirs[] = {
<a name="l02510"></a>02510      0,
<a name="l02511"></a>02511      <span class="stringliteral">&quot;/var/tmp&quot;</span>,
<a name="l02512"></a>02512      <span class="stringliteral">&quot;/usr/tmp&quot;</span>,
<a name="l02513"></a>02513      <span class="stringliteral">&quot;/tmp&quot;</span>,
<a name="l02514"></a>02514      <span class="stringliteral">&quot;.&quot;</span>,
<a name="l02515"></a>02515   };
<a name="l02516"></a>02516   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> zChars[] =
<a name="l02517"></a>02517     <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<a name="l02518"></a>02518     <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>
<a name="l02519"></a>02519     <span class="stringliteral">&quot;0123456789&quot;</span>;
<a name="l02520"></a>02520   <span class="keywordtype">int</span> i, j;
<a name="l02521"></a>02521   <span class="keyword">struct </span>stat buf;
<a name="l02522"></a>02522   <span class="keyword">const</span> <span class="keywordtype">char</span> *zDir = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l02523"></a>02523 
<a name="l02524"></a>02524   <span class="comment">/* It&apos;s odd to simulate an io-error here, but really this is just</span>
<a name="l02525"></a>02525 <span class="comment">  ** using the io-error infrastructure to test that SQLite handles this</span>
<a name="l02526"></a>02526 <span class="comment">  ** function failing. </span>
<a name="l02527"></a>02527 <span class="comment">  */</span>
<a name="l02528"></a>02528   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a45a4718698f155ae3b45d37d3b94d9a2">SQLITE_IOERR</a> );
<a name="l02529"></a>02529 
<a name="l02530"></a>02530   azDirs[0] = <a class="code" href="main_8c.html#ada2f9f790df64f7ae8bc2b898b183be2">sqlite3_temp_directory</a>;
<a name="l02531"></a>02531   <span class="keywordflow">for</span>(i=0; i&lt;<span class="keyword">sizeof</span>(azDirs)/<span class="keyword">sizeof</span>(azDirs[0]); i++){
<a name="l02532"></a>02532     <span class="keywordflow">if</span>( azDirs[i]==0 ) <span class="keywordflow">continue</span>;
<a name="l02533"></a>02533     <span class="keywordflow">if</span>( stat(azDirs[i], &amp;buf) ) <span class="keywordflow">continue</span>;
<a name="l02534"></a>02534     <span class="keywordflow">if</span>( !S_ISDIR(buf.st_mode) ) <span class="keywordflow">continue</span>;
<a name="l02535"></a>02535     <span class="keywordflow">if</span>( access(azDirs[i], 07) ) <span class="keywordflow">continue</span>;
<a name="l02536"></a>02536     zDir = azDirs[i];
<a name="l02537"></a>02537     <span class="keywordflow">break</span>;
<a name="l02538"></a>02538   }
<a name="l02539"></a>02539 
<a name="l02540"></a>02540   <span class="comment">/* Check that the output buffer is large enough for the temporary file </span>
<a name="l02541"></a>02541 <span class="comment">  ** name. If it is not, return SQLITE_ERROR.</span>
<a name="l02542"></a>02542 <span class="comment">  */</span>
<a name="l02543"></a>02543   <span class="keywordflow">if</span>( (strlen(zDir) + strlen(<a class="code" href="os_8h.html#a7aeb41d98ec51e888340be247364dd85">SQLITE_TEMP_FILE_PREFIX</a>) + 17) &gt;= nBuf ){
<a name="l02544"></a>02544     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02545"></a>02545   }
<a name="l02546"></a>02546 
<a name="l02547"></a>02547   <span class="keywordflow">do</span>{
<a name="l02548"></a>02548     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nBuf-17, zBuf, <span class="stringliteral">&quot;%s/&quot;</span><a class="code" href="os_8h.html#a7aeb41d98ec51e888340be247364dd85">SQLITE_TEMP_FILE_PREFIX</a>, zDir);
<a name="l02549"></a>02549     j = strlen(zBuf);
<a name="l02550"></a>02550     <a class="code" href="random_8c.html#a1431cd360c32f40da9dec267d29eb998">sqlite3_randomness</a>(15, &amp;zBuf[j]);
<a name="l02551"></a>02551     <span class="keywordflow">for</span>(i=0; i&lt;15; i++, j++){
<a name="l02552"></a>02552       zBuf[j] = (char)zChars[ ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)zBuf[j])%(<span class="keyword">sizeof</span>(zChars)-1) ];
<a name="l02553"></a>02553     }
<a name="l02554"></a>02554     zBuf[j] = 0;
<a name="l02555"></a>02555   }<span class="keywordflow">while</span>( access(zBuf,0)==0 );
<a name="l02556"></a>02556   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02557"></a>02557 }
<a name="l02558"></a>02558 
<a name="l02559"></a>02559 
<a name="l02560"></a>02560 <span class="comment">/*</span>
<a name="l02561"></a>02561 <span class="comment">** Open the file zPath.</span>
<a name="l02562"></a>02562 <span class="comment">** </span>
<a name="l02563"></a>02563 <span class="comment">** Previously, the SQLite OS layer used three functions in place of this</span>
<a name="l02564"></a>02564 <span class="comment">** one:</span>
<a name="l02565"></a>02565 <span class="comment">**</span>
<a name="l02566"></a>02566 <span class="comment">**     sqlite3OsOpenReadWrite();</span>
<a name="l02567"></a>02567 <span class="comment">**     sqlite3OsOpenReadOnly();</span>
<a name="l02568"></a>02568 <span class="comment">**     sqlite3OsOpenExclusive();</span>
<a name="l02569"></a>02569 <span class="comment">**</span>
<a name="l02570"></a>02570 <span class="comment">** These calls correspond to the following combinations of flags:</span>
<a name="l02571"></a>02571 <span class="comment">**</span>
<a name="l02572"></a>02572 <span class="comment">**     ReadWrite() -&gt;     (READWRITE | CREATE)</span>
<a name="l02573"></a>02573 <span class="comment">**     ReadOnly()  -&gt;     (READONLY) </span>
<a name="l02574"></a>02574 <span class="comment">**     OpenExclusive() -&gt; (READWRITE | CREATE | EXCLUSIVE)</span>
<a name="l02575"></a>02575 <span class="comment">**</span>
<a name="l02576"></a>02576 <span class="comment">** The old OpenExclusive() accepted a boolean argument - &quot;delFlag&quot;. If</span>
<a name="l02577"></a>02577 <span class="comment">** true, the file was configured to be automatically deleted when the</span>
<a name="l02578"></a>02578 <span class="comment">** file handle closed. To achieve the same effect using this new </span>
<a name="l02579"></a>02579 <span class="comment">** interface, add the DELETEONCLOSE flag to those specified above for </span>
<a name="l02580"></a>02580 <span class="comment">** OpenExclusive().</span>
<a name="l02581"></a>02581 <span class="comment">*/</span>
<a name="l02582"></a><a class="code" href="os__unix_8c.html#a8ed5efc47b6e14f7805cd1bb9b215775">02582</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a8ed5efc47b6e14f7805cd1bb9b215775">unixOpen</a>(
<a name="l02583"></a>02583   <a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, 
<a name="l02584"></a>02584   <span class="keyword">const</span> <span class="keywordtype">char</span> *zPath, 
<a name="l02585"></a>02585   <a class="code" href="structsqlite3__file.html">sqlite3_file</a> *pFile,
<a name="l02586"></a>02586   <span class="keywordtype">int</span> flags,
<a name="l02587"></a>02587   <span class="keywordtype">int</span> *pOutFlags
<a name="l02588"></a>02588 ){
<a name="l02589"></a>02589   <span class="keywordtype">int</span> fd = 0;                    <span class="comment">/* File descriptor returned by open() */</span>
<a name="l02590"></a>02590   <span class="keywordtype">int</span> dirfd = -1;                <span class="comment">/* Directory file descriptor */</span>
<a name="l02591"></a>02591   <span class="keywordtype">int</span> oflags = 0;                <span class="comment">/* Flags to pass to open() */</span>
<a name="l02592"></a>02592   <span class="keywordtype">int</span> eType = flags&amp;0xFFFFFF00;  <span class="comment">/* Type of file to open */</span>
<a name="l02593"></a>02593   <span class="keywordtype">int</span> noLock;                    <span class="comment">/* True to omit locking primitives */</span>
<a name="l02594"></a>02594 
<a name="l02595"></a>02595   <span class="keywordtype">int</span> isExclusive  = (flags &amp; <a class="code" href="sqlite3_8h.html#a3eace21577bcc4790a72a096c21ba645">SQLITE_OPEN_EXCLUSIVE</a>);
<a name="l02596"></a>02596   <span class="keywordtype">int</span> isDelete     = (flags &amp; <a class="code" href="sqlite3_8h.html#a64253edf05cdfa93174ebf8fd4155e39">SQLITE_OPEN_DELETEONCLOSE</a>);
<a name="l02597"></a>02597   <span class="keywordtype">int</span> isCreate     = (flags &amp; <a class="code" href="sqlite3_8h.html#a06cff06321a46ca610a29c8f125f9c08">SQLITE_OPEN_CREATE</a>);
<a name="l02598"></a>02598   <span class="keywordtype">int</span> isReadonly   = (flags &amp; <a class="code" href="sqlite3_8h.html#a9f0b8777cdd16d53be7a2e1ccf759ff1">SQLITE_OPEN_READONLY</a>);
<a name="l02599"></a>02599   <span class="keywordtype">int</span> isReadWrite  = (flags &amp; <a class="code" href="sqlite3_8h.html#a3eb39cf04a78fae3b553b96d65f93419">SQLITE_OPEN_READWRITE</a>);
<a name="l02600"></a>02600 
<a name="l02601"></a>02601   <span class="comment">/* If creating a master or main-file journal, this function will open</span>
<a name="l02602"></a>02602 <span class="comment">  ** a file-descriptor on the directory too. The first time unixSync()</span>
<a name="l02603"></a>02603 <span class="comment">  ** is called the directory file descriptor will be fsync()ed and close()d.</span>
<a name="l02604"></a>02604 <span class="comment">  */</span>
<a name="l02605"></a>02605   <span class="keywordtype">int</span> isOpenDirectory = (isCreate &amp;&amp; 
<a name="l02606"></a>02606       (eType==<a class="code" href="sqlite3_8h.html#abd5b137f274db77586b40939b1390e07">SQLITE_OPEN_MASTER_JOURNAL</a> || eType==<a class="code" href="sqlite3_8h.html#a267fdf184a2dfb8e2561ecb7bc469ec0">SQLITE_OPEN_MAIN_JOURNAL</a>)
<a name="l02607"></a>02607   );
<a name="l02608"></a>02608 
<a name="l02609"></a>02609   <span class="comment">/* If argument zPath is a NULL pointer, this function is required to open</span>
<a name="l02610"></a>02610 <span class="comment">  ** a temporary file. Use this buffer to store the file name in.</span>
<a name="l02611"></a>02611 <span class="comment">  */</span>
<a name="l02612"></a>02612   <span class="keywordtype">char</span> zTmpname[<a class="code" href="os__symbian_8c.html#aa4e5ca47d52a8be522912705c27e0d1c">MAX_PATHNAME</a>+1];
<a name="l02613"></a>02613   <span class="keyword">const</span> <span class="keywordtype">char</span> *zName = zPath;
<a name="l02614"></a>02614 
<a name="l02615"></a>02615   <span class="comment">/* Check the following statements are true: </span>
<a name="l02616"></a>02616 <span class="comment">  **</span>
<a name="l02617"></a>02617 <span class="comment">  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and </span>
<a name="l02618"></a>02618 <span class="comment">  **   (b) if CREATE is set, then READWRITE must also be set, and</span>
<a name="l02619"></a>02619 <span class="comment">  **   (c) if EXCLUSIVE is set, then CREATE must also be set.</span>
<a name="l02620"></a>02620 <span class="comment">  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.</span>
<a name="l02621"></a>02621 <span class="comment">  */</span>
<a name="l02622"></a>02622   assert((isReadonly==0 || isReadWrite==0) &amp;&amp; (isReadWrite || isReadonly));
<a name="l02623"></a>02623   assert(isCreate==0 || isReadWrite);
<a name="l02624"></a>02624   assert(isExclusive==0 || isCreate);
<a name="l02625"></a>02625   assert(isDelete==0 || isCreate);
<a name="l02626"></a>02626 
<a name="l02627"></a>02627   <span class="comment">/* The main DB, main journal, and master journal are never automatically</span>
<a name="l02628"></a>02628 <span class="comment">  ** deleted</span>
<a name="l02629"></a>02629 <span class="comment">  */</span>
<a name="l02630"></a>02630   assert( eType!=<a class="code" href="sqlite3_8h.html#a3e21dbcdb840bd34587d19bcced7dbc9">SQLITE_OPEN_MAIN_DB</a> || !isDelete );
<a name="l02631"></a>02631   assert( eType!=<a class="code" href="sqlite3_8h.html#a267fdf184a2dfb8e2561ecb7bc469ec0">SQLITE_OPEN_MAIN_JOURNAL</a> || !isDelete );
<a name="l02632"></a>02632   assert( eType!=<a class="code" href="sqlite3_8h.html#abd5b137f274db77586b40939b1390e07">SQLITE_OPEN_MASTER_JOURNAL</a> || !isDelete );
<a name="l02633"></a>02633 
<a name="l02634"></a>02634   <span class="comment">/* Assert that the upper layer has set one of the &quot;file-type&quot; flags. */</span>
<a name="l02635"></a>02635   assert( eType==<a class="code" href="sqlite3_8h.html#a3e21dbcdb840bd34587d19bcced7dbc9">SQLITE_OPEN_MAIN_DB</a>      || eType==<a class="code" href="sqlite3_8h.html#a1798ff24deb9484a2f95e994ee76af4c">SQLITE_OPEN_TEMP_DB</a> 
<a name="l02636"></a>02636        || eType==<a class="code" href="sqlite3_8h.html#a267fdf184a2dfb8e2561ecb7bc469ec0">SQLITE_OPEN_MAIN_JOURNAL</a> || eType==<a class="code" href="sqlite3_8h.html#a442225f21dce90d9e936300a3d93bb89">SQLITE_OPEN_TEMP_JOURNAL</a> 
<a name="l02637"></a>02637        || eType==<a class="code" href="sqlite3_8h.html#a4b9767bd8ec44b5a1d08082af935991e">SQLITE_OPEN_SUBJOURNAL</a>   || eType==<a class="code" href="sqlite3_8h.html#abd5b137f274db77586b40939b1390e07">SQLITE_OPEN_MASTER_JOURNAL</a> 
<a name="l02638"></a>02638        || eType==<a class="code" href="sqlite3_8h.html#afc7fbd65e1786cd345a6d87e8820d38e">SQLITE_OPEN_TRANSIENT_DB</a>
<a name="l02639"></a>02639   );
<a name="l02640"></a>02640 
<a name="l02641"></a>02641   memset(pFile, 0, <span class="keyword">sizeof</span>(<a class="code" href="structunixFile.html">unixFile</a>));
<a name="l02642"></a>02642 
<a name="l02643"></a>02643   <span class="keywordflow">if</span>( !zName ){
<a name="l02644"></a>02644     <span class="keywordtype">int</span> rc;
<a name="l02645"></a>02645     assert(isDelete &amp;&amp; !isOpenDirectory);
<a name="l02646"></a>02646     rc = <a class="code" href="os__unix_8c.html#af3db87f63e82a07ea1fc857a663ec30f">getTempname</a>(<a class="code" href="os__symbian_8c.html#aa4e5ca47d52a8be522912705c27e0d1c">MAX_PATHNAME</a>+1, zTmpname);
<a name="l02647"></a>02647     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02648"></a>02648       <span class="keywordflow">return</span> rc;
<a name="l02649"></a>02649     }
<a name="l02650"></a>02650     zName = zTmpname;
<a name="l02651"></a>02651   }
<a name="l02652"></a>02652 
<a name="l02653"></a>02653   <span class="keywordflow">if</span>( isReadonly )  oflags |= O_RDONLY;
<a name="l02654"></a>02654   <span class="keywordflow">if</span>( isReadWrite ) oflags |= O_RDWR;
<a name="l02655"></a>02655   <span class="keywordflow">if</span>( isCreate )    oflags |= O_CREAT;
<a name="l02656"></a>02656   <span class="keywordflow">if</span>( isExclusive ) oflags |= (O_EXCL|<a class="code" href="os__symbian_8c.html#a82d4d551b214905742c9e045185d352a">O_NOFOLLOW</a>);
<a name="l02657"></a>02657   oflags |= (<a class="code" href="os__symbian_8c.html#a1126309aa58e7c99553c7f6be1bc7348">O_LARGEFILE</a>|<a class="code" href="os__symbian_8c.html#a36fa9b2e726512bc17a7a6d3e39002be">O_BINARY</a>);
<a name="l02658"></a>02658 
<a name="l02659"></a>02659   fd = open(zName, oflags, isDelete?0600:<a class="code" href="os__symbian_8c.html#a29c670fb1a9edf61afa0a5fcd67613c1">SQLITE_DEFAULT_FILE_PERMISSIONS</a>);
<a name="l02660"></a>02660   <span class="keywordflow">if</span>( fd&lt;0 &amp;&amp; errno!=EISDIR &amp;&amp; isReadWrite &amp;&amp; !isExclusive ){
<a name="l02661"></a>02661     <span class="comment">/* Failed to open the file for read/write access. Try read-only. */</span>
<a name="l02662"></a>02662     flags &amp;= ~(<a class="code" href="sqlite3_8h.html#a3eb39cf04a78fae3b553b96d65f93419">SQLITE_OPEN_READWRITE</a>|<a class="code" href="sqlite3_8h.html#a06cff06321a46ca610a29c8f125f9c08">SQLITE_OPEN_CREATE</a>);
<a name="l02663"></a>02663     flags |= <a class="code" href="sqlite3_8h.html#a9f0b8777cdd16d53be7a2e1ccf759ff1">SQLITE_OPEN_READONLY</a>;
<a name="l02664"></a>02664     <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#a8ed5efc47b6e14f7805cd1bb9b215775">unixOpen</a>(pVfs, zPath, pFile, flags, pOutFlags);
<a name="l02665"></a>02665   }
<a name="l02666"></a>02666   <span class="keywordflow">if</span>( fd&lt;0 ){
<a name="l02667"></a>02667     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afd6b86c2df4363b6d0f18e16b76ff897">SQLITE_CANTOPEN</a>;
<a name="l02668"></a>02668   }
<a name="l02669"></a>02669   <span class="keywordflow">if</span>( isDelete ){
<a name="l02670"></a>02670     unlink(zName);
<a name="l02671"></a>02671   }
<a name="l02672"></a>02672   <span class="keywordflow">if</span>( pOutFlags ){
<a name="l02673"></a>02673     *pOutFlags = flags;
<a name="l02674"></a>02674   }
<a name="l02675"></a>02675 
<a name="l02676"></a>02676   assert(fd!=0);
<a name="l02677"></a>02677   <span class="keywordflow">if</span>( isOpenDirectory ){
<a name="l02678"></a>02678     <span class="keywordtype">int</span> rc = <a class="code" href="os__unix_8c.html#ad4ba5d254297ce92f291987213d165da">openDirectory</a>(zPath, &amp;dirfd);
<a name="l02679"></a>02679     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02680"></a>02680       close(fd);
<a name="l02681"></a>02681       <span class="keywordflow">return</span> rc;
<a name="l02682"></a>02682     }
<a name="l02683"></a>02683   }
<a name="l02684"></a>02684 
<a name="l02685"></a>02685 <span class="preprocessor">#ifdef FD_CLOEXEC</span>
<a name="l02686"></a>02686 <span class="preprocessor"></span>  fcntl(fd, F_SETFD, fcntl(fd, F_GETFD, 0) | FD_CLOEXEC);
<a name="l02687"></a>02687 <span class="preprocessor">#endif</span>
<a name="l02688"></a>02688 <span class="preprocessor"></span>
<a name="l02689"></a>02689   noLock = eType!=<a class="code" href="sqlite3_8h.html#a3e21dbcdb840bd34587d19bcced7dbc9">SQLITE_OPEN_MAIN_DB</a>;
<a name="l02690"></a>02690   <span class="keywordflow">return</span> <a class="code" href="os__unix_8c.html#a6c00828dfb64e464ad14f3d5ca73c30e">fillInUnixFile</a>(pVfs, fd, dirfd, pFile, zPath, noLock);
<a name="l02691"></a>02691 }
<a name="l02692"></a>02692 
<a name="l02693"></a>02693 <span class="comment">/*</span>
<a name="l02694"></a>02694 <span class="comment">** Delete the file at zPath. If the dirSync argument is true, fsync()</span>
<a name="l02695"></a>02695 <span class="comment">** the directory after deleting the file.</span>
<a name="l02696"></a>02696 <span class="comment">*/</span>
<a name="l02697"></a><a class="code" href="os__unix_8c.html#a5857884b5530ee2ef0ce1e47b277d390">02697</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a5857884b5530ee2ef0ce1e47b277d390">unixDelete</a>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, <span class="keyword">const</span> <span class="keywordtype">char</span> *zPath, <span class="keywordtype">int</span> dirSync){
<a name="l02698"></a>02698   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02699"></a>02699   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>(<span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a6c57f4ecb8541b6b375189815acf58b1">SQLITE_IOERR_DELETE</a>);
<a name="l02700"></a>02700   unlink(zPath);
<a name="l02701"></a>02701 <span class="preprocessor">#ifndef SQLITE_DISABLE_DIRSYNC</span>
<a name="l02702"></a>02702 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( dirSync ){
<a name="l02703"></a>02703     <span class="keywordtype">int</span> fd;
<a name="l02704"></a>02704     rc = <a class="code" href="os__unix_8c.html#ad4ba5d254297ce92f291987213d165da">openDirectory</a>(zPath, &amp;fd);
<a name="l02705"></a>02705     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02706"></a>02706       <span class="keywordflow">if</span>( fsync(fd) ){
<a name="l02707"></a>02707         rc = <a class="code" href="sqlite3_8h.html#a89142904d69608910e0e6f3d53da4ffb">SQLITE_IOERR_DIR_FSYNC</a>;
<a name="l02708"></a>02708       }
<a name="l02709"></a>02709       close(fd);
<a name="l02710"></a>02710     }
<a name="l02711"></a>02711   }
<a name="l02712"></a>02712 <span class="preprocessor">#endif</span>
<a name="l02713"></a>02713 <span class="preprocessor"></span>  <span class="keywordflow">return</span> rc;
<a name="l02714"></a>02714 }
<a name="l02715"></a>02715 
<a name="l02716"></a>02716 <span class="comment">/*</span>
<a name="l02717"></a>02717 <span class="comment">** Test the existance of or access permissions of file zPath. The</span>
<a name="l02718"></a>02718 <span class="comment">** test performed depends on the value of flags:</span>
<a name="l02719"></a>02719 <span class="comment">**</span>
<a name="l02720"></a>02720 <span class="comment">**     SQLITE_ACCESS_EXISTS: Return 1 if the file exists</span>
<a name="l02721"></a>02721 <span class="comment">**     SQLITE_ACCESS_READWRITE: Return 1 if the file is read and writable.</span>
<a name="l02722"></a>02722 <span class="comment">**     SQLITE_ACCESS_READONLY: Return 1 if the file is readable.</span>
<a name="l02723"></a>02723 <span class="comment">**</span>
<a name="l02724"></a>02724 <span class="comment">** Otherwise return 0.</span>
<a name="l02725"></a>02725 <span class="comment">*/</span>
<a name="l02726"></a><a class="code" href="os__unix_8c.html#afdc5264b0751ec73076be9c796a2865e">02726</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#afdc5264b0751ec73076be9c796a2865e">unixAccess</a>(
<a name="l02727"></a>02727   <a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, 
<a name="l02728"></a>02728   <span class="keyword">const</span> <span class="keywordtype">char</span> *zPath, 
<a name="l02729"></a>02729   <span class="keywordtype">int</span> flags, 
<a name="l02730"></a>02730   <span class="keywordtype">int</span> *pResOut
<a name="l02731"></a>02731 ){
<a name="l02732"></a>02732   <span class="keywordtype">int</span> amode = 0;
<a name="l02733"></a>02733   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ac045bb32e396debbd7c9ba6a777fae68">SQLITE_IOERR_ACCESS</a>; );
<a name="l02734"></a>02734   <span class="keywordflow">switch</span>( flags ){
<a name="l02735"></a>02735     <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#a8451f266ab642f03f344209484dc3b61">SQLITE_ACCESS_EXISTS</a>:
<a name="l02736"></a>02736       amode = F_OK;
<a name="l02737"></a>02737       <span class="keywordflow">break</span>;
<a name="l02738"></a>02738     <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#ad5f9561f0e5bfd90f61a3b9162eff3bc">SQLITE_ACCESS_READWRITE</a>:
<a name="l02739"></a>02739       amode = W_OK|R_OK;
<a name="l02740"></a>02740       <span class="keywordflow">break</span>;
<a name="l02741"></a>02741     <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#a31fe78771892ba5cddff318500a62c09">SQLITE_ACCESS_READ</a>:
<a name="l02742"></a>02742       amode = R_OK;
<a name="l02743"></a>02743       <span class="keywordflow">break</span>;
<a name="l02744"></a>02744 
<a name="l02745"></a>02745     <span class="keywordflow">default</span>:
<a name="l02746"></a>02746       assert(!<span class="stringliteral">&quot;Invalid flags argument&quot;</span>);
<a name="l02747"></a>02747   }
<a name="l02748"></a>02748   *pResOut = (access(zPath, amode)==0);
<a name="l02749"></a>02749   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02750"></a>02750 }
<a name="l02751"></a>02751 
<a name="l02752"></a>02752 
<a name="l02753"></a>02753 <span class="comment">/*</span>
<a name="l02754"></a>02754 <span class="comment">** Turn a relative pathname into a full pathname. The relative path</span>
<a name="l02755"></a>02755 <span class="comment">** is stored as a nul-terminated string in the buffer pointed to by</span>
<a name="l02756"></a>02756 <span class="comment">** zPath. </span>
<a name="l02757"></a>02757 <span class="comment">**</span>
<a name="l02758"></a>02758 <span class="comment">** zOut points to a buffer of at least sqlite3_vfs.mxPathname bytes </span>
<a name="l02759"></a>02759 <span class="comment">** (in this case, MAX_PATHNAME bytes). The full-path is written to</span>
<a name="l02760"></a>02760 <span class="comment">** this buffer before returning.</span>
<a name="l02761"></a>02761 <span class="comment">*/</span>
<a name="l02762"></a><a class="code" href="os__unix_8c.html#a129b22de988456c437b033551f7cd7af">02762</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a129b22de988456c437b033551f7cd7af">unixFullPathname</a>(
<a name="l02763"></a>02763   <a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs,            <span class="comment">/* Pointer to vfs object */</span>
<a name="l02764"></a>02764   <span class="keyword">const</span> <span class="keywordtype">char</span> *zPath,            <span class="comment">/* Possibly relative input path */</span>
<a name="l02765"></a>02765   <span class="keywordtype">int</span> nOut,                     <span class="comment">/* Size of output buffer in bytes */</span>
<a name="l02766"></a>02766   <span class="keywordtype">char</span> *zOut                    <span class="comment">/* Output buffer */</span>
<a name="l02767"></a>02767 ){
<a name="l02768"></a>02768 
<a name="l02769"></a>02769   <span class="comment">/* It&apos;s odd to simulate an io-error here, but really this is just</span>
<a name="l02770"></a>02770 <span class="comment">  ** using the io-error infrastructure to test that SQLite handles this</span>
<a name="l02771"></a>02771 <span class="comment">  ** function failing. This function could fail if, for example, the</span>
<a name="l02772"></a>02772 <span class="comment">  ** current working directly has been unlinked.</span>
<a name="l02773"></a>02773 <span class="comment">  */</span>
<a name="l02774"></a>02774   <a class="code" href="os__common_8h.html#a985fbe826d2533f24c47a0b23e282ce5">SimulateIOError</a>( <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a> );
<a name="l02775"></a>02775 
<a name="l02776"></a>02776   assert( pVfs-&gt;<a class="code" href="structsqlite3__vfs.html#adb2d82c74891b00b5529fb94e7710135">mxPathname</a>==<a class="code" href="os__symbian_8c.html#aa4e5ca47d52a8be522912705c27e0d1c">MAX_PATHNAME</a> );
<a name="l02777"></a>02777   zOut[nOut-1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l02778"></a>02778   <span class="keywordflow">if</span>( zPath[0]==<span class="charliteral">&apos;/&apos;</span> ){
<a name="l02779"></a>02779     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nOut, zOut, <span class="stringliteral">&quot;%s&quot;</span>, zPath);
<a name="l02780"></a>02780   }<span class="keywordflow">else</span>{
<a name="l02781"></a>02781     <span class="keywordtype">int</span> nCwd;
<a name="l02782"></a>02782     <span class="keywordflow">if</span>( getcwd(zOut, nOut-1)==0 ){
<a name="l02783"></a>02783       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afd6b86c2df4363b6d0f18e16b76ff897">SQLITE_CANTOPEN</a>;
<a name="l02784"></a>02784     }
<a name="l02785"></a>02785     nCwd = strlen(zOut);
<a name="l02786"></a>02786     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nOut-nCwd, &amp;zOut[nCwd], <span class="stringliteral">&quot;/%s&quot;</span>, zPath);
<a name="l02787"></a>02787   }
<a name="l02788"></a>02788   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02789"></a>02789 
<a name="l02790"></a>02790 <span class="preprocessor">#if 0</span>
<a name="l02791"></a>02791 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l02792"></a>02792 <span class="comment">  ** Remove &quot;/./&quot; path elements and convert &quot;/A/./&quot; path elements</span>
<a name="l02793"></a>02793 <span class="comment">  ** to just &quot;/&quot;.</span>
<a name="l02794"></a>02794 <span class="comment">  */</span>
<a name="l02795"></a>02795   <span class="keywordflow">if</span>( zFull ){
<a name="l02796"></a>02796     <span class="keywordtype">int</span> i, j;
<a name="l02797"></a>02797     <span class="keywordflow">for</span>(i=j=0; zFull[i]; i++){
<a name="l02798"></a>02798       <span class="keywordflow">if</span>( zFull[i]==<span class="charliteral">&apos;/&apos;</span> ){
<a name="l02799"></a>02799         <span class="keywordflow">if</span>( zFull[i+1]==<span class="charliteral">&apos;/&apos;</span> ) <span class="keywordflow">continue</span>;
<a name="l02800"></a>02800         <span class="keywordflow">if</span>( zFull[i+1]==<span class="charliteral">&apos;.&apos;</span> &amp;&amp; zFull[i+2]==<span class="charliteral">&apos;/&apos;</span> ){
<a name="l02801"></a>02801           i += 1;
<a name="l02802"></a>02802           <span class="keywordflow">continue</span>;
<a name="l02803"></a>02803         }
<a name="l02804"></a>02804         <span class="keywordflow">if</span>( zFull[i+1]==<span class="charliteral">&apos;.&apos;</span> &amp;&amp; zFull[i+2]==<span class="charliteral">&apos;.&apos;</span> &amp;&amp; zFull[i+3]==<span class="charliteral">&apos;/&apos;</span> ){
<a name="l02805"></a>02805           <span class="keywordflow">while</span>( j&gt;0 &amp;&amp; zFull[j-1]!=<span class="charliteral">&apos;/&apos;</span> ){ j--; }
<a name="l02806"></a>02806           i += 3;
<a name="l02807"></a>02807           <span class="keywordflow">continue</span>;
<a name="l02808"></a>02808         }
<a name="l02809"></a>02809       }
<a name="l02810"></a>02810       zFull[j++] = zFull[i];
<a name="l02811"></a>02811     }
<a name="l02812"></a>02812     zFull[j] = 0;
<a name="l02813"></a>02813   }
<a name="l02814"></a>02814 <span class="preprocessor">#endif</span>
<a name="l02815"></a>02815 <span class="preprocessor"></span>}
<a name="l02816"></a>02816 
<a name="l02817"></a>02817 
<a name="l02818"></a>02818 <span class="preprocessor">#ifndef SQLITE_OMIT_LOAD_EXTENSION</span>
<a name="l02819"></a>02819 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l02820"></a>02820 <span class="comment">** Interfaces for opening a shared library, finding entry points</span>
<a name="l02821"></a>02821 <span class="comment">** within the shared library, and closing the shared library.</span>
<a name="l02822"></a>02822 <span class="comment">*/</span>
<a name="l02823"></a>02823 <span class="preprocessor">#include &lt;dlfcn.h&gt;</span>
<a name="l02824"></a><a class="code" href="os__unix_8c.html#ad7b5dfe26629021eaa838f2117d96cdf">02824</a> <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="os__unix_8c.html#ad7b5dfe26629021eaa838f2117d96cdf">unixDlOpen</a>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFilename){
<a name="l02825"></a>02825   <span class="keywordflow">return</span> dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL);
<a name="l02826"></a>02826 }
<a name="l02827"></a>02827 
<a name="l02828"></a>02828 <span class="comment">/*</span>
<a name="l02829"></a>02829 <span class="comment">** SQLite calls this function immediately after a call to unixDlSym() or</span>
<a name="l02830"></a>02830 <span class="comment">** unixDlOpen() fails (returns a null pointer). If a more detailed error</span>
<a name="l02831"></a>02831 <span class="comment">** message is available, it is written to zBufOut. If no error message</span>
<a name="l02832"></a>02832 <span class="comment">** is available, zBufOut is left unmodified and SQLite uses a default</span>
<a name="l02833"></a>02833 <span class="comment">** error message.</span>
<a name="l02834"></a>02834 <span class="comment">*/</span>
<a name="l02835"></a><a class="code" href="os__unix_8c.html#a4ed68bf26e47a9d5d54ed3ec887e7661">02835</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="os__unix_8c.html#a4ed68bf26e47a9d5d54ed3ec887e7661">unixDlError</a>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, <span class="keywordtype">int</span> nBuf, <span class="keywordtype">char</span> *zBufOut){
<a name="l02836"></a>02836   <span class="keywordtype">char</span> *zErr;
<a name="l02837"></a>02837   <a class="code" href="os__unix_8c.html#aa7eac13947d45ad35dd5ad6bce01b7cb">enterMutex</a>();
<a name="l02838"></a>02838   zErr = dlerror();
<a name="l02839"></a>02839   <span class="keywordflow">if</span>( zErr ){
<a name="l02840"></a>02840     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(nBuf, zBufOut, <span class="stringliteral">&quot;%s&quot;</span>, zErr);
<a name="l02841"></a>02841   }
<a name="l02842"></a>02842   <a class="code" href="os__unix_8c.html#a22e6ff8ce3eac1f47927fef3ae551aa3">leaveMutex</a>();
<a name="l02843"></a>02843 }
<a name="l02844"></a><a class="code" href="os__unix_8c.html#a89b252086d6f6d76b424e3ad03f699c7">02844</a> <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="os__unix_8c.html#a89b252086d6f6d76b424e3ad03f699c7">unixDlSym</a>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, <span class="keywordtype">void</span> *pHandle, <span class="keyword">const</span> <span class="keywordtype">char</span> *zSymbol){
<a name="l02845"></a>02845   <span class="keywordflow">return</span> dlsym(pHandle, zSymbol);
<a name="l02846"></a>02846 }
<a name="l02847"></a><a class="code" href="os__unix_8c.html#ae3bca181dfef2b65f0c7df786b8afc2c">02847</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="os__unix_8c.html#ae3bca181dfef2b65f0c7df786b8afc2c">unixDlClose</a>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, <span class="keywordtype">void</span> *pHandle){
<a name="l02848"></a>02848   dlclose(pHandle);
<a name="l02849"></a>02849 }
<a name="l02850"></a>02850 <span class="preprocessor">#else </span><span class="comment">/* if SQLITE_OMIT_LOAD_EXTENSION is defined: */</span>
<a name="l02851"></a>02851 <span class="preprocessor">  #define unixDlOpen  0</span>
<a name="l02852"></a>02852 <span class="preprocessor"></span><span class="preprocessor">  #define unixDlError 0</span>
<a name="l02853"></a>02853 <span class="preprocessor"></span><span class="preprocessor">  #define unixDlSym   0</span>
<a name="l02854"></a>02854 <span class="preprocessor"></span><span class="preprocessor">  #define unixDlClose 0</span>
<a name="l02855"></a>02855 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02856"></a>02856 <span class="preprocessor"></span>
<a name="l02857"></a>02857 <span class="comment">/*</span>
<a name="l02858"></a>02858 <span class="comment">** Write nBuf bytes of random data to the supplied buffer zBuf.</span>
<a name="l02859"></a>02859 <span class="comment">*/</span>
<a name="l02860"></a><a class="code" href="os__unix_8c.html#aec7c6d3a7f00deafc8d9103af1a77913">02860</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#aec7c6d3a7f00deafc8d9103af1a77913">unixRandomness</a>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, <span class="keywordtype">int</span> nBuf, <span class="keywordtype">char</span> *zBuf){
<a name="l02861"></a>02861 
<a name="l02862"></a>02862   assert(nBuf&gt;=(<span class="keyword">sizeof</span>(time_t)+<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)));
<a name="l02863"></a>02863 
<a name="l02864"></a>02864   <span class="comment">/* We have to initialize zBuf to prevent valgrind from reporting</span>
<a name="l02865"></a>02865 <span class="comment">  ** errors.  The reports issued by valgrind are incorrect - we would</span>
<a name="l02866"></a>02866 <span class="comment">  ** prefer that the randomness be increased by making use of the</span>
<a name="l02867"></a>02867 <span class="comment">  ** uninitialized space in zBuf - but valgrind errors tend to worry</span>
<a name="l02868"></a>02868 <span class="comment">  ** some users.  Rather than argue, it seems easier just to initialize</span>
<a name="l02869"></a>02869 <span class="comment">  ** the whole array and silence valgrind, even if that means less randomness</span>
<a name="l02870"></a>02870 <span class="comment">  ** in the random seed.</span>
<a name="l02871"></a>02871 <span class="comment">  **</span>
<a name="l02872"></a>02872 <span class="comment">  ** When testing, initializing zBuf[] to zero is all we do.  That means</span>
<a name="l02873"></a>02873 <span class="comment">  ** that we always use the same random number sequence.  This makes the</span>
<a name="l02874"></a>02874 <span class="comment">  ** tests repeatable.</span>
<a name="l02875"></a>02875 <span class="comment">  */</span>
<a name="l02876"></a>02876   memset(zBuf, 0, nBuf);
<a name="l02877"></a>02877 <span class="preprocessor">#if !defined(SQLITE_TEST)</span>
<a name="l02878"></a>02878 <span class="preprocessor"></span>  {
<a name="l02879"></a>02879     <span class="keywordtype">int</span> pid, fd;
<a name="l02880"></a>02880     fd = open(<span class="stringliteral">&quot;/dev/urandom&quot;</span>, O_RDONLY);
<a name="l02881"></a>02881     <span class="keywordflow">if</span>( fd&lt;0 ){
<a name="l02882"></a>02882       time_t t;
<a name="l02883"></a>02883       time(&amp;t);
<a name="l02884"></a>02884       memcpy(zBuf, &amp;t, <span class="keyword">sizeof</span>(t));
<a name="l02885"></a>02885       pid = getpid();
<a name="l02886"></a>02886       memcpy(&amp;zBuf[<span class="keyword">sizeof</span>(t)], &amp;pid, <span class="keyword">sizeof</span>(pid));
<a name="l02887"></a>02887       assert( <span class="keyword">sizeof</span>(t)+<span class="keyword">sizeof</span>(pid)&lt;=nBuf );
<a name="l02888"></a>02888       nBuf = <span class="keyword">sizeof</span>(t) + <span class="keyword">sizeof</span>(pid);
<a name="l02889"></a>02889     }<span class="keywordflow">else</span>{
<a name="l02890"></a>02890       nBuf = read(fd, zBuf, nBuf);
<a name="l02891"></a>02891       close(fd);
<a name="l02892"></a>02892     }
<a name="l02893"></a>02893   }
<a name="l02894"></a>02894 <span class="preprocessor">#endif</span>
<a name="l02895"></a>02895 <span class="preprocessor"></span>  <span class="keywordflow">return</span> nBuf;
<a name="l02896"></a>02896 }
<a name="l02897"></a>02897 
<a name="l02898"></a>02898 
<a name="l02899"></a>02899 <span class="comment">/*</span>
<a name="l02900"></a>02900 <span class="comment">** Sleep for a little while.  Return the amount of time slept.</span>
<a name="l02901"></a>02901 <span class="comment">** The argument is the number of microseconds we want to sleep.</span>
<a name="l02902"></a>02902 <span class="comment">** The return value is the number of microseconds of sleep actually</span>
<a name="l02903"></a>02903 <span class="comment">** requested from the underlying operating system, a number which</span>
<a name="l02904"></a>02904 <span class="comment">** might be greater than or equal to the argument, but not less</span>
<a name="l02905"></a>02905 <span class="comment">** than the argument.</span>
<a name="l02906"></a>02906 <span class="comment">*/</span>
<a name="l02907"></a><a class="code" href="os__unix_8c.html#a9cb67ab56b343db3e1b4f03c8746a8e7">02907</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a9cb67ab56b343db3e1b4f03c8746a8e7">unixSleep</a>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, <span class="keywordtype">int</span> microseconds){
<a name="l02908"></a>02908 <span class="preprocessor">#if defined(HAVE_USLEEP) &amp;&amp; HAVE_USLEEP</span>
<a name="l02909"></a>02909 <span class="preprocessor"></span>  usleep(microseconds);
<a name="l02910"></a>02910   <span class="keywordflow">return</span> microseconds;
<a name="l02911"></a>02911 <span class="preprocessor">#else</span>
<a name="l02912"></a>02912 <span class="preprocessor"></span>  <span class="keywordtype">int</span> seconds = (microseconds+999999)/1000000;
<a name="l02913"></a>02913   sleep(seconds);
<a name="l02914"></a>02914   <span class="keywordflow">return</span> seconds*1000000;
<a name="l02915"></a>02915 <span class="preprocessor">#endif</span>
<a name="l02916"></a>02916 <span class="preprocessor"></span>}
<a name="l02917"></a>02917 
<a name="l02918"></a>02918 <span class="comment">/*</span>
<a name="l02919"></a>02919 <span class="comment">** The following variable, if set to a non-zero value, becomes the result</span>
<a name="l02920"></a>02920 <span class="comment">** returned from sqlite3OsCurrentTime().  This is used for testing.</span>
<a name="l02921"></a>02921 <span class="comment">*/</span>
<a name="l02922"></a>02922 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l02923"></a>02923 <span class="preprocessor"></span><span class="keywordtype">int</span> sqlite3_current_time = 0;
<a name="l02924"></a>02924 <span class="preprocessor">#endif</span>
<a name="l02925"></a>02925 <span class="preprocessor"></span>
<a name="l02926"></a>02926 <span class="comment">/*</span>
<a name="l02927"></a>02927 <span class="comment">** Find the current time (in Universal Coordinated Time).  Write the</span>
<a name="l02928"></a>02928 <span class="comment">** current time and date as a Julian Day number into *prNow and</span>
<a name="l02929"></a>02929 <span class="comment">** return 0.  Return 1 if the time and date cannot be found.</span>
<a name="l02930"></a>02930 <span class="comment">*/</span>
<a name="l02931"></a><a class="code" href="os__unix_8c.html#a7679f2efe18a64cf4c662c634e4a34e9">02931</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#a7679f2efe18a64cf4c662c634e4a34e9">unixCurrentTime</a>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, <span class="keywordtype">double</span> *prNow){
<a name="l02932"></a>02932 <span class="preprocessor">#ifdef NO_GETTOD</span>
<a name="l02933"></a>02933 <span class="preprocessor"></span>  time_t t;
<a name="l02934"></a>02934   time(&amp;t);
<a name="l02935"></a>02935   *prNow = t/86400.0 + 2440587.5;
<a name="l02936"></a>02936 <span class="preprocessor">#else</span>
<a name="l02937"></a>02937 <span class="preprocessor"></span>  <span class="keyword">struct </span>timeval sNow;
<a name="l02938"></a>02938   gettimeofday(&amp;sNow, 0);
<a name="l02939"></a>02939   *prNow = 2440587.5 + sNow.tv_sec/86400.0 + sNow.tv_usec/86400000000.0;
<a name="l02940"></a>02940 <span class="preprocessor">#endif</span>
<a name="l02941"></a>02941 <span class="preprocessor"></span><span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l02942"></a>02942 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( sqlite3_current_time ){
<a name="l02943"></a>02943     *prNow = sqlite3_current_time/86400.0 + 2440587.5;
<a name="l02944"></a>02944   }
<a name="l02945"></a>02945 <span class="preprocessor">#endif</span>
<a name="l02946"></a>02946 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
<a name="l02947"></a>02947 }
<a name="l02948"></a>02948 
<a name="l02949"></a><a class="code" href="os__unix_8c.html#af644065e43014484ad66a309b97c4cc5">02949</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="os__unix_8c.html#af644065e43014484ad66a309b97c4cc5">unixGetLastError</a>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs, <span class="keywordtype">int</span> nBuf, <span class="keywordtype">char</span> *zBuf){
<a name="l02950"></a>02950   <span class="keywordflow">return</span> 0;
<a name="l02951"></a>02951 }
<a name="l02952"></a>02952 
<a name="l02953"></a>02953 <span class="comment">/*</span>
<a name="l02954"></a>02954 <span class="comment">** Initialize the operating system interface.</span>
<a name="l02955"></a>02955 <span class="comment">*/</span>
<a name="l02956"></a><a class="code" href="os__unix_8c.html#a63f238567b6ed63b40e133e87a2dbdec">02956</a> <span class="keywordtype">int</span> <a class="code" href="os__symbian_8c.html#a63f238567b6ed63b40e133e87a2dbdec">sqlite3_os_init</a>(<span class="keywordtype">void</span>){ 
<a name="l02957"></a>02957   <span class="comment">/* Macro to define the static contents of an sqlite3_vfs structure for</span>
<a name="l02958"></a>02958 <span class="comment">  ** the unix backend. The two parameters are the values to use for</span>
<a name="l02959"></a>02959 <span class="comment">  ** the sqlite3_vfs.zName and sqlite3_vfs.pAppData fields, respectively.</span>
<a name="l02960"></a>02960 <span class="comment">  ** </span>
<a name="l02961"></a>02961 <span class="comment">  */</span>
<a name="l02962"></a>02962 <span class="preprocessor">  #define UNIXVFS(zVfsName, pVfsAppData) {                  \</span>
<a name="l02963"></a>02963 <span class="preprocessor">    1,                    </span><span class="comment">/* iVersion */</span>                    \
<a name="l02964"></a>02964     sizeof(unixFile),     <span class="comment">/* szOsFile */</span>                    \
<a name="l02965"></a>02965     MAX_PATHNAME,         <span class="comment">/* mxPathname */</span>                  \
<a name="l02966"></a>02966     0,                    <span class="comment">/* pNext */</span>                       \
<a name="l02967"></a>02967     zVfsName,             <span class="comment">/* zName */</span>                       \
<a name="l02968"></a>02968     (void *)pVfsAppData,  <span class="comment">/* pAppData */</span>                    \
<a name="l02969"></a>02969     unixOpen,             <span class="comment">/* xOpen */</span>                       \
<a name="l02970"></a>02970     unixDelete,           <span class="comment">/* xDelete */</span>                     \
<a name="l02971"></a>02971     unixAccess,           <span class="comment">/* xAccess */</span>                     \
<a name="l02972"></a>02972     unixFullPathname,     <span class="comment">/* xFullPathname */</span>               \
<a name="l02973"></a>02973     unixDlOpen,           <span class="comment">/* xDlOpen */</span>                     \
<a name="l02974"></a>02974     unixDlError,          <span class="comment">/* xDlError */</span>                    \
<a name="l02975"></a>02975     unixDlSym,            <span class="comment">/* xDlSym */</span>                      \
<a name="l02976"></a>02976     unixDlClose,          <span class="comment">/* xDlClose */</span>                    \
<a name="l02977"></a>02977     unixRandomness,       <span class="comment">/* xRandomness */</span>                 \
<a name="l02978"></a>02978     unixSleep,            <span class="comment">/* xSleep */</span>                      \
<a name="l02979"></a>02979     unixCurrentTime,      <span class="comment">/* xCurrentTime */</span>                \
<a name="l02980"></a>02980     unixGetLastError      <span class="comment">/* xGetLastError */</span>               \
<a name="l02981"></a>02981   }
<a name="l02982"></a>02982 
<a name="l02983"></a>02983   <span class="keyword">static</span> <a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> unixVfs = <a class="code" href="os__symbian_8c.html#aabf620cbb686206cced5cec9f346f3a7">UNIXVFS</a>(<span class="stringliteral">&quot;unix&quot;</span>, 0);
<a name="l02984"></a>02984 <span class="preprocessor">#if SQLITE_ENABLE_LOCKING_STYLE</span>
<a name="l02985"></a>02985 <span class="preprocessor"></span>  <span class="keywordtype">int</span> i;
<a name="l02986"></a>02986   <span class="keyword">static</span> <a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> aVfs[] = {
<a name="l02987"></a>02987     <a class="code" href="os__symbian_8c.html#aabf620cbb686206cced5cec9f346f3a7">UNIXVFS</a>(<span class="stringliteral">&quot;unix-posix&quot;</span>,   <a class="code" href="os__unix_8c.html#ab9b6ea85c2889dcd69eff1e8bd68356c">LOCKING_STYLE_POSIX</a>), 
<a name="l02988"></a>02988     <a class="code" href="os__symbian_8c.html#aabf620cbb686206cced5cec9f346f3a7">UNIXVFS</a>(<span class="stringliteral">&quot;unix-afp&quot;</span>,     <a class="code" href="os__unix_8c.html#aa540763b2d32dabe7148496c6f42997c">LOCKING_STYLE_AFP</a>), 
<a name="l02989"></a>02989     <a class="code" href="os__symbian_8c.html#aabf620cbb686206cced5cec9f346f3a7">UNIXVFS</a>(<span class="stringliteral">&quot;unix-flock&quot;</span>,   <a class="code" href="os__unix_8c.html#a6bc7290dc781332aa31f3d8daae9772f">LOCKING_STYLE_FLOCK</a>), 
<a name="l02990"></a>02990     <a class="code" href="os__symbian_8c.html#aabf620cbb686206cced5cec9f346f3a7">UNIXVFS</a>(<span class="stringliteral">&quot;unix-dotfile&quot;</span>, <a class="code" href="os__unix_8c.html#afec800c31b854518e9548d55921e6eee">LOCKING_STYLE_DOTFILE</a>), 
<a name="l02991"></a>02991     <a class="code" href="os__symbian_8c.html#aabf620cbb686206cced5cec9f346f3a7">UNIXVFS</a>(<span class="stringliteral">&quot;unix-none&quot;</span>,    <a class="code" href="os__unix_8c.html#aabd10577b2d58c00dc8bf1541bab46e7">LOCKING_STYLE_NONE</a>)
<a name="l02992"></a>02992   };
<a name="l02993"></a>02993   <span class="keywordflow">for</span>(i=0; i&lt;(<span class="keyword">sizeof</span>(aVfs)/<span class="keyword">sizeof</span>(<a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a>)); i++){
<a name="l02994"></a>02994     <a class="code" href="os_8c.html#ae7c5e86e3ae223cde05a7a03a32ed4f2">sqlite3_vfs_register</a>(&amp;aVfs[i], 0);
<a name="l02995"></a>02995   }
<a name="l02996"></a>02996 <span class="preprocessor">#endif</span>
<a name="l02997"></a>02997 <span class="preprocessor"></span>  <a class="code" href="os_8c.html#ae7c5e86e3ae223cde05a7a03a32ed4f2">sqlite3_vfs_register</a>(&amp;unixVfs, 1);
<a name="l02998"></a>02998   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>; 
<a name="l02999"></a>02999 }
<a name="l03000"></a>03000 
<a name="l03001"></a>03001 <span class="comment">/*</span>
<a name="l03002"></a>03002 <span class="comment">** Shutdown the operating system interface. This is a no-op for unix.</span>
<a name="l03003"></a>03003 <span class="comment">*/</span>
<a name="l03004"></a><a class="code" href="os__unix_8c.html#a0b6445138837780f8731c70f45d0990f">03004</a> <span class="keywordtype">int</span> <a class="code" href="os__symbian_8c.html#a0b6445138837780f8731c70f45d0990f">sqlite3_os_end</a>(<span class="keywordtype">void</span>){ 
<a name="l03005"></a>03005   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>; 
<a name="l03006"></a>03006 }
<a name="l03007"></a>03007  
<a name="l03008"></a>03008 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OS_UNIX */</span>
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:55 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
