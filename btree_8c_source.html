<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: btree.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>btree.c</h1><a href="btree_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">** 2004 April 6</span>
<a name="l00003"></a>00003 <span class="comment">**</span>
<a name="l00004"></a>00004 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00005"></a>00005 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00006"></a>00006 <span class="comment">**</span>
<a name="l00007"></a>00007 <span class="comment">**    May you do good and not evil.</span>
<a name="l00008"></a>00008 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00009"></a>00009 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">*************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment">** $Id: btree.c,v 1.533 2008/11/12 08:49:52 danielk1977 Exp $</span>
<a name="l00013"></a>00013 <span class="comment">**</span>
<a name="l00014"></a>00014 <span class="comment">** This file implements a external (disk-based) database using BTrees.</span>
<a name="l00015"></a>00015 <span class="comment">** See the header comment on &quot;btreeInt.h&quot; for additional information.</span>
<a name="l00016"></a>00016 <span class="comment">** Including a description of file format and an overview of operation.</span>
<a name="l00017"></a>00017 <span class="comment">*/</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;<a class="code" href="btreeInt_8h.html">btreeInt.h</a>&quot;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/*</span>
<a name="l00021"></a>00021 <span class="comment">** The header string that appears at the beginning of every</span>
<a name="l00022"></a>00022 <span class="comment">** SQLite database.</span>
<a name="l00023"></a>00023 <span class="comment">*/</span>
<a name="l00024"></a><a class="code" href="btree_8c.html#ad8b5d12d71aa6b7df992adb8ecc5fa64">00024</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="btree_8c.html#ad8b5d12d71aa6b7df992adb8ecc5fa64">zMagicHeader</a>[] = <a class="code" href="btreeInt_8h.html#ac884c3152a57f9447fb524360c12224a">SQLITE_FILE_HEADER</a>;
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment">** Set this global variable to 1 to enable tracing using the TRACE</span>
<a name="l00028"></a>00028 <span class="comment">** macro.</span>
<a name="l00029"></a>00029 <span class="comment">*/</span>
<a name="l00030"></a>00030 <span class="preprocessor">#if 0</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="keywordtype">int</span> sqlite3BtreeTrace=0;  <span class="comment">/* True to enable tracing */</span>
<a name="l00032"></a>00032 <span class="preprocessor"># define TRACE(X)  if(sqlite3BtreeTrace){printf X;fflush(stdout);}</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00034"></a><a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">00034</a> <span class="preprocessor"></span><span class="preprocessor"># define TRACE(X)</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00037"></a>00037 <span class="comment">/*</span>
<a name="l00038"></a>00038 <span class="comment">** Sometimes we need a small amount of code such as a variable initialization</span>
<a name="l00039"></a>00039 <span class="comment">** to setup for a later assert() statement.  We do not want this code to</span>
<a name="l00040"></a>00040 <span class="comment">** appear when assert() is disabled.  The following macro is therefore</span>
<a name="l00041"></a>00041 <span class="comment">** used to contain that setup code.  The &quot;VVA&quot; acronym stands for</span>
<a name="l00042"></a>00042 <span class="comment">** &quot;Verification, Validation, and Accreditation&quot;.  In other words, the</span>
<a name="l00043"></a>00043 <span class="comment">** code within VVA_ONLY() will only run during verification processes.</span>
<a name="l00044"></a>00044 <span class="comment">*/</span>
<a name="l00045"></a>00045 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor"># define VVA_ONLY(X)  X</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00048"></a><a class="code" href="btree_8c.html#ad2f62e901555bee1364572b9d1c0c536">00048</a> <span class="preprocessor"></span><span class="preprocessor"># define VVA_ONLY(X)</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00055"></a>00055 <span class="comment">** A list of BtShared objects that are eligible for participation</span>
<a name="l00056"></a>00056 <span class="comment">** in shared cache.  This variable has file scope during normal builds,</span>
<a name="l00057"></a>00057 <span class="comment">** but the test harness needs to access it so we make it global for </span>
<a name="l00058"></a>00058 <span class="comment">** test builds.</span>
<a name="l00059"></a>00059 <span class="comment">*/</span>
<a name="l00060"></a>00060 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><a class="code" href="structBtShared.html">BtShared</a> *<a class="code" href="sqliteInt_8h.html#a8e0dad3bed1d9dc1ee42098adace3cb8">SQLITE_WSD</a> <a class="code" href="btree_8c.html#a377c6be2bf996f2a66cc72f9ba763a22">sqlite3SharedCacheList</a> = 0;
<a name="l00062"></a>00062 <span class="preprocessor">#else</span>
<a name="l00063"></a><a class="code" href="btree_8c.html#a377c6be2bf996f2a66cc72f9ba763a22">00063</a> <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="structBtShared.html">BtShared</a> *<a class="code" href="sqliteInt_8h.html#a8e0dad3bed1d9dc1ee42098adace3cb8">SQLITE_WSD</a> <a class="code" href="btree_8c.html#a377c6be2bf996f2a66cc72f9ba763a22">sqlite3SharedCacheList</a> = 0;
<a name="l00064"></a>00064 <span class="preprocessor">#endif</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_SHARED_CACHE */</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00069"></a>00069 <span class="comment">** Enable or disable the shared pager and schema features.</span>
<a name="l00070"></a>00070 <span class="comment">**</span>
<a name="l00071"></a>00071 <span class="comment">** This routine has no effect on existing database connections.</span>
<a name="l00072"></a>00072 <span class="comment">** The shared cache setting effects only future calls to</span>
<a name="l00073"></a>00073 <span class="comment">** sqlite3_open(), sqlite3_open16(), or sqlite3_open_v2().</span>
<a name="l00074"></a>00074 <span class="comment">*/</span>
<a name="l00075"></a><a class="code" href="sqlite3_8h.html#a561ae8b7a7de28c8ea7b1139173c0d4b">00075</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#af1e3064a9e7e3f1bb4feb8e842df5535">sqlite3_enable_shared_cache</a>(<span class="keywordtype">int</span> enable){
<a name="l00076"></a>00076   <a class="code" href="sqliteInt_8h.html#a8f7bcba4c905097c1d01e3aa80e99739">sqlite3GlobalConfig</a>.sharedCacheEnabled = enable;
<a name="l00077"></a>00077   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 <span class="preprocessor">#endif</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span>
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="comment">/*</span>
<a name="l00083"></a>00083 <span class="comment">** Forward declaration</span>
<a name="l00084"></a>00084 <span class="comment">*/</span>
<a name="l00085"></a>00085 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#accb60c0dac28fa55737649f0c556eef9">checkReadLocks</a>(<a class="code" href="structBtree.html">Btree</a>*, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a>, <a class="code" href="structBtCursor.html">BtCursor</a>*, <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="preprocessor">#ifdef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l00090"></a>00090 <span class="comment">  ** The functions queryTableLock(), lockTable() and unlockAllTables()</span>
<a name="l00091"></a>00091 <span class="comment">  ** manipulate entries in the BtShared.pLock linked list used to store</span>
<a name="l00092"></a>00092 <span class="comment">  ** shared-cache table level locks. If the library is compiled with the</span>
<a name="l00093"></a>00093 <span class="comment">  ** shared-cache feature disabled, then there is only ever one user</span>
<a name="l00094"></a>00094 <span class="comment">  ** of each BtShared structure and so this locking is not necessary. </span>
<a name="l00095"></a>00095 <span class="comment">  ** So define the lock related functions as no-ops.</span>
<a name="l00096"></a>00096 <span class="comment">  */</span>
<a name="l00097"></a>00097 <span class="preprocessor">  #define queryTableLock(a,b,c) SQLITE_OK</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">  #define lockTable(a,b,c) SQLITE_OK</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">  #define unlockAllTables(a)</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>
<a name="l00102"></a>00102 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00104"></a>00104 <span class="comment">** Query to see if btree handle p may obtain a lock of type eLock </span>
<a name="l00105"></a>00105 <span class="comment">** (READ_LOCK or WRITE_LOCK) on the table with root-page iTab. Return</span>
<a name="l00106"></a>00106 <span class="comment">** SQLITE_OK if the lock may be obtained (by calling lockTable()), or</span>
<a name="l00107"></a>00107 <span class="comment">** SQLITE_LOCKED if not.</span>
<a name="l00108"></a>00108 <span class="comment">*/</span>
<a name="l00109"></a><a class="code" href="btree_8c.html#a950bafa2f267025f9e7369992a6aa026">00109</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a950bafa2f267025f9e7369992a6aa026">queryTableLock</a>(<a class="code" href="structBtree.html">Btree</a> *p, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iTab, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eLock){
<a name="l00110"></a>00110   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l00111"></a>00111   <a class="code" href="structBtLock.html">BtLock</a> *pIter;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   assert( sqlite3BtreeHoldsMutex(p) );
<a name="l00114"></a>00114   assert( eLock==<a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a> || eLock==<a class="code" href="btreeInt_8h.html#ac917241e9ac8d772d244a2a5bfcf4506">WRITE_LOCK</a> );
<a name="l00115"></a>00115   assert( p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>!=0 );
<a name="l00116"></a>00116   
<a name="l00117"></a>00117   <span class="comment">/* This is a no-op if the shared-cache is not enabled */</span>
<a name="l00118"></a>00118   <span class="keywordflow">if</span>( !p-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> ){
<a name="l00119"></a>00119     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00120"></a>00120   }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   <span class="comment">/* If some other connection is holding an exclusive lock, the</span>
<a name="l00123"></a>00123 <span class="comment">  ** requested lock may not be obtained.</span>
<a name="l00124"></a>00124 <span class="comment">  */</span>
<a name="l00125"></a>00125   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a9a6c1d6f6802a4549a190d62332c0045">pExclusive</a> &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#a9a6c1d6f6802a4549a190d62332c0045">pExclusive</a>!=p ){
<a name="l00126"></a>00126     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>;
<a name="l00127"></a>00127   }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   <span class="comment">/* This (along with lockTable()) is where the ReadUncommitted flag is</span>
<a name="l00130"></a>00130 <span class="comment">  ** dealt with. If the caller is querying for a read-lock and the flag is</span>
<a name="l00131"></a>00131 <span class="comment">  ** set, it is unconditionally granted - even if there are write-locks</span>
<a name="l00132"></a>00132 <span class="comment">  ** on the table. If a write-lock is requested, the ReadUncommitted flag</span>
<a name="l00133"></a>00133 <span class="comment">  ** is not considered.</span>
<a name="l00134"></a>00134 <span class="comment">  **</span>
<a name="l00135"></a>00135 <span class="comment">  ** In function lockTable(), if a read-lock is demanded and the </span>
<a name="l00136"></a>00136 <span class="comment">  ** ReadUncommitted flag is set, no entry is added to the locks list </span>
<a name="l00137"></a>00137 <span class="comment">  ** (BtShared.pLock).</span>
<a name="l00138"></a>00138 <span class="comment">  **</span>
<a name="l00139"></a>00139 <span class="comment">  ** To summarize: If the ReadUncommitted flag is set, then read cursors do</span>
<a name="l00140"></a>00140 <span class="comment">  ** not create or respect table locks. The locking procedure for a </span>
<a name="l00141"></a>00141 <span class="comment">  ** write-cursor does not change.</span>
<a name="l00142"></a>00142 <span class="comment">  */</span>
<a name="l00143"></a>00143   <span class="keywordflow">if</span>( 
<a name="l00144"></a>00144     0==(p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a>&amp;<a class="code" href="sqliteInt_8h.html#adb6fa03198bc2e2db034979738ab0c27">SQLITE_ReadUncommitted</a>) || 
<a name="l00145"></a>00145     eLock==<a class="code" href="btreeInt_8h.html#ac917241e9ac8d772d244a2a5bfcf4506">WRITE_LOCK</a> ||
<a name="l00146"></a>00146     iTab==<a class="code" href="sqliteInt_8h.html#a55c81f26551028f4d36e84190993eaed">MASTER_ROOT</a>
<a name="l00147"></a>00147   ){
<a name="l00148"></a>00148     <span class="keywordflow">for</span>(pIter=pBt-&gt;<a class="code" href="structBtShared.html#af58c79eec88f99ed5a07d8cabf8a1d1a">pLock</a>; pIter; pIter=pIter-&gt;<a class="code" href="structBtLock.html#ad42de86209c7aab43604c52a549b7bca">pNext</a>){
<a name="l00149"></a>00149       <span class="keywordflow">if</span>( pIter-&gt;<a class="code" href="structBtLock.html#ab9125b8e79d480b75f3af21cb2ab55c7">pBtree</a>!=p &amp;&amp; pIter-&gt;<a class="code" href="structBtLock.html#a822efcf018d6c8eb343341cde5df980d">iTable</a>==iTab &amp;&amp; 
<a name="l00150"></a>00150           (pIter-&gt;<a class="code" href="structBtLock.html#abe07b71018ee423e0d94b5cdba044b5c">eLock</a>!=eLock || eLock!=<a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a>) ){
<a name="l00151"></a>00151         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>;
<a name="l00152"></a>00152       }
<a name="l00153"></a>00153     }
<a name="l00154"></a>00154   }
<a name="l00155"></a>00155   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00156"></a>00156 }
<a name="l00157"></a>00157 <span class="preprocessor">#endif </span><span class="comment">/* !SQLITE_OMIT_SHARED_CACHE */</span>
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00161"></a>00161 <span class="comment">** Add a lock on the table with root-page iTable to the shared-btree used</span>
<a name="l00162"></a>00162 <span class="comment">** by Btree handle p. Parameter eLock must be either READ_LOCK or </span>
<a name="l00163"></a>00163 <span class="comment">** WRITE_LOCK.</span>
<a name="l00164"></a>00164 <span class="comment">**</span>
<a name="l00165"></a>00165 <span class="comment">** SQLITE_OK is returned if the lock is added successfully. SQLITE_BUSY and</span>
<a name="l00166"></a>00166 <span class="comment">** SQLITE_NOMEM may also be returned.</span>
<a name="l00167"></a>00167 <span class="comment">*/</span>
<a name="l00168"></a><a class="code" href="btree_8c.html#a089cf86fc7bb3c6873eb1cc4ae547578">00168</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a089cf86fc7bb3c6873eb1cc4ae547578">lockTable</a>(<a class="code" href="structBtree.html">Btree</a> *p, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iTable, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eLock){
<a name="l00169"></a>00169   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l00170"></a>00170   <a class="code" href="structBtLock.html">BtLock</a> *pLock = 0;
<a name="l00171"></a>00171   <a class="code" href="structBtLock.html">BtLock</a> *pIter;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   assert( sqlite3BtreeHoldsMutex(p) );
<a name="l00174"></a>00174   assert( eLock==<a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a> || eLock==<a class="code" href="btreeInt_8h.html#ac917241e9ac8d772d244a2a5bfcf4506">WRITE_LOCK</a> );
<a name="l00175"></a>00175   assert( p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>!=0 );
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   <span class="comment">/* This is a no-op if the shared-cache is not enabled */</span>
<a name="l00178"></a>00178   <span class="keywordflow">if</span>( !p-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> ){
<a name="l00179"></a>00179     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00180"></a>00180   }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   assert( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==<a class="code" href="btree_8c.html#a950bafa2f267025f9e7369992a6aa026">queryTableLock</a>(p, iTable, eLock) );
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="comment">/* If the read-uncommitted flag is set and a read-lock is requested,</span>
<a name="l00185"></a>00185 <span class="comment">  ** return early without adding an entry to the BtShared.pLock list. See</span>
<a name="l00186"></a>00186 <span class="comment">  ** comment in function queryTableLock() for more info on handling </span>
<a name="l00187"></a>00187 <span class="comment">  ** the ReadUncommitted flag.</span>
<a name="l00188"></a>00188 <span class="comment">  */</span>
<a name="l00189"></a>00189   <span class="keywordflow">if</span>( 
<a name="l00190"></a>00190     (p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a>&amp;<a class="code" href="sqliteInt_8h.html#adb6fa03198bc2e2db034979738ab0c27">SQLITE_ReadUncommitted</a>) &amp;&amp; 
<a name="l00191"></a>00191     (eLock==<a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a>) &amp;&amp;
<a name="l00192"></a>00192     iTable!=<a class="code" href="sqliteInt_8h.html#a55c81f26551028f4d36e84190993eaed">MASTER_ROOT</a>
<a name="l00193"></a>00193   ){
<a name="l00194"></a>00194     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00195"></a>00195   }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="comment">/* First search the list for an existing lock on this table. */</span>
<a name="l00198"></a>00198   <span class="keywordflow">for</span>(pIter=pBt-&gt;<a class="code" href="structBtShared.html#af58c79eec88f99ed5a07d8cabf8a1d1a">pLock</a>; pIter; pIter=pIter-&gt;<a class="code" href="structBtLock.html#ad42de86209c7aab43604c52a549b7bca">pNext</a>){
<a name="l00199"></a>00199     <span class="keywordflow">if</span>( pIter-&gt;<a class="code" href="structBtLock.html#a822efcf018d6c8eb343341cde5df980d">iTable</a>==iTable &amp;&amp; pIter-&gt;<a class="code" href="structBtLock.html#ab9125b8e79d480b75f3af21cb2ab55c7">pBtree</a>==p ){
<a name="l00200"></a>00200       pLock = pIter;
<a name="l00201"></a>00201       <span class="keywordflow">break</span>;
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203   }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205   <span class="comment">/* If the above search did not find a BtLock struct associating Btree p</span>
<a name="l00206"></a>00206 <span class="comment">  ** with table iTable, allocate one and link it into the list.</span>
<a name="l00207"></a>00207 <span class="comment">  */</span>
<a name="l00208"></a>00208   <span class="keywordflow">if</span>( !pLock ){
<a name="l00209"></a>00209     pLock = (<a class="code" href="structBtLock.html">BtLock</a> *)<a class="code" href="malloc_8c.html#aa88ccfc5604fb4bd9b60b3ca4f9f58d4">sqlite3MallocZero</a>(<span class="keyword">sizeof</span>(<a class="code" href="structBtLock.html">BtLock</a>));
<a name="l00210"></a>00210     <span class="keywordflow">if</span>( !pLock ){
<a name="l00211"></a>00211       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213     pLock-&gt;<a class="code" href="structBtLock.html#a822efcf018d6c8eb343341cde5df980d">iTable</a> = iTable;
<a name="l00214"></a>00214     pLock-&gt;<a class="code" href="structBtLock.html#ab9125b8e79d480b75f3af21cb2ab55c7">pBtree</a> = p;
<a name="l00215"></a>00215     pLock-&gt;<a class="code" href="structBtLock.html#ad42de86209c7aab43604c52a549b7bca">pNext</a> = pBt-&gt;<a class="code" href="structBtShared.html#af58c79eec88f99ed5a07d8cabf8a1d1a">pLock</a>;
<a name="l00216"></a>00216     pBt-&gt;<a class="code" href="structBtShared.html#af58c79eec88f99ed5a07d8cabf8a1d1a">pLock</a> = pLock;
<a name="l00217"></a>00217   }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <span class="comment">/* Set the BtLock.eLock variable to the maximum of the current lock</span>
<a name="l00220"></a>00220 <span class="comment">  ** and the requested lock. This means if a write-lock was already held</span>
<a name="l00221"></a>00221 <span class="comment">  ** and a read-lock requested, we don&apos;t incorrectly downgrade the lock.</span>
<a name="l00222"></a>00222 <span class="comment">  */</span>
<a name="l00223"></a>00223   assert( <a class="code" href="btreeInt_8h.html#ac917241e9ac8d772d244a2a5bfcf4506">WRITE_LOCK</a>&gt;<a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a> );
<a name="l00224"></a>00224   <span class="keywordflow">if</span>( eLock&gt;pLock-&gt;<a class="code" href="structBtLock.html#abe07b71018ee423e0d94b5cdba044b5c">eLock</a> ){
<a name="l00225"></a>00225     pLock-&gt;<a class="code" href="structBtLock.html#abe07b71018ee423e0d94b5cdba044b5c">eLock</a> = eLock;
<a name="l00226"></a>00226   }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00229"></a>00229 }
<a name="l00230"></a>00230 <span class="preprocessor">#endif </span><span class="comment">/* !SQLITE_OMIT_SHARED_CACHE */</span>
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00234"></a>00234 <span class="comment">** Release all the table locks (locks obtained via calls to the lockTable()</span>
<a name="l00235"></a>00235 <span class="comment">** procedure) held by Btree handle p.</span>
<a name="l00236"></a>00236 <span class="comment">*/</span>
<a name="l00237"></a><a class="code" href="btree_8c.html#a0e6849fc355cc0b10cc35b0db87e7817">00237</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a0e6849fc355cc0b10cc35b0db87e7817">unlockAllTables</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l00238"></a>00238   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l00239"></a>00239   <a class="code" href="structBtLock.html">BtLock</a> **ppIter = &amp;pBt-&gt;<a class="code" href="structBtShared.html#af58c79eec88f99ed5a07d8cabf8a1d1a">pLock</a>;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241   assert( sqlite3BtreeHoldsMutex(p) );
<a name="l00242"></a>00242   assert( p-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> || 0==*ppIter );
<a name="l00243"></a>00243 
<a name="l00244"></a>00244   <span class="keywordflow">while</span>( *ppIter ){
<a name="l00245"></a>00245     <a class="code" href="structBtLock.html">BtLock</a> *pLock = *ppIter;
<a name="l00246"></a>00246     assert( pBt-&gt;<a class="code" href="structBtShared.html#a9a6c1d6f6802a4549a190d62332c0045">pExclusive</a>==0 || pBt-&gt;<a class="code" href="structBtShared.html#a9a6c1d6f6802a4549a190d62332c0045">pExclusive</a>==pLock-&gt;<a class="code" href="structBtLock.html#ab9125b8e79d480b75f3af21cb2ab55c7">pBtree</a> );
<a name="l00247"></a>00247     <span class="keywordflow">if</span>( pLock-&gt;<a class="code" href="structBtLock.html#ab9125b8e79d480b75f3af21cb2ab55c7">pBtree</a>==p ){
<a name="l00248"></a>00248       *ppIter = pLock-&gt;<a class="code" href="structBtLock.html#ad42de86209c7aab43604c52a549b7bca">pNext</a>;
<a name="l00249"></a>00249       <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pLock);
<a name="l00250"></a>00250     }<span class="keywordflow">else</span>{
<a name="l00251"></a>00251       ppIter = &amp;pLock-&gt;<a class="code" href="structBtLock.html#ad42de86209c7aab43604c52a549b7bca">pNext</a>;
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253   }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a9a6c1d6f6802a4549a190d62332c0045">pExclusive</a>==p ){
<a name="l00256"></a>00256     pBt-&gt;<a class="code" href="structBtShared.html#a9a6c1d6f6802a4549a190d62332c0045">pExclusive</a> = 0;
<a name="l00257"></a>00257   }
<a name="l00258"></a>00258 }
<a name="l00259"></a>00259 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_SHARED_CACHE */</span>
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage);  <span class="comment">/* Forward reference */</span>
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="comment">/*</span>
<a name="l00264"></a>00264 <span class="comment">** Verify that the cursor holds a mutex on the BtShared</span>
<a name="l00265"></a>00265 <span class="comment">*/</span>
<a name="l00266"></a>00266 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> cursorHoldsMutex(<a class="code" href="structBtCursor.html">BtCursor</a> *p){
<a name="l00268"></a>00268   <span class="keywordflow">return</span> <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(p-&gt;<a class="code" href="structBtCursor.html#a61c245712549192f7644e5ac23c00b74">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>);
<a name="l00269"></a>00269 }
<a name="l00270"></a>00270 <span class="preprocessor">#endif</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span>
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="preprocessor">#ifndef SQLITE_OMIT_INCRBLOB</span>
<a name="l00274"></a>00274 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00275"></a>00275 <span class="comment">** Invalidate the overflow page-list cache for cursor pCur, if any.</span>
<a name="l00276"></a>00276 <span class="comment">*/</span>
<a name="l00277"></a><a class="code" href="btree_8c.html#a419e64e1c771d39b27b2917f164fb8d4">00277</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a419e64e1c771d39b27b2917f164fb8d4">invalidateOverflowCache</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l00278"></a>00278   assert( cursorHoldsMutex(pCur) );
<a name="l00279"></a>00279   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a>);
<a name="l00280"></a>00280   pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a> = 0;
<a name="l00281"></a>00281 }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="comment">/*</span>
<a name="l00284"></a>00284 <span class="comment">** Invalidate the overflow page-list cache for all cursors opened</span>
<a name="l00285"></a>00285 <span class="comment">** on the shared btree structure pBt.</span>
<a name="l00286"></a>00286 <span class="comment">*/</span>
<a name="l00287"></a><a class="code" href="btree_8c.html#ae54a9c06fff6f71d61f77b1f08f3e09c">00287</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#ae54a9c06fff6f71d61f77b1f08f3e09c">invalidateAllOverflowCache</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt){
<a name="l00288"></a>00288   <a class="code" href="structBtCursor.html">BtCursor</a> *p;
<a name="l00289"></a>00289   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00290"></a>00290   <span class="keywordflow">for</span>(p=pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a>; p; p=p-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>){
<a name="l00291"></a>00291     <a class="code" href="btree_8c.html#a419e64e1c771d39b27b2917f164fb8d4">invalidateOverflowCache</a>(p);
<a name="l00292"></a>00292   }
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 <span class="preprocessor">#else</span>
<a name="l00295"></a>00295 <span class="preprocessor"></span><span class="preprocessor">  #define invalidateOverflowCache(x)</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span><span class="preprocessor">  #define invalidateAllOverflowCache(x)</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>
<a name="l00299"></a>00299 <span class="comment">/*</span>
<a name="l00300"></a>00300 <span class="comment">** Save the current cursor position in the variables BtCursor.nKey </span>
<a name="l00301"></a>00301 <span class="comment">** and BtCursor.pKey. The cursor&apos;s state is set to CURSOR_REQUIRESEEK.</span>
<a name="l00302"></a>00302 <span class="comment">*/</span>
<a name="l00303"></a><a class="code" href="btree_8c.html#a1fd19e15f7d2a03087f0c1f287dda917">00303</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a1fd19e15f7d2a03087f0c1f287dda917">saveCursorPosition</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l00304"></a>00304   <span class="keywordtype">int</span> rc;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   assert( <a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a>==pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> );
<a name="l00307"></a>00307   assert( 0==pCur-&gt;<a class="code" href="structBtCursor.html#a3c979824f27f63678d7a2b02311bc330">pKey</a> );
<a name="l00308"></a>00308   assert( cursorHoldsMutex(pCur) );
<a name="l00309"></a>00309 
<a name="l00310"></a>00310   rc = <a class="code" href="btree_8c.html#a2d5023d925e7eade74a33a94fbbc45e0">sqlite3BtreeKeySize</a>(pCur, &amp;pCur-&gt;<a class="code" href="structBtCursor.html#a23f6a271258c109aaeda0ba19e808f92">nKey</a>);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312   <span class="comment">/* If this is an intKey table, then the above call to BtreeKeySize()</span>
<a name="l00313"></a>00313 <span class="comment">  ** stores the integer key in pCur-&gt;nKey. In this case this value is</span>
<a name="l00314"></a>00314 <span class="comment">  ** all that is required. Otherwise, if pCur is not open on an intKey</span>
<a name="l00315"></a>00315 <span class="comment">  ** table, then malloc space for and store the pCur-&gt;nKey bytes of key </span>
<a name="l00316"></a>00316 <span class="comment">  ** data.</span>
<a name="l00317"></a>00317 <span class="comment">  */</span>
<a name="l00318"></a>00318   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; 0==pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0]-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a>){
<a name="l00319"></a>00319     <span class="keywordtype">void</span> *pKey = <a class="code" href="malloc_8c.html#a8c1a33577a57524c7c6eef3d9e64e742">sqlite3Malloc</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a23f6a271258c109aaeda0ba19e808f92">nKey</a>);
<a name="l00320"></a>00320     <span class="keywordflow">if</span>( pKey ){
<a name="l00321"></a>00321       rc = <a class="code" href="btree_8c.html#aed214bf6f1ee501ac77d819ef9fe12ee">sqlite3BtreeKey</a>(pCur, 0, pCur-&gt;<a class="code" href="structBtCursor.html#a23f6a271258c109aaeda0ba19e808f92">nKey</a>, pKey);
<a name="l00322"></a>00322       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00323"></a>00323         pCur-&gt;<a class="code" href="structBtCursor.html#a3c979824f27f63678d7a2b02311bc330">pKey</a> = pKey;
<a name="l00324"></a>00324       }<span class="keywordflow">else</span>{
<a name="l00325"></a>00325         <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pKey);
<a name="l00326"></a>00326       }
<a name="l00327"></a>00327     }<span class="keywordflow">else</span>{
<a name="l00328"></a>00328       rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l00329"></a>00329     }
<a name="l00330"></a>00330   }
<a name="l00331"></a>00331   assert( !pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0]-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> || !pCur-&gt;<a class="code" href="structBtCursor.html#a3c979824f27f63678d7a2b02311bc330">pKey</a> );
<a name="l00332"></a>00332 
<a name="l00333"></a>00333   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00334"></a>00334     <span class="keywordtype">int</span> i;
<a name="l00335"></a>00335     <span class="keywordflow">for</span>(i=0; i&lt;=pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>; i++){
<a name="l00336"></a>00336       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[i]);
<a name="l00337"></a>00337       pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[i] = 0;
<a name="l00338"></a>00338     }
<a name="l00339"></a>00339     pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a> = -1;
<a name="l00340"></a>00340     pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#aa6b8c9600c6ffb4faf986e971f674800">CURSOR_REQUIRESEEK</a>;
<a name="l00341"></a>00341   }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343   <a class="code" href="btree_8c.html#a419e64e1c771d39b27b2917f164fb8d4">invalidateOverflowCache</a>(pCur);
<a name="l00344"></a>00344   <span class="keywordflow">return</span> rc;
<a name="l00345"></a>00345 }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="comment">/*</span>
<a name="l00348"></a>00348 <span class="comment">** Save the positions of all cursors except pExcept open on the table </span>
<a name="l00349"></a>00349 <span class="comment">** with root-page iRoot. Usually, this is called just before cursor</span>
<a name="l00350"></a>00350 <span class="comment">** pExcept is used to modify the table (BtreeDelete() or BtreeInsert()).</span>
<a name="l00351"></a>00351 <span class="comment">*/</span>
<a name="l00352"></a><a class="code" href="btree_8c.html#add0c7a5086792caf465148beaadb913d">00352</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#add0c7a5086792caf465148beaadb913d">saveAllCursors</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iRoot, <a class="code" href="structBtCursor.html">BtCursor</a> *pExcept){
<a name="l00353"></a>00353   <a class="code" href="structBtCursor.html">BtCursor</a> *p;
<a name="l00354"></a>00354   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00355"></a>00355   assert( pExcept==0 || pExcept-&gt;<a class="code" href="structBtCursor.html#a61c245712549192f7644e5ac23c00b74">pBt</a>==pBt );
<a name="l00356"></a>00356   <span class="keywordflow">for</span>(p=pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a>; p; p=p-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>){
<a name="l00357"></a>00357     <span class="keywordflow">if</span>( p!=pExcept &amp;&amp; (0==iRoot || p-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>==iRoot) &amp;&amp; 
<a name="l00358"></a>00358         p-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> ){
<a name="l00359"></a>00359       <span class="keywordtype">int</span> rc = <a class="code" href="btree_8c.html#a1fd19e15f7d2a03087f0c1f287dda917">saveCursorPosition</a>(p);
<a name="l00360"></a>00360       <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=rc ){
<a name="l00361"></a>00361         <span class="keywordflow">return</span> rc;
<a name="l00362"></a>00362       }
<a name="l00363"></a>00363     }
<a name="l00364"></a>00364   }
<a name="l00365"></a>00365   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00366"></a>00366 }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="comment">/*</span>
<a name="l00369"></a>00369 <span class="comment">** Clear the current cursor position.</span>
<a name="l00370"></a>00370 <span class="comment">*/</span>
<a name="l00371"></a><a class="code" href="btree_8h.html#a6924c2695a85458a8911d9d9cda03759">00371</a> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a1b4b9b532ff7779a50f6482c723b3b50">sqlite3BtreeClearCursor</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l00372"></a>00372   assert( cursorHoldsMutex(pCur) );
<a name="l00373"></a>00373   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a3c979824f27f63678d7a2b02311bc330">pKey</a>);
<a name="l00374"></a>00374   pCur-&gt;<a class="code" href="structBtCursor.html#a3c979824f27f63678d7a2b02311bc330">pKey</a> = 0;
<a name="l00375"></a>00375   pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>;
<a name="l00376"></a>00376 }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="comment">/*</span>
<a name="l00379"></a>00379 <span class="comment">** Restore the cursor to the position it was in (or as close to as possible)</span>
<a name="l00380"></a>00380 <span class="comment">** when saveCursorPosition() was called. Note that this call deletes the </span>
<a name="l00381"></a>00381 <span class="comment">** saved position info stored by saveCursorPosition(), so there can be</span>
<a name="l00382"></a>00382 <span class="comment">** at most one effective restoreCursorPosition() call after each </span>
<a name="l00383"></a>00383 <span class="comment">** saveCursorPosition().</span>
<a name="l00384"></a>00384 <span class="comment">*/</span>
<a name="l00385"></a><a class="code" href="btreeInt_8h.html#a7782332abc1183b8d9124240906695fd">00385</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a7782332abc1183b8d9124240906695fd">sqlite3BtreeRestoreCursorPosition</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l00386"></a>00386   <span class="keywordtype">int</span> rc;
<a name="l00387"></a>00387   assert( cursorHoldsMutex(pCur) );
<a name="l00388"></a>00388   assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>&gt;=<a class="code" href="btreeInt_8h.html#aa6b8c9600c6ffb4faf986e971f674800">CURSOR_REQUIRESEEK</a> );
<a name="l00389"></a>00389   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a3906ad079a2cc489d948fcbbe3035e42">CURSOR_FAULT</a> ){
<a name="l00390"></a>00390     <span class="keywordflow">return</span> pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a>;
<a name="l00391"></a>00391   }
<a name="l00392"></a>00392   pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>;
<a name="l00393"></a>00393   rc = <a class="code" href="btree_8c.html#a0ae0770006edd874a30bcbbe303ee31d">sqlite3BtreeMoveto</a>(pCur, pCur-&gt;<a class="code" href="structBtCursor.html#a3c979824f27f63678d7a2b02311bc330">pKey</a>, pCur-&gt;<a class="code" href="structBtCursor.html#a23f6a271258c109aaeda0ba19e808f92">nKey</a>, 0, &amp;pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a>);
<a name="l00394"></a>00394   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00395"></a>00395     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a3c979824f27f63678d7a2b02311bc330">pKey</a>);
<a name="l00396"></a>00396     pCur-&gt;<a class="code" href="structBtCursor.html#a3c979824f27f63678d7a2b02311bc330">pKey</a> = 0;
<a name="l00397"></a>00397     assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> || pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> );
<a name="l00398"></a>00398   }
<a name="l00399"></a>00399   <span class="keywordflow">return</span> rc;
<a name="l00400"></a>00400 }
<a name="l00401"></a>00401 
<a name="l00402"></a><a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">00402</a> <span class="preprocessor">#define restoreCursorPosition(p) \</span>
<a name="l00403"></a>00403 <span class="preprocessor">  (p-&gt;eState&gt;=CURSOR_REQUIRESEEK ? \</span>
<a name="l00404"></a>00404 <span class="preprocessor">         sqlite3BtreeRestoreCursorPosition(p) : \</span>
<a name="l00405"></a>00405 <span class="preprocessor">         SQLITE_OK)</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span>
<a name="l00407"></a>00407 <span class="comment">/*</span>
<a name="l00408"></a>00408 <span class="comment">** Determine whether or not a cursor has moved from the position it</span>
<a name="l00409"></a>00409 <span class="comment">** was last placed at.  Cursors can move when the row they are pointing</span>
<a name="l00410"></a>00410 <span class="comment">** at is deleted out from under them.</span>
<a name="l00411"></a>00411 <span class="comment">**</span>
<a name="l00412"></a>00412 <span class="comment">** This routine returns an error code if something goes wrong.  The</span>
<a name="l00413"></a>00413 <span class="comment">** integer *pHasMoved is set to one if the cursor has moved and 0 if not.</span>
<a name="l00414"></a>00414 <span class="comment">*/</span>
<a name="l00415"></a><a class="code" href="btree_8h.html#accaf2da8cd3a03eeb72c015f21a5c094">00415</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a8175c379b606ff1986a8c51c88d979c8">sqlite3BtreeCursorHasMoved</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <span class="keywordtype">int</span> *pHasMoved){
<a name="l00416"></a>00416   <span class="keywordtype">int</span> rc;
<a name="l00417"></a>00417 
<a name="l00418"></a>00418   rc = <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCur);
<a name="l00419"></a>00419   <span class="keywordflow">if</span>( rc ){
<a name="l00420"></a>00420     *pHasMoved = 1;
<a name="l00421"></a>00421     <span class="keywordflow">return</span> rc;
<a name="l00422"></a>00422   }
<a name="l00423"></a>00423   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>!=<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> || pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a>!=0 ){
<a name="l00424"></a>00424     *pHasMoved = 1;
<a name="l00425"></a>00425   }<span class="keywordflow">else</span>{
<a name="l00426"></a>00426     *pHasMoved = 0;
<a name="l00427"></a>00427   }
<a name="l00428"></a>00428   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00429"></a>00429 }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00433"></a>00433 <span class="comment">** Given a page number of a regular database page, return the page</span>
<a name="l00434"></a>00434 <span class="comment">** number for the pointer-map page that contains the entry for the</span>
<a name="l00435"></a>00435 <span class="comment">** input page number.</span>
<a name="l00436"></a>00436 <span class="comment">*/</span>
<a name="l00437"></a><a class="code" href="btree_8c.html#abb7c2bfe804909af45f975a844539b51">00437</a> <span class="keyword">static</span> <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> <a class="code" href="btree_8c.html#abb7c2bfe804909af45f975a844539b51">ptrmapPageno</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgno){
<a name="l00438"></a>00438   <span class="keywordtype">int</span> nPagesPerMapPage, iPtrMap, ret;
<a name="l00439"></a>00439   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00440"></a>00440   nPagesPerMapPage = (pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>/5)+1;
<a name="l00441"></a>00441   iPtrMap = (pgno-2)/nPagesPerMapPage;
<a name="l00442"></a>00442   ret = (iPtrMap*nPagesPerMapPage) + 2; 
<a name="l00443"></a>00443   <span class="keywordflow">if</span>( ret==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){
<a name="l00444"></a>00444     ret++;
<a name="l00445"></a>00445   }
<a name="l00446"></a>00446   <span class="keywordflow">return</span> ret;
<a name="l00447"></a>00447 }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 <span class="comment">/*</span>
<a name="l00450"></a>00450 <span class="comment">** Write an entry into the pointer map.</span>
<a name="l00451"></a>00451 <span class="comment">**</span>
<a name="l00452"></a>00452 <span class="comment">** This routine updates the pointer map entry for page number &apos;key&apos;</span>
<a name="l00453"></a>00453 <span class="comment">** so that it maps to type &apos;eType&apos; and parent page number &apos;pgno&apos;.</span>
<a name="l00454"></a>00454 <span class="comment">** An error code is returned if something goes wrong, otherwise SQLITE_OK.</span>
<a name="l00455"></a>00455 <span class="comment">*/</span>
<a name="l00456"></a><a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">00456</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> key, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eType, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> parent){
<a name="l00457"></a>00457   <a class="code" href="structPgHdr.html">DbPage</a> *pDbPage;  <span class="comment">/* The pointer map page */</span>
<a name="l00458"></a>00458   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pPtrmap;      <span class="comment">/* The pointer map data */</span>
<a name="l00459"></a>00459   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iPtrmap;     <span class="comment">/* The pointer map page number */</span>
<a name="l00460"></a>00460   <span class="keywordtype">int</span> offset;       <span class="comment">/* Offset in pointer map page */</span>
<a name="l00461"></a>00461   <span class="keywordtype">int</span> rc;
<a name="l00462"></a>00462 
<a name="l00463"></a>00463   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00464"></a>00464   <span class="comment">/* The master-journal page number must never be used as a pointer map page */</span>
<a name="l00465"></a>00465   assert( 0==<a class="code" href="btreeInt_8h.html#a5236c788e81fad4b3d02e93a63f8f649">PTRMAP_ISPAGE</a>(pBt, <a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt)) );
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   assert( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> );
<a name="l00468"></a>00468   <span class="keywordflow">if</span>( key==0 ){
<a name="l00469"></a>00469     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l00470"></a>00470   }
<a name="l00471"></a>00471   iPtrmap = <a class="code" href="btreeInt_8h.html#af4119a9a3bb0a5df2c67d813e9bea637">PTRMAP_PAGENO</a>(pBt, key);
<a name="l00472"></a>00472   rc = <a class="code" href="pager_8h.html#ac690af087310cf9d64d04d8559be402e">sqlite3PagerGet</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, iPtrmap, &amp;pDbPage);
<a name="l00473"></a>00473   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00474"></a>00474     <span class="keywordflow">return</span> rc;
<a name="l00475"></a>00475   }
<a name="l00476"></a>00476   offset = <a class="code" href="btreeInt_8h.html#a06de54dda2005967ed4e6e2a587c9937">PTRMAP_PTROFFSET</a>(iPtrmap, key);
<a name="l00477"></a>00477   pPtrmap = (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *)<a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pDbPage);
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   <span class="keywordflow">if</span>( eType!=pPtrmap[offset] || <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPtrmap[offset+1])!=parent ){
<a name="l00480"></a>00480     <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;PTRMAP_UPDATE: %d-&gt;(%d,%d)\n&quot;</span>, key, eType, parent));
<a name="l00481"></a>00481     rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pDbPage);
<a name="l00482"></a>00482     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00483"></a>00483       pPtrmap[offset] = eType;
<a name="l00484"></a>00484       <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPtrmap[offset+1], parent);
<a name="l00485"></a>00485     }
<a name="l00486"></a>00486   }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488   <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pDbPage);
<a name="l00489"></a>00489   <span class="keywordflow">return</span> rc;
<a name="l00490"></a>00490 }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="comment">/*</span>
<a name="l00493"></a>00493 <span class="comment">** Read an entry from the pointer map.</span>
<a name="l00494"></a>00494 <span class="comment">**</span>
<a name="l00495"></a>00495 <span class="comment">** This routine retrieves the pointer map entry for page &apos;key&apos;, writing</span>
<a name="l00496"></a>00496 <span class="comment">** the type and parent page number to *pEType and *pPgno respectively.</span>
<a name="l00497"></a>00497 <span class="comment">** An error code is returned if something goes wrong, otherwise SQLITE_OK.</span>
<a name="l00498"></a>00498 <span class="comment">*/</span>
<a name="l00499"></a><a class="code" href="btree_8c.html#ae91bfd9c1bec807a52a384d2ed01934b">00499</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ae91bfd9c1bec807a52a384d2ed01934b">ptrmapGet</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> key, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pEType, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> *pPgno){
<a name="l00500"></a>00500   <a class="code" href="structPgHdr.html">DbPage</a> *pDbPage;   <span class="comment">/* The pointer map page */</span>
<a name="l00501"></a>00501   <span class="keywordtype">int</span> iPtrmap;       <span class="comment">/* Pointer map page index */</span>
<a name="l00502"></a>00502   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pPtrmap;       <span class="comment">/* Pointer map page data */</span>
<a name="l00503"></a>00503   <span class="keywordtype">int</span> offset;        <span class="comment">/* Offset of entry in pointer map */</span>
<a name="l00504"></a>00504   <span class="keywordtype">int</span> rc;
<a name="l00505"></a>00505 
<a name="l00506"></a>00506   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00507"></a>00507 
<a name="l00508"></a>00508   iPtrmap = <a class="code" href="btreeInt_8h.html#af4119a9a3bb0a5df2c67d813e9bea637">PTRMAP_PAGENO</a>(pBt, key);
<a name="l00509"></a>00509   rc = <a class="code" href="pager_8h.html#ac690af087310cf9d64d04d8559be402e">sqlite3PagerGet</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, iPtrmap, &amp;pDbPage);
<a name="l00510"></a>00510   <span class="keywordflow">if</span>( rc!=0 ){
<a name="l00511"></a>00511     <span class="keywordflow">return</span> rc;
<a name="l00512"></a>00512   }
<a name="l00513"></a>00513   pPtrmap = (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *)<a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pDbPage);
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   offset = <a class="code" href="btreeInt_8h.html#a06de54dda2005967ed4e6e2a587c9937">PTRMAP_PTROFFSET</a>(iPtrmap, key);
<a name="l00516"></a>00516   assert( pEType!=0 );
<a name="l00517"></a>00517   *pEType = pPtrmap[offset];
<a name="l00518"></a>00518   <span class="keywordflow">if</span>( pPgno ) *pPgno = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPtrmap[offset+1]);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pDbPage);
<a name="l00521"></a>00521   <span class="keywordflow">if</span>( *pEType&lt;1 || *pEType&gt;5 ) <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l00522"></a>00522   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00523"></a>00523 }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 <span class="preprocessor">#else </span><span class="comment">/* if defined SQLITE_OMIT_AUTOVACUUM */</span>
<a name="l00526"></a>00526 <span class="preprocessor">  #define ptrmapPut(w,x,y,z) SQLITE_OK</span>
<a name="l00527"></a>00527 <span class="preprocessor"></span><span class="preprocessor">  #define ptrmapGet(w,x,y,z) SQLITE_OK</span>
<a name="l00528"></a>00528 <span class="preprocessor"></span><span class="preprocessor">  #define ptrmapPutOvfl(y,z) SQLITE_OK</span>
<a name="l00529"></a>00529 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00530"></a>00530 <span class="preprocessor"></span>
<a name="l00531"></a>00531 <span class="comment">/*</span>
<a name="l00532"></a>00532 <span class="comment">** Given a btree page and a cell index (0 means the first cell on</span>
<a name="l00533"></a>00533 <span class="comment">** the page, 1 means the second cell, and so forth) return a pointer</span>
<a name="l00534"></a>00534 <span class="comment">** to the cell content.</span>
<a name="l00535"></a>00535 <span class="comment">**</span>
<a name="l00536"></a>00536 <span class="comment">** This routine works only for pages that do not contain overflow cells.</span>
<a name="l00537"></a>00537 <span class="comment">*/</span>
<a name="l00538"></a><a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">00538</a> <span class="preprocessor">#define findCell(P,I) \</span>
<a name="l00539"></a>00539 <span class="preprocessor">  ((P)-&gt;aData + ((P)-&gt;maskPage &amp; get2byte(&amp;(P)-&gt;aData[(P)-&gt;cellOffset+2*(I)])))</span>
<a name="l00540"></a>00540 <span class="preprocessor"></span>
<a name="l00541"></a>00541 <span class="comment">/*</span>
<a name="l00542"></a>00542 <span class="comment">** This a more complex version of findCell() that works for</span>
<a name="l00543"></a>00543 <span class="comment">** pages that do contain overflow cells.  See insert</span>
<a name="l00544"></a>00544 <span class="comment">*/</span>
<a name="l00545"></a><a class="code" href="btree_8c.html#a4789c15455047776c4cca9c18cc6ec65">00545</a> <span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *<a class="code" href="btree_8c.html#a4789c15455047776c4cca9c18cc6ec65">findOverflowCell</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <span class="keywordtype">int</span> iCell){
<a name="l00546"></a>00546   <span class="keywordtype">int</span> i;
<a name="l00547"></a>00547   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00548"></a>00548   <span class="keywordflow">for</span>(i=pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>-1; i&gt;=0; i--){
<a name="l00549"></a>00549     <span class="keywordtype">int</span> k;
<a name="l00550"></a>00550     <span class="keyword">struct </span>_OvflCell *pOvfl;
<a name="l00551"></a>00551     pOvfl = &amp;pPage-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>[i];
<a name="l00552"></a>00552     k = pOvfl-&gt;<a class="code" href="structMemPage_1_1__OvflCell.html#ad10c93756d29693601aa63923a7fbee3">idx</a>;
<a name="l00553"></a>00553     <span class="keywordflow">if</span>( k&lt;=iCell ){
<a name="l00554"></a>00554       <span class="keywordflow">if</span>( k==iCell ){
<a name="l00555"></a>00555         <span class="keywordflow">return</span> pOvfl-&gt;pCell;
<a name="l00556"></a>00556       }
<a name="l00557"></a>00557       iCell--;
<a name="l00558"></a>00558     }
<a name="l00559"></a>00559   }
<a name="l00560"></a>00560   <span class="keywordflow">return</span> <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, iCell);
<a name="l00561"></a>00561 }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="comment">/*</span>
<a name="l00564"></a>00564 <span class="comment">** Parse a cell content block and fill in the CellInfo structure.  There</span>
<a name="l00565"></a>00565 <span class="comment">** are two versions of this function.  sqlite3BtreeParseCell() takes a </span>
<a name="l00566"></a>00566 <span class="comment">** cell index as the second argument and sqlite3BtreeParseCellPtr() </span>
<a name="l00567"></a>00567 <span class="comment">** takes a pointer to the body of the cell as its second argument.</span>
<a name="l00568"></a>00568 <span class="comment">**</span>
<a name="l00569"></a>00569 <span class="comment">** Within this file, the parseCell() macro can be called instead of</span>
<a name="l00570"></a>00570 <span class="comment">** sqlite3BtreeParseCellPtr(). Using some compilers, this will be faster.</span>
<a name="l00571"></a>00571 <span class="comment">*/</span>
<a name="l00572"></a><a class="code" href="btreeInt_8h.html#acf9c389968cbd797496767409b2f3cff">00572</a> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(
<a name="l00573"></a>00573   <a class="code" href="structMemPage.html">MemPage</a> *pPage,         <span class="comment">/* Page containing the cell */</span>
<a name="l00574"></a>00574   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell,              <span class="comment">/* Pointer to the cell text. */</span>
<a name="l00575"></a>00575   <a class="code" href="structCellInfo.html">CellInfo</a> *pInfo         <span class="comment">/* Fill in this structure */</span>
<a name="l00576"></a>00576 ){
<a name="l00577"></a>00577   <span class="keywordtype">int</span> n;                  <span class="comment">/* Number bytes in cell content header */</span>
<a name="l00578"></a>00578   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> nPayload;           <span class="comment">/* Number of bytes of cell payload */</span>
<a name="l00579"></a>00579 
<a name="l00580"></a>00580   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00581"></a>00581 
<a name="l00582"></a>00582   pInfo-&gt;<a class="code" href="structCellInfo.html#a595ed7eeb60ea274d868f24347b7238e">pCell</a> = pCell;
<a name="l00583"></a>00583   assert( pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a>==0 || pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a>==1 );
<a name="l00584"></a>00584   n = pPage-&gt;<a class="code" href="structMemPage.html#aeba10281fc255d9bbc0e31486f8fbd48">childPtrSize</a>;
<a name="l00585"></a>00585   assert( n==4-4*pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> );
<a name="l00586"></a>00586   <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> ){
<a name="l00587"></a>00587     <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#af7b608d25c2e326f82cc270cd53dd8f8">hasData</a> ){
<a name="l00588"></a>00588       n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(&amp;pCell[n], nPayload);
<a name="l00589"></a>00589     }<span class="keywordflow">else</span>{
<a name="l00590"></a>00590       nPayload = 0;
<a name="l00591"></a>00591     }
<a name="l00592"></a>00592     n += <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(&amp;pCell[n], (<a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a>*)&amp;pInfo-&gt;<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>);
<a name="l00593"></a>00593     pInfo-&gt;<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a> = nPayload;
<a name="l00594"></a>00594   }<span class="keywordflow">else</span>{
<a name="l00595"></a>00595     pInfo-&gt;<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a> = 0;
<a name="l00596"></a>00596     n += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(&amp;pCell[n], nPayload);
<a name="l00597"></a>00597     pInfo-&gt;<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a> = nPayload;
<a name="l00598"></a>00598   }
<a name="l00599"></a>00599   pInfo-&gt;<a class="code" href="structCellInfo.html#ac1e3c1b4216a8e778bbac82907bb1485">nPayload</a> = nPayload;
<a name="l00600"></a>00600   pInfo-&gt;<a class="code" href="structCellInfo.html#a99bb1f87208f793359cf63e3d164025b">nHeader</a> = n;
<a name="l00601"></a>00601   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a77f81ddecd2d17f448f368d5a7c8a8fc">likely</a>(nPayload&lt;=pPage-&gt;maxLocal) ){
<a name="l00602"></a>00602     <span class="comment">/* This is the (easy) common case where the entire payload fits</span>
<a name="l00603"></a>00603 <span class="comment">    ** on the local page.  No overflow is required.</span>
<a name="l00604"></a>00604 <span class="comment">    */</span>
<a name="l00605"></a>00605     <span class="keywordtype">int</span> nSize;          <span class="comment">/* Total size of cell content in bytes */</span>
<a name="l00606"></a>00606     nSize = nPayload + n;
<a name="l00607"></a>00607     pInfo-&gt;<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> = nPayload;
<a name="l00608"></a>00608     pInfo-&gt;<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a> = 0;
<a name="l00609"></a>00609     <span class="keywordflow">if</span>( (nSize &amp; ~3)==0 ){
<a name="l00610"></a>00610       nSize = 4;        <span class="comment">/* Minimum cell size is 4 */</span>
<a name="l00611"></a>00611     }
<a name="l00612"></a>00612     pInfo-&gt;<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = nSize;
<a name="l00613"></a>00613   }<span class="keywordflow">else</span>{
<a name="l00614"></a>00614     <span class="comment">/* If the payload will not fit completely on the local page, we have</span>
<a name="l00615"></a>00615 <span class="comment">    ** to decide how much to store locally and how much to spill onto</span>
<a name="l00616"></a>00616 <span class="comment">    ** overflow pages.  The strategy is to minimize the amount of unused</span>
<a name="l00617"></a>00617 <span class="comment">    ** space on overflow pages while keeping the amount of local storage</span>
<a name="l00618"></a>00618 <span class="comment">    ** in between minLocal and maxLocal.</span>
<a name="l00619"></a>00619 <span class="comment">    **</span>
<a name="l00620"></a>00620 <span class="comment">    ** Warning:  changing the way overflow payload is distributed in any</span>
<a name="l00621"></a>00621 <span class="comment">    ** way will result in an incompatible file format.</span>
<a name="l00622"></a>00622 <span class="comment">    */</span>
<a name="l00623"></a>00623     <span class="keywordtype">int</span> minLocal;  <span class="comment">/* Minimum amount of payload held locally */</span>
<a name="l00624"></a>00624     <span class="keywordtype">int</span> maxLocal;  <span class="comment">/* Maximum amount of payload held locally */</span>
<a name="l00625"></a>00625     <span class="keywordtype">int</span> surplus;   <span class="comment">/* Overflow payload available for local storage */</span>
<a name="l00626"></a>00626 
<a name="l00627"></a>00627     minLocal = pPage-&gt;<a class="code" href="structMemPage.html#a95cab31aa57bf8b478be273557c5c807">minLocal</a>;
<a name="l00628"></a>00628     maxLocal = pPage-&gt;<a class="code" href="structMemPage.html#a36394b7c3abf4652e7a24be4ab314f13">maxLocal</a>;
<a name="l00629"></a>00629     surplus = minLocal + (nPayload - minLocal)%(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> - 4);
<a name="l00630"></a>00630     <span class="keywordflow">if</span>( surplus &lt;= maxLocal ){
<a name="l00631"></a>00631       pInfo-&gt;<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> = surplus;
<a name="l00632"></a>00632     }<span class="keywordflow">else</span>{
<a name="l00633"></a>00633       pInfo-&gt;<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> = minLocal;
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635     pInfo-&gt;<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a> = pInfo-&gt;<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> + n;
<a name="l00636"></a>00636     pInfo-&gt;<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = pInfo-&gt;<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a> + 4;
<a name="l00637"></a>00637   }
<a name="l00638"></a>00638 }
<a name="l00639"></a><a class="code" href="btree_8c.html#aae282b7c9624906845b95570a02609cc">00639</a> <span class="preprocessor">#define parseCell(pPage, iCell, pInfo) \</span>
<a name="l00640"></a>00640 <span class="preprocessor">  sqlite3BtreeParseCellPtr((pPage), findCell((pPage), (iCell)), (pInfo))</span>
<a name="l00641"></a><a class="code" href="btreeInt_8h.html#af47ab2325832155ab4ad5a42a6d75459">00641</a> <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="btree_8c.html#ac350761e25d0e6db77f71c4c2d925bea">sqlite3BtreeParseCell</a>(
<a name="l00642"></a>00642   <a class="code" href="structMemPage.html">MemPage</a> *pPage,         <span class="comment">/* Page containing the cell */</span>
<a name="l00643"></a>00643   <span class="keywordtype">int</span> iCell,              <span class="comment">/* The cell index.  First cell is 0 */</span>
<a name="l00644"></a>00644   <a class="code" href="structCellInfo.html">CellInfo</a> *pInfo         <span class="comment">/* Fill in this structure */</span>
<a name="l00645"></a>00645 ){
<a name="l00646"></a>00646   <a class="code" href="btree_8c.html#aae282b7c9624906845b95570a02609cc">parseCell</a>(pPage, iCell, pInfo);
<a name="l00647"></a>00647 }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="comment">/*</span>
<a name="l00650"></a>00650 <span class="comment">** Compute the total number of bytes that a Cell needs in the cell</span>
<a name="l00651"></a>00651 <span class="comment">** data area of the btree-page.  The return number includes the cell</span>
<a name="l00652"></a>00652 <span class="comment">** data header and the local payload, but not any overflow page or</span>
<a name="l00653"></a>00653 <span class="comment">** the space used by the cell pointer.</span>
<a name="l00654"></a>00654 <span class="comment">*/</span>
<a name="l00655"></a>00655 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> cellSize(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <span class="keywordtype">int</span> iCell){
<a name="l00657"></a>00657   <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l00658"></a>00658   <a class="code" href="btree_8c.html#ac350761e25d0e6db77f71c4c2d925bea">sqlite3BtreeParseCell</a>(pPage, iCell, &amp;info);
<a name="l00659"></a>00659   <span class="keywordflow">return</span> info.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a>;
<a name="l00660"></a>00660 }
<a name="l00661"></a>00661 <span class="preprocessor">#endif</span>
<a name="l00662"></a><a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">00662</a> <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell){
<a name="l00663"></a>00663   <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l00664"></a>00664   <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(pPage, pCell, &amp;info);
<a name="l00665"></a>00665   <span class="keywordflow">return</span> info.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a>;
<a name="l00666"></a>00666 }
<a name="l00667"></a>00667 
<a name="l00668"></a>00668 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l00669"></a>00669 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00670"></a>00670 <span class="comment">** If the cell pCell, part of page pPage contains a pointer</span>
<a name="l00671"></a>00671 <span class="comment">** to an overflow page, insert an entry into the pointer-map</span>
<a name="l00672"></a>00672 <span class="comment">** for the overflow page.</span>
<a name="l00673"></a>00673 <span class="comment">*/</span>
<a name="l00674"></a><a class="code" href="btree_8c.html#a6746c96531d079a003aba72e1b7fc8a8">00674</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a6746c96531d079a003aba72e1b7fc8a8">ptrmapPutOvflPtr</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell){
<a name="l00675"></a>00675   <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l00676"></a>00676   assert( pCell!=0 );
<a name="l00677"></a>00677   <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(pPage, pCell, &amp;info);
<a name="l00678"></a>00678   assert( (info.<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a>+(pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a>?0:info.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>))==info.<a class="code" href="structCellInfo.html#ac1e3c1b4216a8e778bbac82907bb1485">nPayload</a> );
<a name="l00679"></a>00679   <span class="keywordflow">if</span>( (info.<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a>+(pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a>?0:info.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>))&gt;info.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> ){
<a name="l00680"></a>00680     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> ovfl = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pCell[info.<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a>]);
<a name="l00681"></a>00681     <span class="keywordflow">return</span> <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>, ovfl, <a class="code" href="btreeInt_8h.html#add9dc5f20d087b06cce9c19b30794560">PTRMAP_OVERFLOW1</a>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l00682"></a>00682   }
<a name="l00683"></a>00683   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00684"></a>00684 }
<a name="l00685"></a>00685 <span class="comment">/*</span>
<a name="l00686"></a>00686 <span class="comment">** If the cell with index iCell on page pPage contains a pointer</span>
<a name="l00687"></a>00687 <span class="comment">** to an overflow page, insert an entry into the pointer-map</span>
<a name="l00688"></a>00688 <span class="comment">** for the overflow page.</span>
<a name="l00689"></a>00689 <span class="comment">*/</span>
<a name="l00690"></a><a class="code" href="btree_8c.html#a4cf3751ebbf00f1d6405e916c95fbd6e">00690</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a4cf3751ebbf00f1d6405e916c95fbd6e">ptrmapPutOvfl</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <span class="keywordtype">int</span> iCell){
<a name="l00691"></a>00691   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell;
<a name="l00692"></a>00692   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00693"></a>00693   pCell = <a class="code" href="btree_8c.html#a4789c15455047776c4cca9c18cc6ec65">findOverflowCell</a>(pPage, iCell);
<a name="l00694"></a>00694   <span class="keywordflow">return</span> <a class="code" href="btree_8c.html#a6746c96531d079a003aba72e1b7fc8a8">ptrmapPutOvflPtr</a>(pPage, pCell);
<a name="l00695"></a>00695 }
<a name="l00696"></a>00696 <span class="preprocessor">#endif</span>
<a name="l00697"></a>00697 <span class="preprocessor"></span>
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 <span class="comment">/*</span>
<a name="l00700"></a>00700 <span class="comment">** Defragment the page given.  All Cells are moved to the</span>
<a name="l00701"></a>00701 <span class="comment">** end of the page and all free space is collected into one</span>
<a name="l00702"></a>00702 <span class="comment">** big FreeBlk that occurs in between the header and cell</span>
<a name="l00703"></a>00703 <span class="comment">** pointer array and the cell content area.</span>
<a name="l00704"></a>00704 <span class="comment">*/</span>
<a name="l00705"></a><a class="code" href="btree_8c.html#a47dc01495c37a948842e1fd7f5ffd98f">00705</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a47dc01495c37a948842e1fd7f5ffd98f">defragmentPage</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage){
<a name="l00706"></a>00706   <span class="keywordtype">int</span> i;                     <span class="comment">/* Loop counter */</span>
<a name="l00707"></a>00707   <span class="keywordtype">int</span> pc;                    <span class="comment">/* Address of a i-th cell */</span>
<a name="l00708"></a>00708   <span class="keywordtype">int</span> addr;                  <span class="comment">/* Offset of first byte after cell pointer array */</span>
<a name="l00709"></a>00709   <span class="keywordtype">int</span> hdr;                   <span class="comment">/* Offset to the page header */</span>
<a name="l00710"></a>00710   <span class="keywordtype">int</span> size;                  <span class="comment">/* Size of a cell */</span>
<a name="l00711"></a>00711   <span class="keywordtype">int</span> usableSize;            <span class="comment">/* Number of usable bytes on a page */</span>
<a name="l00712"></a>00712   <span class="keywordtype">int</span> cellOffset;            <span class="comment">/* Offset to the cell pointer array */</span>
<a name="l00713"></a>00713   <span class="keywordtype">int</span> cbrk;                  <span class="comment">/* Offset to the cell content area */</span>
<a name="l00714"></a>00714   <span class="keywordtype">int</span> nCell;                 <span class="comment">/* Number of cells on the page */</span>
<a name="l00715"></a>00715   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data;       <span class="comment">/* The page data */</span>
<a name="l00716"></a>00716   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *temp;       <span class="comment">/* Temp area for cell content */</span>
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   assert( sqlite3PagerIswriteable(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l00719"></a>00719   assert( pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>!=0 );
<a name="l00720"></a>00720   assert( pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> &lt;= <a class="code" href="sqliteLimit_8h.html#a5535106e00ef873848b6d344bc850692">SQLITE_MAX_PAGE_SIZE</a> );
<a name="l00721"></a>00721   assert( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==0 );
<a name="l00722"></a>00722   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00723"></a>00723   temp = <a class="code" href="pager_8c.html#a5cddf0f02cb45ade3ad6d24fd4a52e9c">sqlite3PagerTempSpace</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l00724"></a>00724   data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l00725"></a>00725   hdr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>;
<a name="l00726"></a>00726   cellOffset = pPage-&gt;<a class="code" href="structMemPage.html#a324ed834d93c3ae72994fb5730940521">cellOffset</a>;
<a name="l00727"></a>00727   nCell = pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>;
<a name="l00728"></a>00728   assert( nCell==<a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+3]) );
<a name="l00729"></a>00729   usableSize = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>;
<a name="l00730"></a>00730   cbrk = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]);
<a name="l00731"></a>00731   memcpy(&amp;temp[cbrk], &amp;data[cbrk], usableSize - cbrk);
<a name="l00732"></a>00732   cbrk = usableSize;
<a name="l00733"></a>00733   <span class="keywordflow">for</span>(i=0; i&lt;nCell; i++){
<a name="l00734"></a>00734     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pAddr;     <span class="comment">/* The i-th cell pointer */</span>
<a name="l00735"></a>00735     pAddr = &amp;data[cellOffset + i*2];
<a name="l00736"></a>00736     pc = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(pAddr);
<a name="l00737"></a>00737     <span class="keywordflow">if</span> (pc &gt;= pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>) {
<a name="l00738"></a>00738       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740     size = <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pPage, &amp;temp[pc]);
<a name="l00741"></a>00741     cbrk -= size;
<a name="l00742"></a>00742     <span class="keywordflow">if</span> ((cbrk &lt; cellOffset+2*nCell) || (cbrk+size&gt;pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>)) {
<a name="l00743"></a>00743       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l00744"></a>00744     }
<a name="l00745"></a>00745     memcpy(&amp;data[cbrk], &amp;temp[pc], size);
<a name="l00746"></a>00746     <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(pAddr, cbrk);
<a name="l00747"></a>00747   }
<a name="l00748"></a>00748   assert( cbrk&gt;=cellOffset+2*nCell );
<a name="l00749"></a>00749   <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[hdr+5], cbrk);
<a name="l00750"></a>00750   data[hdr+1] = 0;
<a name="l00751"></a>00751   data[hdr+2] = 0;
<a name="l00752"></a>00752   data[hdr+7] = 0;
<a name="l00753"></a>00753   addr = cellOffset+2*nCell;
<a name="l00754"></a>00754   memset(&amp;data[addr], 0, cbrk-addr);
<a name="l00755"></a>00755   <span class="keywordflow">if</span>( cbrk-addr!=pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> ){
<a name="l00756"></a>00756     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l00757"></a>00757   }
<a name="l00758"></a>00758   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00759"></a>00759 }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 <span class="comment">/*</span>
<a name="l00762"></a>00762 <span class="comment">** Allocate nByte bytes of space on a page.</span>
<a name="l00763"></a>00763 <span class="comment">**</span>
<a name="l00764"></a>00764 <span class="comment">** Return the index into pPage-&gt;aData[] of the first byte of</span>
<a name="l00765"></a>00765 <span class="comment">** the new allocation.  The caller guarantees that there is enough</span>
<a name="l00766"></a>00766 <span class="comment">** space.  This routine will never fail.</span>
<a name="l00767"></a>00767 <span class="comment">**</span>
<a name="l00768"></a>00768 <span class="comment">** If the page contains nBytes of free space but does not contain</span>
<a name="l00769"></a>00769 <span class="comment">** nBytes of contiguous free space, then this routine automatically</span>
<a name="l00770"></a>00770 <span class="comment">** calls defragementPage() to consolidate all free space before </span>
<a name="l00771"></a>00771 <span class="comment">** allocating the new chunk.</span>
<a name="l00772"></a>00772 <span class="comment">*/</span>
<a name="l00773"></a><a class="code" href="btree_8c.html#a39da5157552cf85c36496f7999a1197f">00773</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a39da5157552cf85c36496f7999a1197f">allocateSpace</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <span class="keywordtype">int</span> nByte){
<a name="l00774"></a>00774   <span class="keywordtype">int</span> addr, pc, hdr;
<a name="l00775"></a>00775   <span class="keywordtype">int</span> size;
<a name="l00776"></a>00776   <span class="keywordtype">int</span> nFrag;
<a name="l00777"></a>00777   <span class="keywordtype">int</span> top;
<a name="l00778"></a>00778   <span class="keywordtype">int</span> nCell;
<a name="l00779"></a>00779   <span class="keywordtype">int</span> cellOffset;
<a name="l00780"></a>00780   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data;
<a name="l00781"></a>00781   
<a name="l00782"></a>00782   data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l00783"></a>00783   assert( sqlite3PagerIswriteable(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l00784"></a>00784   assert( pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a> );
<a name="l00785"></a>00785   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00786"></a>00786   assert( nByte&gt;=0 );  <span class="comment">/* Minimum cell size is 4 */</span>
<a name="l00787"></a>00787   assert( pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>&gt;=nByte );
<a name="l00788"></a>00788   assert( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==0 );
<a name="l00789"></a>00789   pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> -= nByte;
<a name="l00790"></a>00790   hdr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>;
<a name="l00791"></a>00791 
<a name="l00792"></a>00792   nFrag = data[hdr+7];
<a name="l00793"></a>00793   <span class="keywordflow">if</span>( nFrag&lt;60 ){
<a name="l00794"></a>00794     <span class="comment">/* Search the freelist looking for a slot big enough to satisfy the</span>
<a name="l00795"></a>00795 <span class="comment">    ** space request. */</span>
<a name="l00796"></a>00796     addr = hdr+1;
<a name="l00797"></a>00797     <span class="keywordflow">while</span>( (pc = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[addr]))&gt;0 ){
<a name="l00798"></a>00798       size = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[pc+2]);
<a name="l00799"></a>00799       <span class="keywordflow">if</span>( size&gt;=nByte ){
<a name="l00800"></a>00800         <span class="keywordflow">if</span>( size&lt;nByte+4 ){
<a name="l00801"></a>00801           memcpy(&amp;data[addr], &amp;data[pc], 2);
<a name="l00802"></a>00802           data[hdr+7] = nFrag + size - nByte;
<a name="l00803"></a>00803           <span class="keywordflow">return</span> pc;
<a name="l00804"></a>00804         }<span class="keywordflow">else</span>{
<a name="l00805"></a>00805           <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[pc+2], size-nByte);
<a name="l00806"></a>00806           <span class="keywordflow">return</span> pc + size - nByte;
<a name="l00807"></a>00807         }
<a name="l00808"></a>00808       }
<a name="l00809"></a>00809       addr = pc;
<a name="l00810"></a>00810     }
<a name="l00811"></a>00811   }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813   <span class="comment">/* Allocate memory from the gap in between the cell pointer array</span>
<a name="l00814"></a>00814 <span class="comment">  ** and the cell content area.</span>
<a name="l00815"></a>00815 <span class="comment">  */</span>
<a name="l00816"></a>00816   top = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]);
<a name="l00817"></a>00817   nCell = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+3]);
<a name="l00818"></a>00818   cellOffset = pPage-&gt;<a class="code" href="structMemPage.html#a324ed834d93c3ae72994fb5730940521">cellOffset</a>;
<a name="l00819"></a>00819   <span class="keywordflow">if</span>( nFrag&gt;=60 || cellOffset + 2*nCell &gt; top - nByte ){
<a name="l00820"></a>00820     <a class="code" href="btree_8c.html#a47dc01495c37a948842e1fd7f5ffd98f">defragmentPage</a>(pPage);
<a name="l00821"></a>00821     top = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]);
<a name="l00822"></a>00822   }
<a name="l00823"></a>00823   top -= nByte;
<a name="l00824"></a>00824   assert( cellOffset + 2*nCell &lt;= top );
<a name="l00825"></a>00825   <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[hdr+5], top);
<a name="l00826"></a>00826   <span class="keywordflow">return</span> top;
<a name="l00827"></a>00827 }
<a name="l00828"></a>00828 
<a name="l00829"></a>00829 <span class="comment">/*</span>
<a name="l00830"></a>00830 <span class="comment">** Return a section of the pPage-&gt;aData to the freelist.</span>
<a name="l00831"></a>00831 <span class="comment">** The first byte of the new free block is pPage-&gt;aDisk[start]</span>
<a name="l00832"></a>00832 <span class="comment">** and the size of the block is &quot;size&quot; bytes.</span>
<a name="l00833"></a>00833 <span class="comment">**</span>
<a name="l00834"></a>00834 <span class="comment">** Most of the effort here is involved in coalesing adjacent</span>
<a name="l00835"></a>00835 <span class="comment">** free blocks into a single big free block.</span>
<a name="l00836"></a>00836 <span class="comment">*/</span>
<a name="l00837"></a><a class="code" href="btree_8c.html#ac7a66d1b107f53d3e9c04a51f6dad514">00837</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#ac7a66d1b107f53d3e9c04a51f6dad514">freeSpace</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> size){
<a name="l00838"></a>00838   <span class="keywordtype">int</span> addr, pbegin, hdr;
<a name="l00839"></a>00839   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l00840"></a>00840 
<a name="l00841"></a>00841   assert( pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>!=0 );
<a name="l00842"></a>00842   assert( sqlite3PagerIswriteable(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l00843"></a>00843   assert( start&gt;=pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+6+(pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a>?0:4) );
<a name="l00844"></a>00844   assert( (start + size)&lt;=pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> );
<a name="l00845"></a>00845   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00846"></a>00846   assert( size&gt;=0 );   <span class="comment">/* Minimum cell size is 4 */</span>
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 <span class="preprocessor">#ifdef SQLITE_SECURE_DELETE</span>
<a name="l00849"></a>00849 <span class="preprocessor"></span>  <span class="comment">/* Overwrite deleted information with zeros when the SECURE_DELETE </span>
<a name="l00850"></a>00850 <span class="comment">  ** option is enabled at compile-time */</span>
<a name="l00851"></a>00851   memset(&amp;data[start], 0, size);
<a name="l00852"></a>00852 <span class="preprocessor">#endif</span>
<a name="l00853"></a>00853 <span class="preprocessor"></span>
<a name="l00854"></a>00854   <span class="comment">/* Add the space back into the linked list of freeblocks */</span>
<a name="l00855"></a>00855   hdr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>;
<a name="l00856"></a>00856   addr = hdr + 1;
<a name="l00857"></a>00857   <span class="keywordflow">while</span>( (pbegin = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[addr]))&lt;start &amp;&amp; pbegin&gt;0 ){
<a name="l00858"></a>00858     assert( pbegin&lt;=pPage-&gt;pBt-&gt;usableSize-4 );
<a name="l00859"></a>00859     assert( pbegin&gt;addr );
<a name="l00860"></a>00860     addr = pbegin;
<a name="l00861"></a>00861   }
<a name="l00862"></a>00862   assert( pbegin&lt;=pPage-&gt;pBt-&gt;usableSize-4 );
<a name="l00863"></a>00863   assert( pbegin&gt;addr || pbegin==0 );
<a name="l00864"></a>00864   <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[addr], start);
<a name="l00865"></a>00865   <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[start], pbegin);
<a name="l00866"></a>00866   <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[start+2], size);
<a name="l00867"></a>00867   pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> += size;
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   <span class="comment">/* Coalesce adjacent free blocks */</span>
<a name="l00870"></a>00870   addr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a> + 1;
<a name="l00871"></a>00871   <span class="keywordflow">while</span>( (pbegin = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[addr]))&gt;0 ){
<a name="l00872"></a>00872     <span class="keywordtype">int</span> pnext, psize;
<a name="l00873"></a>00873     assert( pbegin&gt;addr );
<a name="l00874"></a>00874     assert( pbegin&lt;=pPage-&gt;pBt-&gt;usableSize-4 );
<a name="l00875"></a>00875     pnext = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[pbegin]);
<a name="l00876"></a>00876     psize = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[pbegin+2]);
<a name="l00877"></a>00877     <span class="keywordflow">if</span>( pbegin + psize + 3 &gt;= pnext &amp;&amp; pnext&gt;0 ){
<a name="l00878"></a>00878       <span class="keywordtype">int</span> frag = pnext - (pbegin+psize);
<a name="l00879"></a>00879       assert( frag&lt;=data[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+7] );
<a name="l00880"></a>00880       data[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+7] -= frag;
<a name="l00881"></a>00881       <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[pbegin], <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[pnext]));
<a name="l00882"></a>00882       <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[pbegin+2], pnext+<a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[pnext+2])-pbegin);
<a name="l00883"></a>00883     }<span class="keywordflow">else</span>{
<a name="l00884"></a>00884       addr = pbegin;
<a name="l00885"></a>00885     }
<a name="l00886"></a>00886   }
<a name="l00887"></a>00887 
<a name="l00888"></a>00888   <span class="comment">/* If the cell content area begins with a freeblock, remove it. */</span>
<a name="l00889"></a>00889   <span class="keywordflow">if</span>( data[hdr+1]==data[hdr+5] &amp;&amp; data[hdr+2]==data[hdr+6] ){
<a name="l00890"></a>00890     <span class="keywordtype">int</span> top;
<a name="l00891"></a>00891     pbegin = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+1]);
<a name="l00892"></a>00892     memcpy(&amp;data[hdr+1], &amp;data[pbegin], 2);
<a name="l00893"></a>00893     top = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]);
<a name="l00894"></a>00894     <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[hdr+5], top + <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[pbegin+2]));
<a name="l00895"></a>00895   }
<a name="l00896"></a>00896 }
<a name="l00897"></a>00897 
<a name="l00898"></a>00898 <span class="comment">/*</span>
<a name="l00899"></a>00899 <span class="comment">** Decode the flags byte (the first byte of the header) for a page</span>
<a name="l00900"></a>00900 <span class="comment">** and initialize fields of the MemPage structure accordingly.</span>
<a name="l00901"></a>00901 <span class="comment">**</span>
<a name="l00902"></a>00902 <span class="comment">** Only the following combinations are supported.  Anything different</span>
<a name="l00903"></a>00903 <span class="comment">** indicates a corrupt database files:</span>
<a name="l00904"></a>00904 <span class="comment">**</span>
<a name="l00905"></a>00905 <span class="comment">**         PTF_ZERODATA</span>
<a name="l00906"></a>00906 <span class="comment">**         PTF_ZERODATA | PTF_LEAF</span>
<a name="l00907"></a>00907 <span class="comment">**         PTF_LEAFDATA | PTF_INTKEY</span>
<a name="l00908"></a>00908 <span class="comment">**         PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF</span>
<a name="l00909"></a>00909 <span class="comment">*/</span>
<a name="l00910"></a><a class="code" href="btree_8c.html#acb168e46383706f31cefd555da235eae">00910</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#acb168e46383706f31cefd555da235eae">decodeFlags</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <span class="keywordtype">int</span> flagByte){
<a name="l00911"></a>00911   <a class="code" href="structBtShared.html">BtShared</a> *pBt;     <span class="comment">/* A copy of pPage-&gt;pBt */</span>
<a name="l00912"></a>00912 
<a name="l00913"></a>00913   assert( pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>==(pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>==1 ? 100 : 0) );
<a name="l00914"></a>00914   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00915"></a>00915   pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> = flagByte&gt;&gt;3;  assert( <a class="code" href="btreeInt_8h.html#a75a736a457cd09a431cef0c66aa45ce6">PTF_LEAF</a> == 1&lt;&lt;3 );
<a name="l00916"></a>00916   flagByte &amp;= ~<a class="code" href="btreeInt_8h.html#a75a736a457cd09a431cef0c66aa45ce6">PTF_LEAF</a>;
<a name="l00917"></a>00917   pPage-&gt;<a class="code" href="structMemPage.html#aeba10281fc255d9bbc0e31486f8fbd48">childPtrSize</a> = 4-4*pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a>;
<a name="l00918"></a>00918   pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l00919"></a>00919   <span class="keywordflow">if</span>( flagByte==(<a class="code" href="btreeInt_8h.html#a341dd6332e4cec8da26caed497810520">PTF_LEAFDATA</a> | <a class="code" href="btreeInt_8h.html#a140a8063c22071245b2a0469b31ee35b">PTF_INTKEY</a>) ){
<a name="l00920"></a>00920     pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> = 1;
<a name="l00921"></a>00921     pPage-&gt;<a class="code" href="structMemPage.html#af7b608d25c2e326f82cc270cd53dd8f8">hasData</a> = pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a>;
<a name="l00922"></a>00922     pPage-&gt;<a class="code" href="structMemPage.html#a36394b7c3abf4652e7a24be4ab314f13">maxLocal</a> = pBt-&gt;<a class="code" href="structBtShared.html#aac6494904c409641e70dc5f6c4d3579f">maxLeaf</a>;
<a name="l00923"></a>00923     pPage-&gt;<a class="code" href="structMemPage.html#a95cab31aa57bf8b478be273557c5c807">minLocal</a> = pBt-&gt;<a class="code" href="structBtShared.html#ac59606a27fc150707e9d1221c503246e">minLeaf</a>;
<a name="l00924"></a>00924   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( flagByte==<a class="code" href="btreeInt_8h.html#a4015fb3e9389825ee6f4f7a1b01cfdfa">PTF_ZERODATA</a> ){
<a name="l00925"></a>00925     pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> = 0;
<a name="l00926"></a>00926     pPage-&gt;<a class="code" href="structMemPage.html#af7b608d25c2e326f82cc270cd53dd8f8">hasData</a> = 0;
<a name="l00927"></a>00927     pPage-&gt;<a class="code" href="structMemPage.html#a36394b7c3abf4652e7a24be4ab314f13">maxLocal</a> = pBt-&gt;<a class="code" href="structBtShared.html#a3e8d9c50bd1d4afd09773b16d166d0ca">maxLocal</a>;
<a name="l00928"></a>00928     pPage-&gt;<a class="code" href="structMemPage.html#a95cab31aa57bf8b478be273557c5c807">minLocal</a> = pBt-&gt;<a class="code" href="structBtShared.html#a5c7ffeaddfc0530fdaadcaba8801ac53">minLocal</a>;
<a name="l00929"></a>00929   }<span class="keywordflow">else</span>{
<a name="l00930"></a>00930     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l00931"></a>00931   }
<a name="l00932"></a>00932   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00933"></a>00933 }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935 <span class="comment">/*</span>
<a name="l00936"></a>00936 <span class="comment">** Initialize the auxiliary information for a disk block.</span>
<a name="l00937"></a>00937 <span class="comment">**</span>
<a name="l00938"></a>00938 <span class="comment">** Return SQLITE_OK on success.  If we see that the page does</span>
<a name="l00939"></a>00939 <span class="comment">** not contain a well-formed database page, then return </span>
<a name="l00940"></a>00940 <span class="comment">** SQLITE_CORRUPT.  Note that a return of SQLITE_OK does not</span>
<a name="l00941"></a>00941 <span class="comment">** guarantee that the page is well-formed.  It only shows that</span>
<a name="l00942"></a>00942 <span class="comment">** we failed to detect any corruption.</span>
<a name="l00943"></a>00943 <span class="comment">*/</span>
<a name="l00944"></a><a class="code" href="btreeInt_8h.html#a6bd53cc52eb7920b1ab1d0510212bfa0">00944</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage){
<a name="l00945"></a>00945 
<a name="l00946"></a>00946   assert( pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>!=0 );
<a name="l00947"></a>00947   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l00948"></a>00948   assert( pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>==sqlite3PagerPagenumber(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l00949"></a>00949   assert( pPage == <a class="code" href="pager_8c.html#a439dda936e73b4bceae7d0a7950d2af6">sqlite3PagerGetExtra</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l00950"></a>00950   assert( pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a> == <a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l00951"></a>00951 
<a name="l00952"></a>00952   <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> ){
<a name="l00953"></a>00953     <span class="keywordtype">int</span> pc;            <span class="comment">/* Address of a freeblock within pPage-&gt;aData[] */</span>
<a name="l00954"></a>00954     <span class="keywordtype">int</span> hdr;           <span class="comment">/* Offset to beginning of page header */</span>
<a name="l00955"></a>00955     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *data;          <span class="comment">/* Equal to pPage-&gt;aData */</span>
<a name="l00956"></a>00956     <a class="code" href="structBtShared.html">BtShared</a> *pBt;        <span class="comment">/* The main btree structure */</span>
<a name="l00957"></a>00957     <span class="keywordtype">int</span> usableSize;    <span class="comment">/* Amount of usable space on each page */</span>
<a name="l00958"></a>00958     <span class="keywordtype">int</span> cellOffset;    <span class="comment">/* Offset from start of page to first cell pointer */</span>
<a name="l00959"></a>00959     <span class="keywordtype">int</span> nFree;         <span class="comment">/* Number of unused bytes on the page */</span>
<a name="l00960"></a>00960     <span class="keywordtype">int</span> top;           <span class="comment">/* First byte of the cell content area */</span>
<a name="l00961"></a>00961 
<a name="l00962"></a>00962     pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964     hdr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>;
<a name="l00965"></a>00965     data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l00966"></a>00966     <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#acb168e46383706f31cefd555da235eae">decodeFlags</a>(pPage, data[hdr]) ) <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l00967"></a>00967     assert( pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>&gt;=512 &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>&lt;=32768 );
<a name="l00968"></a>00968     pPage-&gt;<a class="code" href="structMemPage.html#aa3d64e8755cc9f431bbc8423a2b506ec">maskPage</a> = pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> - 1;
<a name="l00969"></a>00969     pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a> = 0;
<a name="l00970"></a>00970     usableSize = pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>;
<a name="l00971"></a>00971     pPage-&gt;<a class="code" href="structMemPage.html#a324ed834d93c3ae72994fb5730940521">cellOffset</a> = cellOffset = hdr + 12 - 4*pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a>;
<a name="l00972"></a>00972     top = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]);
<a name="l00973"></a>00973     pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+3]);
<a name="l00974"></a>00974     <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>&gt;<a class="code" href="btreeInt_8h.html#a5f4299af45c4457a1fcfcfe188e14017">MX_CELL</a>(pBt) ){
<a name="l00975"></a>00975       <span class="comment">/* To many cells for a single page.  The page must be corrupt */</span>
<a name="l00976"></a>00976       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l00977"></a>00977     }
<a name="l00978"></a>00978   
<a name="l00979"></a>00979     <span class="comment">/* Compute the total free space on the page */</span>
<a name="l00980"></a>00980     pc = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+1]);
<a name="l00981"></a>00981     nFree = data[hdr+7] + top - (cellOffset + 2*pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>);
<a name="l00982"></a>00982     <span class="keywordflow">while</span>( pc&gt;0 ){
<a name="l00983"></a>00983       <span class="keywordtype">int</span> <a class="code" href="llex_8c.html#a8ab976102fb046f9974c53caaf5a1995">next</a>, size;
<a name="l00984"></a>00984       <span class="keywordflow">if</span>( pc&gt;usableSize-4 ){
<a name="l00985"></a>00985         <span class="comment">/* Free block is off the page */</span>
<a name="l00986"></a>00986         <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>; 
<a name="l00987"></a>00987       }
<a name="l00988"></a>00988       next = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[pc]);
<a name="l00989"></a>00989       size = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[pc+2]);
<a name="l00990"></a>00990       <span class="keywordflow">if</span>( next&gt;0 &amp;&amp; next&lt;=pc+size+3 ){
<a name="l00991"></a>00991         <span class="comment">/* Free blocks must be in accending order */</span>
<a name="l00992"></a>00992         <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>; 
<a name="l00993"></a>00993       }
<a name="l00994"></a>00994       nFree += size;
<a name="l00995"></a>00995       pc = next;
<a name="l00996"></a>00996     }
<a name="l00997"></a>00997     pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> = nFree;
<a name="l00998"></a>00998     <span class="keywordflow">if</span>( nFree&gt;=usableSize ){
<a name="l00999"></a>00999       <span class="comment">/* Free space cannot exceed total page size */</span>
<a name="l01000"></a>01000       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>; 
<a name="l01001"></a>01001     }
<a name="l01002"></a>01002 
<a name="l01003"></a>01003 <span class="preprocessor">#if 0</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span>  <span class="comment">/* Check that all the offsets in the cell offset array are within range. </span>
<a name="l01005"></a>01005 <span class="comment">  ** </span>
<a name="l01006"></a>01006 <span class="comment">  ** Omitting this consistency check and using the pPage-&gt;maskPage mask</span>
<a name="l01007"></a>01007 <span class="comment">  ** to prevent overrunning the page buffer in findCell() results in a</span>
<a name="l01008"></a>01008 <span class="comment">  ** 2.5% performance gain.</span>
<a name="l01009"></a>01009 <span class="comment">  */</span>
<a name="l01010"></a>01010   {
<a name="l01011"></a>01011     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pOff;        <span class="comment">/* Iterator used to check all cell offsets are in range */</span>
<a name="l01012"></a>01012     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pEnd;        <span class="comment">/* Pointer to end of cell offset array */</span>
<a name="l01013"></a>01013     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> mask;         <span class="comment">/* Mask of bits that must be zero in MSB of cell offsets */</span>
<a name="l01014"></a>01014     mask = ~(((<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>)(pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>&gt;&gt;8))-1);
<a name="l01015"></a>01015     pEnd = &amp;data[cellOffset + pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>*2];
<a name="l01016"></a>01016     <span class="keywordflow">for</span>(pOff=&amp;data[cellOffset]; pOff!=pEnd &amp;&amp; !((*pOff)&amp;mask); pOff+=2);
<a name="l01017"></a>01017     <span class="keywordflow">if</span>( pOff!=pEnd ){
<a name="l01018"></a>01018       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l01019"></a>01019     }
<a name="l01020"></a>01020   }
<a name="l01021"></a>01021 <span class="preprocessor">#endif</span>
<a name="l01022"></a>01022 <span class="preprocessor"></span>
<a name="l01023"></a>01023     pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> = 1;
<a name="l01024"></a>01024   }
<a name="l01025"></a>01025   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01026"></a>01026 }
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 <span class="comment">/*</span>
<a name="l01029"></a>01029 <span class="comment">** Set up a raw page so that it looks like a database page holding</span>
<a name="l01030"></a>01030 <span class="comment">** no entries.</span>
<a name="l01031"></a>01031 <span class="comment">*/</span>
<a name="l01032"></a><a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">01032</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">zeroPage</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <span class="keywordtype">int</span> flags){
<a name="l01033"></a>01033   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l01034"></a>01034   <a class="code" href="structBtShared.html">BtShared</a> *pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l01035"></a>01035   <span class="keywordtype">int</span> hdr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>;
<a name="l01036"></a>01036   <span class="keywordtype">int</span> first;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038   assert( sqlite3PagerPagenumber(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>)==pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a> );
<a name="l01039"></a>01039   assert( <a class="code" href="pager_8c.html#a439dda936e73b4bceae7d0a7950d2af6">sqlite3PagerGetExtra</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) == (<span class="keywordtype">void</span>*)pPage );
<a name="l01040"></a>01040   assert( <a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pPage-&gt;pDbPage) == data );
<a name="l01041"></a>01041   assert( sqlite3PagerIswriteable(pPage-&gt;pDbPage) );
<a name="l01042"></a>01042   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l01043"></a>01043   <span class="comment">/*memset(&amp;data[hdr], 0, pBt-&gt;usableSize - hdr);*/</span>
<a name="l01044"></a>01044   data[hdr] = flags;
<a name="l01045"></a>01045   first = hdr + 8 + 4*((flags&amp;<a class="code" href="btreeInt_8h.html#a75a736a457cd09a431cef0c66aa45ce6">PTF_LEAF</a>)==0);
<a name="l01046"></a>01046   memset(&amp;data[hdr+1], 0, 4);
<a name="l01047"></a>01047   data[hdr+7] = 0;
<a name="l01048"></a>01048   <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[hdr+5], pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>);
<a name="l01049"></a>01049   pPage-&gt;nFree = pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> - first;
<a name="l01050"></a>01050   <a class="code" href="btree_8c.html#acb168e46383706f31cefd555da235eae">decodeFlags</a>(pPage, flags);
<a name="l01051"></a>01051   pPage-&gt;hdrOffset = hdr;
<a name="l01052"></a>01052   pPage-&gt;cellOffset = first;
<a name="l01053"></a>01053   pPage-&gt;nOverflow = 0;
<a name="l01054"></a>01054   assert( pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>&gt;=512 &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>&lt;=32768 );
<a name="l01055"></a>01055   pPage-&gt;maskPage = pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> - 1;
<a name="l01056"></a>01056   pPage-&gt;nCell = 0;
<a name="l01057"></a>01057   pPage-&gt;isInit = 1;
<a name="l01058"></a>01058 }
<a name="l01059"></a>01059 
<a name="l01060"></a>01060 
<a name="l01061"></a>01061 <span class="comment">/*</span>
<a name="l01062"></a>01062 <span class="comment">** Convert a DbPage obtained from the pager into a MemPage used by</span>
<a name="l01063"></a>01063 <span class="comment">** the btree layer.</span>
<a name="l01064"></a>01064 <span class="comment">*/</span>
<a name="l01065"></a><a class="code" href="btree_8c.html#a148c0bf09d4ef14a49e0e7a2c0506c80">01065</a> <span class="keyword">static</span> <a class="code" href="structMemPage.html">MemPage</a> *<a class="code" href="btree_8c.html#a148c0bf09d4ef14a49e0e7a2c0506c80">btreePageFromDbPage</a>(<a class="code" href="structPgHdr.html">DbPage</a> *pDbPage, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgno, <a class="code" href="structBtShared.html">BtShared</a> *pBt){
<a name="l01066"></a>01066   <a class="code" href="structMemPage.html">MemPage</a> *pPage = (<a class="code" href="structMemPage.html">MemPage</a>*)<a class="code" href="pager_8c.html#a439dda936e73b4bceae7d0a7950d2af6">sqlite3PagerGetExtra</a>(pDbPage);
<a name="l01067"></a>01067   pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a> = <a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pDbPage);
<a name="l01068"></a>01068   pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a> = pDbPage;
<a name="l01069"></a>01069   pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a> = pBt;
<a name="l01070"></a>01070   pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a> = pgno;
<a name="l01071"></a>01071   pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a> = pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>==1 ? 100 : 0;
<a name="l01072"></a>01072   <span class="keywordflow">return</span> pPage; 
<a name="l01073"></a>01073 }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 <span class="comment">/*</span>
<a name="l01076"></a>01076 <span class="comment">** Get a page from the pager.  Initialize the MemPage.pBt and</span>
<a name="l01077"></a>01077 <span class="comment">** MemPage.aData elements if needed.</span>
<a name="l01078"></a>01078 <span class="comment">**</span>
<a name="l01079"></a>01079 <span class="comment">** If the noContent flag is set, it means that we do not care about</span>
<a name="l01080"></a>01080 <span class="comment">** the content of the page at this time.  So do not go to the disk</span>
<a name="l01081"></a>01081 <span class="comment">** to fetch the content.  Just fill in the content with zeros for now.</span>
<a name="l01082"></a>01082 <span class="comment">** If in the future we call sqlite3PagerWrite() on this page, that</span>
<a name="l01083"></a>01083 <span class="comment">** means we have started to be concerned about content and the disk</span>
<a name="l01084"></a>01084 <span class="comment">** read should occur at that point.</span>
<a name="l01085"></a>01085 <span class="comment">*/</span>
<a name="l01086"></a><a class="code" href="btreeInt_8h.html#ac922f8c73d0f1281b3e8a4acadf779fc">01086</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(
<a name="l01087"></a>01087   <a class="code" href="structBtShared.html">BtShared</a> *pBt,       <span class="comment">/* The btree */</span>
<a name="l01088"></a>01088   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgno,           <span class="comment">/* Number of the page to fetch */</span>
<a name="l01089"></a>01089   <a class="code" href="structMemPage.html">MemPage</a> **ppPage,    <span class="comment">/* Return the page in this parameter */</span>
<a name="l01090"></a>01090   <span class="keywordtype">int</span> noContent        <span class="comment">/* Do not load page content if true */</span>
<a name="l01091"></a>01091 ){
<a name="l01092"></a>01092   <span class="keywordtype">int</span> rc;
<a name="l01093"></a>01093   <a class="code" href="structPgHdr.html">DbPage</a> *pDbPage;
<a name="l01094"></a>01094 
<a name="l01095"></a>01095   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l01096"></a>01096   rc = <a class="code" href="pager_8c.html#a9f6852d5ccc8770454ef902742d0046e">sqlite3PagerAcquire</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, pgno, (<a class="code" href="structPgHdr.html">DbPage</a>**)&amp;pDbPage, noContent);
<a name="l01097"></a>01097   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l01098"></a>01098   *ppPage = <a class="code" href="btree_8c.html#a148c0bf09d4ef14a49e0e7a2c0506c80">btreePageFromDbPage</a>(pDbPage, pgno, pBt);
<a name="l01099"></a>01099   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01100"></a>01100 }
<a name="l01101"></a>01101 
<a name="l01102"></a>01102 <span class="comment">/*</span>
<a name="l01103"></a>01103 <span class="comment">** Return the size of the database file in pages.  Or return -1 if</span>
<a name="l01104"></a>01104 <span class="comment">** there is any kind of error.</span>
<a name="l01105"></a>01105 <span class="comment">*/</span>
<a name="l01106"></a><a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">01106</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(<a class="code" href="structPager.html">Pager</a> *pPager){
<a name="l01107"></a>01107   <span class="keywordtype">int</span> rc;
<a name="l01108"></a>01108   <span class="keywordtype">int</span> nPage;
<a name="l01109"></a>01109   rc = <a class="code" href="pager_8c.html#a6d8fdd988248746fc0c3bb7befb25d4a">sqlite3PagerPagecount</a>(pPager, &amp;nPage);
<a name="l01110"></a>01110   <span class="keywordflow">return</span> (rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>?nPage:-1);
<a name="l01111"></a>01111 }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 <span class="comment">/*</span>
<a name="l01114"></a>01114 <span class="comment">** Get a page from the pager and initialize it.  This routine</span>
<a name="l01115"></a>01115 <span class="comment">** is just a convenience wrapper around separate calls to</span>
<a name="l01116"></a>01116 <span class="comment">** sqlite3BtreeGetPage() and sqlite3BtreeInitPage().</span>
<a name="l01117"></a>01117 <span class="comment">*/</span>
<a name="l01118"></a><a class="code" href="btree_8c.html#a443538c685fb93b3b41ee3497629698e">01118</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a443538c685fb93b3b41ee3497629698e">getAndInitPage</a>(
<a name="l01119"></a>01119   <a class="code" href="structBtShared.html">BtShared</a> *pBt,          <span class="comment">/* The database file */</span>
<a name="l01120"></a>01120   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgno,           <span class="comment">/* Number of the page to get */</span>
<a name="l01121"></a>01121   <a class="code" href="structMemPage.html">MemPage</a> **ppPage     <span class="comment">/* Write the page pointer here */</span>
<a name="l01122"></a>01122 ){
<a name="l01123"></a>01123   <span class="keywordtype">int</span> rc;
<a name="l01124"></a>01124   <a class="code" href="structPgHdr.html">DbPage</a> *pDbPage;
<a name="l01125"></a>01125   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l01126"></a>01126 
<a name="l01127"></a>01127   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l01128"></a>01128   <span class="keywordflow">if</span>( pgno==0 ){
<a name="l01129"></a>01129     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>; 
<a name="l01130"></a>01130   }
<a name="l01131"></a>01131 
<a name="l01132"></a>01132   <span class="comment">/* It is often the case that the page we want is already in cache.</span>
<a name="l01133"></a>01133 <span class="comment">  ** If so, get it directly.  This saves us from having to call</span>
<a name="l01134"></a>01134 <span class="comment">  ** pagerPagecount() to make sure pgno is within limits, which results</span>
<a name="l01135"></a>01135 <span class="comment">  ** in a measureable performance improvements.</span>
<a name="l01136"></a>01136 <span class="comment">  */</span>
<a name="l01137"></a>01137   pDbPage = <a class="code" href="pager_8c.html#a3a243697982c8308911882344f87106d">sqlite3PagerLookup</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, pgno);
<a name="l01138"></a>01138   <span class="keywordflow">if</span>( pDbPage ){
<a name="l01139"></a>01139     <span class="comment">/* Page is already in cache */</span>
<a name="l01140"></a>01140     *ppPage = pPage = <a class="code" href="btree_8c.html#a148c0bf09d4ef14a49e0e7a2c0506c80">btreePageFromDbPage</a>(pDbPage, pgno, pBt);
<a name="l01141"></a>01141     rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01142"></a>01142   }<span class="keywordflow">else</span>{
<a name="l01143"></a>01143     <span class="comment">/* Page not in cache.  Acquire it. */</span>
<a name="l01144"></a>01144     <span class="keywordflow">if</span>( pgno&gt;<a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>) ){
<a name="l01145"></a>01145       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>; 
<a name="l01146"></a>01146     }
<a name="l01147"></a>01147     rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, pgno, ppPage, 0);
<a name="l01148"></a>01148     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l01149"></a>01149     pPage = *ppPage;
<a name="l01150"></a>01150   }
<a name="l01151"></a>01151   <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> ){
<a name="l01152"></a>01152     rc = <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(pPage);
<a name="l01153"></a>01153   }
<a name="l01154"></a>01154   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01155"></a>01155     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l01156"></a>01156     *ppPage = 0;
<a name="l01157"></a>01157   }
<a name="l01158"></a>01158   <span class="keywordflow">return</span> rc;
<a name="l01159"></a>01159 }
<a name="l01160"></a>01160 
<a name="l01161"></a>01161 <span class="comment">/*</span>
<a name="l01162"></a>01162 <span class="comment">** Release a MemPage.  This should be called once for each prior</span>
<a name="l01163"></a>01163 <span class="comment">** call to sqlite3BtreeGetPage.</span>
<a name="l01164"></a>01164 <span class="comment">*/</span>
<a name="l01165"></a><a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">01165</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage){
<a name="l01166"></a>01166   <span class="keywordflow">if</span>( pPage ){
<a name="l01167"></a>01167     assert( pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a> );
<a name="l01168"></a>01168     assert( pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a> );
<a name="l01169"></a>01169     assert( <a class="code" href="pager_8c.html#a439dda936e73b4bceae7d0a7950d2af6">sqlite3PagerGetExtra</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) == (<span class="keywordtype">void</span>*)pPage );
<a name="l01170"></a>01170     assert( <a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pPage-&gt;pDbPage)==pPage-&gt;aData );
<a name="l01171"></a>01171     assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;pBt-&gt;mutex) );
<a name="l01172"></a>01172     <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pPage-&gt;pDbPage);
<a name="l01173"></a>01173   }
<a name="l01174"></a>01174 }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176 <span class="comment">/*</span>
<a name="l01177"></a>01177 <span class="comment">** During a rollback, when the pager reloads information into the cache</span>
<a name="l01178"></a>01178 <span class="comment">** so that the cache is restored to its original state at the start of</span>
<a name="l01179"></a>01179 <span class="comment">** the transaction, for each page restored this routine is called.</span>
<a name="l01180"></a>01180 <span class="comment">**</span>
<a name="l01181"></a>01181 <span class="comment">** This routine needs to reset the extra data section at the end of the</span>
<a name="l01182"></a>01182 <span class="comment">** page to agree with the restored data.</span>
<a name="l01183"></a>01183 <span class="comment">*/</span>
<a name="l01184"></a><a class="code" href="btree_8c.html#aa27cac56390e92c5ef6d566ee7defb59">01184</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#aa27cac56390e92c5ef6d566ee7defb59">pageReinit</a>(<a class="code" href="structPgHdr.html">DbPage</a> *pData){
<a name="l01185"></a>01185   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l01186"></a>01186   pPage = (<a class="code" href="structMemPage.html">MemPage</a> *)<a class="code" href="pager_8c.html#a439dda936e73b4bceae7d0a7950d2af6">sqlite3PagerGetExtra</a>(pData);
<a name="l01187"></a>01187   <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> ){
<a name="l01188"></a>01188     assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l01189"></a>01189     pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> = 0;
<a name="l01190"></a>01190     <span class="keywordflow">if</span>( <a class="code" href="pager_8c.html#ad26965e228379211944b6a3a27b3038d">sqlite3PagerPageRefcount</a>(pData)&gt;0 ){
<a name="l01191"></a>01191       <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(pPage);
<a name="l01192"></a>01192     }
<a name="l01193"></a>01193   }
<a name="l01194"></a>01194 }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 <span class="comment">/*</span>
<a name="l01197"></a>01197 <span class="comment">** Invoke the busy handler for a btree.</span>
<a name="l01198"></a>01198 <span class="comment">*/</span>
<a name="l01199"></a><a class="code" href="btree_8c.html#a530d18a920d8cf20bb0bb5570632423c">01199</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a530d18a920d8cf20bb0bb5570632423c">sqlite3BtreeInvokeBusyHandler</a>(<span class="keywordtype">void</span> *pArg, <span class="keywordtype">int</span> n){
<a name="l01200"></a>01200   <a class="code" href="structBtShared.html">BtShared</a> *pBt = (<a class="code" href="structBtShared.html">BtShared</a>*)pArg;
<a name="l01201"></a>01201   assert( pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> );
<a name="l01202"></a>01202   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l01203"></a>01203   <span class="keywordflow">return</span> <a class="code" href="main_8c.html#ae4babe149c37fdf9aeb8ae6c215b41fa">sqlite3InvokeBusyHandler</a>(&amp;pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a>-&gt;<a class="code" href="structsqlite3.html#a5f50915803efe2ad40dc1a5e31763671">busyHandler</a>);
<a name="l01204"></a>01204 }
<a name="l01205"></a>01205 
<a name="l01206"></a>01206 <span class="comment">/*</span>
<a name="l01207"></a>01207 <span class="comment">** Open a database file.</span>
<a name="l01208"></a>01208 <span class="comment">** </span>
<a name="l01209"></a>01209 <span class="comment">** zFilename is the name of the database file.  If zFilename is NULL</span>
<a name="l01210"></a>01210 <span class="comment">** a new database with a random name is created.  This randomly named</span>
<a name="l01211"></a>01211 <span class="comment">** database file will be deleted when sqlite3BtreeClose() is called.</span>
<a name="l01212"></a>01212 <span class="comment">** If zFilename is &quot;:memory:&quot; then an in-memory database is created</span>
<a name="l01213"></a>01213 <span class="comment">** that is automatically destroyed when it is closed.</span>
<a name="l01214"></a>01214 <span class="comment">*/</span>
<a name="l01215"></a><a class="code" href="btree_8h.html#af386b0d602c1b22a568c635a444d991c">01215</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a4e2109b5885238951e6c0d1a4e9bdb39">sqlite3BtreeOpen</a>(
<a name="l01216"></a>01216   <span class="keyword">const</span> <span class="keywordtype">char</span> *zFilename,  <span class="comment">/* Name of the file containing the BTree database */</span>
<a name="l01217"></a>01217   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>,            <span class="comment">/* Associated database handle */</span>
<a name="l01218"></a>01218   <a class="code" href="structBtree.html">Btree</a> **ppBtree,        <span class="comment">/* Pointer to new Btree object written here */</span>
<a name="l01219"></a>01219   <span class="keywordtype">int</span> flags,              <span class="comment">/* Options */</span>
<a name="l01220"></a>01220   <span class="keywordtype">int</span> vfsFlags            <span class="comment">/* Flags passed through to sqlite3_vfs.xOpen() */</span>
<a name="l01221"></a>01221 ){
<a name="l01222"></a>01222   <a class="code" href="structsqlite3__vfs.html">sqlite3_vfs</a> *pVfs;      <span class="comment">/* The VFS to use for this btree */</span>
<a name="l01223"></a>01223   <a class="code" href="structBtShared.html">BtShared</a> *pBt = 0;      <span class="comment">/* Shared part of btree structure */</span>
<a name="l01224"></a>01224   <a class="code" href="structBtree.html">Btree</a> *p;               <span class="comment">/* Handle to return */</span>
<a name="l01225"></a>01225   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01226"></a>01226   <span class="keywordtype">int</span> nReserve;
<a name="l01227"></a>01227   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> zDbHeader[100];
<a name="l01228"></a>01228 
<a name="l01229"></a>01229   <span class="comment">/* Set the variable isMemdb to true for an in-memory database, or </span>
<a name="l01230"></a>01230 <span class="comment">  ** false for a file-based database. This symbol is only required if</span>
<a name="l01231"></a>01231 <span class="comment">  ** either of the shared-data or autovacuum features are compiled </span>
<a name="l01232"></a>01232 <span class="comment">  ** into the library.</span>
<a name="l01233"></a>01233 <span class="comment">  */</span>
<a name="l01234"></a>01234 <span class="preprocessor">#if !defined(SQLITE_OMIT_SHARED_CACHE) || !defined(SQLITE_OMIT_AUTOVACUUM)</span>
<a name="l01235"></a>01235 <span class="preprocessor"></span><span class="preprocessor">  #ifdef SQLITE_OMIT_MEMORYDB</span>
<a name="l01236"></a>01236 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> isMemdb = 0;
<a name="l01237"></a>01237 <span class="preprocessor">  #else</span>
<a name="l01238"></a>01238 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> isMemdb = zFilename &amp;&amp; !strcmp(zFilename, <span class="stringliteral">&quot;:memory:&quot;</span>);
<a name="l01239"></a>01239 <span class="preprocessor">  #endif</span>
<a name="l01240"></a>01240 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01241"></a>01241 <span class="preprocessor"></span>
<a name="l01242"></a>01242   assert( db!=0 );
<a name="l01243"></a>01243   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(db-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l01244"></a>01244 
<a name="l01245"></a>01245   pVfs = db-&gt;<a class="code" href="structsqlite3.html#a8ad0bcb473e4cb492165739acff918cd">pVfs</a>;
<a name="l01246"></a>01246   p = <a class="code" href="malloc_8c.html#aa88ccfc5604fb4bd9b60b3ca4f9f58d4">sqlite3MallocZero</a>(<span class="keyword">sizeof</span>(<a class="code" href="structBtree.html">Btree</a>));
<a name="l01247"></a>01247   <span class="keywordflow">if</span>( !p ){
<a name="l01248"></a>01248     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01249"></a>01249   }
<a name="l01250"></a>01250   p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a> = <a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a>;
<a name="l01251"></a>01251   p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a> = db;
<a name="l01252"></a>01252 
<a name="l01253"></a>01253 <span class="preprocessor">#if !defined(SQLITE_OMIT_SHARED_CACHE) &amp;&amp; !defined(SQLITE_OMIT_DISKIO)</span>
<a name="l01254"></a>01254 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l01255"></a>01255 <span class="comment">  ** If this Btree is a candidate for shared cache, try to find an</span>
<a name="l01256"></a>01256 <span class="comment">  ** existing BtShared object that we can share with</span>
<a name="l01257"></a>01257 <span class="comment">  */</span>
<a name="l01258"></a>01258   <span class="keywordflow">if</span>( isMemdb==0
<a name="l01259"></a>01259    &amp;&amp; (db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#ad86bd2bec16dd883edc18def0790cbe3">SQLITE_Vtab</a>)==0
<a name="l01260"></a>01260    &amp;&amp; zFilename &amp;&amp; zFilename[0]
<a name="l01261"></a>01261   ){
<a name="l01262"></a>01262     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a8f7bcba4c905097c1d01e3aa80e99739">sqlite3GlobalConfig</a>.sharedCacheEnabled ){
<a name="l01263"></a>01263       <span class="keywordtype">int</span> nFullPathname = pVfs-&gt;<a class="code" href="structsqlite3__vfs.html#adb2d82c74891b00b5529fb94e7710135">mxPathname</a>+1;
<a name="l01264"></a>01264       <span class="keywordtype">char</span> *zFullPathname = <a class="code" href="malloc_8c.html#a8c1a33577a57524c7c6eef3d9e64e742">sqlite3Malloc</a>(nFullPathname);
<a name="l01265"></a>01265       <a class="code" href="sqlite3_8h.html#a0f546860bde03fddb33a9fed920da05c">sqlite3_mutex</a> *mutexShared;
<a name="l01266"></a>01266       p-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> = 1;
<a name="l01267"></a>01267       db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> |= <a class="code" href="sqliteInt_8h.html#a7c5cd3f09f5f14658d2725833122563b">SQLITE_SharedCache</a>;
<a name="l01268"></a>01268       <span class="keywordflow">if</span>( !zFullPathname ){
<a name="l01269"></a>01269         <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p);
<a name="l01270"></a>01270         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01271"></a>01271       }
<a name="l01272"></a>01272       <a class="code" href="os_8c.html#a0107e460384be5fa29765421c20e4a46">sqlite3OsFullPathname</a>(pVfs, zFilename, nFullPathname, zFullPathname);
<a name="l01273"></a>01273       mutexShared = <a class="code" href="mutex_8h.html#a35e6a158f17df4b319462d26685c345f">sqlite3MutexAlloc</a>(<a class="code" href="sqlite3_8h.html#a182cdcec7ab77f67221af68bcd805cc6">SQLITE_MUTEX_STATIC_MASTER</a>);
<a name="l01274"></a>01274       <a class="code" href="mutex_8h.html#afbab5dc0108b65678f2fa579473041ac">sqlite3_mutex_enter</a>(mutexShared);
<a name="l01275"></a>01275       <span class="keywordflow">for</span>(pBt=<a class="code" href="sqliteInt_8h.html#ab2cd20d9321c782db91b9414da0c23ee">GLOBAL</a>(<a class="code" href="structBtShared.html">BtShared</a>*,<a class="code" href="btree_8c.html#a377c6be2bf996f2a66cc72f9ba763a22">sqlite3SharedCacheList</a>); pBt; pBt=pBt-&gt;<a class="code" href="structBtShared.html#aaa9dd5c5d4ec2bb79ebe4b37ee926ae3">pNext</a>){
<a name="l01276"></a>01276         assert( pBt-&gt;<a class="code" href="structBtShared.html#a43d0226fa08d7fae5f992f3a2d72cc08">nRef</a>&gt;0 );
<a name="l01277"></a>01277         <span class="keywordflow">if</span>( 0==strcmp(zFullPathname, <a class="code" href="pager_8c.html#a847887e627ae6a0ac767663f8b1da8e5">sqlite3PagerFilename</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>))
<a name="l01278"></a>01278                  &amp;&amp; <a class="code" href="pager_8c.html#a30d8dc64525d08ee4418176525dabdf8">sqlite3PagerVfs</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>)==pVfs ){
<a name="l01279"></a>01279           p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a> = pBt;
<a name="l01280"></a>01280           pBt-&gt;<a class="code" href="structBtShared.html#a43d0226fa08d7fae5f992f3a2d72cc08">nRef</a>++;
<a name="l01281"></a>01281           <span class="keywordflow">break</span>;
<a name="l01282"></a>01282         }
<a name="l01283"></a>01283       }
<a name="l01284"></a>01284       <a class="code" href="mutex_8h.html#aba06556afc1a17868af4675ba856701c">sqlite3_mutex_leave</a>(mutexShared);
<a name="l01285"></a>01285       <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(zFullPathname);
<a name="l01286"></a>01286     }
<a name="l01287"></a>01287 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l01288"></a>01288 <span class="preprocessor"></span>    <span class="keywordflow">else</span>{
<a name="l01289"></a>01289       <span class="comment">/* In debug mode, we mark all persistent databases as sharable</span>
<a name="l01290"></a>01290 <span class="comment">      ** even when they are not.  This exercises the locking code and</span>
<a name="l01291"></a>01291 <span class="comment">      ** gives more opportunity for asserts(sqlite3_mutex_held())</span>
<a name="l01292"></a>01292 <span class="comment">      ** statements to find locking problems.</span>
<a name="l01293"></a>01293 <span class="comment">      */</span>
<a name="l01294"></a>01294       p-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> = 1;
<a name="l01295"></a>01295     }
<a name="l01296"></a>01296 <span class="preprocessor">#endif</span>
<a name="l01297"></a>01297 <span class="preprocessor"></span>  }
<a name="l01298"></a>01298 <span class="preprocessor">#endif</span>
<a name="l01299"></a>01299 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pBt==0 ){
<a name="l01300"></a>01300     <span class="comment">/*</span>
<a name="l01301"></a>01301 <span class="comment">    ** The following asserts make sure that structures used by the btree are</span>
<a name="l01302"></a>01302 <span class="comment">    ** the right size.  This is to guard against size changes that result</span>
<a name="l01303"></a>01303 <span class="comment">    ** when compiling on a different architecture.</span>
<a name="l01304"></a>01304 <span class="comment">    */</span>
<a name="l01305"></a>01305     assert( <span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)==8 || <span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)==4 );
<a name="l01306"></a>01306     assert( <span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a>)==8 || <span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a>)==4 );
<a name="l01307"></a>01307     assert( <span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a>)==4 );
<a name="l01308"></a>01308     assert( <span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a>)==2 );
<a name="l01309"></a>01309     assert( <span class="keyword">sizeof</span>(<a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a>)==4 );
<a name="l01310"></a>01310   
<a name="l01311"></a>01311     pBt = <a class="code" href="malloc_8c.html#aa88ccfc5604fb4bd9b60b3ca4f9f58d4">sqlite3MallocZero</a>( <span class="keyword">sizeof</span>(*pBt) );
<a name="l01312"></a>01312     <span class="keywordflow">if</span>( pBt==0 ){
<a name="l01313"></a>01313       rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01314"></a>01314       <span class="keywordflow">goto</span> btree_open_out;
<a name="l01315"></a>01315     }
<a name="l01316"></a>01316     pBt-&gt;<a class="code" href="structBtShared.html#a2b95c83c5a67c4daec0004d84f1deec7">busyHdr</a>.<a class="code" href="structBusyHandler.html#aafc84c4e4934de2d5bdf02f268e9340f">xFunc</a> = <a class="code" href="btree_8c.html#a530d18a920d8cf20bb0bb5570632423c">sqlite3BtreeInvokeBusyHandler</a>;
<a name="l01317"></a>01317     pBt-&gt;<a class="code" href="structBtShared.html#a2b95c83c5a67c4daec0004d84f1deec7">busyHdr</a>.<a class="code" href="structBusyHandler.html#a1c793d2b815e79cf3684de46847551bd">pArg</a> = pBt;
<a name="l01318"></a>01318     rc = <a class="code" href="pager_8c.html#af56e7e646d7df307c8c9fc3a4f165062">sqlite3PagerOpen</a>(pVfs, &amp;pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, zFilename,
<a name="l01319"></a>01319                           <a class="code" href="btreeInt_8h.html#a14310221be58e5b64cc335aaecc80afd">EXTRA_SIZE</a>, flags, vfsFlags);
<a name="l01320"></a>01320     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01321"></a>01321       rc = <a class="code" href="pager_8c.html#a3bd5f4481f76d457b64abefb602eca41">sqlite3PagerReadFileheader</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>,<span class="keyword">sizeof</span>(zDbHeader),zDbHeader);
<a name="l01322"></a>01322     }
<a name="l01323"></a>01323     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01324"></a>01324       <span class="keywordflow">goto</span> btree_open_out;
<a name="l01325"></a>01325     }
<a name="l01326"></a>01326     <a class="code" href="pager_8c.html#ad557478a4d88698f41d2833bbe037fa5">sqlite3PagerSetBusyhandler</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, &amp;pBt-&gt;<a class="code" href="structBtShared.html#a2b95c83c5a67c4daec0004d84f1deec7">busyHdr</a>);
<a name="l01327"></a>01327     p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a> = pBt;
<a name="l01328"></a>01328   
<a name="l01329"></a>01329     <a class="code" href="pager_8c.html#a435b289b141e95177dbe382be3167af9">sqlite3PagerSetReiniter</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, <a class="code" href="btree_8c.html#aa27cac56390e92c5ef6d566ee7defb59">pageReinit</a>);
<a name="l01330"></a>01330     pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a> = 0;
<a name="l01331"></a>01331     pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a> = 0;
<a name="l01332"></a>01332     pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> = <a class="code" href="pager_8c.html#a633eaf78bbd6ef4bad746d76054b08b6">sqlite3PagerIsreadonly</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l01333"></a>01333     pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;zDbHeader[16]);
<a name="l01334"></a>01334     <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>&lt;512 || pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>&gt;<a class="code" href="sqliteLimit_8h.html#a5535106e00ef873848b6d344bc850692">SQLITE_MAX_PAGE_SIZE</a>
<a name="l01335"></a>01335          || ((pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>-1)&amp;pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>)!=0 ){
<a name="l01336"></a>01336       pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> = 0;
<a name="l01337"></a>01337       <a class="code" href="pager_8c.html#a1f6a43782a235f694dbfec4f6371c94b">sqlite3PagerSetPagesize</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, &amp;pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>);
<a name="l01338"></a>01338 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l01339"></a>01339 <span class="preprocessor"></span>      <span class="comment">/* If the magic name &quot;:memory:&quot; will create an in-memory database, then</span>
<a name="l01340"></a>01340 <span class="comment">      ** leave the autoVacuum mode at 0 (do not auto-vacuum), even if</span>
<a name="l01341"></a>01341 <span class="comment">      ** SQLITE_DEFAULT_AUTOVACUUM is true. On the other hand, if</span>
<a name="l01342"></a>01342 <span class="comment">      ** SQLITE_OMIT_MEMORYDB has been defined, then &quot;:memory:&quot; is just a</span>
<a name="l01343"></a>01343 <span class="comment">      ** regular file-name. In this case the auto-vacuum applies as per normal.</span>
<a name="l01344"></a>01344 <span class="comment">      */</span>
<a name="l01345"></a>01345       <span class="keywordflow">if</span>( zFilename &amp;&amp; !isMemdb ){
<a name="l01346"></a>01346         pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> = (<a class="code" href="btree_8h.html#a42019e2b7d184d2d7ba35a8225c3a0fb">SQLITE_DEFAULT_AUTOVACUUM</a> ? 1 : 0);
<a name="l01347"></a>01347         pBt-&gt;<a class="code" href="structBtShared.html#a8d8ba06335a63d8a36294a0f1ae8377a">incrVacuum</a> = (<a class="code" href="btree_8h.html#a42019e2b7d184d2d7ba35a8225c3a0fb">SQLITE_DEFAULT_AUTOVACUUM</a>==2 ? 1 : 0);
<a name="l01348"></a>01348       }
<a name="l01349"></a>01349 <span class="preprocessor">#endif</span>
<a name="l01350"></a>01350 <span class="preprocessor"></span>      nReserve = 0;
<a name="l01351"></a>01351     }<span class="keywordflow">else</span>{
<a name="l01352"></a>01352       nReserve = zDbHeader[20];
<a name="l01353"></a>01353       pBt-&gt;<a class="code" href="structBtShared.html#a0e728415ef91a26a8a1c6c9a6a9d8cd0">pageSizeFixed</a> = 1;
<a name="l01354"></a>01354 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l01355"></a>01355 <span class="preprocessor"></span>      pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> = (<a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;zDbHeader[36 + 4*4])?1:0);
<a name="l01356"></a>01356       pBt-&gt;<a class="code" href="structBtShared.html#a8d8ba06335a63d8a36294a0f1ae8377a">incrVacuum</a> = (<a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;zDbHeader[36 + 7*4])?1:0);
<a name="l01357"></a>01357 <span class="preprocessor">#endif</span>
<a name="l01358"></a>01358 <span class="preprocessor"></span>    }
<a name="l01359"></a>01359     pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> = pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> - nReserve;
<a name="l01360"></a>01360     assert( (pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> &amp; 7)==0 );  <span class="comment">/* 8-byte alignment of pageSize */</span>
<a name="l01361"></a>01361     <a class="code" href="pager_8c.html#a1f6a43782a235f694dbfec4f6371c94b">sqlite3PagerSetPagesize</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, &amp;pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>);
<a name="l01362"></a>01362    
<a name="l01363"></a>01363 <span class="preprocessor">#if !defined(SQLITE_OMIT_SHARED_CACHE) &amp;&amp; !defined(SQLITE_OMIT_DISKIO)</span>
<a name="l01364"></a>01364 <span class="preprocessor"></span>    <span class="comment">/* Add the new BtShared object to the linked list sharable BtShareds.</span>
<a name="l01365"></a>01365 <span class="comment">    */</span>
<a name="l01366"></a>01366     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> ){
<a name="l01367"></a>01367       <a class="code" href="sqlite3_8h.html#a0f546860bde03fddb33a9fed920da05c">sqlite3_mutex</a> *mutexShared;
<a name="l01368"></a>01368       pBt-&gt;<a class="code" href="structBtShared.html#a43d0226fa08d7fae5f992f3a2d72cc08">nRef</a> = 1;
<a name="l01369"></a>01369       mutexShared = <a class="code" href="mutex_8h.html#a35e6a158f17df4b319462d26685c345f">sqlite3MutexAlloc</a>(<a class="code" href="sqlite3_8h.html#a182cdcec7ab77f67221af68bcd805cc6">SQLITE_MUTEX_STATIC_MASTER</a>);
<a name="l01370"></a>01370       <span class="keywordflow">if</span>( <a class="code" href="sqlite3__config_8h.html#a51a3f6cae62658ac2a75f53f1d006a18">SQLITE_THREADSAFE</a> &amp;&amp; <a class="code" href="sqliteInt_8h.html#a8f7bcba4c905097c1d01e3aa80e99739">sqlite3GlobalConfig</a>.bCoreMutex ){
<a name="l01371"></a>01371         pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a> = <a class="code" href="mutex_8h.html#a35e6a158f17df4b319462d26685c345f">sqlite3MutexAlloc</a>(<a class="code" href="sqlite3_8h.html#a4ef87e82595a68dfc7fc4e8353ab701d">SQLITE_MUTEX_FAST</a>);
<a name="l01372"></a>01372         <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>==0 ){
<a name="l01373"></a>01373           rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l01374"></a>01374           db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 0;
<a name="l01375"></a>01375           <span class="keywordflow">goto</span> btree_open_out;
<a name="l01376"></a>01376         }
<a name="l01377"></a>01377       }
<a name="l01378"></a>01378       <a class="code" href="mutex_8h.html#afbab5dc0108b65678f2fa579473041ac">sqlite3_mutex_enter</a>(mutexShared);
<a name="l01379"></a>01379       pBt-&gt;<a class="code" href="structBtShared.html#aaa9dd5c5d4ec2bb79ebe4b37ee926ae3">pNext</a> = <a class="code" href="sqliteInt_8h.html#ab2cd20d9321c782db91b9414da0c23ee">GLOBAL</a>(<a class="code" href="structBtShared.html">BtShared</a>*,<a class="code" href="btree_8c.html#a377c6be2bf996f2a66cc72f9ba763a22">sqlite3SharedCacheList</a>);
<a name="l01380"></a>01380       <a class="code" href="sqliteInt_8h.html#ab2cd20d9321c782db91b9414da0c23ee">GLOBAL</a>(<a class="code" href="structBtShared.html">BtShared</a>*,<a class="code" href="btree_8c.html#a377c6be2bf996f2a66cc72f9ba763a22">sqlite3SharedCacheList</a>) = pBt;
<a name="l01381"></a>01381       <a class="code" href="mutex_8h.html#aba06556afc1a17868af4675ba856701c">sqlite3_mutex_leave</a>(mutexShared);
<a name="l01382"></a>01382     }
<a name="l01383"></a>01383 <span class="preprocessor">#endif</span>
<a name="l01384"></a>01384 <span class="preprocessor"></span>  }
<a name="l01385"></a>01385 
<a name="l01386"></a>01386 <span class="preprocessor">#if !defined(SQLITE_OMIT_SHARED_CACHE) &amp;&amp; !defined(SQLITE_OMIT_DISKIO)</span>
<a name="l01387"></a>01387 <span class="preprocessor"></span>  <span class="comment">/* If the new Btree uses a sharable pBtShared, then link the new</span>
<a name="l01388"></a>01388 <span class="comment">  ** Btree into the list of all sharable Btrees for the same connection.</span>
<a name="l01389"></a>01389 <span class="comment">  ** The list is kept in ascending order by pBt address.</span>
<a name="l01390"></a>01390 <span class="comment">  */</span>
<a name="l01391"></a>01391   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> ){
<a name="l01392"></a>01392     <span class="keywordtype">int</span> i;
<a name="l01393"></a>01393     <a class="code" href="structBtree.html">Btree</a> *pSib;
<a name="l01394"></a>01394     <span class="keywordflow">for</span>(i=0; i&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a>; i++){
<a name="l01395"></a>01395       <span class="keywordflow">if</span>( (pSib = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>)!=0 &amp;&amp; pSib-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> ){
<a name="l01396"></a>01396         <span class="keywordflow">while</span>( pSib-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a> ){ pSib = pSib-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a>; }
<a name="l01397"></a>01397         <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>&lt;pSib-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a> ){
<a name="l01398"></a>01398           p-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a> = pSib;
<a name="l01399"></a>01399           p-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a> = 0;
<a name="l01400"></a>01400           pSib-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a> = p;
<a name="l01401"></a>01401         }<span class="keywordflow">else</span>{
<a name="l01402"></a>01402           <span class="keywordflow">while</span>( pSib-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a> &amp;&amp; pSib-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a>-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>&lt;p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a> ){
<a name="l01403"></a>01403             pSib = pSib-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a>;
<a name="l01404"></a>01404           }
<a name="l01405"></a>01405           p-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a> = pSib-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a>;
<a name="l01406"></a>01406           p-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a> = pSib;
<a name="l01407"></a>01407           <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a> ){
<a name="l01408"></a>01408             p-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a>-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a> = p;
<a name="l01409"></a>01409           }
<a name="l01410"></a>01410           pSib-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a> = p;
<a name="l01411"></a>01411         }
<a name="l01412"></a>01412         <span class="keywordflow">break</span>;
<a name="l01413"></a>01413       }
<a name="l01414"></a>01414     }
<a name="l01415"></a>01415   }
<a name="l01416"></a>01416 <span class="preprocessor">#endif</span>
<a name="l01417"></a>01417 <span class="preprocessor"></span>  *ppBtree = p;
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 btree_open_out:
<a name="l01420"></a>01420   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01421"></a>01421     <span class="keywordflow">if</span>( pBt &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a> ){
<a name="l01422"></a>01422       <a class="code" href="pager_8c.html#a1cb36c9dd2b9cc0aaec4752ea10f6ffd">sqlite3PagerClose</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l01423"></a>01423     }
<a name="l01424"></a>01424     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pBt);
<a name="l01425"></a>01425     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p);
<a name="l01426"></a>01426     *ppBtree = 0;
<a name="l01427"></a>01427   }
<a name="l01428"></a>01428   <span class="keywordflow">return</span> rc;
<a name="l01429"></a>01429 }
<a name="l01430"></a>01430 
<a name="l01431"></a>01431 <span class="comment">/*</span>
<a name="l01432"></a>01432 <span class="comment">** Decrement the BtShared.nRef counter.  When it reaches zero,</span>
<a name="l01433"></a>01433 <span class="comment">** remove the BtShared structure from the sharing list.  Return</span>
<a name="l01434"></a>01434 <span class="comment">** true if the BtShared.nRef counter reaches zero and return</span>
<a name="l01435"></a>01435 <span class="comment">** false if it is still positive.</span>
<a name="l01436"></a>01436 <span class="comment">*/</span>
<a name="l01437"></a><a class="code" href="btree_8c.html#a7b1a8df3e1fcfc9e69c19633f0d08af3">01437</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a7b1a8df3e1fcfc9e69c19633f0d08af3">removeFromSharingList</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt){
<a name="l01438"></a>01438 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l01439"></a>01439 <span class="preprocessor"></span>  <a class="code" href="sqlite3_8h.html#a0f546860bde03fddb33a9fed920da05c">sqlite3_mutex</a> *pMaster;
<a name="l01440"></a>01440   <a class="code" href="structBtShared.html">BtShared</a> *pList;
<a name="l01441"></a>01441   <span class="keywordtype">int</span> removed = 0;
<a name="l01442"></a>01442 
<a name="l01443"></a>01443   assert( <a class="code" href="mutex_8h.html#abdd6d418242d5544b8ed921d0582625d">sqlite3_mutex_notheld</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l01444"></a>01444   pMaster = <a class="code" href="mutex_8h.html#a35e6a158f17df4b319462d26685c345f">sqlite3MutexAlloc</a>(<a class="code" href="sqlite3_8h.html#a182cdcec7ab77f67221af68bcd805cc6">SQLITE_MUTEX_STATIC_MASTER</a>);
<a name="l01445"></a>01445   <a class="code" href="mutex_8h.html#afbab5dc0108b65678f2fa579473041ac">sqlite3_mutex_enter</a>(pMaster);
<a name="l01446"></a>01446   pBt-&gt;<a class="code" href="structBtShared.html#a43d0226fa08d7fae5f992f3a2d72cc08">nRef</a>--;
<a name="l01447"></a>01447   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a43d0226fa08d7fae5f992f3a2d72cc08">nRef</a>&lt;=0 ){
<a name="l01448"></a>01448     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#ab2cd20d9321c782db91b9414da0c23ee">GLOBAL</a>(<a class="code" href="structBtShared.html">BtShared</a>*,<a class="code" href="btree_8c.html#a377c6be2bf996f2a66cc72f9ba763a22">sqlite3SharedCacheList</a>)==pBt ){
<a name="l01449"></a>01449       <a class="code" href="sqliteInt_8h.html#ab2cd20d9321c782db91b9414da0c23ee">GLOBAL</a>(<a class="code" href="structBtShared.html">BtShared</a>*,<a class="code" href="btree_8c.html#a377c6be2bf996f2a66cc72f9ba763a22">sqlite3SharedCacheList</a>) = pBt-&gt;<a class="code" href="structBtShared.html#aaa9dd5c5d4ec2bb79ebe4b37ee926ae3">pNext</a>;
<a name="l01450"></a>01450     }<span class="keywordflow">else</span>{
<a name="l01451"></a>01451       pList = <a class="code" href="sqliteInt_8h.html#ab2cd20d9321c782db91b9414da0c23ee">GLOBAL</a>(<a class="code" href="structBtShared.html">BtShared</a>*,<a class="code" href="btree_8c.html#a377c6be2bf996f2a66cc72f9ba763a22">sqlite3SharedCacheList</a>);
<a name="l01452"></a>01452       <span class="keywordflow">while</span>( <a class="code" href="sqliteInt_8h.html#a68d1f09d0baf7bc12a51d34a5c18fcfb">ALWAYS</a>(pList) &amp;&amp; pList-&gt;<a class="code" href="structBtShared.html#aaa9dd5c5d4ec2bb79ebe4b37ee926ae3">pNext</a>!=pBt ){
<a name="l01453"></a>01453         pList=pList-&gt;<a class="code" href="structBtShared.html#aaa9dd5c5d4ec2bb79ebe4b37ee926ae3">pNext</a>;
<a name="l01454"></a>01454       }
<a name="l01455"></a>01455       <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a68d1f09d0baf7bc12a51d34a5c18fcfb">ALWAYS</a>(pList) ){
<a name="l01456"></a>01456         pList-&gt;<a class="code" href="structBtShared.html#aaa9dd5c5d4ec2bb79ebe4b37ee926ae3">pNext</a> = pBt-&gt;<a class="code" href="structBtShared.html#aaa9dd5c5d4ec2bb79ebe4b37ee926ae3">pNext</a>;
<a name="l01457"></a>01457       }
<a name="l01458"></a>01458     }
<a name="l01459"></a>01459     <span class="keywordflow">if</span>( <a class="code" href="sqlite3__config_8h.html#a51a3f6cae62658ac2a75f53f1d006a18">SQLITE_THREADSAFE</a> ){
<a name="l01460"></a>01460       <a class="code" href="mutex_8h.html#af3fd6fcf7751b76ca92c1d930015afea">sqlite3_mutex_free</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>);
<a name="l01461"></a>01461     }
<a name="l01462"></a>01462     removed = 1;
<a name="l01463"></a>01463   }
<a name="l01464"></a>01464   <a class="code" href="mutex_8h.html#aba06556afc1a17868af4675ba856701c">sqlite3_mutex_leave</a>(pMaster);
<a name="l01465"></a>01465   <span class="keywordflow">return</span> removed;
<a name="l01466"></a>01466 <span class="preprocessor">#else</span>
<a name="l01467"></a>01467 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 1;
<a name="l01468"></a>01468 <span class="preprocessor">#endif</span>
<a name="l01469"></a>01469 <span class="preprocessor"></span>}
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="comment">/*</span>
<a name="l01472"></a>01472 <span class="comment">** Make sure pBt-&gt;pTmpSpace points to an allocation of </span>
<a name="l01473"></a>01473 <span class="comment">** MX_CELL_SIZE(pBt) bytes.</span>
<a name="l01474"></a>01474 <span class="comment">*/</span>
<a name="l01475"></a><a class="code" href="btree_8c.html#a392335de1138023e2acc7d684caa9e66">01475</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a392335de1138023e2acc7d684caa9e66">allocateTempSpace</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt){
<a name="l01476"></a>01476   <span class="keywordflow">if</span>( !pBt-&gt;<a class="code" href="structBtShared.html#a89102c20327da8a304f7e95af557bdf4">pTmpSpace</a> ){
<a name="l01477"></a>01477     pBt-&gt;<a class="code" href="structBtShared.html#a89102c20327da8a304f7e95af557bdf4">pTmpSpace</a> = <a class="code" href="pcache_8c.html#a477574c3feb4e18cd674fe9593ae6cb0">sqlite3PageMalloc</a>( pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> );
<a name="l01478"></a>01478   }
<a name="l01479"></a>01479 }
<a name="l01480"></a>01480 
<a name="l01481"></a>01481 <span class="comment">/*</span>
<a name="l01482"></a>01482 <span class="comment">** Free the pBt-&gt;pTmpSpace allocation</span>
<a name="l01483"></a>01483 <span class="comment">*/</span>
<a name="l01484"></a><a class="code" href="btree_8c.html#aec277d601edd310860ca5a81c99ed411">01484</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#aec277d601edd310860ca5a81c99ed411">freeTempSpace</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt){
<a name="l01485"></a>01485   <a class="code" href="pcache_8c.html#acc509b3b0633dde5f0f65e3964993a6d">sqlite3PageFree</a>( pBt-&gt;<a class="code" href="structBtShared.html#a89102c20327da8a304f7e95af557bdf4">pTmpSpace</a>);
<a name="l01486"></a>01486   pBt-&gt;<a class="code" href="structBtShared.html#a89102c20327da8a304f7e95af557bdf4">pTmpSpace</a> = 0;
<a name="l01487"></a>01487 }
<a name="l01488"></a>01488 
<a name="l01489"></a>01489 <span class="comment">/*</span>
<a name="l01490"></a>01490 <span class="comment">** Close an open database and invalidate all cursors.</span>
<a name="l01491"></a>01491 <span class="comment">*/</span>
<a name="l01492"></a><a class="code" href="btree_8h.html#a74b531d37beb9327df977394a6257c9c">01492</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aa017e368e670ab1b08097a8d4f6307d3">sqlite3BtreeClose</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l01493"></a>01493   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l01494"></a>01494   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur;
<a name="l01495"></a>01495 
<a name="l01496"></a>01496   <span class="comment">/* Close all cursors opened via this handle.  */</span>
<a name="l01497"></a>01497   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l01498"></a>01498   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01499"></a>01499   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l01500"></a>01500   pCur = pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a>;
<a name="l01501"></a>01501   <span class="keywordflow">while</span>( pCur ){
<a name="l01502"></a>01502     <a class="code" href="structBtCursor.html">BtCursor</a> *pTmp = pCur;
<a name="l01503"></a>01503     pCur = pCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>;
<a name="l01504"></a>01504     <span class="keywordflow">if</span>( pTmp-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>==p ){
<a name="l01505"></a>01505       <a class="code" href="btree_8c.html#aceb051a90ea80c52fc1513ed5de5087d">sqlite3BtreeCloseCursor</a>(pTmp);
<a name="l01506"></a>01506     }
<a name="l01507"></a>01507   }
<a name="l01508"></a>01508 
<a name="l01509"></a>01509   <span class="comment">/* Rollback any active transaction and free the handle structure.</span>
<a name="l01510"></a>01510 <span class="comment">  ** The call to sqlite3BtreeRollback() drops any table-locks held by</span>
<a name="l01511"></a>01511 <span class="comment">  ** this handle.</span>
<a name="l01512"></a>01512 <span class="comment">  */</span>
<a name="l01513"></a>01513   <a class="code" href="btree_8c.html#a447e8e3e0dc60f5adaa0f1f13980fc2d">sqlite3BtreeRollback</a>(p);
<a name="l01514"></a>01514   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01515"></a>01515 
<a name="l01516"></a>01516   <span class="comment">/* If there are still other outstanding references to the shared-btree</span>
<a name="l01517"></a>01517 <span class="comment">  ** structure, return now. The remainder of this procedure cleans </span>
<a name="l01518"></a>01518 <span class="comment">  ** up the shared-btree.</span>
<a name="l01519"></a>01519 <span class="comment">  */</span>
<a name="l01520"></a>01520   assert( p-&gt;<a class="code" href="structBtree.html#a97368ea300f0b74b8e80ea07da0cea2a">wantToLock</a>==0 &amp;&amp; p-&gt;<a class="code" href="structBtree.html#a16fc8292bae9a66cfec03f6cb82d06a8">locked</a>==0 );
<a name="l01521"></a>01521   <span class="keywordflow">if</span>( !p-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> || <a class="code" href="btree_8c.html#a7b1a8df3e1fcfc9e69c19633f0d08af3">removeFromSharingList</a>(pBt) ){
<a name="l01522"></a>01522     <span class="comment">/* The pBt is no longer on the sharing list, so we can access</span>
<a name="l01523"></a>01523 <span class="comment">    ** it without having to hold the mutex.</span>
<a name="l01524"></a>01524 <span class="comment">    **</span>
<a name="l01525"></a>01525 <span class="comment">    ** Clean out and delete the BtShared object.</span>
<a name="l01526"></a>01526 <span class="comment">    */</span>
<a name="l01527"></a>01527     assert( !pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a> );
<a name="l01528"></a>01528     <a class="code" href="pager_8c.html#a1cb36c9dd2b9cc0aaec4752ea10f6ffd">sqlite3PagerClose</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l01529"></a>01529     <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a7c4816c63acea30ed44ffc58b468463e">xFreeSchema</a> &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#aea3ccb6775c768fbd4f3e29df8cb925d">pSchema</a> ){
<a name="l01530"></a>01530       pBt-&gt;<a class="code" href="structBtShared.html#a7c4816c63acea30ed44ffc58b468463e">xFreeSchema</a>(pBt-&gt;<a class="code" href="structBtShared.html#aea3ccb6775c768fbd4f3e29df8cb925d">pSchema</a>);
<a name="l01531"></a>01531     }
<a name="l01532"></a>01532     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pBt-&gt;<a class="code" href="structBtShared.html#aea3ccb6775c768fbd4f3e29df8cb925d">pSchema</a>);
<a name="l01533"></a>01533     <a class="code" href="btree_8c.html#aec277d601edd310860ca5a81c99ed411">freeTempSpace</a>(pBt);
<a name="l01534"></a>01534     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pBt);
<a name="l01535"></a>01535   }
<a name="l01536"></a>01536 
<a name="l01537"></a>01537 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l01538"></a>01538 <span class="preprocessor"></span>  assert( p-&gt;<a class="code" href="structBtree.html#a97368ea300f0b74b8e80ea07da0cea2a">wantToLock</a>==0 );
<a name="l01539"></a>01539   assert( p-&gt;<a class="code" href="structBtree.html#a16fc8292bae9a66cfec03f6cb82d06a8">locked</a>==0 );
<a name="l01540"></a>01540   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a> ) p-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a>-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a> = p-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a>;
<a name="l01541"></a>01541   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a> ) p-&gt;<a class="code" href="structBtree.html#a9e6d2ca44c10ed8ef0be004225a74ef5">pNext</a>-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a> = p-&gt;<a class="code" href="structBtree.html#a0423f1c55c1fe6812161a49bb2bf604f">pPrev</a>;
<a name="l01542"></a>01542 <span class="preprocessor">#endif</span>
<a name="l01543"></a>01543 <span class="preprocessor"></span>
<a name="l01544"></a>01544   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(p);
<a name="l01545"></a>01545   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01546"></a>01546 }
<a name="l01547"></a>01547 
<a name="l01548"></a>01548 <span class="comment">/*</span>
<a name="l01549"></a>01549 <span class="comment">** Change the limit on the number of pages allowed in the cache.</span>
<a name="l01550"></a>01550 <span class="comment">**</span>
<a name="l01551"></a>01551 <span class="comment">** The maximum number of cache pages is set to the absolute</span>
<a name="l01552"></a>01552 <span class="comment">** value of mxPage.  If mxPage is negative, the pager will</span>
<a name="l01553"></a>01553 <span class="comment">** operate asynchronously - it will not stop to do fsync()s</span>
<a name="l01554"></a>01554 <span class="comment">** to insure data is written to the disk surface before</span>
<a name="l01555"></a>01555 <span class="comment">** continuing.  Transactions still work if synchronous is off,</span>
<a name="l01556"></a>01556 <span class="comment">** and the database cannot be corrupted if this program</span>
<a name="l01557"></a>01557 <span class="comment">** crashes.  But if the operating system crashes or there is</span>
<a name="l01558"></a>01558 <span class="comment">** an abrupt power failure when synchronous is off, the database</span>
<a name="l01559"></a>01559 <span class="comment">** could be left in an inconsistent and unrecoverable state.</span>
<a name="l01560"></a>01560 <span class="comment">** Synchronous is on by default so database corruption is not</span>
<a name="l01561"></a>01561 <span class="comment">** normally a worry.</span>
<a name="l01562"></a>01562 <span class="comment">*/</span>
<a name="l01563"></a><a class="code" href="btree_8h.html#a6103b8eb280870f9ea368280e2b58ea5">01563</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a0b9a94952a1db07c9e97555d1de1df7b">sqlite3BtreeSetCacheSize</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> mxPage){
<a name="l01564"></a>01564   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l01565"></a>01565   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l01566"></a>01566   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01567"></a>01567   <a class="code" href="pager_8c.html#acaffee8b6fc7b78166d0d1dc27c85b22">sqlite3PagerSetCachesize</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, mxPage);
<a name="l01568"></a>01568   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01569"></a>01569   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01570"></a>01570 }
<a name="l01571"></a>01571 
<a name="l01572"></a>01572 <span class="comment">/*</span>
<a name="l01573"></a>01573 <span class="comment">** Change the way data is synced to disk in order to increase or decrease</span>
<a name="l01574"></a>01574 <span class="comment">** how well the database resists damage due to OS crashes and power</span>
<a name="l01575"></a>01575 <span class="comment">** failures.  Level 1 is the same as asynchronous (no syncs() occur and</span>
<a name="l01576"></a>01576 <span class="comment">** there is a high probability of damage)  Level 2 is the default.  There</span>
<a name="l01577"></a>01577 <span class="comment">** is a very low but non-zero probability of damage.  Level 3 reduces the</span>
<a name="l01578"></a>01578 <span class="comment">** probability of damage to near zero but with a write performance reduction.</span>
<a name="l01579"></a>01579 <span class="comment">*/</span>
<a name="l01580"></a>01580 <span class="preprocessor">#ifndef SQLITE_OMIT_PAGER_PRAGMAS</span>
<a name="l01581"></a><a class="code" href="btree_8h.html#ad9e84ba111e2b47ea121eb6110b75cb4">01581</a> <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a38075d55ee973b875ed36cf80144dcc0">sqlite3BtreeSetSafetyLevel</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> fullSync){
<a name="l01582"></a>01582   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l01583"></a>01583   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l01584"></a>01584   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01585"></a>01585   <a class="code" href="pager_8c.html#af7a468354231f8a4038e9f7561f4953f">sqlite3PagerSetSafetyLevel</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, level, fullSync);
<a name="l01586"></a>01586   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01587"></a>01587   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01588"></a>01588 }
<a name="l01589"></a>01589 <span class="preprocessor">#endif</span>
<a name="l01590"></a>01590 <span class="preprocessor"></span>
<a name="l01591"></a>01591 <span class="comment">/*</span>
<a name="l01592"></a>01592 <span class="comment">** Return TRUE if the given btree is set to safety level 1.  In other</span>
<a name="l01593"></a>01593 <span class="comment">** words, return TRUE if no sync() occurs on the disk files.</span>
<a name="l01594"></a>01594 <span class="comment">*/</span>
<a name="l01595"></a><a class="code" href="btree_8h.html#a6a3345738287a92e3a7b6e3e951d8c8f">01595</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a4b57ba6fa84109fa8bb257bd5f56b37c">sqlite3BtreeSyncDisabled</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l01596"></a>01596   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l01597"></a>01597   <span class="keywordtype">int</span> rc;
<a name="l01598"></a>01598   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );  
<a name="l01599"></a>01599   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01600"></a>01600   assert( pBt &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a> );
<a name="l01601"></a>01601   rc = <a class="code" href="pager_8c.html#abd78cb4bcc79d88960998ec4ad34f103">sqlite3PagerNosync</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l01602"></a>01602   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01603"></a>01603   <span class="keywordflow">return</span> rc;
<a name="l01604"></a>01604 }
<a name="l01605"></a>01605 
<a name="l01606"></a>01606 <span class="preprocessor">#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) || !defined(SQLITE_OMIT_VACUUM)</span>
<a name="l01607"></a>01607 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01608"></a>01608 <span class="comment">** Change the default pages size and the number of reserved bytes per page.</span>
<a name="l01609"></a>01609 <span class="comment">**</span>
<a name="l01610"></a>01610 <span class="comment">** The page size must be a power of 2 between 512 and 65536.  If the page</span>
<a name="l01611"></a>01611 <span class="comment">** size supplied does not meet this constraint then the page size is not</span>
<a name="l01612"></a>01612 <span class="comment">** changed.</span>
<a name="l01613"></a>01613 <span class="comment">**</span>
<a name="l01614"></a>01614 <span class="comment">** Page sizes are constrained to be a power of two so that the region</span>
<a name="l01615"></a>01615 <span class="comment">** of the database file used for locking (beginning at PENDING_BYTE,</span>
<a name="l01616"></a>01616 <span class="comment">** the first byte past the 1GB boundary, 0x40000000) needs to occur</span>
<a name="l01617"></a>01617 <span class="comment">** at the beginning of a page.</span>
<a name="l01618"></a>01618 <span class="comment">**</span>
<a name="l01619"></a>01619 <span class="comment">** If parameter nReserve is less than zero, then the number of reserved</span>
<a name="l01620"></a>01620 <span class="comment">** bytes per page is left unchanged.</span>
<a name="l01621"></a>01621 <span class="comment">*/</span>
<a name="l01622"></a><a class="code" href="btree_8h.html#a5046e846320986665d51371837979265">01622</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aa07fefab8eadf1f9d2d3380063cbacaa">sqlite3BtreeSetPageSize</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> pageSize, <span class="keywordtype">int</span> nReserve){
<a name="l01623"></a>01623   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01624"></a>01624   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l01625"></a>01625   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01626"></a>01626   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a0e728415ef91a26a8a1c6c9a6a9d8cd0">pageSizeFixed</a> ){
<a name="l01627"></a>01627     <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01628"></a>01628     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a>;
<a name="l01629"></a>01629   }
<a name="l01630"></a>01630   <span class="keywordflow">if</span>( nReserve&lt;0 ){
<a name="l01631"></a>01631     nReserve = pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> - pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>;
<a name="l01632"></a>01632   }
<a name="l01633"></a>01633   <span class="keywordflow">if</span>( pageSize&gt;=512 &amp;&amp; pageSize&lt;=<a class="code" href="sqliteLimit_8h.html#a5535106e00ef873848b6d344bc850692">SQLITE_MAX_PAGE_SIZE</a> &amp;&amp;
<a name="l01634"></a>01634         ((pageSize-1)&amp;pageSize)==0 ){
<a name="l01635"></a>01635     assert( (pageSize &amp; 7)==0 );
<a name="l01636"></a>01636     assert( !pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a> &amp;&amp; !pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a> );
<a name="l01637"></a>01637     pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> = pageSize;
<a name="l01638"></a>01638     <a class="code" href="btree_8c.html#aec277d601edd310860ca5a81c99ed411">freeTempSpace</a>(pBt);
<a name="l01639"></a>01639     rc = <a class="code" href="pager_8c.html#a1f6a43782a235f694dbfec4f6371c94b">sqlite3PagerSetPagesize</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, &amp;pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>);
<a name="l01640"></a>01640   }
<a name="l01641"></a>01641   pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> = pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> - nReserve;
<a name="l01642"></a>01642   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01643"></a>01643   <span class="keywordflow">return</span> rc;
<a name="l01644"></a>01644 }
<a name="l01645"></a>01645 
<a name="l01646"></a>01646 <span class="comment">/*</span>
<a name="l01647"></a>01647 <span class="comment">** Return the currently defined page size</span>
<a name="l01648"></a>01648 <span class="comment">*/</span>
<a name="l01649"></a><a class="code" href="btree_8h.html#a0bd8a56d67b1dae75acc554bf97078bf">01649</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aef8682e7278660258fa922830f05f0dc">sqlite3BtreeGetPageSize</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l01650"></a>01650   <span class="keywordflow">return</span> p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>;
<a name="l01651"></a>01651 }
<a name="l01652"></a><a class="code" href="btree_8h.html#ab046a7a49f4ca3b484669fafa911330b">01652</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#adcaee16506dff8bfdd4edfee6711e065">sqlite3BtreeGetReserve</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l01653"></a>01653   <span class="keywordtype">int</span> n;
<a name="l01654"></a>01654   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01655"></a>01655   n = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> - p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>;
<a name="l01656"></a>01656   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01657"></a>01657   <span class="keywordflow">return</span> n;
<a name="l01658"></a>01658 }
<a name="l01659"></a>01659 
<a name="l01660"></a>01660 <span class="comment">/*</span>
<a name="l01661"></a>01661 <span class="comment">** Set the maximum page count for a database if mxPage is positive.</span>
<a name="l01662"></a>01662 <span class="comment">** No changes are made if mxPage is 0 or negative.</span>
<a name="l01663"></a>01663 <span class="comment">** Regardless of the value of mxPage, return the maximum page count.</span>
<a name="l01664"></a>01664 <span class="comment">*/</span>
<a name="l01665"></a><a class="code" href="btree_8h.html#a2a42500587dff119d3d8ef9557997962">01665</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a1c25f9c511f7b47b1a821eec217d7b0c">sqlite3BtreeMaxPageCount</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> mxPage){
<a name="l01666"></a>01666   <span class="keywordtype">int</span> n;
<a name="l01667"></a>01667   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01668"></a>01668   n = <a class="code" href="pager_8c.html#a16d4242d943d49be4b3b87137cb4c4d8">sqlite3PagerMaxPageCount</a>(p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, mxPage);
<a name="l01669"></a>01669   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01670"></a>01670   <span class="keywordflow">return</span> n;
<a name="l01671"></a>01671 }
<a name="l01672"></a>01672 <span class="preprocessor">#endif </span><span class="comment">/* !defined(SQLITE_OMIT_PAGER_PRAGMAS) || !defined(SQLITE_OMIT_VACUUM) */</span>
<a name="l01673"></a>01673 
<a name="l01674"></a>01674 <span class="comment">/*</span>
<a name="l01675"></a>01675 <span class="comment">** Change the &apos;auto-vacuum&apos; property of the database. If the &apos;autoVacuum&apos;</span>
<a name="l01676"></a>01676 <span class="comment">** parameter is non-zero, then auto-vacuum mode is enabled. If zero, it</span>
<a name="l01677"></a>01677 <span class="comment">** is disabled. The default value for the auto-vacuum property is </span>
<a name="l01678"></a>01678 <span class="comment">** determined by the SQLITE_DEFAULT_AUTOVACUUM macro.</span>
<a name="l01679"></a>01679 <span class="comment">*/</span>
<a name="l01680"></a><a class="code" href="btree_8h.html#a4923bdcdc0e69e3fedcf3f01b2c689dd">01680</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a88f5f78732cbd9269443935d6e0ce305">sqlite3BtreeSetAutoVacuum</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> autoVacuum){
<a name="l01681"></a>01681 <span class="preprocessor">#ifdef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l01682"></a>01682 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a>;
<a name="l01683"></a>01683 <span class="preprocessor">#else</span>
<a name="l01684"></a>01684 <span class="preprocessor"></span>  <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l01685"></a>01685   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01686"></a>01686   <span class="keywordtype">int</span> av = (autoVacuum?1:0);
<a name="l01687"></a>01687 
<a name="l01688"></a>01688   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01689"></a>01689   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a0e728415ef91a26a8a1c6c9a6a9d8cd0">pageSizeFixed</a> &amp;&amp; av!=pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l01690"></a>01690     rc = <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a>;
<a name="l01691"></a>01691   }<span class="keywordflow">else</span>{
<a name="l01692"></a>01692     pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> = av;
<a name="l01693"></a>01693   }
<a name="l01694"></a>01694   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01695"></a>01695   <span class="keywordflow">return</span> rc;
<a name="l01696"></a>01696 <span class="preprocessor">#endif</span>
<a name="l01697"></a>01697 <span class="preprocessor"></span>}
<a name="l01698"></a>01698 
<a name="l01699"></a>01699 <span class="comment">/*</span>
<a name="l01700"></a>01700 <span class="comment">** Return the value of the &apos;auto-vacuum&apos; property. If auto-vacuum is </span>
<a name="l01701"></a>01701 <span class="comment">** enabled 1 is returned. Otherwise 0.</span>
<a name="l01702"></a>01702 <span class="comment">*/</span>
<a name="l01703"></a><a class="code" href="btree_8h.html#abfbf9aea33a843dbac7f0359c38192af">01703</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a48a872ca5ba1a5b70ef32bea6614bbfd">sqlite3BtreeGetAutoVacuum</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l01704"></a>01704 <span class="preprocessor">#ifdef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l01705"></a>01705 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="btree_8h.html#ade22a579862cad281e14d5800ab15244">BTREE_AUTOVACUUM_NONE</a>;
<a name="l01706"></a>01706 <span class="preprocessor">#else</span>
<a name="l01707"></a>01707 <span class="preprocessor"></span>  <span class="keywordtype">int</span> rc;
<a name="l01708"></a>01708   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01709"></a>01709   rc = (
<a name="l01710"></a>01710     (!p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a>)?<a class="code" href="btree_8h.html#ade22a579862cad281e14d5800ab15244">BTREE_AUTOVACUUM_NONE</a>:
<a name="l01711"></a>01711     (!p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a8d8ba06335a63d8a36294a0f1ae8377a">incrVacuum</a>)?<a class="code" href="btree_8h.html#a4c6b3b48cdc61bc9c8f9ba659bc6a0d3">BTREE_AUTOVACUUM_FULL</a>:
<a name="l01712"></a>01712     <a class="code" href="btree_8h.html#a5fd5f64b71994bee9d722dd04c051345">BTREE_AUTOVACUUM_INCR</a>
<a name="l01713"></a>01713   );
<a name="l01714"></a>01714   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l01715"></a>01715   <span class="keywordflow">return</span> rc;
<a name="l01716"></a>01716 <span class="preprocessor">#endif</span>
<a name="l01717"></a>01717 <span class="preprocessor"></span>}
<a name="l01718"></a>01718 
<a name="l01719"></a>01719 
<a name="l01720"></a>01720 <span class="comment">/*</span>
<a name="l01721"></a>01721 <span class="comment">** Get a reference to pPage1 of the database file.  This will</span>
<a name="l01722"></a>01722 <span class="comment">** also acquire a readlock on that file.</span>
<a name="l01723"></a>01723 <span class="comment">**</span>
<a name="l01724"></a>01724 <span class="comment">** SQLITE_OK is returned on success.  If the file is not a</span>
<a name="l01725"></a>01725 <span class="comment">** well-formed database file, then SQLITE_CORRUPT is returned.</span>
<a name="l01726"></a>01726 <span class="comment">** SQLITE_BUSY is returned if the database is locked.  SQLITE_NOMEM</span>
<a name="l01727"></a>01727 <span class="comment">** is returned if we run out of memory. </span>
<a name="l01728"></a>01728 <span class="comment">*/</span>
<a name="l01729"></a><a class="code" href="btree_8c.html#a5b808194d3178be15705a420265cee9d">01729</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a5b808194d3178be15705a420265cee9d">lockBtree</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt){
<a name="l01730"></a>01730   <span class="keywordtype">int</span> rc;
<a name="l01731"></a>01731   <a class="code" href="structMemPage.html">MemPage</a> *pPage1;
<a name="l01732"></a>01732   <span class="keywordtype">int</span> nPage;
<a name="l01733"></a>01733 
<a name="l01734"></a>01734   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l01735"></a>01735   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a> ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01736"></a>01736   rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, 1, &amp;pPage1, 0);
<a name="l01737"></a>01737   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l01738"></a>01738 
<a name="l01739"></a>01739   <span class="comment">/* Do some checking to help insure the file we opened really is</span>
<a name="l01740"></a>01740 <span class="comment">  ** a valid database file. </span>
<a name="l01741"></a>01741 <span class="comment">  */</span>
<a name="l01742"></a>01742   rc = <a class="code" href="pager_8c.html#a6d8fdd988248746fc0c3bb7befb25d4a">sqlite3PagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, &amp;nPage);
<a name="l01743"></a>01743   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01744"></a>01744     <span class="keywordflow">goto</span> page1_init_failed;
<a name="l01745"></a>01745   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( nPage&gt;0 ){
<a name="l01746"></a>01746     <span class="keywordtype">int</span> pageSize;
<a name="l01747"></a>01747     <span class="keywordtype">int</span> usableSize;
<a name="l01748"></a>01748     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *page1 = pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l01749"></a>01749     rc = <a class="code" href="sqlite3_8h.html#a880bb9bb0cdb7b6d6bafd05192ef029c">SQLITE_NOTADB</a>;
<a name="l01750"></a>01750     <span class="keywordflow">if</span>( memcmp(page1, <a class="code" href="btree_8c.html#ad8b5d12d71aa6b7df992adb8ecc5fa64">zMagicHeader</a>, 16)!=0 ){
<a name="l01751"></a>01751       <span class="keywordflow">goto</span> page1_init_failed;
<a name="l01752"></a>01752     }
<a name="l01753"></a>01753     <span class="keywordflow">if</span>( page1[18]&gt;1 ){
<a name="l01754"></a>01754       pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> = 1;
<a name="l01755"></a>01755     }
<a name="l01756"></a>01756     <span class="keywordflow">if</span>( page1[19]&gt;1 ){
<a name="l01757"></a>01757       <span class="keywordflow">goto</span> page1_init_failed;
<a name="l01758"></a>01758     }
<a name="l01759"></a>01759 
<a name="l01760"></a>01760     <span class="comment">/* The maximum embedded fraction must be exactly 25%.  And the minimum</span>
<a name="l01761"></a>01761 <span class="comment">    ** embedded fraction must be 12.5% for both leaf-data and non-leaf-data.</span>
<a name="l01762"></a>01762 <span class="comment">    ** The original design allowed these amounts to vary, but as of</span>
<a name="l01763"></a>01763 <span class="comment">    ** version 3.6.0, we require them to be fixed.</span>
<a name="l01764"></a>01764 <span class="comment">    */</span>
<a name="l01765"></a>01765     <span class="keywordflow">if</span>( memcmp(&amp;page1[21], <span class="stringliteral">&quot;\100\040\040&quot;</span>,3)!=0 ){
<a name="l01766"></a>01766       <span class="keywordflow">goto</span> page1_init_failed;
<a name="l01767"></a>01767     }
<a name="l01768"></a>01768     pageSize = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;page1[16]);
<a name="l01769"></a>01769     <span class="keywordflow">if</span>( ((pageSize-1)&amp;pageSize)!=0 || pageSize&lt;512 ||
<a name="l01770"></a>01770         (SQLITE_MAX_PAGE_SIZE&lt;32768 &amp;&amp; pageSize&gt;<a class="code" href="sqliteLimit_8h.html#a5535106e00ef873848b6d344bc850692">SQLITE_MAX_PAGE_SIZE</a>)
<a name="l01771"></a>01771     ){
<a name="l01772"></a>01772       <span class="keywordflow">goto</span> page1_init_failed;
<a name="l01773"></a>01773     }
<a name="l01774"></a>01774     assert( (pageSize &amp; 7)==0 );
<a name="l01775"></a>01775     usableSize = pageSize - page1[20];
<a name="l01776"></a>01776     <span class="keywordflow">if</span>( pageSize!=pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> ){
<a name="l01777"></a>01777       <span class="comment">/* After reading the first page of the database assuming a page size</span>
<a name="l01778"></a>01778 <span class="comment">      ** of BtShared.pageSize, we have discovered that the page-size is</span>
<a name="l01779"></a>01779 <span class="comment">      ** actually pageSize. Unlock the database, leave pBt-&gt;pPage1 at</span>
<a name="l01780"></a>01780 <span class="comment">      ** zero and return SQLITE_OK. The caller will call this function</span>
<a name="l01781"></a>01781 <span class="comment">      ** again with the correct page-size.</span>
<a name="l01782"></a>01782 <span class="comment">      */</span>
<a name="l01783"></a>01783       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage1);
<a name="l01784"></a>01784       pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> = usableSize;
<a name="l01785"></a>01785       pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> = pageSize;
<a name="l01786"></a>01786       <a class="code" href="btree_8c.html#aec277d601edd310860ca5a81c99ed411">freeTempSpace</a>(pBt);
<a name="l01787"></a>01787       <a class="code" href="pager_8c.html#a1f6a43782a235f694dbfec4f6371c94b">sqlite3PagerSetPagesize</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, &amp;pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>);
<a name="l01788"></a>01788       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01789"></a>01789     }
<a name="l01790"></a>01790     <span class="keywordflow">if</span>( usableSize&lt;500 ){
<a name="l01791"></a>01791       <span class="keywordflow">goto</span> page1_init_failed;
<a name="l01792"></a>01792     }
<a name="l01793"></a>01793     pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> = pageSize;
<a name="l01794"></a>01794     pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> = usableSize;
<a name="l01795"></a>01795 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l01796"></a>01796 <span class="preprocessor"></span>    pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> = (<a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;page1[36 + 4*4])?1:0);
<a name="l01797"></a>01797     pBt-&gt;<a class="code" href="structBtShared.html#a8d8ba06335a63d8a36294a0f1ae8377a">incrVacuum</a> = (<a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;page1[36 + 7*4])?1:0);
<a name="l01798"></a>01798 <span class="preprocessor">#endif</span>
<a name="l01799"></a>01799 <span class="preprocessor"></span>  }
<a name="l01800"></a>01800 
<a name="l01801"></a>01801   <span class="comment">/* maxLocal is the maximum amount of payload to store locally for</span>
<a name="l01802"></a>01802 <span class="comment">  ** a cell.  Make sure it is small enough so that at least minFanout</span>
<a name="l01803"></a>01803 <span class="comment">  ** cells can will fit on one page.  We assume a 10-byte page header.</span>
<a name="l01804"></a>01804 <span class="comment">  ** Besides the payload, the cell must store:</span>
<a name="l01805"></a>01805 <span class="comment">  **     2-byte pointer to the cell</span>
<a name="l01806"></a>01806 <span class="comment">  **     4-byte child pointer</span>
<a name="l01807"></a>01807 <span class="comment">  **     9-byte nKey value</span>
<a name="l01808"></a>01808 <span class="comment">  **     4-byte nData value</span>
<a name="l01809"></a>01809 <span class="comment">  **     4-byte overflow page pointer</span>
<a name="l01810"></a>01810 <span class="comment">  ** So a cell consists of a 2-byte poiner, a header which is as much as</span>
<a name="l01811"></a>01811 <span class="comment">  ** 17 bytes long, 0 to N bytes of payload, and an optional 4 byte overflow</span>
<a name="l01812"></a>01812 <span class="comment">  ** page pointer.</span>
<a name="l01813"></a>01813 <span class="comment">  */</span>
<a name="l01814"></a>01814   pBt-&gt;<a class="code" href="structBtShared.html#a3e8d9c50bd1d4afd09773b16d166d0ca">maxLocal</a> = (pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>-12)*64/255 - 23;
<a name="l01815"></a>01815   pBt-&gt;<a class="code" href="structBtShared.html#a5c7ffeaddfc0530fdaadcaba8801ac53">minLocal</a> = (pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>-12)*32/255 - 23;
<a name="l01816"></a>01816   pBt-&gt;<a class="code" href="structBtShared.html#aac6494904c409641e70dc5f6c4d3579f">maxLeaf</a> = pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> - 35;
<a name="l01817"></a>01817   pBt-&gt;<a class="code" href="structBtShared.html#ac59606a27fc150707e9d1221c503246e">minLeaf</a> = (pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>-12)*32/255 - 23;
<a name="l01818"></a>01818   assert( pBt-&gt;<a class="code" href="structBtShared.html#aac6494904c409641e70dc5f6c4d3579f">maxLeaf</a> + 23 &lt;= <a class="code" href="btreeInt_8h.html#a62abfe072e83ebc1a16bcb22419cca6c">MX_CELL_SIZE</a>(pBt) );
<a name="l01819"></a>01819   pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a> = pPage1;
<a name="l01820"></a>01820   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01821"></a>01821 
<a name="l01822"></a>01822 page1_init_failed:
<a name="l01823"></a>01823   <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage1);
<a name="l01824"></a>01824   pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a> = 0;
<a name="l01825"></a>01825   <span class="keywordflow">return</span> rc;
<a name="l01826"></a>01826 }
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 <span class="comment">/*</span>
<a name="l01829"></a>01829 <span class="comment">** This routine works like lockBtree() except that it also invokes the</span>
<a name="l01830"></a>01830 <span class="comment">** busy callback if there is lock contention.</span>
<a name="l01831"></a>01831 <span class="comment">*/</span>
<a name="l01832"></a><a class="code" href="btree_8c.html#a6bfd699c64823f0b858a0a77c10f92f1">01832</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a6bfd699c64823f0b858a0a77c10f92f1">lockBtreeWithRetry</a>(<a class="code" href="structBtree.html">Btree</a> *pRef){
<a name="l01833"></a>01833   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01834"></a>01834 
<a name="l01835"></a>01835   assert( sqlite3BtreeHoldsMutex(pRef) );
<a name="l01836"></a>01836   <span class="keywordflow">if</span>( pRef-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>==<a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a> ){
<a name="l01837"></a>01837     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> inTransaction = pRef-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>;
<a name="l01838"></a>01838     <a class="code" href="btreeInt_8h.html#ad72671cebaea135fea75a2d28f2ca154">btreeIntegrity</a>(pRef);
<a name="l01839"></a>01839     rc = <a class="code" href="btree_8c.html#aa347f2c69b05ad6cb2ebfad1c9c54718">sqlite3BtreeBeginTrans</a>(pRef, 0);
<a name="l01840"></a>01840     pRef-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a> = inTransaction;
<a name="l01841"></a>01841     pRef-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a> = <a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a>;
<a name="l01842"></a>01842     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01843"></a>01843       pRef-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a6101a0e79a95e884ac4dc9c70a947715">nTransaction</a>--;
<a name="l01844"></a>01844     }
<a name="l01845"></a>01845     <a class="code" href="btreeInt_8h.html#ad72671cebaea135fea75a2d28f2ca154">btreeIntegrity</a>(pRef);
<a name="l01846"></a>01846   }
<a name="l01847"></a>01847   <span class="keywordflow">return</span> rc;
<a name="l01848"></a>01848 }
<a name="l01849"></a>01849        
<a name="l01850"></a>01850 
<a name="l01851"></a>01851 <span class="comment">/*</span>
<a name="l01852"></a>01852 <span class="comment">** If there are no outstanding cursors and we are not in the middle</span>
<a name="l01853"></a>01853 <span class="comment">** of a transaction but there is a read lock on the database, then</span>
<a name="l01854"></a>01854 <span class="comment">** this routine unrefs the first page of the database file which </span>
<a name="l01855"></a>01855 <span class="comment">** has the effect of releasing the read lock.</span>
<a name="l01856"></a>01856 <span class="comment">**</span>
<a name="l01857"></a>01857 <span class="comment">** If there are any outstanding cursors, this routine is a no-op.</span>
<a name="l01858"></a>01858 <span class="comment">**</span>
<a name="l01859"></a>01859 <span class="comment">** If there is a transaction in progress, this routine is a no-op.</span>
<a name="l01860"></a>01860 <span class="comment">*/</span>
<a name="l01861"></a><a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">01861</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">unlockBtreeIfUnused</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt){
<a name="l01862"></a>01862   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l01863"></a>01863   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>==<a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a> &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a>==0 &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>!=0 ){
<a name="l01864"></a>01864     <span class="keywordflow">if</span>( <a class="code" href="pager_8c.html#a05500bf4ea783ce94abc20c6153730e5">sqlite3PagerRefcount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>)&gt;=1 ){
<a name="l01865"></a>01865       assert( pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a> );
<a name="l01866"></a>01866 <span class="preprocessor">#if 0</span>
<a name="l01867"></a>01867 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>==0 ){
<a name="l01868"></a>01868         <a class="code" href="structMemPage.html">MemPage</a> *pPage = pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>;
<a name="l01869"></a>01869         pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a> = <a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l01870"></a>01870         pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a> = pBt;
<a name="l01871"></a>01871         pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a> = 1;
<a name="l01872"></a>01872       }
<a name="l01873"></a>01873 <span class="preprocessor">#endif</span>
<a name="l01874"></a>01874 <span class="preprocessor"></span>      <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>);
<a name="l01875"></a>01875     }
<a name="l01876"></a>01876     pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a> = 0;
<a name="l01877"></a>01877     pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> = 0;
<a name="l01878"></a>01878   }
<a name="l01879"></a>01879 }
<a name="l01880"></a>01880 
<a name="l01881"></a>01881 <span class="comment">/*</span>
<a name="l01882"></a>01882 <span class="comment">** Create a new database by initializing the first page of the</span>
<a name="l01883"></a>01883 <span class="comment">** file.</span>
<a name="l01884"></a>01884 <span class="comment">*/</span>
<a name="l01885"></a><a class="code" href="btree_8c.html#a974c792d17dab330807b588197cae229">01885</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a974c792d17dab330807b588197cae229">newDatabase</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt){
<a name="l01886"></a>01886   <a class="code" href="structMemPage.html">MemPage</a> *pP1;
<a name="l01887"></a>01887   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data;
<a name="l01888"></a>01888   <span class="keywordtype">int</span> rc;
<a name="l01889"></a>01889   <span class="keywordtype">int</span> nPage;
<a name="l01890"></a>01890 
<a name="l01891"></a>01891   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l01892"></a>01892   rc = <a class="code" href="pager_8c.html#a6d8fdd988248746fc0c3bb7befb25d4a">sqlite3PagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, &amp;nPage);
<a name="l01893"></a>01893   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> || nPage&gt;0 ){
<a name="l01894"></a>01894     <span class="keywordflow">return</span> rc;
<a name="l01895"></a>01895   }
<a name="l01896"></a>01896   pP1 = pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>;
<a name="l01897"></a>01897   assert( pP1!=0 );
<a name="l01898"></a>01898   data = pP1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l01899"></a>01899   rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pP1-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l01900"></a>01900   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l01901"></a>01901   memcpy(data, <a class="code" href="btree_8c.html#ad8b5d12d71aa6b7df992adb8ecc5fa64">zMagicHeader</a>, <span class="keyword">sizeof</span>(<a class="code" href="btree_8c.html#ad8b5d12d71aa6b7df992adb8ecc5fa64">zMagicHeader</a>));
<a name="l01902"></a>01902   assert( <span class="keyword">sizeof</span>(<a class="code" href="btree_8c.html#ad8b5d12d71aa6b7df992adb8ecc5fa64">zMagicHeader</a>)==16 );
<a name="l01903"></a>01903   <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[16], pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>);
<a name="l01904"></a>01904   data[18] = 1;
<a name="l01905"></a>01905   data[19] = 1;
<a name="l01906"></a>01906   data[20] = pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> - pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>;
<a name="l01907"></a>01907   data[21] = 64;
<a name="l01908"></a>01908   data[22] = 32;
<a name="l01909"></a>01909   data[23] = 32;
<a name="l01910"></a>01910   memset(&amp;data[24], 0, 100-24);
<a name="l01911"></a>01911   <a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">zeroPage</a>(pP1, <a class="code" href="btreeInt_8h.html#a140a8063c22071245b2a0469b31ee35b">PTF_INTKEY</a>|<a class="code" href="btreeInt_8h.html#a75a736a457cd09a431cef0c66aa45ce6">PTF_LEAF</a>|<a class="code" href="btreeInt_8h.html#a341dd6332e4cec8da26caed497810520">PTF_LEAFDATA</a> );
<a name="l01912"></a>01912   pBt-&gt;<a class="code" href="structBtShared.html#a0e728415ef91a26a8a1c6c9a6a9d8cd0">pageSizeFixed</a> = 1;
<a name="l01913"></a>01913 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l01914"></a>01914 <span class="preprocessor"></span>  assert( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a>==1 || pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a>==0 );
<a name="l01915"></a>01915   assert( pBt-&gt;<a class="code" href="structBtShared.html#a8d8ba06335a63d8a36294a0f1ae8377a">incrVacuum</a>==1 || pBt-&gt;<a class="code" href="structBtShared.html#a8d8ba06335a63d8a36294a0f1ae8377a">incrVacuum</a>==0 );
<a name="l01916"></a>01916   <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;data[36 + 4*4], pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a>);
<a name="l01917"></a>01917   <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;data[36 + 7*4], pBt-&gt;<a class="code" href="structBtShared.html#a8d8ba06335a63d8a36294a0f1ae8377a">incrVacuum</a>);
<a name="l01918"></a>01918 <span class="preprocessor">#endif</span>
<a name="l01919"></a>01919 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01920"></a>01920 }
<a name="l01921"></a>01921 
<a name="l01922"></a>01922 <span class="comment">/*</span>
<a name="l01923"></a>01923 <span class="comment">** Attempt to start a new transaction. A write-transaction</span>
<a name="l01924"></a>01924 <span class="comment">** is started if the second argument is nonzero, otherwise a read-</span>
<a name="l01925"></a>01925 <span class="comment">** transaction.  If the second argument is 2 or more and exclusive</span>
<a name="l01926"></a>01926 <span class="comment">** transaction is started, meaning that no other process is allowed</span>
<a name="l01927"></a>01927 <span class="comment">** to access the database.  A preexisting transaction may not be</span>
<a name="l01928"></a>01928 <span class="comment">** upgraded to exclusive by calling this routine a second time - the</span>
<a name="l01929"></a>01929 <span class="comment">** exclusivity flag only works for a new transaction.</span>
<a name="l01930"></a>01930 <span class="comment">**</span>
<a name="l01931"></a>01931 <span class="comment">** A write-transaction must be started before attempting any </span>
<a name="l01932"></a>01932 <span class="comment">** changes to the database.  None of the following routines </span>
<a name="l01933"></a>01933 <span class="comment">** will work unless a transaction is started first:</span>
<a name="l01934"></a>01934 <span class="comment">**</span>
<a name="l01935"></a>01935 <span class="comment">**      sqlite3BtreeCreateTable()</span>
<a name="l01936"></a>01936 <span class="comment">**      sqlite3BtreeCreateIndex()</span>
<a name="l01937"></a>01937 <span class="comment">**      sqlite3BtreeClearTable()</span>
<a name="l01938"></a>01938 <span class="comment">**      sqlite3BtreeDropTable()</span>
<a name="l01939"></a>01939 <span class="comment">**      sqlite3BtreeInsert()</span>
<a name="l01940"></a>01940 <span class="comment">**      sqlite3BtreeDelete()</span>
<a name="l01941"></a>01941 <span class="comment">**      sqlite3BtreeUpdateMeta()</span>
<a name="l01942"></a>01942 <span class="comment">**</span>
<a name="l01943"></a>01943 <span class="comment">** If an initial attempt to acquire the lock fails because of lock contention</span>
<a name="l01944"></a>01944 <span class="comment">** and the database was previously unlocked, then invoke the busy handler</span>
<a name="l01945"></a>01945 <span class="comment">** if there is one.  But if there was previously a read-lock, do not</span>
<a name="l01946"></a>01946 <span class="comment">** invoke the busy handler - just return SQLITE_BUSY.  SQLITE_BUSY is </span>
<a name="l01947"></a>01947 <span class="comment">** returned when there is already a read-lock in order to avoid a deadlock.</span>
<a name="l01948"></a>01948 <span class="comment">**</span>
<a name="l01949"></a>01949 <span class="comment">** Suppose there are two processes A and B.  A has a read lock and B has</span>
<a name="l01950"></a>01950 <span class="comment">** a reserved lock.  B tries to promote to exclusive but is blocked because</span>
<a name="l01951"></a>01951 <span class="comment">** of A&apos;s read lock.  A tries to promote to reserved but is blocked by B.</span>
<a name="l01952"></a>01952 <span class="comment">** One or the other of the two processes must give way or there can be</span>
<a name="l01953"></a>01953 <span class="comment">** no progress.  By returning SQLITE_BUSY and not invoking the busy callback</span>
<a name="l01954"></a>01954 <span class="comment">** when A already has a read lock, we encourage A to give up and let B</span>
<a name="l01955"></a>01955 <span class="comment">** proceed.</span>
<a name="l01956"></a>01956 <span class="comment">*/</span>
<a name="l01957"></a><a class="code" href="btree_8h.html#ad881986e8cbf8d5984f59c2e0924a0ec">01957</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aa347f2c69b05ad6cb2ebfad1c9c54718">sqlite3BtreeBeginTrans</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> wrflag){
<a name="l01958"></a>01958   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l01959"></a>01959   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l01960"></a>01960 
<a name="l01961"></a>01961   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l01962"></a>01962   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l01963"></a>01963   <a class="code" href="btreeInt_8h.html#ad72671cebaea135fea75a2d28f2ca154">btreeIntegrity</a>(p);
<a name="l01964"></a>01964 
<a name="l01965"></a>01965   <span class="comment">/* If the btree is already in a write-transaction, or it</span>
<a name="l01966"></a>01966 <span class="comment">  ** is already in a read-transaction and a read-transaction</span>
<a name="l01967"></a>01967 <span class="comment">  ** is requested, this is a no-op.</span>
<a name="l01968"></a>01968 <span class="comment">  */</span>
<a name="l01969"></a>01969   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> || (p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>==<a class="code" href="btreeInt_8h.html#a03621a625578cf71dcce39d6ccf44bdf">TRANS_READ</a> &amp;&amp; !wrflag) ){
<a name="l01970"></a>01970     <span class="keywordflow">goto</span> trans_begun;
<a name="l01971"></a>01971   }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973   <span class="comment">/* Write transactions are not possible on a read-only database */</span>
<a name="l01974"></a>01974   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> &amp;&amp; wrflag ){
<a name="l01975"></a>01975     rc = <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a>;
<a name="l01976"></a>01976     <span class="keywordflow">goto</span> trans_begun;
<a name="l01977"></a>01977   }
<a name="l01978"></a>01978 
<a name="l01979"></a>01979   <span class="comment">/* If another database handle has already opened a write transaction </span>
<a name="l01980"></a>01980 <span class="comment">  ** on this shared-btree structure and a second write transaction is</span>
<a name="l01981"></a>01981 <span class="comment">  ** requested, return SQLITE_BUSY.</span>
<a name="l01982"></a>01982 <span class="comment">  */</span>
<a name="l01983"></a>01983   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> &amp;&amp; wrflag ){
<a name="l01984"></a>01984     rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l01985"></a>01985     <span class="keywordflow">goto</span> trans_begun;
<a name="l01986"></a>01986   }
<a name="l01987"></a>01987 
<a name="l01988"></a>01988 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l01989"></a>01989 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( wrflag&gt;1 ){
<a name="l01990"></a>01990     <a class="code" href="structBtLock.html">BtLock</a> *pIter;
<a name="l01991"></a>01991     <span class="keywordflow">for</span>(pIter=pBt-&gt;<a class="code" href="structBtShared.html#af58c79eec88f99ed5a07d8cabf8a1d1a">pLock</a>; pIter; pIter=pIter-&gt;<a class="code" href="structBtLock.html#ad42de86209c7aab43604c52a549b7bca">pNext</a>){
<a name="l01992"></a>01992       <span class="keywordflow">if</span>( pIter-&gt;<a class="code" href="structBtLock.html#ab9125b8e79d480b75f3af21cb2ab55c7">pBtree</a>!=p ){
<a name="l01993"></a>01993         rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l01994"></a>01994         <span class="keywordflow">goto</span> trans_begun;
<a name="l01995"></a>01995       }
<a name="l01996"></a>01996     }
<a name="l01997"></a>01997   }
<a name="l01998"></a>01998 <span class="preprocessor">#endif</span>
<a name="l01999"></a>01999 <span class="preprocessor"></span>
<a name="l02000"></a>02000   <span class="keywordflow">do</span> {
<a name="l02001"></a>02001     <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>==0 ){
<a name="l02002"></a>02002       <span class="keywordflow">do</span>{
<a name="l02003"></a>02003         rc = <a class="code" href="btree_8c.html#a5b808194d3178be15705a420265cee9d">lockBtree</a>(pBt);
<a name="l02004"></a>02004       }<span class="keywordflow">while</span>( pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>==0 &amp;&amp; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> );
<a name="l02005"></a>02005     }
<a name="l02006"></a>02006 
<a name="l02007"></a>02007     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; wrflag ){
<a name="l02008"></a>02008       <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ){
<a name="l02009"></a>02009         rc = <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a>;
<a name="l02010"></a>02010       }<span class="keywordflow">else</span>{
<a name="l02011"></a>02011         rc = <a class="code" href="pager_8c.html#a5fb382ed27ad4c2398bb7a9a7cb2d795">sqlite3PagerBegin</a>(pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>, wrflag&gt;1);
<a name="l02012"></a>02012         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02013"></a>02013           rc = <a class="code" href="btree_8c.html#a974c792d17dab330807b588197cae229">newDatabase</a>(pBt);
<a name="l02014"></a>02014         }
<a name="l02015"></a>02015       }
<a name="l02016"></a>02016     }
<a name="l02017"></a>02017   
<a name="l02018"></a>02018     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02019"></a>02019       <span class="keywordflow">if</span>( wrflag ) pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> = 0;
<a name="l02020"></a>02020     }<span class="keywordflow">else</span>{
<a name="l02021"></a>02021       <a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">unlockBtreeIfUnused</a>(pBt);
<a name="l02022"></a>02022     }
<a name="l02023"></a>02023   }<span class="keywordflow">while</span>( rc==<a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a> &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>==<a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a> &amp;&amp;
<a name="l02024"></a>02024           <a class="code" href="btree_8c.html#a530d18a920d8cf20bb0bb5570632423c">sqlite3BtreeInvokeBusyHandler</a>(pBt, 0) );
<a name="l02025"></a>02025 
<a name="l02026"></a>02026   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02027"></a>02027     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>==<a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a> ){
<a name="l02028"></a>02028       pBt-&gt;<a class="code" href="structBtShared.html#a6101a0e79a95e884ac4dc9c70a947715">nTransaction</a>++;
<a name="l02029"></a>02029     }
<a name="l02030"></a>02030     p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a> = (wrflag?<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a>:<a class="code" href="btreeInt_8h.html#a03621a625578cf71dcce39d6ccf44bdf">TRANS_READ</a>);
<a name="l02031"></a>02031     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>&gt;pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a> ){
<a name="l02032"></a>02032       pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a> = p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>;
<a name="l02033"></a>02033     }
<a name="l02034"></a>02034 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l02035"></a>02035 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( wrflag&gt;1 ){
<a name="l02036"></a>02036       assert( !pBt-&gt;<a class="code" href="structBtShared.html#a9a6c1d6f6802a4549a190d62332c0045">pExclusive</a> );
<a name="l02037"></a>02037       pBt-&gt;<a class="code" href="structBtShared.html#a9a6c1d6f6802a4549a190d62332c0045">pExclusive</a> = p;
<a name="l02038"></a>02038     }
<a name="l02039"></a>02039 <span class="preprocessor">#endif</span>
<a name="l02040"></a>02040 <span class="preprocessor"></span>  }
<a name="l02041"></a>02041 
<a name="l02042"></a>02042 
<a name="l02043"></a>02043 trans_begun:
<a name="l02044"></a>02044   <a class="code" href="btreeInt_8h.html#ad72671cebaea135fea75a2d28f2ca154">btreeIntegrity</a>(p);
<a name="l02045"></a>02045   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02046"></a>02046   <span class="keywordflow">return</span> rc;
<a name="l02047"></a>02047 }
<a name="l02048"></a>02048 
<a name="l02049"></a>02049 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l02050"></a>02050 <span class="preprocessor"></span>
<a name="l02051"></a>02051 <span class="comment">/*</span>
<a name="l02052"></a>02052 <span class="comment">** Set the pointer-map entries for all children of page pPage. Also, if</span>
<a name="l02053"></a>02053 <span class="comment">** pPage contains cells that point to overflow pages, set the pointer</span>
<a name="l02054"></a>02054 <span class="comment">** map entries for the overflow pages as well.</span>
<a name="l02055"></a>02055 <span class="comment">*/</span>
<a name="l02056"></a><a class="code" href="btree_8c.html#adf2ff6d11495ca47f88ace93f5be9d91">02056</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#adf2ff6d11495ca47f88ace93f5be9d91">setChildPtrmaps</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage){
<a name="l02057"></a>02057   <span class="keywordtype">int</span> i;                             <span class="comment">/* Counter variable */</span>
<a name="l02058"></a>02058   <span class="keywordtype">int</span> nCell;                         <span class="comment">/* Number of cells in page pPage */</span>
<a name="l02059"></a>02059   <span class="keywordtype">int</span> rc;                            <span class="comment">/* Return code */</span>
<a name="l02060"></a>02060   <a class="code" href="structBtShared.html">BtShared</a> *pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l02061"></a>02061   <span class="keywordtype">int</span> isInitOrig = pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a>;
<a name="l02062"></a>02062   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgno = pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>;
<a name="l02063"></a>02063 
<a name="l02064"></a>02064   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l02065"></a>02065   rc = <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(pPage);
<a name="l02066"></a>02066   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02067"></a>02067     <span class="keywordflow">goto</span> set_child_ptrmaps_out;
<a name="l02068"></a>02068   }
<a name="l02069"></a>02069   nCell = pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>;
<a name="l02070"></a>02070 
<a name="l02071"></a>02071   <span class="keywordflow">for</span>(i=0; i&lt;nCell; i++){
<a name="l02072"></a>02072     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, i);
<a name="l02073"></a>02073 
<a name="l02074"></a>02074     rc = <a class="code" href="btree_8c.html#a6746c96531d079a003aba72e1b7fc8a8">ptrmapPutOvflPtr</a>(pPage, pCell);
<a name="l02075"></a>02075     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02076"></a>02076       <span class="keywordflow">goto</span> set_child_ptrmaps_out;
<a name="l02077"></a>02077     }
<a name="l02078"></a>02078 
<a name="l02079"></a>02079     <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l02080"></a>02080       <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> childPgno = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pCell);
<a name="l02081"></a>02081       rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, childPgno, <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, pgno);
<a name="l02082"></a>02082       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> set_child_ptrmaps_out;
<a name="l02083"></a>02083     }
<a name="l02084"></a>02084   }
<a name="l02085"></a>02085 
<a name="l02086"></a>02086   <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l02087"></a>02087     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> childPgno = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8]);
<a name="l02088"></a>02088     rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, childPgno, <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, pgno);
<a name="l02089"></a>02089   }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091 set_child_ptrmaps_out:
<a name="l02092"></a>02092   pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> = isInitOrig;
<a name="l02093"></a>02093   <span class="keywordflow">return</span> rc;
<a name="l02094"></a>02094 }
<a name="l02095"></a>02095 
<a name="l02096"></a>02096 <span class="comment">/*</span>
<a name="l02097"></a>02097 <span class="comment">** Somewhere on pPage, which is guarenteed to be a btree page, not an overflow</span>
<a name="l02098"></a>02098 <span class="comment">** page, is a pointer to page iFrom. Modify this pointer so that it points to</span>
<a name="l02099"></a>02099 <span class="comment">** iTo. Parameter eType describes the type of pointer to be modified, as </span>
<a name="l02100"></a>02100 <span class="comment">** follows:</span>
<a name="l02101"></a>02101 <span class="comment">**</span>
<a name="l02102"></a>02102 <span class="comment">** PTRMAP_BTREE:     pPage is a btree-page. The pointer points at a child </span>
<a name="l02103"></a>02103 <span class="comment">**                   page of pPage.</span>
<a name="l02104"></a>02104 <span class="comment">**</span>
<a name="l02105"></a>02105 <span class="comment">** PTRMAP_OVERFLOW1: pPage is a btree-page. The pointer points at an overflow</span>
<a name="l02106"></a>02106 <span class="comment">**                   page pointed to by one of the cells on pPage.</span>
<a name="l02107"></a>02107 <span class="comment">**</span>
<a name="l02108"></a>02108 <span class="comment">** PTRMAP_OVERFLOW2: pPage is an overflow-page. The pointer points at the next</span>
<a name="l02109"></a>02109 <span class="comment">**                   overflow page in the list.</span>
<a name="l02110"></a>02110 <span class="comment">*/</span>
<a name="l02111"></a><a class="code" href="btree_8c.html#acc82754cf975b3a8033b396d86f1045a">02111</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#acc82754cf975b3a8033b396d86f1045a">modifyPagePointer</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iFrom, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iTo, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eType){
<a name="l02112"></a>02112   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l02113"></a>02113   <span class="keywordflow">if</span>( eType==<a class="code" href="btreeInt_8h.html#a2ae32756efb02fe2c719669a0bfabe9a">PTRMAP_OVERFLOW2</a> ){
<a name="l02114"></a>02114     <span class="comment">/* The pointer is always the first 4 bytes of the page in this case.  */</span>
<a name="l02115"></a>02115     <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>)!=iFrom ){
<a name="l02116"></a>02116       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l02117"></a>02117     }
<a name="l02118"></a>02118     <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>, iTo);
<a name="l02119"></a>02119   }<span class="keywordflow">else</span>{
<a name="l02120"></a>02120     <span class="keywordtype">int</span> isInitOrig = pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a>;
<a name="l02121"></a>02121     <span class="keywordtype">int</span> i;
<a name="l02122"></a>02122     <span class="keywordtype">int</span> nCell;
<a name="l02123"></a>02123 
<a name="l02124"></a>02124     <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(pPage);
<a name="l02125"></a>02125     nCell = pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>;
<a name="l02126"></a>02126 
<a name="l02127"></a>02127     <span class="keywordflow">for</span>(i=0; i&lt;nCell; i++){
<a name="l02128"></a>02128       <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, i);
<a name="l02129"></a>02129       <span class="keywordflow">if</span>( eType==<a class="code" href="btreeInt_8h.html#add9dc5f20d087b06cce9c19b30794560">PTRMAP_OVERFLOW1</a> ){
<a name="l02130"></a>02130         <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l02131"></a>02131         <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(pPage, pCell, &amp;info);
<a name="l02132"></a>02132         <span class="keywordflow">if</span>( info.<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a> ){
<a name="l02133"></a>02133           <span class="keywordflow">if</span>( iFrom==<a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pCell[info.<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a>]) ){
<a name="l02134"></a>02134             <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pCell[info.<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a>], iTo);
<a name="l02135"></a>02135             <span class="keywordflow">break</span>;
<a name="l02136"></a>02136           }
<a name="l02137"></a>02137         }
<a name="l02138"></a>02138       }<span class="keywordflow">else</span>{
<a name="l02139"></a>02139         <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pCell)==iFrom ){
<a name="l02140"></a>02140           <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(pCell, iTo);
<a name="l02141"></a>02141           <span class="keywordflow">break</span>;
<a name="l02142"></a>02142         }
<a name="l02143"></a>02143       }
<a name="l02144"></a>02144     }
<a name="l02145"></a>02145   
<a name="l02146"></a>02146     <span class="keywordflow">if</span>( i==nCell ){
<a name="l02147"></a>02147       <span class="keywordflow">if</span>( eType!=<a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a> || 
<a name="l02148"></a>02148           <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8])!=iFrom ){
<a name="l02149"></a>02149         <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l02150"></a>02150       }
<a name="l02151"></a>02151       <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8], iTo);
<a name="l02152"></a>02152     }
<a name="l02153"></a>02153 
<a name="l02154"></a>02154     pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> = isInitOrig;
<a name="l02155"></a>02155   }
<a name="l02156"></a>02156   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02157"></a>02157 }
<a name="l02158"></a>02158 
<a name="l02159"></a>02159 
<a name="l02160"></a>02160 <span class="comment">/*</span>
<a name="l02161"></a>02161 <span class="comment">** Move the open database page pDbPage to location iFreePage in the </span>
<a name="l02162"></a>02162 <span class="comment">** database. The pDbPage reference remains valid.</span>
<a name="l02163"></a>02163 <span class="comment">*/</span>
<a name="l02164"></a><a class="code" href="btree_8c.html#af8fb5934ff87b02845c89350c57fd2bc">02164</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#af8fb5934ff87b02845c89350c57fd2bc">relocatePage</a>(
<a name="l02165"></a>02165   <a class="code" href="structBtShared.html">BtShared</a> *pBt,           <span class="comment">/* Btree */</span>
<a name="l02166"></a>02166   <a class="code" href="structMemPage.html">MemPage</a> *pDbPage,        <span class="comment">/* Open page to move */</span>
<a name="l02167"></a>02167   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eType,                <span class="comment">/* Pointer map &apos;type&apos; entry for pDbPage */</span>
<a name="l02168"></a>02168   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iPtrPage,           <span class="comment">/* Pointer map &apos;page-no&apos; entry for pDbPage */</span>
<a name="l02169"></a>02169   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iFreePage,          <span class="comment">/* The location to move pDbPage to */</span>
<a name="l02170"></a>02170   <span class="keywordtype">int</span> isCommit
<a name="l02171"></a>02171 ){
<a name="l02172"></a>02172   <a class="code" href="structMemPage.html">MemPage</a> *pPtrPage;   <span class="comment">/* The page that contains a pointer to pDbPage */</span>
<a name="l02173"></a>02173   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iDbPage = pDbPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>;
<a name="l02174"></a>02174   <a class="code" href="structPager.html">Pager</a> *pPager = pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>;
<a name="l02175"></a>02175   <span class="keywordtype">int</span> rc;
<a name="l02176"></a>02176 
<a name="l02177"></a>02177   assert( eType==<a class="code" href="btreeInt_8h.html#a2ae32756efb02fe2c719669a0bfabe9a">PTRMAP_OVERFLOW2</a> || eType==<a class="code" href="btreeInt_8h.html#add9dc5f20d087b06cce9c19b30794560">PTRMAP_OVERFLOW1</a> || 
<a name="l02178"></a>02178       eType==<a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a> || eType==<a class="code" href="btreeInt_8h.html#a5379d8ad602ca2c25996e08e33a5e9a9">PTRMAP_ROOTPAGE</a> );
<a name="l02179"></a>02179   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l02180"></a>02180   assert( pDbPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>==pBt );
<a name="l02181"></a>02181 
<a name="l02182"></a>02182   <span class="comment">/* Move page iDbPage from its current location to page number iFreePage */</span>
<a name="l02183"></a>02183   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\n&quot;</span>, 
<a name="l02184"></a>02184       iDbPage, iFreePage, iPtrPage, eType));
<a name="l02185"></a>02185   rc = <a class="code" href="pager_8c.html#aca9274dac7d0691383a8fc236bab287f">sqlite3PagerMovepage</a>(pPager, pDbPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>, iFreePage, isCommit);
<a name="l02186"></a>02186   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02187"></a>02187     <span class="keywordflow">return</span> rc;
<a name="l02188"></a>02188   }
<a name="l02189"></a>02189   pDbPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a> = iFreePage;
<a name="l02190"></a>02190 
<a name="l02191"></a>02191   <span class="comment">/* If pDbPage was a btree-page, then it may have child pages and/or cells</span>
<a name="l02192"></a>02192 <span class="comment">  ** that point to overflow pages. The pointer map entries for all these</span>
<a name="l02193"></a>02193 <span class="comment">  ** pages need to be changed.</span>
<a name="l02194"></a>02194 <span class="comment">  **</span>
<a name="l02195"></a>02195 <span class="comment">  ** If pDbPage is an overflow page, then the first 4 bytes may store a</span>
<a name="l02196"></a>02196 <span class="comment">  ** pointer to a subsequent overflow page. If this is the case, then</span>
<a name="l02197"></a>02197 <span class="comment">  ** the pointer map needs to be updated for the subsequent overflow page.</span>
<a name="l02198"></a>02198 <span class="comment">  */</span>
<a name="l02199"></a>02199   <span class="keywordflow">if</span>( eType==<a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a> || eType==<a class="code" href="btreeInt_8h.html#a5379d8ad602ca2c25996e08e33a5e9a9">PTRMAP_ROOTPAGE</a> ){
<a name="l02200"></a>02200     rc = <a class="code" href="btree_8c.html#adf2ff6d11495ca47f88ace93f5be9d91">setChildPtrmaps</a>(pDbPage);
<a name="l02201"></a>02201     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02202"></a>02202       <span class="keywordflow">return</span> rc;
<a name="l02203"></a>02203     }
<a name="l02204"></a>02204   }<span class="keywordflow">else</span>{
<a name="l02205"></a>02205     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nextOvfl = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pDbPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>);
<a name="l02206"></a>02206     <span class="keywordflow">if</span>( nextOvfl!=0 ){
<a name="l02207"></a>02207       rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, nextOvfl, <a class="code" href="btreeInt_8h.html#a2ae32756efb02fe2c719669a0bfabe9a">PTRMAP_OVERFLOW2</a>, iFreePage);
<a name="l02208"></a>02208       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02209"></a>02209         <span class="keywordflow">return</span> rc;
<a name="l02210"></a>02210       }
<a name="l02211"></a>02211     }
<a name="l02212"></a>02212   }
<a name="l02213"></a>02213 
<a name="l02214"></a>02214   <span class="comment">/* Fix the database pointer on page iPtrPage that pointed at iDbPage so</span>
<a name="l02215"></a>02215 <span class="comment">  ** that it points at iFreePage. Also fix the pointer map entry for</span>
<a name="l02216"></a>02216 <span class="comment">  ** iPtrPage.</span>
<a name="l02217"></a>02217 <span class="comment">  */</span>
<a name="l02218"></a>02218   <span class="keywordflow">if</span>( eType!=<a class="code" href="btreeInt_8h.html#a5379d8ad602ca2c25996e08e33a5e9a9">PTRMAP_ROOTPAGE</a> ){
<a name="l02219"></a>02219     rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, iPtrPage, &amp;pPtrPage, 0);
<a name="l02220"></a>02220     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02221"></a>02221       <span class="keywordflow">return</span> rc;
<a name="l02222"></a>02222     }
<a name="l02223"></a>02223     rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPtrPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l02224"></a>02224     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02225"></a>02225       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPtrPage);
<a name="l02226"></a>02226       <span class="keywordflow">return</span> rc;
<a name="l02227"></a>02227     }
<a name="l02228"></a>02228     rc = <a class="code" href="btree_8c.html#acc82754cf975b3a8033b396d86f1045a">modifyPagePointer</a>(pPtrPage, iDbPage, iFreePage, eType);
<a name="l02229"></a>02229     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPtrPage);
<a name="l02230"></a>02230     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02231"></a>02231       rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, iFreePage, eType, iPtrPage);
<a name="l02232"></a>02232     }
<a name="l02233"></a>02233   }
<a name="l02234"></a>02234   <span class="keywordflow">return</span> rc;
<a name="l02235"></a>02235 }
<a name="l02236"></a>02236 
<a name="l02237"></a>02237 <span class="comment">/* Forward declaration required by incrVacuumStep(). */</span>
<a name="l02238"></a>02238 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(<a class="code" href="structBtShared.html">BtShared</a> *, <a class="code" href="structMemPage.html">MemPage</a> **, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> *, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a>, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>);
<a name="l02239"></a>02239 
<a name="l02240"></a>02240 <span class="comment">/*</span>
<a name="l02241"></a>02241 <span class="comment">** Perform a single step of an incremental-vacuum. If successful,</span>
<a name="l02242"></a>02242 <span class="comment">** return SQLITE_OK. If there is no work to do (and therefore no</span>
<a name="l02243"></a>02243 <span class="comment">** point in calling this function again), return SQLITE_DONE.</span>
<a name="l02244"></a>02244 <span class="comment">**</span>
<a name="l02245"></a>02245 <span class="comment">** More specificly, this function attempts to re-organize the </span>
<a name="l02246"></a>02246 <span class="comment">** database so that the last page of the file currently in use</span>
<a name="l02247"></a>02247 <span class="comment">** is no longer in use.</span>
<a name="l02248"></a>02248 <span class="comment">**</span>
<a name="l02249"></a>02249 <span class="comment">** If the nFin parameter is non-zero, the implementation assumes</span>
<a name="l02250"></a>02250 <span class="comment">** that the caller will keep calling incrVacuumStep() until</span>
<a name="l02251"></a>02251 <span class="comment">** it returns SQLITE_DONE or an error, and that nFin is the</span>
<a name="l02252"></a>02252 <span class="comment">** number of pages the database file will contain after this </span>
<a name="l02253"></a>02253 <span class="comment">** process is complete.</span>
<a name="l02254"></a>02254 <span class="comment">*/</span>
<a name="l02255"></a><a class="code" href="btree_8c.html#a05051e73add3ab88854ae8dba949f6e7">02255</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a05051e73add3ab88854ae8dba949f6e7">incrVacuumStep</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nFin){
<a name="l02256"></a>02256   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iLastPg;             <span class="comment">/* Last page in the database */</span>
<a name="l02257"></a>02257   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nFreeList;           <span class="comment">/* Number of pages still on the free-list */</span>
<a name="l02258"></a>02258 
<a name="l02259"></a>02259   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l02260"></a>02260   iLastPg = pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>;
<a name="l02261"></a>02261   <span class="keywordflow">if</span>( iLastPg==0 ){
<a name="l02262"></a>02262     iLastPg = <a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l02263"></a>02263   }
<a name="l02264"></a>02264 
<a name="l02265"></a>02265   <span class="keywordflow">if</span>( !<a class="code" href="btreeInt_8h.html#a5236c788e81fad4b3d02e93a63f8f649">PTRMAP_ISPAGE</a>(pBt, iLastPg) &amp;&amp; iLastPg!=<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){
<a name="l02266"></a>02266     <span class="keywordtype">int</span> rc;
<a name="l02267"></a>02267     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eType;
<a name="l02268"></a>02268     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iPtrPage;
<a name="l02269"></a>02269 
<a name="l02270"></a>02270     nFreeList = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[36]);
<a name="l02271"></a>02271     <span class="keywordflow">if</span>( nFreeList==0 || nFin==iLastPg ){
<a name="l02272"></a>02272       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>;
<a name="l02273"></a>02273     }
<a name="l02274"></a>02274 
<a name="l02275"></a>02275     rc = <a class="code" href="btree_8c.html#ae91bfd9c1bec807a52a384d2ed01934b">ptrmapGet</a>(pBt, iLastPg, &amp;eType, &amp;iPtrPage);
<a name="l02276"></a>02276     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02277"></a>02277       <span class="keywordflow">return</span> rc;
<a name="l02278"></a>02278     }
<a name="l02279"></a>02279     <span class="keywordflow">if</span>( eType==<a class="code" href="btreeInt_8h.html#a5379d8ad602ca2c25996e08e33a5e9a9">PTRMAP_ROOTPAGE</a> ){
<a name="l02280"></a>02280       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l02281"></a>02281     }
<a name="l02282"></a>02282 
<a name="l02283"></a>02283     <span class="keywordflow">if</span>( eType==<a class="code" href="btreeInt_8h.html#a2eb986d0fb6e4c953a5a2579d8a163d4">PTRMAP_FREEPAGE</a> ){
<a name="l02284"></a>02284       <span class="keywordflow">if</span>( nFin==0 ){
<a name="l02285"></a>02285         <span class="comment">/* Remove the page from the files free-list. This is not required</span>
<a name="l02286"></a>02286 <span class="comment">        ** if nFin is non-zero. In that case, the free-list will be</span>
<a name="l02287"></a>02287 <span class="comment">        ** truncated to zero after this function returns, so it doesn&apos;t </span>
<a name="l02288"></a>02288 <span class="comment">        ** matter if it still contains some garbage entries.</span>
<a name="l02289"></a>02289 <span class="comment">        */</span>
<a name="l02290"></a>02290         <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iFreePg;
<a name="l02291"></a>02291         <a class="code" href="structMemPage.html">MemPage</a> *pFreePg;
<a name="l02292"></a>02292         rc = <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(pBt, &amp;pFreePg, &amp;iFreePg, iLastPg, 1);
<a name="l02293"></a>02293         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02294"></a>02294           <span class="keywordflow">return</span> rc;
<a name="l02295"></a>02295         }
<a name="l02296"></a>02296         assert( iFreePg==iLastPg );
<a name="l02297"></a>02297         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pFreePg);
<a name="l02298"></a>02298       }
<a name="l02299"></a>02299     } <span class="keywordflow">else</span> {
<a name="l02300"></a>02300       <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iFreePg;             <span class="comment">/* Index of free page to move pLastPg to */</span>
<a name="l02301"></a>02301       <a class="code" href="structMemPage.html">MemPage</a> *pLastPg;
<a name="l02302"></a>02302 
<a name="l02303"></a>02303       rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, iLastPg, &amp;pLastPg, 0);
<a name="l02304"></a>02304       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02305"></a>02305         <span class="keywordflow">return</span> rc;
<a name="l02306"></a>02306       }
<a name="l02307"></a>02307 
<a name="l02308"></a>02308       <span class="comment">/* If nFin is zero, this loop runs exactly once and page pLastPg</span>
<a name="l02309"></a>02309 <span class="comment">      ** is swapped with the first free page pulled off the free list.</span>
<a name="l02310"></a>02310 <span class="comment">      **</span>
<a name="l02311"></a>02311 <span class="comment">      ** On the other hand, if nFin is greater than zero, then keep</span>
<a name="l02312"></a>02312 <span class="comment">      ** looping until a free-page located within the first nFin pages</span>
<a name="l02313"></a>02313 <span class="comment">      ** of the file is found.</span>
<a name="l02314"></a>02314 <span class="comment">      */</span>
<a name="l02315"></a>02315       <span class="keywordflow">do</span> {
<a name="l02316"></a>02316         <a class="code" href="structMemPage.html">MemPage</a> *pFreePg;
<a name="l02317"></a>02317         rc = <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(pBt, &amp;pFreePg, &amp;iFreePg, 0, 0);
<a name="l02318"></a>02318         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02319"></a>02319           <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pLastPg);
<a name="l02320"></a>02320           <span class="keywordflow">return</span> rc;
<a name="l02321"></a>02321         }
<a name="l02322"></a>02322         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pFreePg);
<a name="l02323"></a>02323       }<span class="keywordflow">while</span>( nFin!=0 &amp;&amp; iFreePg&gt;nFin );
<a name="l02324"></a>02324       assert( iFreePg&lt;iLastPg );
<a name="l02325"></a>02325       
<a name="l02326"></a>02326       rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pLastPg-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l02327"></a>02327       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02328"></a>02328         rc = <a class="code" href="btree_8c.html#af8fb5934ff87b02845c89350c57fd2bc">relocatePage</a>(pBt, pLastPg, eType, iPtrPage, iFreePg, nFin!=0);
<a name="l02329"></a>02329       }
<a name="l02330"></a>02330       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pLastPg);
<a name="l02331"></a>02331       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02332"></a>02332         <span class="keywordflow">return</span> rc;
<a name="l02333"></a>02333       }
<a name="l02334"></a>02334     }
<a name="l02335"></a>02335   }
<a name="l02336"></a>02336 
<a name="l02337"></a>02337   pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a> = iLastPg - 1;
<a name="l02338"></a>02338   <span class="keywordflow">while</span>( pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt)||<a class="code" href="btreeInt_8h.html#a5236c788e81fad4b3d02e93a63f8f649">PTRMAP_ISPAGE</a>(pBt, pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>) ){
<a name="l02339"></a>02339     pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>--;
<a name="l02340"></a>02340   }
<a name="l02341"></a>02341   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02342"></a>02342 }
<a name="l02343"></a>02343 
<a name="l02344"></a>02344 <span class="comment">/*</span>
<a name="l02345"></a>02345 <span class="comment">** A write-transaction must be opened before calling this function.</span>
<a name="l02346"></a>02346 <span class="comment">** It performs a single unit of work towards an incremental vacuum.</span>
<a name="l02347"></a>02347 <span class="comment">**</span>
<a name="l02348"></a>02348 <span class="comment">** If the incremental vacuum is finished after this function has run,</span>
<a name="l02349"></a>02349 <span class="comment">** SQLITE_DONE is returned. If it is not finished, but no error occured,</span>
<a name="l02350"></a>02350 <span class="comment">** SQLITE_OK is returned. Otherwise an SQLite error code. </span>
<a name="l02351"></a>02351 <span class="comment">*/</span>
<a name="l02352"></a><a class="code" href="btree_8h.html#afb99bb8bdeb2823d8aba42d06552c641">02352</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#acd8b8c1daba4ffc422e5efe414f60cf4">sqlite3BtreeIncrVacuum</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l02353"></a>02353   <span class="keywordtype">int</span> rc;
<a name="l02354"></a>02354   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l02355"></a>02355 
<a name="l02356"></a>02356   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l02357"></a>02357   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l02358"></a>02358   assert( pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> &amp;&amp; p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> );
<a name="l02359"></a>02359   <span class="keywordflow">if</span>( !pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l02360"></a>02360     rc = <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>;
<a name="l02361"></a>02361   }<span class="keywordflow">else</span>{
<a name="l02362"></a>02362     <a class="code" href="btree_8c.html#ae54a9c06fff6f71d61f77b1f08f3e09c">invalidateAllOverflowCache</a>(pBt);
<a name="l02363"></a>02363     rc = <a class="code" href="btree_8c.html#a05051e73add3ab88854ae8dba949f6e7">incrVacuumStep</a>(pBt, 0);
<a name="l02364"></a>02364   }
<a name="l02365"></a>02365   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02366"></a>02366   <span class="keywordflow">return</span> rc;
<a name="l02367"></a>02367 }
<a name="l02368"></a>02368 
<a name="l02369"></a>02369 <span class="comment">/*</span>
<a name="l02370"></a>02370 <span class="comment">** This routine is called prior to sqlite3PagerCommit when a transaction</span>
<a name="l02371"></a>02371 <span class="comment">** is commited for an auto-vacuum database.</span>
<a name="l02372"></a>02372 <span class="comment">**</span>
<a name="l02373"></a>02373 <span class="comment">** If SQLITE_OK is returned, then *pnTrunc is set to the number of pages</span>
<a name="l02374"></a>02374 <span class="comment">** the database file should be truncated to during the commit process. </span>
<a name="l02375"></a>02375 <span class="comment">** i.e. the database has been reorganized so that only the first *pnTrunc</span>
<a name="l02376"></a>02376 <span class="comment">** pages are in use.</span>
<a name="l02377"></a>02377 <span class="comment">*/</span>
<a name="l02378"></a><a class="code" href="btree_8c.html#a0a4eb6d4438b5dd0973fb4a2e8bce0dc">02378</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a0a4eb6d4438b5dd0973fb4a2e8bce0dc">autoVacuumCommit</a>(<a class="code" href="structBtShared.html">BtShared</a> *pBt, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> *pnTrunc){
<a name="l02379"></a>02379   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02380"></a>02380   <a class="code" href="structPager.html">Pager</a> *pPager = pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>;
<a name="l02381"></a>02381   <a class="code" href="btree_8c.html#ad2f62e901555bee1364572b9d1c0c536">VVA_ONLY</a>( <span class="keywordtype">int</span> nRef = <a class="code" href="pager_8c.html#a05500bf4ea783ce94abc20c6153730e5">sqlite3PagerRefcount</a>(pPager) );
<a name="l02382"></a>02382 
<a name="l02383"></a>02383   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l02384"></a>02384   <a class="code" href="btree_8c.html#ae54a9c06fff6f71d61f77b1f08f3e09c">invalidateAllOverflowCache</a>(pBt);
<a name="l02385"></a>02385   assert(pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a>);
<a name="l02386"></a>02386   <span class="keywordflow">if</span>( !pBt-&gt;<a class="code" href="structBtShared.html#a8d8ba06335a63d8a36294a0f1ae8377a">incrVacuum</a> ){
<a name="l02387"></a>02387     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nFin = 0;
<a name="l02388"></a>02388 
<a name="l02389"></a>02389     <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>==0 ){
<a name="l02390"></a>02390       <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nFree;
<a name="l02391"></a>02391       <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nPtrmap;
<a name="l02392"></a>02392       <span class="keyword">const</span> <span class="keywordtype">int</span> pgsz = pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>;
<a name="l02393"></a>02393       <span class="keywordtype">int</span> nOrig = <a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l02394"></a>02394 
<a name="l02395"></a>02395       <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#a5236c788e81fad4b3d02e93a63f8f649">PTRMAP_ISPAGE</a>(pBt, nOrig) ){
<a name="l02396"></a>02396         <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l02397"></a>02397       }
<a name="l02398"></a>02398       <span class="keywordflow">if</span>( nOrig==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){
<a name="l02399"></a>02399         nOrig--;
<a name="l02400"></a>02400       }
<a name="l02401"></a>02401       nFree = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[36]);
<a name="l02402"></a>02402       nPtrmap = (nFree-nOrig+<a class="code" href="btreeInt_8h.html#af4119a9a3bb0a5df2c67d813e9bea637">PTRMAP_PAGENO</a>(pBt, nOrig)+pgsz/5)/(pgsz/5);
<a name="l02403"></a>02403       nFin = nOrig - nFree - nPtrmap;
<a name="l02404"></a>02404       <span class="keywordflow">if</span>( nOrig&gt;<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) &amp;&amp; nFin&lt;=<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){
<a name="l02405"></a>02405         nFin--;
<a name="l02406"></a>02406       }
<a name="l02407"></a>02407       <span class="keywordflow">while</span>( <a class="code" href="btreeInt_8h.html#a5236c788e81fad4b3d02e93a63f8f649">PTRMAP_ISPAGE</a>(pBt, nFin) || nFin==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){
<a name="l02408"></a>02408         nFin--;
<a name="l02409"></a>02409       }
<a name="l02410"></a>02410     }
<a name="l02411"></a>02411 
<a name="l02412"></a>02412     <span class="keywordflow">while</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02413"></a>02413       rc = <a class="code" href="btree_8c.html#a05051e73add3ab88854ae8dba949f6e7">incrVacuumStep</a>(pBt, nFin);
<a name="l02414"></a>02414     }
<a name="l02415"></a>02415     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l02416"></a>02416       assert(nFin==0 || pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>==0 || nFin&lt;=pBt-&gt;nTrunc);
<a name="l02417"></a>02417       rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02418"></a>02418       <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a> &amp;&amp; nFin ){
<a name="l02419"></a>02419         rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l02420"></a>02420         <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[32], 0);
<a name="l02421"></a>02421         <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[36], 0);
<a name="l02422"></a>02422         pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a> = nFin;
<a name="l02423"></a>02423       }
<a name="l02424"></a>02424     }
<a name="l02425"></a>02425     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02426"></a>02426       <a class="code" href="pager_8c.html#aeeefe012df954af841de39a42b9f3b0e">sqlite3PagerRollback</a>(pPager);
<a name="l02427"></a>02427     }
<a name="l02428"></a>02428   }
<a name="l02429"></a>02429 
<a name="l02430"></a>02430   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02431"></a>02431     *pnTrunc = pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>;
<a name="l02432"></a>02432     pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a> = 0;
<a name="l02433"></a>02433   }
<a name="l02434"></a>02434   assert( nRef==<a class="code" href="pager_8c.html#a05500bf4ea783ce94abc20c6153730e5">sqlite3PagerRefcount</a>(pPager) );
<a name="l02435"></a>02435   <span class="keywordflow">return</span> rc;
<a name="l02436"></a>02436 }
<a name="l02437"></a>02437 
<a name="l02438"></a>02438 <span class="preprocessor">#endif </span><span class="comment">/* ifndef SQLITE_OMIT_AUTOVACUUM */</span>
<a name="l02439"></a>02439 
<a name="l02440"></a>02440 <span class="comment">/*</span>
<a name="l02441"></a>02441 <span class="comment">** This routine does the first phase of a two-phase commit.  This routine</span>
<a name="l02442"></a>02442 <span class="comment">** causes a rollback journal to be created (if it does not already exist)</span>
<a name="l02443"></a>02443 <span class="comment">** and populated with enough information so that if a power loss occurs</span>
<a name="l02444"></a>02444 <span class="comment">** the database can be restored to its original state by playing back</span>
<a name="l02445"></a>02445 <span class="comment">** the journal.  Then the contents of the journal are flushed out to</span>
<a name="l02446"></a>02446 <span class="comment">** the disk.  After the journal is safely on oxide, the changes to the</span>
<a name="l02447"></a>02447 <span class="comment">** database are written into the database file and flushed to oxide.</span>
<a name="l02448"></a>02448 <span class="comment">** At the end of this call, the rollback journal still exists on the</span>
<a name="l02449"></a>02449 <span class="comment">** disk and we are still holding all locks, so the transaction has not</span>
<a name="l02450"></a>02450 <span class="comment">** committed.  See sqlite3BtreeCommit() for the second phase of the</span>
<a name="l02451"></a>02451 <span class="comment">** commit process.</span>
<a name="l02452"></a>02452 <span class="comment">**</span>
<a name="l02453"></a>02453 <span class="comment">** This call is a no-op if no write-transaction is currently active on pBt.</span>
<a name="l02454"></a>02454 <span class="comment">**</span>
<a name="l02455"></a>02455 <span class="comment">** Otherwise, sync the database file for the btree pBt. zMaster points to</span>
<a name="l02456"></a>02456 <span class="comment">** the name of a master journal file that should be written into the</span>
<a name="l02457"></a>02457 <span class="comment">** individual journal file, or is NULL, indicating no master journal file </span>
<a name="l02458"></a>02458 <span class="comment">** (single database transaction).</span>
<a name="l02459"></a>02459 <span class="comment">**</span>
<a name="l02460"></a>02460 <span class="comment">** When this is called, the master journal should already have been</span>
<a name="l02461"></a>02461 <span class="comment">** created, populated with this journal pointer and synced to disk.</span>
<a name="l02462"></a>02462 <span class="comment">**</span>
<a name="l02463"></a>02463 <span class="comment">** Once this is routine has returned, the only thing required to commit</span>
<a name="l02464"></a>02464 <span class="comment">** the write-transaction for this database file is to delete the journal.</span>
<a name="l02465"></a>02465 <span class="comment">*/</span>
<a name="l02466"></a><a class="code" href="btree_8h.html#ac88f29ddd650f6bbe7e6b621dbe57266">02466</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aaa86a820748624295c214bf418a2cbd9">sqlite3BtreeCommitPhaseOne</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *zMaster){
<a name="l02467"></a>02467   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02468"></a>02468   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l02469"></a>02469     <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l02470"></a>02470     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nTrunc = 0;
<a name="l02471"></a>02471     <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l02472"></a>02472     pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l02473"></a>02473 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l02474"></a>02474 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l02475"></a>02475       rc = <a class="code" href="btree_8c.html#a0a4eb6d4438b5dd0973fb4a2e8bce0dc">autoVacuumCommit</a>(pBt, &amp;nTrunc); 
<a name="l02476"></a>02476       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02477"></a>02477         <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02478"></a>02478         <span class="keywordflow">return</span> rc;
<a name="l02479"></a>02479       }
<a name="l02480"></a>02480     }
<a name="l02481"></a>02481 <span class="preprocessor">#endif</span>
<a name="l02482"></a>02482 <span class="preprocessor"></span>    rc = <a class="code" href="pager_8c.html#a97867dfbbcc9f163e9146c56af2c6918">sqlite3PagerCommitPhaseOne</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, zMaster, nTrunc, 0);
<a name="l02483"></a>02483     <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02484"></a>02484   }
<a name="l02485"></a>02485   <span class="keywordflow">return</span> rc;
<a name="l02486"></a>02486 }
<a name="l02487"></a>02487 
<a name="l02488"></a>02488 <span class="comment">/*</span>
<a name="l02489"></a>02489 <span class="comment">** Commit the transaction currently in progress.</span>
<a name="l02490"></a>02490 <span class="comment">**</span>
<a name="l02491"></a>02491 <span class="comment">** This routine implements the second phase of a 2-phase commit.  The</span>
<a name="l02492"></a>02492 <span class="comment">** sqlite3BtreeSync() routine does the first phase and should be invoked</span>
<a name="l02493"></a>02493 <span class="comment">** prior to calling this routine.  The sqlite3BtreeSync() routine did</span>
<a name="l02494"></a>02494 <span class="comment">** all the work of writing information out to disk and flushing the</span>
<a name="l02495"></a>02495 <span class="comment">** contents so that they are written onto the disk platter.  All this</span>
<a name="l02496"></a>02496 <span class="comment">** routine has to do is delete or truncate the rollback journal</span>
<a name="l02497"></a>02497 <span class="comment">** (which causes the transaction to commit) and drop locks.</span>
<a name="l02498"></a>02498 <span class="comment">**</span>
<a name="l02499"></a>02499 <span class="comment">** This will release the write lock on the database file.  If there</span>
<a name="l02500"></a>02500 <span class="comment">** are no active cursors, it also releases the read lock.</span>
<a name="l02501"></a>02501 <span class="comment">*/</span>
<a name="l02502"></a><a class="code" href="btree_8h.html#ad6bc3b54fb37082866b6bf832932f12d">02502</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#abd2fba5cda8e4602f74dbcb7b949d417">sqlite3BtreeCommitPhaseTwo</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l02503"></a>02503   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l02504"></a>02504 
<a name="l02505"></a>02505   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l02506"></a>02506   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l02507"></a>02507   <a class="code" href="btreeInt_8h.html#ad72671cebaea135fea75a2d28f2ca154">btreeIntegrity</a>(p);
<a name="l02508"></a>02508 
<a name="l02509"></a>02509   <span class="comment">/* If the handle has a write-transaction open, commit the shared-btrees </span>
<a name="l02510"></a>02510 <span class="comment">  ** transaction and set the shared state to TRANS_READ.</span>
<a name="l02511"></a>02511 <span class="comment">  */</span>
<a name="l02512"></a>02512   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l02513"></a>02513     <span class="keywordtype">int</span> rc;
<a name="l02514"></a>02514     assert( pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> );
<a name="l02515"></a>02515     assert( pBt-&gt;<a class="code" href="structBtShared.html#a6101a0e79a95e884ac4dc9c70a947715">nTransaction</a>&gt;0 );
<a name="l02516"></a>02516     rc = <a class="code" href="pager_8c.html#a5c717cfe264d0cb2be6c7b56c6a92cc9">sqlite3PagerCommitPhaseTwo</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l02517"></a>02517     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02518"></a>02518       <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02519"></a>02519       <span class="keywordflow">return</span> rc;
<a name="l02520"></a>02520     }
<a name="l02521"></a>02521     pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a> = <a class="code" href="btreeInt_8h.html#a03621a625578cf71dcce39d6ccf44bdf">TRANS_READ</a>;
<a name="l02522"></a>02522     pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> = 0;
<a name="l02523"></a>02523   }
<a name="l02524"></a>02524   <a class="code" href="btree_8c.html#a0e6849fc355cc0b10cc35b0db87e7817">unlockAllTables</a>(p);
<a name="l02525"></a>02525 
<a name="l02526"></a>02526   <span class="comment">/* If the handle has any kind of transaction open, decrement the transaction</span>
<a name="l02527"></a>02527 <span class="comment">  ** count of the shared btree. If the transaction count reaches 0, set</span>
<a name="l02528"></a>02528 <span class="comment">  ** the shared state to TRANS_NONE. The unlockBtreeIfUnused() call below</span>
<a name="l02529"></a>02529 <span class="comment">  ** will unlock the pager.</span>
<a name="l02530"></a>02530 <span class="comment">  */</span>
<a name="l02531"></a>02531   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>!=<a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a> ){
<a name="l02532"></a>02532     pBt-&gt;<a class="code" href="structBtShared.html#a6101a0e79a95e884ac4dc9c70a947715">nTransaction</a>--;
<a name="l02533"></a>02533     <span class="keywordflow">if</span>( 0==pBt-&gt;<a class="code" href="structBtShared.html#a6101a0e79a95e884ac4dc9c70a947715">nTransaction</a> ){
<a name="l02534"></a>02534       pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a> = <a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a>;
<a name="l02535"></a>02535     }
<a name="l02536"></a>02536   }
<a name="l02537"></a>02537 
<a name="l02538"></a>02538   <span class="comment">/* Set the handles current transaction state to TRANS_NONE and unlock</span>
<a name="l02539"></a>02539 <span class="comment">  ** the pager if this call closed the only read or write transaction.</span>
<a name="l02540"></a>02540 <span class="comment">  */</span>
<a name="l02541"></a>02541   p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a> = <a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a>;
<a name="l02542"></a>02542   <a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">unlockBtreeIfUnused</a>(pBt);
<a name="l02543"></a>02543 
<a name="l02544"></a>02544   <a class="code" href="btreeInt_8h.html#ad72671cebaea135fea75a2d28f2ca154">btreeIntegrity</a>(p);
<a name="l02545"></a>02545   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02546"></a>02546   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02547"></a>02547 }
<a name="l02548"></a>02548 
<a name="l02549"></a>02549 <span class="comment">/*</span>
<a name="l02550"></a>02550 <span class="comment">** Do both phases of a commit.</span>
<a name="l02551"></a>02551 <span class="comment">*/</span>
<a name="l02552"></a><a class="code" href="btree_8h.html#abcee053b36421631eb0589767a7b9111">02552</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a3c5278c325675867f37daae782ac6c0e">sqlite3BtreeCommit</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l02553"></a>02553   <span class="keywordtype">int</span> rc;
<a name="l02554"></a>02554   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l02555"></a>02555   rc = <a class="code" href="btree_8c.html#aaa86a820748624295c214bf418a2cbd9">sqlite3BtreeCommitPhaseOne</a>(p, 0);
<a name="l02556"></a>02556   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02557"></a>02557     rc = <a class="code" href="btree_8c.html#abd2fba5cda8e4602f74dbcb7b949d417">sqlite3BtreeCommitPhaseTwo</a>(p);
<a name="l02558"></a>02558   }
<a name="l02559"></a>02559   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02560"></a>02560   <span class="keywordflow">return</span> rc;
<a name="l02561"></a>02561 }
<a name="l02562"></a>02562 
<a name="l02563"></a>02563 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l02564"></a>02564 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l02565"></a>02565 <span class="comment">** Return the number of write-cursors open on this handle. This is for use</span>
<a name="l02566"></a>02566 <span class="comment">** in assert() expressions, so it is only compiled if NDEBUG is not</span>
<a name="l02567"></a>02567 <span class="comment">** defined.</span>
<a name="l02568"></a>02568 <span class="comment">**</span>
<a name="l02569"></a>02569 <span class="comment">** For the purposes of this routine, a write-cursor is any cursor that</span>
<a name="l02570"></a>02570 <span class="comment">** is capable of writing to the databse.  That means the cursor was</span>
<a name="l02571"></a>02571 <span class="comment">** originally opened for writing and the cursor has not be disabled</span>
<a name="l02572"></a>02572 <span class="comment">** by having its state changed to CURSOR_FAULT.</span>
<a name="l02573"></a>02573 <span class="comment">*/</span>
<a name="l02574"></a>02574 <span class="keyword">static</span> <span class="keywordtype">int</span> countWriteCursors(<a class="code" href="structBtShared.html">BtShared</a> *pBt){
<a name="l02575"></a>02575   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur;
<a name="l02576"></a>02576   <span class="keywordtype">int</span> r = 0;
<a name="l02577"></a>02577   <span class="keywordflow">for</span>(pCur=pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a>; pCur; pCur=pCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>){
<a name="l02578"></a>02578     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a9482c52d8c85519a3ada18517bf67a47">wrFlag</a> &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>!=<a class="code" href="btreeInt_8h.html#a3906ad079a2cc489d948fcbbe3035e42">CURSOR_FAULT</a> ) r++; 
<a name="l02579"></a>02579   }
<a name="l02580"></a>02580   <span class="keywordflow">return</span> r;
<a name="l02581"></a>02581 }
<a name="l02582"></a>02582 <span class="preprocessor">#endif</span>
<a name="l02583"></a>02583 <span class="preprocessor"></span>
<a name="l02584"></a>02584 <span class="comment">/*</span>
<a name="l02585"></a>02585 <span class="comment">** This routine sets the state to CURSOR_FAULT and the error</span>
<a name="l02586"></a>02586 <span class="comment">** code to errCode for every cursor on BtShared that pBtree</span>
<a name="l02587"></a>02587 <span class="comment">** references.</span>
<a name="l02588"></a>02588 <span class="comment">**</span>
<a name="l02589"></a>02589 <span class="comment">** Every cursor is tripped, including cursors that belong</span>
<a name="l02590"></a>02590 <span class="comment">** to other database connections that happen to be sharing</span>
<a name="l02591"></a>02591 <span class="comment">** the cache with pBtree.</span>
<a name="l02592"></a>02592 <span class="comment">**</span>
<a name="l02593"></a>02593 <span class="comment">** This routine gets called when a rollback occurs.</span>
<a name="l02594"></a>02594 <span class="comment">** All cursors using the same cache must be tripped</span>
<a name="l02595"></a>02595 <span class="comment">** to prevent them from trying to use the btree after</span>
<a name="l02596"></a>02596 <span class="comment">** the rollback.  The rollback may have deleted tables</span>
<a name="l02597"></a>02597 <span class="comment">** or moved root pages, so it is not sufficient to</span>
<a name="l02598"></a>02598 <span class="comment">** save the state of the cursor.  The cursor must be</span>
<a name="l02599"></a>02599 <span class="comment">** invalidated.</span>
<a name="l02600"></a>02600 <span class="comment">*/</span>
<a name="l02601"></a><a class="code" href="btree_8h.html#a40630805527338d94df0408ef11b812b">02601</a> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a16024e460e480bab5c8748ad12113c80">sqlite3BtreeTripAllCursors</a>(<a class="code" href="structBtree.html">Btree</a> *pBtree, <span class="keywordtype">int</span> errCode){
<a name="l02602"></a>02602   <a class="code" href="structBtCursor.html">BtCursor</a> *p;
<a name="l02603"></a>02603   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(pBtree);
<a name="l02604"></a>02604   <span class="keywordflow">for</span>(p=pBtree-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a>; p; p=p-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>){
<a name="l02605"></a>02605     <a class="code" href="btree_8c.html#a1b4b9b532ff7779a50f6482c723b3b50">sqlite3BtreeClearCursor</a>(p);
<a name="l02606"></a>02606     p-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#a3906ad079a2cc489d948fcbbe3035e42">CURSOR_FAULT</a>;
<a name="l02607"></a>02607     p-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a> = errCode;
<a name="l02608"></a>02608   }
<a name="l02609"></a>02609   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(pBtree);
<a name="l02610"></a>02610 }
<a name="l02611"></a>02611 
<a name="l02612"></a>02612 <span class="comment">/*</span>
<a name="l02613"></a>02613 <span class="comment">** Rollback the transaction in progress.  All cursors will be</span>
<a name="l02614"></a>02614 <span class="comment">** invalided by this operation.  Any attempt to use a cursor</span>
<a name="l02615"></a>02615 <span class="comment">** that was open at the beginning of this operation will result</span>
<a name="l02616"></a>02616 <span class="comment">** in an error.</span>
<a name="l02617"></a>02617 <span class="comment">**</span>
<a name="l02618"></a>02618 <span class="comment">** This will release the write lock on the database file.  If there</span>
<a name="l02619"></a>02619 <span class="comment">** are no active cursors, it also releases the read lock.</span>
<a name="l02620"></a>02620 <span class="comment">*/</span>
<a name="l02621"></a><a class="code" href="btree_8h.html#ab071ab953498b2c4b8c32b2a23f26553">02621</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a447e8e3e0dc60f5adaa0f1f13980fc2d">sqlite3BtreeRollback</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l02622"></a>02622   <span class="keywordtype">int</span> rc;
<a name="l02623"></a>02623   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l02624"></a>02624   <a class="code" href="structMemPage.html">MemPage</a> *pPage1;
<a name="l02625"></a>02625 
<a name="l02626"></a>02626   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l02627"></a>02627   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l02628"></a>02628   rc = <a class="code" href="btree_8c.html#add0c7a5086792caf465148beaadb913d">saveAllCursors</a>(pBt, 0, 0);
<a name="l02629"></a>02629 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l02630"></a>02630 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02631"></a>02631     <span class="comment">/* This is a horrible situation. An IO or malloc() error occured whilst</span>
<a name="l02632"></a>02632 <span class="comment">    ** trying to save cursor positions. If this is an automatic rollback (as</span>
<a name="l02633"></a>02633 <span class="comment">    ** the result of a constraint, malloc() failure or IO error) then </span>
<a name="l02634"></a>02634 <span class="comment">    ** the cache may be internally inconsistent (not contain valid trees) so</span>
<a name="l02635"></a>02635 <span class="comment">    ** we cannot simply return the error to the caller. Instead, abort </span>
<a name="l02636"></a>02636 <span class="comment">    ** all queries that may be using any of the cursors that failed to save.</span>
<a name="l02637"></a>02637 <span class="comment">    */</span>
<a name="l02638"></a>02638     <a class="code" href="btree_8c.html#a16024e460e480bab5c8748ad12113c80">sqlite3BtreeTripAllCursors</a>(p, rc);
<a name="l02639"></a>02639   }
<a name="l02640"></a>02640 <span class="preprocessor">#endif</span>
<a name="l02641"></a>02641 <span class="preprocessor"></span>  <a class="code" href="btreeInt_8h.html#ad72671cebaea135fea75a2d28f2ca154">btreeIntegrity</a>(p);
<a name="l02642"></a>02642   <a class="code" href="btree_8c.html#a0e6849fc355cc0b10cc35b0db87e7817">unlockAllTables</a>(p);
<a name="l02643"></a>02643 
<a name="l02644"></a>02644   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l02645"></a>02645     <span class="keywordtype">int</span> rc2;
<a name="l02646"></a>02646 
<a name="l02647"></a>02647 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l02648"></a>02648 <span class="preprocessor"></span>    pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a> = 0;
<a name="l02649"></a>02649 <span class="preprocessor">#endif</span>
<a name="l02650"></a>02650 <span class="preprocessor"></span>
<a name="l02651"></a>02651     assert( <a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a>==pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a> );
<a name="l02652"></a>02652     rc2 = <a class="code" href="pager_8c.html#aeeefe012df954af841de39a42b9f3b0e">sqlite3PagerRollback</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l02653"></a>02653     <span class="keywordflow">if</span>( rc2!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02654"></a>02654       rc = rc2;
<a name="l02655"></a>02655     }
<a name="l02656"></a>02656 
<a name="l02657"></a>02657     <span class="comment">/* The rollback may have destroyed the pPage1-&gt;aData value.  So</span>
<a name="l02658"></a>02658 <span class="comment">    ** call sqlite3BtreeGetPage() on page 1 again to make</span>
<a name="l02659"></a>02659 <span class="comment">    ** sure pPage1-&gt;aData is set correctly. */</span>
<a name="l02660"></a>02660     <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, 1, &amp;pPage1, 0)==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02661"></a>02661       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage1);
<a name="l02662"></a>02662     }
<a name="l02663"></a>02663     assert( countWriteCursors(pBt)==0 );
<a name="l02664"></a>02664     pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a> = <a class="code" href="btreeInt_8h.html#a03621a625578cf71dcce39d6ccf44bdf">TRANS_READ</a>;
<a name="l02665"></a>02665   }
<a name="l02666"></a>02666 
<a name="l02667"></a>02667   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>!=<a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a> ){
<a name="l02668"></a>02668     assert( pBt-&gt;<a class="code" href="structBtShared.html#a6101a0e79a95e884ac4dc9c70a947715">nTransaction</a>&gt;0 );
<a name="l02669"></a>02669     pBt-&gt;<a class="code" href="structBtShared.html#a6101a0e79a95e884ac4dc9c70a947715">nTransaction</a>--;
<a name="l02670"></a>02670     <span class="keywordflow">if</span>( 0==pBt-&gt;<a class="code" href="structBtShared.html#a6101a0e79a95e884ac4dc9c70a947715">nTransaction</a> ){
<a name="l02671"></a>02671       pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a> = <a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a>;
<a name="l02672"></a>02672     }
<a name="l02673"></a>02673   }
<a name="l02674"></a>02674 
<a name="l02675"></a>02675   p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a> = <a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a>;
<a name="l02676"></a>02676   pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> = 0;
<a name="l02677"></a>02677   <a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">unlockBtreeIfUnused</a>(pBt);
<a name="l02678"></a>02678 
<a name="l02679"></a>02679   <a class="code" href="btreeInt_8h.html#ad72671cebaea135fea75a2d28f2ca154">btreeIntegrity</a>(p);
<a name="l02680"></a>02680   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02681"></a>02681   <span class="keywordflow">return</span> rc;
<a name="l02682"></a>02682 }
<a name="l02683"></a>02683 
<a name="l02684"></a>02684 <span class="comment">/*</span>
<a name="l02685"></a>02685 <span class="comment">** Start a statement subtransaction.  The subtransaction can</span>
<a name="l02686"></a>02686 <span class="comment">** can be rolled back independently of the main transaction.</span>
<a name="l02687"></a>02687 <span class="comment">** You must start a transaction before starting a subtransaction.</span>
<a name="l02688"></a>02688 <span class="comment">** The subtransaction is ended automatically if the main transaction</span>
<a name="l02689"></a>02689 <span class="comment">** commits or rolls back.</span>
<a name="l02690"></a>02690 <span class="comment">**</span>
<a name="l02691"></a>02691 <span class="comment">** Only one subtransaction may be active at a time.  It is an error to try</span>
<a name="l02692"></a>02692 <span class="comment">** to start a new subtransaction if another subtransaction is already active.</span>
<a name="l02693"></a>02693 <span class="comment">**</span>
<a name="l02694"></a>02694 <span class="comment">** Statement subtransactions are used around individual SQL statements</span>
<a name="l02695"></a>02695 <span class="comment">** that are contained within a BEGIN...COMMIT block.  If a constraint</span>
<a name="l02696"></a>02696 <span class="comment">** error occurs within the statement, the effect of that one statement</span>
<a name="l02697"></a>02697 <span class="comment">** can be rolled back without having to rollback the entire transaction.</span>
<a name="l02698"></a>02698 <span class="comment">*/</span>
<a name="l02699"></a><a class="code" href="btree_8h.html#adec393291de33917828f4dfc13e322f5">02699</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a19eb3dd7240d94ecb214abde8de779cc">sqlite3BtreeBeginStmt</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l02700"></a>02700   <span class="keywordtype">int</span> rc;
<a name="l02701"></a>02701   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l02702"></a>02702   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l02703"></a>02703   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l02704"></a>02704   <span class="keywordflow">if</span>( (p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>!=<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a>) || pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> ){
<a name="l02705"></a>02705     rc = pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ? <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a> : <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02706"></a>02706   }<span class="keywordflow">else</span>{
<a name="l02707"></a>02707     assert( pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> );
<a name="l02708"></a>02708     rc = pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ? <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> : <a class="code" href="pager_8c.html#a004816ab4d942898cf9ad3c81eecba68">sqlite3PagerStmtBegin</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l02709"></a>02709     pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> = 1;
<a name="l02710"></a>02710   }
<a name="l02711"></a>02711   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02712"></a>02712   <span class="keywordflow">return</span> rc;
<a name="l02713"></a>02713 }
<a name="l02714"></a>02714 
<a name="l02715"></a>02715 
<a name="l02716"></a>02716 <span class="comment">/*</span>
<a name="l02717"></a>02717 <span class="comment">** Commit the statment subtransaction currently in progress.  If no</span>
<a name="l02718"></a>02718 <span class="comment">** subtransaction is active, this is a no-op.</span>
<a name="l02719"></a>02719 <span class="comment">*/</span>
<a name="l02720"></a><a class="code" href="btree_8h.html#aa9ad7a4c516e1655f3b9f948b4d46a18">02720</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a08070c585cf98ef87dd60c2de12fb4b1">sqlite3BtreeCommitStmt</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l02721"></a>02721   <span class="keywordtype">int</span> rc;
<a name="l02722"></a>02722   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l02723"></a>02723   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l02724"></a>02724   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l02725"></a>02725   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> &amp;&amp; !pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ){
<a name="l02726"></a>02726     rc = <a class="code" href="pager_8c.html#a8dd7a91bc5e546bef4c647e851f25274">sqlite3PagerStmtCommit</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l02727"></a>02727   }<span class="keywordflow">else</span>{
<a name="l02728"></a>02728     rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02729"></a>02729   }
<a name="l02730"></a>02730   pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> = 0;
<a name="l02731"></a>02731   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02732"></a>02732   <span class="keywordflow">return</span> rc;
<a name="l02733"></a>02733 }
<a name="l02734"></a>02734 
<a name="l02735"></a>02735 <span class="comment">/*</span>
<a name="l02736"></a>02736 <span class="comment">** Rollback the active statement subtransaction.  If no subtransaction</span>
<a name="l02737"></a>02737 <span class="comment">** is active this routine is a no-op.</span>
<a name="l02738"></a>02738 <span class="comment">**</span>
<a name="l02739"></a>02739 <span class="comment">** All cursors will be invalidated by this operation.  Any attempt</span>
<a name="l02740"></a>02740 <span class="comment">** to use a cursor that was open at the beginning of this operation</span>
<a name="l02741"></a>02741 <span class="comment">** will result in an error.</span>
<a name="l02742"></a>02742 <span class="comment">*/</span>
<a name="l02743"></a><a class="code" href="btree_8h.html#a49837a2aedafc5a5715e0a38a32d2682">02743</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a18ab0ec8e821396eef5dbbd238a5dba3">sqlite3BtreeRollbackStmt</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l02744"></a>02744   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02745"></a>02745   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l02746"></a>02746   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l02747"></a>02747   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l02748"></a>02748   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> &amp;&amp; !pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ){
<a name="l02749"></a>02749     rc = <a class="code" href="pager_8c.html#a3765556d579b3f2c40b02f25a2b235d6">sqlite3PagerStmtRollback</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l02750"></a>02750     pBt-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a> = 0;
<a name="l02751"></a>02751   }
<a name="l02752"></a>02752   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02753"></a>02753   <span class="keywordflow">return</span> rc;
<a name="l02754"></a>02754 }
<a name="l02755"></a>02755 
<a name="l02756"></a>02756 <span class="comment">/*</span>
<a name="l02757"></a>02757 <span class="comment">** Create a new cursor for the BTree whose root is on the page</span>
<a name="l02758"></a>02758 <span class="comment">** iTable.  The act of acquiring a cursor gets a read lock on </span>
<a name="l02759"></a>02759 <span class="comment">** the database file.</span>
<a name="l02760"></a>02760 <span class="comment">**</span>
<a name="l02761"></a>02761 <span class="comment">** If wrFlag==0, then the cursor can only be used for reading.</span>
<a name="l02762"></a>02762 <span class="comment">** If wrFlag==1, then the cursor can be used for reading or for</span>
<a name="l02763"></a>02763 <span class="comment">** writing if other conditions for writing are also met.  These</span>
<a name="l02764"></a>02764 <span class="comment">** are the conditions that must be met in order for writing to</span>
<a name="l02765"></a>02765 <span class="comment">** be allowed:</span>
<a name="l02766"></a>02766 <span class="comment">**</span>
<a name="l02767"></a>02767 <span class="comment">** 1:  The cursor must have been opened with wrFlag==1</span>
<a name="l02768"></a>02768 <span class="comment">**</span>
<a name="l02769"></a>02769 <span class="comment">** 2:  Other database connections that share the same pager cache</span>
<a name="l02770"></a>02770 <span class="comment">**     but which are not in the READ_UNCOMMITTED state may not have</span>
<a name="l02771"></a>02771 <span class="comment">**     cursors open with wrFlag==0 on the same table.  Otherwise</span>
<a name="l02772"></a>02772 <span class="comment">**     the changes made by this write cursor would be visible to</span>
<a name="l02773"></a>02773 <span class="comment">**     the read cursors in the other database connection.</span>
<a name="l02774"></a>02774 <span class="comment">**</span>
<a name="l02775"></a>02775 <span class="comment">** 3:  The database must be writable (not on read-only media)</span>
<a name="l02776"></a>02776 <span class="comment">**</span>
<a name="l02777"></a>02777 <span class="comment">** 4:  There must be an active transaction.</span>
<a name="l02778"></a>02778 <span class="comment">**</span>
<a name="l02779"></a>02779 <span class="comment">** No checking is done to make sure that page iTable really is the</span>
<a name="l02780"></a>02780 <span class="comment">** root page of a b-tree.  If it is not, then the cursor acquired</span>
<a name="l02781"></a>02781 <span class="comment">** will not work correctly.</span>
<a name="l02782"></a>02782 <span class="comment">**</span>
<a name="l02783"></a>02783 <span class="comment">** It is assumed that the sqlite3BtreeCursorSize() bytes of memory </span>
<a name="l02784"></a>02784 <span class="comment">** pointed to by pCur have been zeroed by the caller.</span>
<a name="l02785"></a>02785 <span class="comment">*/</span>
<a name="l02786"></a><a class="code" href="btree_8c.html#a9830bfee9b343086d4443618b13ad4fd">02786</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a9830bfee9b343086d4443618b13ad4fd">btreeCursor</a>(
<a name="l02787"></a>02787   <a class="code" href="structBtree.html">Btree</a> *p,                              <span class="comment">/* The btree */</span>
<a name="l02788"></a>02788   <span class="keywordtype">int</span> iTable,                            <span class="comment">/* Root page of table to open */</span>
<a name="l02789"></a>02789   <span class="keywordtype">int</span> wrFlag,                            <span class="comment">/* 1 to write. 0 read-only */</span>
<a name="l02790"></a>02790   <span class="keyword">struct</span> <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKeyInfo,              <span class="comment">/* First arg to comparison function */</span>
<a name="l02791"></a>02791   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur                         <span class="comment">/* Space for new cursor */</span>
<a name="l02792"></a>02792 ){
<a name="l02793"></a>02793   <span class="keywordtype">int</span> rc;
<a name="l02794"></a>02794   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l02795"></a>02795 
<a name="l02796"></a>02796   assert( sqlite3BtreeHoldsMutex(p) );
<a name="l02797"></a>02797   <span class="keywordflow">if</span>( wrFlag ){
<a name="l02798"></a>02798     <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ){
<a name="l02799"></a>02799       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a>;
<a name="l02800"></a>02800     }
<a name="l02801"></a>02801     <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#accb60c0dac28fa55737649f0c556eef9">checkReadLocks</a>(p, iTable, 0, 0) ){
<a name="l02802"></a>02802       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>;
<a name="l02803"></a>02803     }
<a name="l02804"></a>02804   }
<a name="l02805"></a>02805 
<a name="l02806"></a>02806   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>==0 ){
<a name="l02807"></a>02807     rc = <a class="code" href="btree_8c.html#a6bfd699c64823f0b858a0a77c10f92f1">lockBtreeWithRetry</a>(p);
<a name="l02808"></a>02808     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02809"></a>02809       <span class="keywordflow">return</span> rc;
<a name="l02810"></a>02810     }
<a name="l02811"></a>02811     <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> &amp;&amp; wrFlag ){
<a name="l02812"></a>02812       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a>;
<a name="l02813"></a>02813     }
<a name="l02814"></a>02814   }
<a name="l02815"></a>02815   pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a> = (<a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a>)iTable;
<a name="l02816"></a>02816   <span class="keywordflow">if</span>( iTable==1 &amp;&amp; <a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>)==0 ){
<a name="l02817"></a>02817     rc = <a class="code" href="sqlite3_8h.html#adb3ccb6413bc81a990cab25356ab092f">SQLITE_EMPTY</a>;
<a name="l02818"></a>02818     <span class="keywordflow">goto</span> create_cursor_exception;
<a name="l02819"></a>02819   }
<a name="l02820"></a>02820   rc = <a class="code" href="btree_8c.html#a443538c685fb93b3b41ee3497629698e">getAndInitPage</a>(pBt, pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, &amp;pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0]);
<a name="l02821"></a>02821   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02822"></a>02822     <span class="keywordflow">goto</span> create_cursor_exception;
<a name="l02823"></a>02823   }
<a name="l02824"></a>02824 
<a name="l02825"></a>02825   <span class="comment">/* Now that no other errors can occur, finish filling in the BtCursor</span>
<a name="l02826"></a>02826 <span class="comment">  ** variables, link the cursor into the BtShared list and set *ppCur (the</span>
<a name="l02827"></a>02827 <span class="comment">  ** output argument to this function).</span>
<a name="l02828"></a>02828 <span class="comment">  */</span>
<a name="l02829"></a>02829   pCur-&gt;<a class="code" href="structBtCursor.html#ad2360bda13f959ed70672eb421fdb5ec">pKeyInfo</a> = pKeyInfo;
<a name="l02830"></a>02830   pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a> = p;
<a name="l02831"></a>02831   pCur-&gt;<a class="code" href="structBtCursor.html#a61c245712549192f7644e5ac23c00b74">pBt</a> = pBt;
<a name="l02832"></a>02832   pCur-&gt;<a class="code" href="structBtCursor.html#a9482c52d8c85519a3ada18517bf67a47">wrFlag</a> = wrFlag;
<a name="l02833"></a>02833   pCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a> = pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a>;
<a name="l02834"></a>02834   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a> ){
<a name="l02835"></a>02835     pCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>-&gt;<a class="code" href="structBtCursor.html#ac4f788ee88f252ddfcef8804674c7c90">pPrev</a> = pCur;
<a name="l02836"></a>02836   }
<a name="l02837"></a>02837   pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a> = pCur;
<a name="l02838"></a>02838   pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>;
<a name="l02839"></a>02839 
<a name="l02840"></a>02840   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02841"></a>02841 
<a name="l02842"></a>02842 create_cursor_exception:
<a name="l02843"></a>02843   <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0]);
<a name="l02844"></a>02844   <a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">unlockBtreeIfUnused</a>(pBt);
<a name="l02845"></a>02845   <span class="keywordflow">return</span> rc;
<a name="l02846"></a>02846 }
<a name="l02847"></a><a class="code" href="btree_8h.html#ab76caa3182d0b2ec99b17750f5d83420">02847</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a4b7ea579f2a4d5e2ac49e7ad5b5f47b7">sqlite3BtreeCursor</a>(
<a name="l02848"></a>02848   <a class="code" href="structBtree.html">Btree</a> *p,                                   <span class="comment">/* The btree */</span>
<a name="l02849"></a>02849   <span class="keywordtype">int</span> iTable,                                 <span class="comment">/* Root page of table to open */</span>
<a name="l02850"></a>02850   <span class="keywordtype">int</span> wrFlag,                                 <span class="comment">/* 1 to write. 0 read-only */</span>
<a name="l02851"></a>02851   <span class="keyword">struct</span> <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKeyInfo,                   <span class="comment">/* First arg to xCompare() */</span>
<a name="l02852"></a>02852   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur                              <span class="comment">/* Write new cursor here */</span>
<a name="l02853"></a>02853 ){
<a name="l02854"></a>02854   <span class="keywordtype">int</span> rc;
<a name="l02855"></a>02855   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l02856"></a>02856   p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l02857"></a>02857   rc = <a class="code" href="btree_8c.html#a9830bfee9b343086d4443618b13ad4fd">btreeCursor</a>(p, iTable, wrFlag, pKeyInfo, pCur);
<a name="l02858"></a>02858   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l02859"></a>02859   <span class="keywordflow">return</span> rc;
<a name="l02860"></a>02860 }
<a name="l02861"></a><a class="code" href="btree_8h.html#ae58fcb3c6f2e4624baa74c9daec08ffd">02861</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a96338636fbb297e190ebbe528d065cbe">sqlite3BtreeCursorSize</a>(){
<a name="l02862"></a>02862   <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<a class="code" href="structBtCursor.html">BtCursor</a>);
<a name="l02863"></a>02863 }
<a name="l02864"></a>02864 
<a name="l02865"></a>02865 
<a name="l02866"></a>02866 
<a name="l02867"></a>02867 <span class="comment">/*</span>
<a name="l02868"></a>02868 <span class="comment">** Close a cursor.  The read lock on the database file is released</span>
<a name="l02869"></a>02869 <span class="comment">** when the last cursor is closed.</span>
<a name="l02870"></a>02870 <span class="comment">*/</span>
<a name="l02871"></a><a class="code" href="btree_8h.html#a3d66fa4ba0dbba53cefcdfb0c8b28862">02871</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aceb051a90ea80c52fc1513ed5de5087d">sqlite3BtreeCloseCursor</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l02872"></a>02872   <a class="code" href="structBtree.html">Btree</a> *pBtree = pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>;
<a name="l02873"></a>02873   <span class="keywordflow">if</span>( pBtree ){
<a name="l02874"></a>02874     <span class="keywordtype">int</span> i;
<a name="l02875"></a>02875     <a class="code" href="structBtShared.html">BtShared</a> *pBt = pCur-&gt;<a class="code" href="structBtCursor.html#a61c245712549192f7644e5ac23c00b74">pBt</a>;
<a name="l02876"></a>02876     <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(pBtree);
<a name="l02877"></a>02877     pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = pBtree-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l02878"></a>02878     <a class="code" href="btree_8c.html#a1b4b9b532ff7779a50f6482c723b3b50">sqlite3BtreeClearCursor</a>(pCur);
<a name="l02879"></a>02879     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ac4f788ee88f252ddfcef8804674c7c90">pPrev</a> ){
<a name="l02880"></a>02880       pCur-&gt;<a class="code" href="structBtCursor.html#ac4f788ee88f252ddfcef8804674c7c90">pPrev</a>-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a> = pCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>;
<a name="l02881"></a>02881     }<span class="keywordflow">else</span>{
<a name="l02882"></a>02882       pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a> = pCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>;
<a name="l02883"></a>02883     }
<a name="l02884"></a>02884     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a> ){
<a name="l02885"></a>02885       pCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>-&gt;<a class="code" href="structBtCursor.html#ac4f788ee88f252ddfcef8804674c7c90">pPrev</a> = pCur-&gt;<a class="code" href="structBtCursor.html#ac4f788ee88f252ddfcef8804674c7c90">pPrev</a>;
<a name="l02886"></a>02886     }
<a name="l02887"></a>02887     <span class="keywordflow">for</span>(i=0; i&lt;=pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>; i++){
<a name="l02888"></a>02888       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[i]);
<a name="l02889"></a>02889     }
<a name="l02890"></a>02890     <a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">unlockBtreeIfUnused</a>(pBt);
<a name="l02891"></a>02891     <a class="code" href="btree_8c.html#a419e64e1c771d39b27b2917f164fb8d4">invalidateOverflowCache</a>(pCur);
<a name="l02892"></a>02892     <span class="comment">/* sqlite3_free(pCur); */</span>
<a name="l02893"></a>02893     <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(pBtree);
<a name="l02894"></a>02894   }
<a name="l02895"></a>02895   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02896"></a>02896 }
<a name="l02897"></a>02897 
<a name="l02898"></a>02898 <span class="comment">/*</span>
<a name="l02899"></a>02899 <span class="comment">** Make a temporary cursor by filling in the fields of pTempCur.</span>
<a name="l02900"></a>02900 <span class="comment">** The temporary cursor is not on the cursor list for the Btree.</span>
<a name="l02901"></a>02901 <span class="comment">*/</span>
<a name="l02902"></a><a class="code" href="btreeInt_8h.html#adaa34d465164d3fa306adf517af7faeb">02902</a> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#adaa34d465164d3fa306adf517af7faeb">sqlite3BtreeGetTempCursor</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <a class="code" href="structBtCursor.html">BtCursor</a> *pTempCur){
<a name="l02903"></a>02903   <span class="keywordtype">int</span> i;
<a name="l02904"></a>02904   assert( cursorHoldsMutex(pCur) );
<a name="l02905"></a>02905   memcpy(pTempCur, pCur, <span class="keyword">sizeof</span>(<a class="code" href="structBtCursor.html">BtCursor</a>));
<a name="l02906"></a>02906   pTempCur-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a> = 0;
<a name="l02907"></a>02907   pTempCur-&gt;<a class="code" href="structBtCursor.html#ac4f788ee88f252ddfcef8804674c7c90">pPrev</a> = 0;
<a name="l02908"></a>02908   <span class="keywordflow">for</span>(i=0; i&lt;=pTempCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>; i++){
<a name="l02909"></a>02909     <a class="code" href="pager_8c.html#ab49824cea834244d7fbcbd6e69c016c3">sqlite3PagerRef</a>(pTempCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[i]-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l02910"></a>02910   }
<a name="l02911"></a>02911 }
<a name="l02912"></a>02912 
<a name="l02913"></a>02913 <span class="comment">/*</span>
<a name="l02914"></a>02914 <span class="comment">** Delete a temporary cursor such as was made by the CreateTemporaryCursor()</span>
<a name="l02915"></a>02915 <span class="comment">** function above.</span>
<a name="l02916"></a>02916 <span class="comment">*/</span>
<a name="l02917"></a><a class="code" href="btreeInt_8h.html#a411511352dae53cda562b7b575831e82">02917</a> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a411511352dae53cda562b7b575831e82">sqlite3BtreeReleaseTempCursor</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l02918"></a>02918   <span class="keywordtype">int</span> i;
<a name="l02919"></a>02919   assert( cursorHoldsMutex(pCur) );
<a name="l02920"></a>02920   <span class="keywordflow">for</span>(i=0; i&lt;=pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>; i++){
<a name="l02921"></a>02921     <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[i]-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l02922"></a>02922   }
<a name="l02923"></a>02923 }
<a name="l02924"></a>02924 
<a name="l02925"></a>02925 <span class="comment">/*</span>
<a name="l02926"></a>02926 <span class="comment">** Make sure the BtCursor* given in the argument has a valid</span>
<a name="l02927"></a>02927 <span class="comment">** BtCursor.info structure.  If it is not already valid, call</span>
<a name="l02928"></a>02928 <span class="comment">** sqlite3BtreeParseCell() to fill it in.</span>
<a name="l02929"></a>02929 <span class="comment">**</span>
<a name="l02930"></a>02930 <span class="comment">** BtCursor.info is a cache of the information in the current cell.</span>
<a name="l02931"></a>02931 <span class="comment">** Using this cache reduces the number of calls to sqlite3BtreeParseCell().</span>
<a name="l02932"></a>02932 <span class="comment">**</span>
<a name="l02933"></a>02933 <span class="comment">** 2007-06-25:  There is a bug in some versions of MSVC that cause the</span>
<a name="l02934"></a>02934 <span class="comment">** compiler to crash when getCellInfo() is implemented as a macro.</span>
<a name="l02935"></a>02935 <span class="comment">** But there is a measureable speed advantage to using the macro on gcc</span>
<a name="l02936"></a>02936 <span class="comment">** (when less compiler optimizations like -Os or -O0 are used and the</span>
<a name="l02937"></a>02937 <span class="comment">** compiler is not doing agressive inlining.)  So we use a real function</span>
<a name="l02938"></a>02938 <span class="comment">** for MSVC and a macro for everything else.  Ticket #2457.</span>
<a name="l02939"></a>02939 <span class="comment">*/</span>
<a name="l02940"></a>02940 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l02941"></a>02941 <span class="preprocessor"></span>  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a239eed64a53bd4c8d5a2484b513e8b00">assertCellInfo</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l02942"></a>02942     <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l02943"></a>02943     <span class="keywordtype">int</span> iPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>;
<a name="l02944"></a>02944     memset(&amp;info, 0, <span class="keyword">sizeof</span>(info));
<a name="l02945"></a>02945     <a class="code" href="btree_8c.html#ac350761e25d0e6db77f71c4c2d925bea">sqlite3BtreeParseCell</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[iPage], pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[iPage], &amp;info);
<a name="l02946"></a>02946     assert( memcmp(&amp;info, &amp;pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>, <span class="keyword">sizeof</span>(info))==0 );
<a name="l02947"></a>02947   }
<a name="l02948"></a>02948 <span class="preprocessor">#else</span>
<a name="l02949"></a><a class="code" href="btree_8c.html#a239eed64a53bd4c8d5a2484b513e8b00">02949</a> <span class="preprocessor"></span><span class="preprocessor">  #define assertCellInfo(x)</span>
<a name="l02950"></a>02950 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02951"></a>02951 <span class="preprocessor"></span><span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l02952"></a>02952 <span class="preprocessor"></span>  <span class="comment">/* Use a real function in MSVC to work around bugs in that compiler. */</span>
<a name="l02953"></a>02953   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#ada0c88a82b2b75cb13ee3c85ffcdf380">getCellInfo</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l02954"></a>02954     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a>==0 ){
<a name="l02955"></a>02955       <span class="keywordtype">int</span> iPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>;
<a name="l02956"></a>02956       <a class="code" href="btree_8c.html#ac350761e25d0e6db77f71c4c2d925bea">sqlite3BtreeParseCell</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[iPage],pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[iPage],&amp;pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>);
<a name="l02957"></a>02957       pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 1;
<a name="l02958"></a>02958     }<span class="keywordflow">else</span>{
<a name="l02959"></a>02959       <a class="code" href="btree_8c.html#a239eed64a53bd4c8d5a2484b513e8b00">assertCellInfo</a>(pCur);
<a name="l02960"></a>02960     }
<a name="l02961"></a>02961   }
<a name="l02962"></a>02962 <span class="preprocessor">#else </span><span class="comment">/* if not _MSC_VER */</span>
<a name="l02963"></a>02963   <span class="comment">/* Use a macro in all other compilers so that the function is inlined */</span>
<a name="l02964"></a><a class="code" href="btree_8c.html#ada0c88a82b2b75cb13ee3c85ffcdf380">02964</a> <span class="preprocessor">#define getCellInfo(pCur)                                                      \</span>
<a name="l02965"></a>02965 <span class="preprocessor">  if( pCur-&gt;info.nSize==0 ){                                                   \</span>
<a name="l02966"></a>02966 <span class="preprocessor">    int iPage = pCur-&gt;iPage;                                                   \</span>
<a name="l02967"></a>02967 <span class="preprocessor">    sqlite3BtreeParseCell(pCur-&gt;apPage[iPage],pCur-&gt;aiIdx[iPage],&amp;pCur-&gt;info); \</span>
<a name="l02968"></a>02968 <span class="preprocessor">    pCur-&gt;validNKey = 1;                                                       \</span>
<a name="l02969"></a>02969 <span class="preprocessor">  }else{                                                                       \</span>
<a name="l02970"></a>02970 <span class="preprocessor">    assertCellInfo(pCur);                                                      \</span>
<a name="l02971"></a>02971 <span class="preprocessor">  }</span>
<a name="l02972"></a>02972 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* _MSC_VER */</span>
<a name="l02973"></a>02973 
<a name="l02974"></a>02974 <span class="comment">/*</span>
<a name="l02975"></a>02975 <span class="comment">** Set *pSize to the size of the buffer needed to hold the value of</span>
<a name="l02976"></a>02976 <span class="comment">** the key for the current entry.  If the cursor is not pointing</span>
<a name="l02977"></a>02977 <span class="comment">** to a valid entry, *pSize is set to 0. </span>
<a name="l02978"></a>02978 <span class="comment">**</span>
<a name="l02979"></a>02979 <span class="comment">** For a table with the INTKEY flag set, this routine returns the key</span>
<a name="l02980"></a>02980 <span class="comment">** itself, not the number of bytes in the key.</span>
<a name="l02981"></a>02981 <span class="comment">*/</span>
<a name="l02982"></a><a class="code" href="btree_8h.html#a4d08107efc13adc14cdb2c55beee7ac0">02982</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a2d5023d925e7eade74a33a94fbbc45e0">sqlite3BtreeKeySize</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> *pSize){
<a name="l02983"></a>02983   <span class="keywordtype">int</span> rc;
<a name="l02984"></a>02984 
<a name="l02985"></a>02985   assert( cursorHoldsMutex(pCur) );
<a name="l02986"></a>02986   rc = <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCur);
<a name="l02987"></a>02987   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02988"></a>02988     assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> || pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l02989"></a>02989     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> ){
<a name="l02990"></a>02990       *pSize = 0;
<a name="l02991"></a>02991     }<span class="keywordflow">else</span>{
<a name="l02992"></a>02992       <a class="code" href="btree_8c.html#ada0c88a82b2b75cb13ee3c85ffcdf380">getCellInfo</a>(pCur);
<a name="l02993"></a>02993       *pSize = pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>;
<a name="l02994"></a>02994     }
<a name="l02995"></a>02995   }
<a name="l02996"></a>02996   <span class="keywordflow">return</span> rc;
<a name="l02997"></a>02997 }
<a name="l02998"></a>02998 
<a name="l02999"></a>02999 <span class="comment">/*</span>
<a name="l03000"></a>03000 <span class="comment">** Set *pSize to the number of bytes of data in the entry the</span>
<a name="l03001"></a>03001 <span class="comment">** cursor currently points to.  Always return SQLITE_OK.</span>
<a name="l03002"></a>03002 <span class="comment">** Failure is not possible.  If the cursor is not currently</span>
<a name="l03003"></a>03003 <span class="comment">** pointing to an entry (which can happen, for example, if</span>
<a name="l03004"></a>03004 <span class="comment">** the database is empty) then *pSize is set to 0.</span>
<a name="l03005"></a>03005 <span class="comment">*/</span>
<a name="l03006"></a><a class="code" href="btree_8h.html#aa25f2641124357a6a97842493ee4e858">03006</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a8c49974ebd7131c7789e3bdb7fd41c96">sqlite3BtreeDataSize</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> *pSize){
<a name="l03007"></a>03007   <span class="keywordtype">int</span> rc;
<a name="l03008"></a>03008 
<a name="l03009"></a>03009   assert( cursorHoldsMutex(pCur) );
<a name="l03010"></a>03010   rc = <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCur);
<a name="l03011"></a>03011   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03012"></a>03012     assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> || pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03013"></a>03013     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> ){
<a name="l03014"></a>03014       <span class="comment">/* Not pointing at a valid entry - set *pSize to 0. */</span>
<a name="l03015"></a>03015       *pSize = 0;
<a name="l03016"></a>03016     }<span class="keywordflow">else</span>{
<a name="l03017"></a>03017       <a class="code" href="btree_8c.html#ada0c88a82b2b75cb13ee3c85ffcdf380">getCellInfo</a>(pCur);
<a name="l03018"></a>03018       *pSize = pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a>;
<a name="l03019"></a>03019     }
<a name="l03020"></a>03020   }
<a name="l03021"></a>03021   <span class="keywordflow">return</span> rc;
<a name="l03022"></a>03022 }
<a name="l03023"></a>03023 
<a name="l03024"></a>03024 <span class="comment">/*</span>
<a name="l03025"></a>03025 <span class="comment">** Given the page number of an overflow page in the database (parameter</span>
<a name="l03026"></a>03026 <span class="comment">** ovfl), this function finds the page number of the next page in the </span>
<a name="l03027"></a>03027 <span class="comment">** linked list of overflow pages. If possible, it uses the auto-vacuum</span>
<a name="l03028"></a>03028 <span class="comment">** pointer-map data instead of reading the content of page ovfl to do so. </span>
<a name="l03029"></a>03029 <span class="comment">**</span>
<a name="l03030"></a>03030 <span class="comment">** If an error occurs an SQLite error code is returned. Otherwise:</span>
<a name="l03031"></a>03031 <span class="comment">**</span>
<a name="l03032"></a>03032 <span class="comment">** Unless pPgnoNext is NULL, the page number of the next overflow </span>
<a name="l03033"></a>03033 <span class="comment">** page in the linked list is written to *pPgnoNext. If page ovfl</span>
<a name="l03034"></a>03034 <span class="comment">** is the last page in its linked list, *pPgnoNext is set to zero. </span>
<a name="l03035"></a>03035 <span class="comment">**</span>
<a name="l03036"></a>03036 <span class="comment">** If ppPage is not NULL, *ppPage is set to the MemPage* handle</span>
<a name="l03037"></a>03037 <span class="comment">** for page ovfl. The underlying pager page may have been requested</span>
<a name="l03038"></a>03038 <span class="comment">** with the noContent flag set, so the page data accessable via</span>
<a name="l03039"></a>03039 <span class="comment">** this handle may not be trusted.</span>
<a name="l03040"></a>03040 <span class="comment">*/</span>
<a name="l03041"></a><a class="code" href="btree_8c.html#af907f898e049d621e2c9dc1ed1d63cf4">03041</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#af907f898e049d621e2c9dc1ed1d63cf4">getOverflowPage</a>(
<a name="l03042"></a>03042   <a class="code" href="structBtShared.html">BtShared</a> *pBt, 
<a name="l03043"></a>03043   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> ovfl,                   <span class="comment">/* Overflow page */</span>
<a name="l03044"></a>03044   <a class="code" href="structMemPage.html">MemPage</a> **ppPage,            <span class="comment">/* OUT: MemPage handle */</span>
<a name="l03045"></a>03045   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> *pPgnoNext              <span class="comment">/* OUT: Next overflow page number */</span>
<a name="l03046"></a>03046 ){
<a name="l03047"></a>03047   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> <a class="code" href="llex_8c.html#a8ab976102fb046f9974c53caaf5a1995">next</a> = 0;
<a name="l03048"></a>03048   <span class="keywordtype">int</span> rc;
<a name="l03049"></a>03049 
<a name="l03050"></a>03050   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l03051"></a>03051   <span class="comment">/* One of these must not be NULL. Otherwise, why call this function? */</span>
<a name="l03052"></a>03052   assert(ppPage || pPgnoNext);
<a name="l03053"></a>03053 
<a name="l03054"></a>03054   <span class="comment">/* If pPgnoNext is NULL, then this function is being called to obtain</span>
<a name="l03055"></a>03055 <span class="comment">  ** a MemPage* reference only. No page-data is required in this case.</span>
<a name="l03056"></a>03056 <span class="comment">  */</span>
<a name="l03057"></a>03057   <span class="keywordflow">if</span>( !pPgnoNext ){
<a name="l03058"></a>03058     <span class="keywordflow">return</span> <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, ovfl, ppPage, 1);
<a name="l03059"></a>03059   }
<a name="l03060"></a>03060 
<a name="l03061"></a>03061 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l03062"></a>03062 <span class="preprocessor"></span>  <span class="comment">/* Try to find the next page in the overflow list using the</span>
<a name="l03063"></a>03063 <span class="comment">  ** autovacuum pointer-map pages. Guess that the next page in </span>
<a name="l03064"></a>03064 <span class="comment">  ** the overflow list is page number (ovfl+1). If that guess turns </span>
<a name="l03065"></a>03065 <span class="comment">  ** out to be wrong, fall back to loading the data of page </span>
<a name="l03066"></a>03066 <span class="comment">  ** number ovfl to determine the next page number.</span>
<a name="l03067"></a>03067 <span class="comment">  */</span>
<a name="l03068"></a>03068   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l03069"></a>03069     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgno;
<a name="l03070"></a>03070     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iGuess = ovfl+1;
<a name="l03071"></a>03071     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eType;
<a name="l03072"></a>03072 
<a name="l03073"></a>03073     <span class="keywordflow">while</span>( <a class="code" href="btreeInt_8h.html#a5236c788e81fad4b3d02e93a63f8f649">PTRMAP_ISPAGE</a>(pBt, iGuess) || iGuess==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){
<a name="l03074"></a>03074       iGuess++;
<a name="l03075"></a>03075     }
<a name="l03076"></a>03076 
<a name="l03077"></a>03077     <span class="keywordflow">if</span>( iGuess&lt;=<a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>) ){
<a name="l03078"></a>03078       rc = <a class="code" href="btree_8c.html#ae91bfd9c1bec807a52a384d2ed01934b">ptrmapGet</a>(pBt, iGuess, &amp;eType, &amp;pgno);
<a name="l03079"></a>03079       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03080"></a>03080         <span class="keywordflow">return</span> rc;
<a name="l03081"></a>03081       }
<a name="l03082"></a>03082       <span class="keywordflow">if</span>( eType==<a class="code" href="btreeInt_8h.html#a2ae32756efb02fe2c719669a0bfabe9a">PTRMAP_OVERFLOW2</a> &amp;&amp; pgno==ovfl ){
<a name="l03083"></a>03083         next = iGuess;
<a name="l03084"></a>03084       }
<a name="l03085"></a>03085     }
<a name="l03086"></a>03086   }
<a name="l03087"></a>03087 <span class="preprocessor">#endif</span>
<a name="l03088"></a>03088 <span class="preprocessor"></span>
<a name="l03089"></a>03089   <span class="keywordflow">if</span>( next==0 || ppPage ){
<a name="l03090"></a>03090     <a class="code" href="structMemPage.html">MemPage</a> *pPage = 0;
<a name="l03091"></a>03091 
<a name="l03092"></a>03092     rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, ovfl, &amp;pPage, next!=0);
<a name="l03093"></a>03093     assert(rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> || pPage==0);
<a name="l03094"></a>03094     <span class="keywordflow">if</span>( next==0 &amp;&amp; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03095"></a>03095       next = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>);
<a name="l03096"></a>03096     }
<a name="l03097"></a>03097 
<a name="l03098"></a>03098     <span class="keywordflow">if</span>( ppPage ){
<a name="l03099"></a>03099       *ppPage = pPage;
<a name="l03100"></a>03100     }<span class="keywordflow">else</span>{
<a name="l03101"></a>03101       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l03102"></a>03102     }
<a name="l03103"></a>03103   }
<a name="l03104"></a>03104   *pPgnoNext = next;
<a name="l03105"></a>03105 
<a name="l03106"></a>03106   <span class="keywordflow">return</span> rc;
<a name="l03107"></a>03107 }
<a name="l03108"></a>03108 
<a name="l03109"></a>03109 <span class="comment">/*</span>
<a name="l03110"></a>03110 <span class="comment">** Copy data from a buffer to a page, or from a page to a buffer.</span>
<a name="l03111"></a>03111 <span class="comment">**</span>
<a name="l03112"></a>03112 <span class="comment">** pPayload is a pointer to data stored on database page pDbPage.</span>
<a name="l03113"></a>03113 <span class="comment">** If argument eOp is false, then nByte bytes of data are copied</span>
<a name="l03114"></a>03114 <span class="comment">** from pPayload to the buffer pointed at by pBuf. If eOp is true,</span>
<a name="l03115"></a>03115 <span class="comment">** then sqlite3PagerWrite() is called on pDbPage and nByte bytes</span>
<a name="l03116"></a>03116 <span class="comment">** of data are copied from the buffer pBuf to pPayload.</span>
<a name="l03117"></a>03117 <span class="comment">**</span>
<a name="l03118"></a>03118 <span class="comment">** SQLITE_OK is returned on success, otherwise an error code.</span>
<a name="l03119"></a>03119 <span class="comment">*/</span>
<a name="l03120"></a><a class="code" href="btree_8c.html#aedb2ad4326779a68bc8e012570bda430">03120</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aedb2ad4326779a68bc8e012570bda430">copyPayload</a>(
<a name="l03121"></a>03121   <span class="keywordtype">void</span> *pPayload,           <span class="comment">/* Pointer to page data */</span>
<a name="l03122"></a>03122   <span class="keywordtype">void</span> *pBuf,               <span class="comment">/* Pointer to buffer */</span>
<a name="l03123"></a>03123   <span class="keywordtype">int</span> nByte,                <span class="comment">/* Number of bytes to copy */</span>
<a name="l03124"></a>03124   <span class="keywordtype">int</span> eOp,                  <span class="comment">/* 0 -&gt; copy from page, 1 -&gt; copy to page */</span>
<a name="l03125"></a>03125   <a class="code" href="structPgHdr.html">DbPage</a> *pDbPage           <span class="comment">/* Page containing pPayload */</span>
<a name="l03126"></a>03126 ){
<a name="l03127"></a>03127   <span class="keywordflow">if</span>( eOp ){
<a name="l03128"></a>03128     <span class="comment">/* Copy data from buffer to page (a write operation) */</span>
<a name="l03129"></a>03129     <span class="keywordtype">int</span> rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pDbPage);
<a name="l03130"></a>03130     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03131"></a>03131       <span class="keywordflow">return</span> rc;
<a name="l03132"></a>03132     }
<a name="l03133"></a>03133     memcpy(pPayload, pBuf, nByte);
<a name="l03134"></a>03134   }<span class="keywordflow">else</span>{
<a name="l03135"></a>03135     <span class="comment">/* Copy data from page to buffer (a read operation) */</span>
<a name="l03136"></a>03136     memcpy(pBuf, pPayload, nByte);
<a name="l03137"></a>03137   }
<a name="l03138"></a>03138   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03139"></a>03139 }
<a name="l03140"></a>03140 
<a name="l03141"></a>03141 <span class="comment">/*</span>
<a name="l03142"></a>03142 <span class="comment">** This function is used to read or overwrite payload information</span>
<a name="l03143"></a>03143 <span class="comment">** for the entry that the pCur cursor is pointing to. If the eOp</span>
<a name="l03144"></a>03144 <span class="comment">** parameter is 0, this is a read operation (data copied into</span>
<a name="l03145"></a>03145 <span class="comment">** buffer pBuf). If it is non-zero, a write (data copied from</span>
<a name="l03146"></a>03146 <span class="comment">** buffer pBuf).</span>
<a name="l03147"></a>03147 <span class="comment">**</span>
<a name="l03148"></a>03148 <span class="comment">** A total of &quot;amt&quot; bytes are read or written beginning at &quot;offset&quot;.</span>
<a name="l03149"></a>03149 <span class="comment">** Data is read to or from the buffer pBuf.</span>
<a name="l03150"></a>03150 <span class="comment">**</span>
<a name="l03151"></a>03151 <span class="comment">** This routine does not make a distinction between key and data.</span>
<a name="l03152"></a>03152 <span class="comment">** It just reads or writes bytes from the payload area.  Data might </span>
<a name="l03153"></a>03153 <span class="comment">** appear on the main page or be scattered out on multiple overflow </span>
<a name="l03154"></a>03154 <span class="comment">** pages.</span>
<a name="l03155"></a>03155 <span class="comment">**</span>
<a name="l03156"></a>03156 <span class="comment">** If the BtCursor.isIncrblobHandle flag is set, and the current</span>
<a name="l03157"></a>03157 <span class="comment">** cursor entry uses one or more overflow pages, this function</span>
<a name="l03158"></a>03158 <span class="comment">** allocates space for and lazily popluates the overflow page-list </span>
<a name="l03159"></a>03159 <span class="comment">** cache array (BtCursor.aOverflow). Subsequent calls use this</span>
<a name="l03160"></a>03160 <span class="comment">** cache to make seeking to the supplied offset more efficient.</span>
<a name="l03161"></a>03161 <span class="comment">**</span>
<a name="l03162"></a>03162 <span class="comment">** Once an overflow page-list cache has been allocated, it may be</span>
<a name="l03163"></a>03163 <span class="comment">** invalidated if some other cursor writes to the same table, or if</span>
<a name="l03164"></a>03164 <span class="comment">** the cursor is moved to a different row. Additionally, in auto-vacuum</span>
<a name="l03165"></a>03165 <span class="comment">** mode, the following events may invalidate an overflow page-list cache.</span>
<a name="l03166"></a>03166 <span class="comment">**</span>
<a name="l03167"></a>03167 <span class="comment">**   * An incremental vacuum,</span>
<a name="l03168"></a>03168 <span class="comment">**   * A commit in auto_vacuum=&quot;full&quot; mode,</span>
<a name="l03169"></a>03169 <span class="comment">**   * Creating a table (may require moving an overflow page).</span>
<a name="l03170"></a>03170 <span class="comment">*/</span>
<a name="l03171"></a><a class="code" href="btree_8c.html#a7a651412aed8c025c2be2433f731a9a9">03171</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a7a651412aed8c025c2be2433f731a9a9">accessPayload</a>(
<a name="l03172"></a>03172   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur,      <span class="comment">/* Cursor pointing to entry to read from */</span>
<a name="l03173"></a>03173   <span class="keywordtype">int</span> offset,          <span class="comment">/* Begin reading this far into payload */</span>
<a name="l03174"></a>03174   <span class="keywordtype">int</span> amt,             <span class="comment">/* Read this many bytes */</span>
<a name="l03175"></a>03175   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pBuf, <span class="comment">/* Write the bytes into this buffer */</span> 
<a name="l03176"></a>03176   <span class="keywordtype">int</span> skipKey,         <span class="comment">/* offset begins at data if this is true */</span>
<a name="l03177"></a>03177   <span class="keywordtype">int</span> eOp              <span class="comment">/* zero to read. non-zero to write. */</span>
<a name="l03178"></a>03178 ){
<a name="l03179"></a>03179   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *aPayload;
<a name="l03180"></a>03180   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03181"></a>03181   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> nKey;
<a name="l03182"></a>03182   <span class="keywordtype">int</span> iIdx = 0;
<a name="l03183"></a>03183   <a class="code" href="structMemPage.html">MemPage</a> *pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]; <span class="comment">/* Btree page of current entry */</span>
<a name="l03184"></a>03184   <a class="code" href="structBtShared.html">BtShared</a> *pBt;                              <span class="comment">/* Btree this cursor belongs to */</span>
<a name="l03185"></a>03185 
<a name="l03186"></a>03186   assert( pPage );
<a name="l03187"></a>03187   assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03188"></a>03188   assert( pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]&lt;pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> );
<a name="l03189"></a>03189   assert( offset&gt;=0 );
<a name="l03190"></a>03190   assert( cursorHoldsMutex(pCur) );
<a name="l03191"></a>03191 
<a name="l03192"></a>03192   <a class="code" href="btree_8c.html#ada0c88a82b2b75cb13ee3c85ffcdf380">getCellInfo</a>(pCur);
<a name="l03193"></a>03193   aPayload = pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a595ed7eeb60ea274d868f24347b7238e">pCell</a> + pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a99bb1f87208f793359cf63e3d164025b">nHeader</a>;
<a name="l03194"></a>03194   nKey = (pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> ? 0 : pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>);
<a name="l03195"></a>03195 
<a name="l03196"></a>03196   <span class="keywordflow">if</span>( skipKey ){
<a name="l03197"></a>03197     offset += nKey;
<a name="l03198"></a>03198   }
<a name="l03199"></a>03199   <span class="keywordflow">if</span>( offset+amt &gt; nKey+pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a> ){
<a name="l03200"></a>03200     <span class="comment">/* Trying to read or write past the end of the data is an error */</span>
<a name="l03201"></a>03201     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l03202"></a>03202   }
<a name="l03203"></a>03203 
<a name="l03204"></a>03204   <span class="comment">/* Check if data must be read/written to/from the btree page itself. */</span>
<a name="l03205"></a>03205   <span class="keywordflow">if</span>( offset&lt;pCur-&gt;info.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> ){
<a name="l03206"></a>03206     <span class="keywordtype">int</span> a = amt;
<a name="l03207"></a>03207     <span class="keywordflow">if</span>( a+offset&gt;pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> ){
<a name="l03208"></a>03208       a = pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> - offset;
<a name="l03209"></a>03209     }
<a name="l03210"></a>03210     rc = <a class="code" href="btree_8c.html#aedb2ad4326779a68bc8e012570bda430">copyPayload</a>(&amp;aPayload[offset], pBuf, a, eOp, pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l03211"></a>03211     offset = 0;
<a name="l03212"></a>03212     pBuf += a;
<a name="l03213"></a>03213     amt -= a;
<a name="l03214"></a>03214   }<span class="keywordflow">else</span>{
<a name="l03215"></a>03215     offset -= pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a>;
<a name="l03216"></a>03216   }
<a name="l03217"></a>03217 
<a name="l03218"></a>03218   pBt = pCur-&gt;<a class="code" href="structBtCursor.html#a61c245712549192f7644e5ac23c00b74">pBt</a>;
<a name="l03219"></a>03219   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; amt&gt;0 ){
<a name="l03220"></a>03220     <span class="keyword">const</span> <span class="keywordtype">int</span> ovflSize = pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> - 4;  <span class="comment">/* Bytes content per ovfl page */</span>
<a name="l03221"></a>03221     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nextPage;
<a name="l03222"></a>03222 
<a name="l03223"></a>03223     nextPage = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;aPayload[pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a>]);
<a name="l03224"></a>03224 
<a name="l03225"></a>03225 <span class="preprocessor">#ifndef SQLITE_OMIT_INCRBLOB</span>
<a name="l03226"></a>03226 <span class="preprocessor"></span>    <span class="comment">/* If the isIncrblobHandle flag is set and the BtCursor.aOverflow[]</span>
<a name="l03227"></a>03227 <span class="comment">    ** has not been allocated, allocate it now. The array is sized at</span>
<a name="l03228"></a>03228 <span class="comment">    ** one entry for each overflow page in the overflow chain. The</span>
<a name="l03229"></a>03229 <span class="comment">    ** page number of the first overflow page is stored in aOverflow[0],</span>
<a name="l03230"></a>03230 <span class="comment">    ** etc. A value of 0 in the aOverflow[] array means &quot;not yet known&quot;</span>
<a name="l03231"></a>03231 <span class="comment">    ** (the cache is lazily populated).</span>
<a name="l03232"></a>03232 <span class="comment">    */</span>
<a name="l03233"></a>03233     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a539dc1beff0ec303cfd4c94c274c7a9b">isIncrblobHandle</a> &amp;&amp; !pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a> ){
<a name="l03234"></a>03234       <span class="keywordtype">int</span> nOvfl = (pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ac1e3c1b4216a8e778bbac82907bb1485">nPayload</a>-pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a>+ovflSize-1)/ovflSize;
<a name="l03235"></a>03235       pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a> = (<a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> *)<a class="code" href="malloc_8c.html#aa88ccfc5604fb4bd9b60b3ca4f9f58d4">sqlite3MallocZero</a>(<span class="keyword">sizeof</span>(<a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a>)*nOvfl);
<a name="l03236"></a>03236       <span class="keywordflow">if</span>( nOvfl &amp;&amp; !pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a> ){
<a name="l03237"></a>03237         rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l03238"></a>03238       }
<a name="l03239"></a>03239     }
<a name="l03240"></a>03240 
<a name="l03241"></a>03241     <span class="comment">/* If the overflow page-list cache has been allocated and the</span>
<a name="l03242"></a>03242 <span class="comment">    ** entry for the first required overflow page is valid, skip</span>
<a name="l03243"></a>03243 <span class="comment">    ** directly to it.</span>
<a name="l03244"></a>03244 <span class="comment">    */</span>
<a name="l03245"></a>03245     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a> &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a>[offset/ovflSize] ){
<a name="l03246"></a>03246       iIdx = (offset/ovflSize);
<a name="l03247"></a>03247       nextPage = pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a>[iIdx];
<a name="l03248"></a>03248       offset = (offset%ovflSize);
<a name="l03249"></a>03249     }
<a name="l03250"></a>03250 <span class="preprocessor">#endif</span>
<a name="l03251"></a>03251 <span class="preprocessor"></span>
<a name="l03252"></a>03252     <span class="keywordflow">for</span>( ; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; amt&gt;0 &amp;&amp; nextPage; iIdx++){
<a name="l03253"></a>03253 
<a name="l03254"></a>03254 <span class="preprocessor">#ifndef SQLITE_OMIT_INCRBLOB</span>
<a name="l03255"></a>03255 <span class="preprocessor"></span>      <span class="comment">/* If required, populate the overflow page-list cache. */</span>
<a name="l03256"></a>03256       <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a> ){
<a name="l03257"></a>03257         assert(!pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a>[iIdx] || pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a>[iIdx]==nextPage);
<a name="l03258"></a>03258         pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a>[iIdx] = nextPage;
<a name="l03259"></a>03259       }
<a name="l03260"></a>03260 <span class="preprocessor">#endif</span>
<a name="l03261"></a>03261 <span class="preprocessor"></span>
<a name="l03262"></a>03262       <span class="keywordflow">if</span>( offset&gt;=ovflSize ){
<a name="l03263"></a>03263         <span class="comment">/* The only reason to read this page is to obtain the page</span>
<a name="l03264"></a>03264 <span class="comment">        ** number for the next page in the overflow chain. The page</span>
<a name="l03265"></a>03265 <span class="comment">        ** data is not required. So first try to lookup the overflow</span>
<a name="l03266"></a>03266 <span class="comment">        ** page-list cache, if any, then fall back to the getOverflowPage()</span>
<a name="l03267"></a>03267 <span class="comment">        ** function.</span>
<a name="l03268"></a>03268 <span class="comment">        */</span>
<a name="l03269"></a>03269 <span class="preprocessor">#ifndef SQLITE_OMIT_INCRBLOB</span>
<a name="l03270"></a>03270 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a> &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a>[iIdx+1] ){
<a name="l03271"></a>03271           nextPage = pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a>[iIdx+1];
<a name="l03272"></a>03272         } <span class="keywordflow">else</span> 
<a name="l03273"></a>03273 <span class="preprocessor">#endif</span>
<a name="l03274"></a>03274 <span class="preprocessor"></span>          rc = <a class="code" href="btree_8c.html#af907f898e049d621e2c9dc1ed1d63cf4">getOverflowPage</a>(pBt, nextPage, 0, &amp;nextPage);
<a name="l03275"></a>03275         offset -= ovflSize;
<a name="l03276"></a>03276       }<span class="keywordflow">else</span>{
<a name="l03277"></a>03277         <span class="comment">/* Need to read this page properly. It contains some of the</span>
<a name="l03278"></a>03278 <span class="comment">        ** range of data that is being read (eOp==0) or written (eOp!=0).</span>
<a name="l03279"></a>03279 <span class="comment">        */</span>
<a name="l03280"></a>03280         <a class="code" href="structPgHdr.html">DbPage</a> *pDbPage;
<a name="l03281"></a>03281         <span class="keywordtype">int</span> a = amt;
<a name="l03282"></a>03282         rc = <a class="code" href="pager_8h.html#ac690af087310cf9d64d04d8559be402e">sqlite3PagerGet</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, nextPage, &amp;pDbPage);
<a name="l03283"></a>03283         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03284"></a>03284           aPayload = <a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pDbPage);
<a name="l03285"></a>03285           nextPage = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(aPayload);
<a name="l03286"></a>03286           <span class="keywordflow">if</span>( a + offset &gt; ovflSize ){
<a name="l03287"></a>03287             a = ovflSize - offset;
<a name="l03288"></a>03288           }
<a name="l03289"></a>03289           rc = <a class="code" href="btree_8c.html#aedb2ad4326779a68bc8e012570bda430">copyPayload</a>(&amp;aPayload[offset+4], pBuf, a, eOp, pDbPage);
<a name="l03290"></a>03290           <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pDbPage);
<a name="l03291"></a>03291           offset = 0;
<a name="l03292"></a>03292           amt -= a;
<a name="l03293"></a>03293           pBuf += a;
<a name="l03294"></a>03294         }
<a name="l03295"></a>03295       }
<a name="l03296"></a>03296     }
<a name="l03297"></a>03297   }
<a name="l03298"></a>03298 
<a name="l03299"></a>03299   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; amt&gt;0 ){
<a name="l03300"></a>03300     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l03301"></a>03301   }
<a name="l03302"></a>03302   <span class="keywordflow">return</span> rc;
<a name="l03303"></a>03303 }
<a name="l03304"></a>03304 
<a name="l03305"></a>03305 <span class="comment">/*</span>
<a name="l03306"></a>03306 <span class="comment">** Read part of the key associated with cursor pCur.  Exactly</span>
<a name="l03307"></a>03307 <span class="comment">** &quot;amt&quot; bytes will be transfered into pBuf[].  The transfer</span>
<a name="l03308"></a>03308 <span class="comment">** begins at &quot;offset&quot;.</span>
<a name="l03309"></a>03309 <span class="comment">**</span>
<a name="l03310"></a>03310 <span class="comment">** Return SQLITE_OK on success or an error code if anything goes</span>
<a name="l03311"></a>03311 <span class="comment">** wrong.  An error is returned if &quot;offset+amt&quot; is larger than</span>
<a name="l03312"></a>03312 <span class="comment">** the available payload.</span>
<a name="l03313"></a>03313 <span class="comment">*/</span>
<a name="l03314"></a><a class="code" href="btree_8h.html#a8aafdcf83d17118ad751be0777742ac9">03314</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aed214bf6f1ee501ac77d819ef9fe12ee">sqlite3BtreeKey</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> offset, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> amt, <span class="keywordtype">void</span> *pBuf){
<a name="l03315"></a>03315   <span class="keywordtype">int</span> rc;
<a name="l03316"></a>03316 
<a name="l03317"></a>03317   assert( cursorHoldsMutex(pCur) );
<a name="l03318"></a>03318   rc = <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCur);
<a name="l03319"></a>03319   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03320"></a>03320     assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03321"></a>03321     assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>&gt;=0 &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] );
<a name="l03322"></a>03322     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0]-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> ){
<a name="l03323"></a>03323       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l03324"></a>03324     }
<a name="l03325"></a>03325     assert( pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]&lt;pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> );
<a name="l03326"></a>03326     rc = <a class="code" href="btree_8c.html#a7a651412aed8c025c2be2433f731a9a9">accessPayload</a>(pCur, offset, amt, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)pBuf, 0, 0);
<a name="l03327"></a>03327   }
<a name="l03328"></a>03328   <span class="keywordflow">return</span> rc;
<a name="l03329"></a>03329 }
<a name="l03330"></a>03330 
<a name="l03331"></a>03331 <span class="comment">/*</span>
<a name="l03332"></a>03332 <span class="comment">** Read part of the data associated with cursor pCur.  Exactly</span>
<a name="l03333"></a>03333 <span class="comment">** &quot;amt&quot; bytes will be transfered into pBuf[].  The transfer</span>
<a name="l03334"></a>03334 <span class="comment">** begins at &quot;offset&quot;.</span>
<a name="l03335"></a>03335 <span class="comment">**</span>
<a name="l03336"></a>03336 <span class="comment">** Return SQLITE_OK on success or an error code if anything goes</span>
<a name="l03337"></a>03337 <span class="comment">** wrong.  An error is returned if &quot;offset+amt&quot; is larger than</span>
<a name="l03338"></a>03338 <span class="comment">** the available payload.</span>
<a name="l03339"></a>03339 <span class="comment">*/</span>
<a name="l03340"></a><a class="code" href="btree_8h.html#a59972ced1456046a9a7765ad9b18209b">03340</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a173bbb37f94d673235e12e2ae3ba8d41">sqlite3BtreeData</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> offset, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> amt, <span class="keywordtype">void</span> *pBuf){
<a name="l03341"></a>03341   <span class="keywordtype">int</span> rc;
<a name="l03342"></a>03342 
<a name="l03343"></a>03343 <span class="preprocessor">#ifndef SQLITE_OMIT_INCRBLOB</span>
<a name="l03344"></a>03344 <span class="preprocessor"></span>  <span class="keywordflow">if</span> ( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> ){
<a name="l03345"></a>03345     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab0c18279e950b695575a4667c7bb38b7">SQLITE_ABORT</a>;
<a name="l03346"></a>03346   }
<a name="l03347"></a>03347 <span class="preprocessor">#endif</span>
<a name="l03348"></a>03348 <span class="preprocessor"></span>
<a name="l03349"></a>03349   assert( cursorHoldsMutex(pCur) );
<a name="l03350"></a>03350   rc = <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCur);
<a name="l03351"></a>03351   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03352"></a>03352     assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03353"></a>03353     assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>&gt;=0 &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] );
<a name="l03354"></a>03354     assert( pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]&lt;pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> );
<a name="l03355"></a>03355     rc = <a class="code" href="btree_8c.html#a7a651412aed8c025c2be2433f731a9a9">accessPayload</a>(pCur, offset, amt, pBuf, 1, 0);
<a name="l03356"></a>03356   }
<a name="l03357"></a>03357   <span class="keywordflow">return</span> rc;
<a name="l03358"></a>03358 }
<a name="l03359"></a>03359 
<a name="l03360"></a>03360 <span class="comment">/*</span>
<a name="l03361"></a>03361 <span class="comment">** Return a pointer to payload information from the entry that the </span>
<a name="l03362"></a>03362 <span class="comment">** pCur cursor is pointing to.  The pointer is to the beginning of</span>
<a name="l03363"></a>03363 <span class="comment">** the key if skipKey==0 and it points to the beginning of data if</span>
<a name="l03364"></a>03364 <span class="comment">** skipKey==1.  The number of bytes of available key/data is written</span>
<a name="l03365"></a>03365 <span class="comment">** into *pAmt.  If *pAmt==0, then the value returned will not be</span>
<a name="l03366"></a>03366 <span class="comment">** a valid pointer.</span>
<a name="l03367"></a>03367 <span class="comment">**</span>
<a name="l03368"></a>03368 <span class="comment">** This routine is an optimization.  It is common for the entire key</span>
<a name="l03369"></a>03369 <span class="comment">** and data to fit on the local page and for there to be no overflow</span>
<a name="l03370"></a>03370 <span class="comment">** pages.  When that is so, this routine can be used to access the</span>
<a name="l03371"></a>03371 <span class="comment">** key and data without making a copy.  If the key and/or data spills</span>
<a name="l03372"></a>03372 <span class="comment">** onto overflow pages, then accessPayload() must be used to reassembly</span>
<a name="l03373"></a>03373 <span class="comment">** the key/data and copy it into a preallocated buffer.</span>
<a name="l03374"></a>03374 <span class="comment">**</span>
<a name="l03375"></a>03375 <span class="comment">** The pointer returned by this routine looks directly into the cached</span>
<a name="l03376"></a>03376 <span class="comment">** page of the database.  The data might change or move the next time</span>
<a name="l03377"></a>03377 <span class="comment">** any btree routine is called.</span>
<a name="l03378"></a>03378 <span class="comment">*/</span>
<a name="l03379"></a><a class="code" href="btree_8c.html#aff0623acff7dd97641bdd820289d5255">03379</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="btree_8c.html#aff0623acff7dd97641bdd820289d5255">fetchPayload</a>(
<a name="l03380"></a>03380   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur,      <span class="comment">/* Cursor pointing to entry to read from */</span>
<a name="l03381"></a>03381   <span class="keywordtype">int</span> *pAmt,           <span class="comment">/* Write the number of available bytes here */</span>
<a name="l03382"></a>03382   <span class="keywordtype">int</span> skipKey          <span class="comment">/* read beginning at data if this is true */</span>
<a name="l03383"></a>03383 ){
<a name="l03384"></a>03384   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *aPayload;
<a name="l03385"></a>03385   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l03386"></a>03386   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> nKey;
<a name="l03387"></a>03387   <span class="keywordtype">int</span> nLocal;
<a name="l03388"></a>03388 
<a name="l03389"></a>03389   assert( pCur!=0 &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>&gt;=0 &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]);
<a name="l03390"></a>03390   assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03391"></a>03391   assert( cursorHoldsMutex(pCur) );
<a name="l03392"></a>03392   pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l03393"></a>03393   assert( pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]&lt;pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> );
<a name="l03394"></a>03394   <a class="code" href="btree_8c.html#ada0c88a82b2b75cb13ee3c85ffcdf380">getCellInfo</a>(pCur);
<a name="l03395"></a>03395   aPayload = pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a595ed7eeb60ea274d868f24347b7238e">pCell</a>;
<a name="l03396"></a>03396   aPayload += pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a99bb1f87208f793359cf63e3d164025b">nHeader</a>;
<a name="l03397"></a>03397   <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> ){
<a name="l03398"></a>03398     nKey = 0;
<a name="l03399"></a>03399   }<span class="keywordflow">else</span>{
<a name="l03400"></a>03400     nKey = pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>;
<a name="l03401"></a>03401   }
<a name="l03402"></a>03402   <span class="keywordflow">if</span>( skipKey ){
<a name="l03403"></a>03403     aPayload += nKey;
<a name="l03404"></a>03404     nLocal = pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> - nKey;
<a name="l03405"></a>03405   }<span class="keywordflow">else</span>{
<a name="l03406"></a>03406     nLocal = pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a>;
<a name="l03407"></a>03407     <span class="keywordflow">if</span>( nLocal&gt;nKey ){
<a name="l03408"></a>03408       nLocal = nKey;
<a name="l03409"></a>03409     }
<a name="l03410"></a>03410   }
<a name="l03411"></a>03411   *pAmt = nLocal;
<a name="l03412"></a>03412   <span class="keywordflow">return</span> aPayload;
<a name="l03413"></a>03413 }
<a name="l03414"></a>03414 
<a name="l03415"></a>03415 
<a name="l03416"></a>03416 <span class="comment">/*</span>
<a name="l03417"></a>03417 <span class="comment">** For the entry that cursor pCur is point to, return as</span>
<a name="l03418"></a>03418 <span class="comment">** many bytes of the key or data as are available on the local</span>
<a name="l03419"></a>03419 <span class="comment">** b-tree page.  Write the number of available bytes into *pAmt.</span>
<a name="l03420"></a>03420 <span class="comment">**</span>
<a name="l03421"></a>03421 <span class="comment">** The pointer returned is ephemeral.  The key/data may move</span>
<a name="l03422"></a>03422 <span class="comment">** or be destroyed on the next call to any Btree routine,</span>
<a name="l03423"></a>03423 <span class="comment">** including calls from other threads against the same cache.</span>
<a name="l03424"></a>03424 <span class="comment">** Hence, a mutex on the BtShared should be held prior to calling</span>
<a name="l03425"></a>03425 <span class="comment">** this routine.</span>
<a name="l03426"></a>03426 <span class="comment">**</span>
<a name="l03427"></a>03427 <span class="comment">** These routines is used to get quick access to key and data</span>
<a name="l03428"></a>03428 <span class="comment">** in the common case where no overflow pages are used.</span>
<a name="l03429"></a>03429 <span class="comment">*/</span>
<a name="l03430"></a><a class="code" href="btree_8h.html#aac4d261158c8e6c6868e8ec77eacb982">03430</a> <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="btree_8c.html#a00fd4652b07c4c9b9e8f0b508bc506b9">sqlite3BtreeKeyFetch</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <span class="keywordtype">int</span> *pAmt){
<a name="l03431"></a>03431   assert( cursorHoldsMutex(pCur) );
<a name="l03432"></a>03432   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> ){
<a name="l03433"></a>03433     <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">void</span>*)<a class="code" href="btree_8c.html#aff0623acff7dd97641bdd820289d5255">fetchPayload</a>(pCur, pAmt, 0);
<a name="l03434"></a>03434   }
<a name="l03435"></a>03435   <span class="keywordflow">return</span> 0;
<a name="l03436"></a>03436 }
<a name="l03437"></a><a class="code" href="btree_8h.html#a93e8aecd5b4d5909a5bbf5443200f900">03437</a> <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="btree_8c.html#a151a21a039480e05578c458269d94f89">sqlite3BtreeDataFetch</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <span class="keywordtype">int</span> *pAmt){
<a name="l03438"></a>03438   assert( cursorHoldsMutex(pCur) );
<a name="l03439"></a>03439   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> ){
<a name="l03440"></a>03440     <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">void</span>*)<a class="code" href="btree_8c.html#aff0623acff7dd97641bdd820289d5255">fetchPayload</a>(pCur, pAmt, 1);
<a name="l03441"></a>03441   }
<a name="l03442"></a>03442   <span class="keywordflow">return</span> 0;
<a name="l03443"></a>03443 }
<a name="l03444"></a>03444 
<a name="l03445"></a>03445 
<a name="l03446"></a>03446 <span class="comment">/*</span>
<a name="l03447"></a>03447 <span class="comment">** Move the cursor down to a new child page.  The newPgno argument is the</span>
<a name="l03448"></a>03448 <span class="comment">** page number of the child page to move to.</span>
<a name="l03449"></a>03449 <span class="comment">*/</span>
<a name="l03450"></a><a class="code" href="btree_8c.html#a1dbea539dd841af085ba1e1390922237">03450</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a1dbea539dd841af085ba1e1390922237">moveToChild</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> newPgno){
<a name="l03451"></a>03451   <span class="keywordtype">int</span> rc;
<a name="l03452"></a>03452   <span class="keywordtype">int</span> i = pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>;
<a name="l03453"></a>03453   <a class="code" href="structMemPage.html">MemPage</a> *pNewPage;
<a name="l03454"></a>03454   <a class="code" href="structBtShared.html">BtShared</a> *pBt = pCur-&gt;<a class="code" href="structBtCursor.html#a61c245712549192f7644e5ac23c00b74">pBt</a>;
<a name="l03455"></a>03455 
<a name="l03456"></a>03456   assert( cursorHoldsMutex(pCur) );
<a name="l03457"></a>03457   assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03458"></a>03458   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>&lt;<a class="code" href="btreeInt_8h.html#af0a8a704218e75e8258f2e33c3505473">BTCURSOR_MAX_DEPTH</a> );
<a name="l03459"></a>03459   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>&gt;=(<a class="code" href="btreeInt_8h.html#af0a8a704218e75e8258f2e33c3505473">BTCURSOR_MAX_DEPTH</a>-1) ){
<a name="l03460"></a>03460     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l03461"></a>03461   }
<a name="l03462"></a>03462   rc = <a class="code" href="btree_8c.html#a443538c685fb93b3b41ee3497629698e">getAndInitPage</a>(pBt, newPgno, &amp;pNewPage);
<a name="l03463"></a>03463   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l03464"></a>03464   pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[i+1] = pNewPage;
<a name="l03465"></a>03465   pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[i+1] = 0;
<a name="l03466"></a>03466   pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>++;
<a name="l03467"></a>03467 
<a name="l03468"></a>03468   pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = 0;
<a name="l03469"></a>03469   pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 0;
<a name="l03470"></a>03470   <span class="keywordflow">if</span>( pNewPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>&lt;1 ){
<a name="l03471"></a>03471     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l03472"></a>03472   }
<a name="l03473"></a>03473   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03474"></a>03474 }
<a name="l03475"></a>03475 
<a name="l03476"></a>03476 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l03477"></a>03477 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l03478"></a>03478 <span class="comment">** Page pParent is an internal (non-leaf) tree page. This function </span>
<a name="l03479"></a>03479 <span class="comment">** asserts that page number iChild is the left-child if the iIdx&apos;th</span>
<a name="l03480"></a>03480 <span class="comment">** cell in page pParent. Or, if iIdx is equal to the total number of</span>
<a name="l03481"></a>03481 <span class="comment">** cells in pParent, that page number iChild is the right-child of</span>
<a name="l03482"></a>03482 <span class="comment">** the page.</span>
<a name="l03483"></a>03483 <span class="comment">*/</span>
<a name="l03484"></a>03484 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a7ebae49c2037298dc16979e82277ca0a">assertParentIndex</a>(<a class="code" href="structMemPage.html">MemPage</a> *pParent, <span class="keywordtype">int</span> iIdx, <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iChild){
<a name="l03485"></a>03485   assert( iIdx&lt;=pParent-&gt;nCell );
<a name="l03486"></a>03486   <span class="keywordflow">if</span>( iIdx==pParent-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> ){
<a name="l03487"></a>03487     assert( <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pParent-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pParent-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8])==iChild );
<a name="l03488"></a>03488   }<span class="keywordflow">else</span>{
<a name="l03489"></a>03489     assert( <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(<a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pParent, iIdx))==iChild );
<a name="l03490"></a>03490   }
<a name="l03491"></a>03491 }
<a name="l03492"></a>03492 <span class="preprocessor">#else</span>
<a name="l03493"></a><a class="code" href="btree_8c.html#a7ebae49c2037298dc16979e82277ca0a">03493</a> <span class="preprocessor"></span><span class="preprocessor">#  define assertParentIndex(x,y,z) </span>
<a name="l03494"></a>03494 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03495"></a>03495 <span class="preprocessor"></span>
<a name="l03496"></a>03496 <span class="comment">/*</span>
<a name="l03497"></a>03497 <span class="comment">** Move the cursor up to the parent page.</span>
<a name="l03498"></a>03498 <span class="comment">**</span>
<a name="l03499"></a>03499 <span class="comment">** pCur-&gt;idx is set to the cell index that contains the pointer</span>
<a name="l03500"></a>03500 <span class="comment">** to the page we are coming from.  If we are coming from the</span>
<a name="l03501"></a>03501 <span class="comment">** right-most child page then pCur-&gt;idx is set to one more than</span>
<a name="l03502"></a>03502 <span class="comment">** the largest cell index.</span>
<a name="l03503"></a>03503 <span class="comment">*/</span>
<a name="l03504"></a><a class="code" href="btreeInt_8h.html#a4f174cc02f227c14f098998ec6f011a8">03504</a> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a4f174cc02f227c14f098998ec6f011a8">sqlite3BtreeMoveToParent</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l03505"></a>03505   assert( cursorHoldsMutex(pCur) );
<a name="l03506"></a>03506   assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03507"></a>03507   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>&gt;0 );
<a name="l03508"></a>03508   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] );
<a name="l03509"></a>03509   <a class="code" href="btree_8c.html#a7ebae49c2037298dc16979e82277ca0a">assertParentIndex</a>(
<a name="l03510"></a>03510     pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>-1], 
<a name="l03511"></a>03511     pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>-1], 
<a name="l03512"></a>03512     pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>
<a name="l03513"></a>03513   );
<a name="l03514"></a>03514   <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]);
<a name="l03515"></a>03515   pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>--;
<a name="l03516"></a>03516   pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = 0;
<a name="l03517"></a>03517   pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 0;
<a name="l03518"></a>03518 }
<a name="l03519"></a>03519 
<a name="l03520"></a>03520 <span class="comment">/*</span>
<a name="l03521"></a>03521 <span class="comment">** Move the cursor to the root page</span>
<a name="l03522"></a>03522 <span class="comment">*/</span>
<a name="l03523"></a><a class="code" href="btree_8c.html#a2b8fb9bf88e10e7e4dedc8da64e7e956">03523</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a2b8fb9bf88e10e7e4dedc8da64e7e956">moveToRoot</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l03524"></a>03524   <a class="code" href="structMemPage.html">MemPage</a> *pRoot;
<a name="l03525"></a>03525   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03526"></a>03526   <a class="code" href="structBtree.html">Btree</a> *p = pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>;
<a name="l03527"></a>03527   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l03528"></a>03528 
<a name="l03529"></a>03529   assert( cursorHoldsMutex(pCur) );
<a name="l03530"></a>03530   assert( <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> &lt; <a class="code" href="btreeInt_8h.html#aa6b8c9600c6ffb4faf986e971f674800">CURSOR_REQUIRESEEK</a> );
<a name="l03531"></a>03531   assert( <a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a>   &lt; <a class="code" href="btreeInt_8h.html#aa6b8c9600c6ffb4faf986e971f674800">CURSOR_REQUIRESEEK</a> );
<a name="l03532"></a>03532   assert( <a class="code" href="btreeInt_8h.html#a3906ad079a2cc489d948fcbbe3035e42">CURSOR_FAULT</a>   &gt; <a class="code" href="btreeInt_8h.html#aa6b8c9600c6ffb4faf986e971f674800">CURSOR_REQUIRESEEK</a> );
<a name="l03533"></a>03533   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>&gt;=<a class="code" href="btreeInt_8h.html#aa6b8c9600c6ffb4faf986e971f674800">CURSOR_REQUIRESEEK</a> ){
<a name="l03534"></a>03534     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a3906ad079a2cc489d948fcbbe3035e42">CURSOR_FAULT</a> ){
<a name="l03535"></a>03535       <span class="keywordflow">return</span> pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a>;
<a name="l03536"></a>03536     }
<a name="l03537"></a>03537     <a class="code" href="btree_8c.html#a1b4b9b532ff7779a50f6482c723b3b50">sqlite3BtreeClearCursor</a>(pCur);
<a name="l03538"></a>03538   }
<a name="l03539"></a>03539 
<a name="l03540"></a>03540   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>&gt;=0 ){
<a name="l03541"></a>03541     <span class="keywordtype">int</span> i;
<a name="l03542"></a>03542     <span class="keywordflow">for</span>(i=1; i&lt;=pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>; i++){
<a name="l03543"></a>03543       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[i]);
<a name="l03544"></a>03544     }
<a name="l03545"></a>03545   }<span class="keywordflow">else</span>{
<a name="l03546"></a>03546     <span class="keywordflow">if</span>( 
<a name="l03547"></a>03547       <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=(rc = <a class="code" href="btree_8c.html#a443538c685fb93b3b41ee3497629698e">getAndInitPage</a>(pBt, pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, &amp;pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0]))
<a name="l03548"></a>03548     ){
<a name="l03549"></a>03549       pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>;
<a name="l03550"></a>03550       <span class="keywordflow">return</span> rc;
<a name="l03551"></a>03551     }
<a name="l03552"></a>03552   }
<a name="l03553"></a>03553 
<a name="l03554"></a>03554   pRoot = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0];
<a name="l03555"></a>03555   assert( pRoot-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>==pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a> );
<a name="l03556"></a>03556   pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a> = 0;
<a name="l03557"></a>03557   pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[0] = 0;
<a name="l03558"></a>03558   pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = 0;
<a name="l03559"></a>03559   pCur-&gt;<a class="code" href="structBtCursor.html#afff41eb594a5fc2c20b13232e6ff9689">atLast</a> = 0;
<a name="l03560"></a>03560   pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 0;
<a name="l03561"></a>03561 
<a name="l03562"></a>03562   <span class="keywordflow">if</span>( pRoot-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>==0 &amp;&amp; !pRoot-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l03563"></a>03563     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> subpage;
<a name="l03564"></a>03564     assert( pRoot-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>==1 );
<a name="l03565"></a>03565     subpage = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pRoot-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pRoot-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8]);
<a name="l03566"></a>03566     assert( subpage&gt;0 );
<a name="l03567"></a>03567     pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a>;
<a name="l03568"></a>03568     rc = <a class="code" href="btree_8c.html#a1dbea539dd841af085ba1e1390922237">moveToChild</a>(pCur, subpage);
<a name="l03569"></a>03569   }<span class="keywordflow">else</span>{
<a name="l03570"></a>03570     pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = ((pRoot-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>&gt;0)?<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a>:<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>);
<a name="l03571"></a>03571   }
<a name="l03572"></a>03572   <span class="keywordflow">return</span> rc;
<a name="l03573"></a>03573 }
<a name="l03574"></a>03574 
<a name="l03575"></a>03575 <span class="comment">/*</span>
<a name="l03576"></a>03576 <span class="comment">** Move the cursor down to the left-most leaf entry beneath the</span>
<a name="l03577"></a>03577 <span class="comment">** entry to which it is currently pointing.</span>
<a name="l03578"></a>03578 <span class="comment">**</span>
<a name="l03579"></a>03579 <span class="comment">** The left-most leaf is the one with the smallest key - the first</span>
<a name="l03580"></a>03580 <span class="comment">** in ascending order.</span>
<a name="l03581"></a>03581 <span class="comment">*/</span>
<a name="l03582"></a><a class="code" href="btree_8c.html#ae612f0a49a92eb71d75f018bd3c55400">03582</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ae612f0a49a92eb71d75f018bd3c55400">moveToLeftmost</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l03583"></a>03583   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgno;
<a name="l03584"></a>03584   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03585"></a>03585   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l03586"></a>03586 
<a name="l03587"></a>03587   assert( cursorHoldsMutex(pCur) );
<a name="l03588"></a>03588   assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03589"></a>03589   <span class="keywordflow">while</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; !(pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>])-&gt;leaf ){
<a name="l03590"></a>03590     assert( pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]&lt;pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> );
<a name="l03591"></a>03591     pgno = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(<a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]));
<a name="l03592"></a>03592     rc = <a class="code" href="btree_8c.html#a1dbea539dd841af085ba1e1390922237">moveToChild</a>(pCur, pgno);
<a name="l03593"></a>03593   }
<a name="l03594"></a>03594   <span class="keywordflow">return</span> rc;
<a name="l03595"></a>03595 }
<a name="l03596"></a>03596 
<a name="l03597"></a>03597 <span class="comment">/*</span>
<a name="l03598"></a>03598 <span class="comment">** Move the cursor down to the right-most leaf entry beneath the</span>
<a name="l03599"></a>03599 <span class="comment">** page to which it is currently pointing.  Notice the difference</span>
<a name="l03600"></a>03600 <span class="comment">** between moveToLeftmost() and moveToRightmost().  moveToLeftmost()</span>
<a name="l03601"></a>03601 <span class="comment">** finds the left-most entry beneath the *entry* whereas moveToRightmost()</span>
<a name="l03602"></a>03602 <span class="comment">** finds the right-most entry beneath the *page*.</span>
<a name="l03603"></a>03603 <span class="comment">**</span>
<a name="l03604"></a>03604 <span class="comment">** The right-most entry is the one with the largest key - the last</span>
<a name="l03605"></a>03605 <span class="comment">** key in ascending order.</span>
<a name="l03606"></a>03606 <span class="comment">*/</span>
<a name="l03607"></a><a class="code" href="btree_8c.html#a0f818654466695149ef54b1cdc16887d">03607</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a0f818654466695149ef54b1cdc16887d">moveToRightmost</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l03608"></a>03608   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgno;
<a name="l03609"></a>03609   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03610"></a>03610   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l03611"></a>03611 
<a name="l03612"></a>03612   assert( cursorHoldsMutex(pCur) );
<a name="l03613"></a>03613   assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03614"></a>03614   <span class="keywordflow">while</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; !(pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>])-&gt;leaf ){
<a name="l03615"></a>03615     pgno = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8]);
<a name="l03616"></a>03616     pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] = pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>;
<a name="l03617"></a>03617     rc = <a class="code" href="btree_8c.html#a1dbea539dd841af085ba1e1390922237">moveToChild</a>(pCur, pgno);
<a name="l03618"></a>03618   }
<a name="l03619"></a>03619   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03620"></a>03620     pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] = pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>-1;
<a name="l03621"></a>03621     pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = 0;
<a name="l03622"></a>03622     pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 0;
<a name="l03623"></a>03623   }
<a name="l03624"></a>03624   <span class="keywordflow">return</span> rc;
<a name="l03625"></a>03625 }
<a name="l03626"></a>03626 
<a name="l03627"></a>03627 <span class="comment">/* Move the cursor to the first entry in the table.  Return SQLITE_OK</span>
<a name="l03628"></a>03628 <span class="comment">** on success.  Set *pRes to 0 if the cursor actually points to something</span>
<a name="l03629"></a>03629 <span class="comment">** or set *pRes to 1 if the table is empty.</span>
<a name="l03630"></a>03630 <span class="comment">*/</span>
<a name="l03631"></a><a class="code" href="btree_8h.html#a837056df68f45170549abf4a92718f58">03631</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a035892f63f56d5ac4ebe289d51cb0b9a">sqlite3BtreeFirst</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <span class="keywordtype">int</span> *pRes){
<a name="l03632"></a>03632   <span class="keywordtype">int</span> rc;
<a name="l03633"></a>03633 
<a name="l03634"></a>03634   assert( cursorHoldsMutex(pCur) );
<a name="l03635"></a>03635   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l03636"></a>03636   rc = <a class="code" href="btree_8c.html#a2b8fb9bf88e10e7e4dedc8da64e7e956">moveToRoot</a>(pCur);
<a name="l03637"></a>03637   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03638"></a>03638     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> ){
<a name="l03639"></a>03639       assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>==0 );
<a name="l03640"></a>03640       *pRes = 1;
<a name="l03641"></a>03641       rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03642"></a>03642     }<span class="keywordflow">else</span>{
<a name="l03643"></a>03643       assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>&gt;0 );
<a name="l03644"></a>03644       *pRes = 0;
<a name="l03645"></a>03645       rc = <a class="code" href="btree_8c.html#ae612f0a49a92eb71d75f018bd3c55400">moveToLeftmost</a>(pCur);
<a name="l03646"></a>03646     }
<a name="l03647"></a>03647   }
<a name="l03648"></a>03648   <span class="keywordflow">return</span> rc;
<a name="l03649"></a>03649 }
<a name="l03650"></a>03650 
<a name="l03651"></a>03651 <span class="comment">/* Move the cursor to the last entry in the table.  Return SQLITE_OK</span>
<a name="l03652"></a>03652 <span class="comment">** on success.  Set *pRes to 0 if the cursor actually points to something</span>
<a name="l03653"></a>03653 <span class="comment">** or set *pRes to 1 if the table is empty.</span>
<a name="l03654"></a>03654 <span class="comment">*/</span>
<a name="l03655"></a><a class="code" href="btree_8h.html#ace740999fecd8dd86bd1424a9ed4b005">03655</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#af4c43ac2d9ebc3f08a8fc2bbb181787b">sqlite3BtreeLast</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <span class="keywordtype">int</span> *pRes){
<a name="l03656"></a>03656   <span class="keywordtype">int</span> rc;
<a name="l03657"></a>03657  
<a name="l03658"></a>03658   assert( cursorHoldsMutex(pCur) );
<a name="l03659"></a>03659   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l03660"></a>03660   rc = <a class="code" href="btree_8c.html#a2b8fb9bf88e10e7e4dedc8da64e7e956">moveToRoot</a>(pCur);
<a name="l03661"></a>03661   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03662"></a>03662     <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>==pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> ){
<a name="l03663"></a>03663       assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>==0 );
<a name="l03664"></a>03664       *pRes = 1;
<a name="l03665"></a>03665     }<span class="keywordflow">else</span>{
<a name="l03666"></a>03666       assert( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> );
<a name="l03667"></a>03667       *pRes = 0;
<a name="l03668"></a>03668       rc = <a class="code" href="btree_8c.html#a0f818654466695149ef54b1cdc16887d">moveToRightmost</a>(pCur);
<a name="l03669"></a>03669       <a class="code" href="btree_8c.html#ada0c88a82b2b75cb13ee3c85ffcdf380">getCellInfo</a>(pCur);
<a name="l03670"></a>03670       pCur-&gt;<a class="code" href="structBtCursor.html#afff41eb594a5fc2c20b13232e6ff9689">atLast</a> = rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03671"></a>03671     }
<a name="l03672"></a>03672   }
<a name="l03673"></a>03673   <span class="keywordflow">return</span> rc;
<a name="l03674"></a>03674 }
<a name="l03675"></a>03675 
<a name="l03676"></a>03676 <span class="comment">/* Move the cursor so that it points to an entry near the key </span>
<a name="l03677"></a>03677 <span class="comment">** specified by pIdxKey or intKey.   Return a success code.</span>
<a name="l03678"></a>03678 <span class="comment">**</span>
<a name="l03679"></a>03679 <span class="comment">** For INTKEY tables, the intKey parameter is used.  pIdxKey </span>
<a name="l03680"></a>03680 <span class="comment">** must be NULL.  For index tables, pIdxKey is used and intKey</span>
<a name="l03681"></a>03681 <span class="comment">** is ignored.</span>
<a name="l03682"></a>03682 <span class="comment">**</span>
<a name="l03683"></a>03683 <span class="comment">** If an exact match is not found, then the cursor is always</span>
<a name="l03684"></a>03684 <span class="comment">** left pointing at a leaf page which would hold the entry if it</span>
<a name="l03685"></a>03685 <span class="comment">** were present.  The cursor might point to an entry that comes</span>
<a name="l03686"></a>03686 <span class="comment">** before or after the key.</span>
<a name="l03687"></a>03687 <span class="comment">**</span>
<a name="l03688"></a>03688 <span class="comment">** The result of comparing the key with the entry to which the</span>
<a name="l03689"></a>03689 <span class="comment">** cursor is written to *pRes if pRes!=NULL.  The meaning of</span>
<a name="l03690"></a>03690 <span class="comment">** this value is as follows:</span>
<a name="l03691"></a>03691 <span class="comment">**</span>
<a name="l03692"></a>03692 <span class="comment">**     *pRes&lt;0      The cursor is left pointing at an entry that</span>
<a name="l03693"></a>03693 <span class="comment">**                  is smaller than pKey or if the table is empty</span>
<a name="l03694"></a>03694 <span class="comment">**                  and the cursor is therefore left point to nothing.</span>
<a name="l03695"></a>03695 <span class="comment">**</span>
<a name="l03696"></a>03696 <span class="comment">**     *pRes==0     The cursor is left pointing at an entry that</span>
<a name="l03697"></a>03697 <span class="comment">**                  exactly matches pKey.</span>
<a name="l03698"></a>03698 <span class="comment">**</span>
<a name="l03699"></a>03699 <span class="comment">**     *pRes&gt;0      The cursor is left pointing at an entry that</span>
<a name="l03700"></a>03700 <span class="comment">**                  is larger than pKey.</span>
<a name="l03701"></a>03701 <span class="comment">**</span>
<a name="l03702"></a>03702 <span class="comment">*/</span>
<a name="l03703"></a><a class="code" href="btree_8h.html#aa634a59445ea129e7476d5e4fbdf5bc4">03703</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(
<a name="l03704"></a>03704   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur,          <span class="comment">/* The cursor to be moved */</span>
<a name="l03705"></a>03705   <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *pIdxKey, <span class="comment">/* Unpacked index key */</span>
<a name="l03706"></a>03706   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> intKey,              <span class="comment">/* The table key */</span>
<a name="l03707"></a>03707   <span class="keywordtype">int</span> biasRight,           <span class="comment">/* If true, bias the search to the high end */</span>
<a name="l03708"></a>03708   <span class="keywordtype">int</span> *pRes                <span class="comment">/* Write search results here */</span>
<a name="l03709"></a>03709 ){
<a name="l03710"></a>03710   <span class="keywordtype">int</span> rc;
<a name="l03711"></a>03711 
<a name="l03712"></a>03712   assert( cursorHoldsMutex(pCur) );
<a name="l03713"></a>03713   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l03714"></a>03714 
<a name="l03715"></a>03715   <span class="comment">/* If the cursor is already positioned at the point we are trying</span>
<a name="l03716"></a>03716 <span class="comment">  ** to move to, then just return without doing any work */</span>
<a name="l03717"></a>03717   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> 
<a name="l03718"></a>03718    &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0]-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> 
<a name="l03719"></a>03719   ){
<a name="l03720"></a>03720     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>==intKey ){
<a name="l03721"></a>03721       *pRes = 0;
<a name="l03722"></a>03722       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03723"></a>03723     }
<a name="l03724"></a>03724     <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#afff41eb594a5fc2c20b13232e6ff9689">atLast</a> &amp;&amp; pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>&lt;intKey ){
<a name="l03725"></a>03725       *pRes = -1;
<a name="l03726"></a>03726       <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03727"></a>03727     }
<a name="l03728"></a>03728   }
<a name="l03729"></a>03729 
<a name="l03730"></a>03730   rc = <a class="code" href="btree_8c.html#a2b8fb9bf88e10e7e4dedc8da64e7e956">moveToRoot</a>(pCur);
<a name="l03731"></a>03731   <span class="keywordflow">if</span>( rc ){
<a name="l03732"></a>03732     <span class="keywordflow">return</span> rc;
<a name="l03733"></a>03733   }
<a name="l03734"></a>03734   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] );
<a name="l03735"></a>03735   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> );
<a name="l03736"></a>03736   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> ){
<a name="l03737"></a>03737     *pRes = -1;
<a name="l03738"></a>03738     assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>==0 );
<a name="l03739"></a>03739     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03740"></a>03740   }
<a name="l03741"></a>03741   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0]-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> || pIdxKey );
<a name="l03742"></a>03742   <span class="keywordflow">for</span>(;;){
<a name="l03743"></a>03743     <span class="keywordtype">int</span> lwr, upr;
<a name="l03744"></a>03744     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> chldPg;
<a name="l03745"></a>03745     <a class="code" href="structMemPage.html">MemPage</a> *pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l03746"></a>03746     <span class="keywordtype">int</span> c = -1;  <span class="comment">/* pRes return if table is empty must be -1 */</span>
<a name="l03747"></a>03747     lwr = 0;
<a name="l03748"></a>03748     upr = pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>-1;
<a name="l03749"></a>03749     <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> &amp;&amp; pIdxKey==0 ){
<a name="l03750"></a>03750       rc = <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l03751"></a>03751       <span class="keywordflow">goto</span> moveto_finish;
<a name="l03752"></a>03752     }
<a name="l03753"></a>03753     <span class="keywordflow">if</span>( biasRight ){
<a name="l03754"></a>03754       pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] = upr;
<a name="l03755"></a>03755     }<span class="keywordflow">else</span>{
<a name="l03756"></a>03756       pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] = (upr+lwr)/2;
<a name="l03757"></a>03757     }
<a name="l03758"></a>03758     <span class="keywordflow">if</span>( lwr&lt;=upr ) <span class="keywordflow">for</span>(;;){
<a name="l03759"></a>03759       <span class="keywordtype">void</span> *pCellKey;
<a name="l03760"></a>03760       <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> nCellKey;
<a name="l03761"></a>03761       <span class="keywordtype">int</span> idx = pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l03762"></a>03762       pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = 0;
<a name="l03763"></a>03763       pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 1;
<a name="l03764"></a>03764       <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> ){
<a name="l03765"></a>03765         <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell;
<a name="l03766"></a>03766         pCell = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, idx) + pPage-&gt;<a class="code" href="structMemPage.html#aeba10281fc255d9bbc0e31486f8fbd48">childPtrSize</a>;
<a name="l03767"></a>03767         <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#af7b608d25c2e326f82cc270cd53dd8f8">hasData</a> ){
<a name="l03768"></a>03768           <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> dummy;
<a name="l03769"></a>03769           pCell += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(pCell, dummy);
<a name="l03770"></a>03770         }
<a name="l03771"></a>03771         <a class="code" href="sqliteInt_8h.html#a2abb01bd1a223b05224c0c799b07d422">getVarint</a>(pCell, (<a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a>*)&amp;nCellKey);
<a name="l03772"></a>03772         <span class="keywordflow">if</span>( nCellKey==intKey ){
<a name="l03773"></a>03773           c = 0;
<a name="l03774"></a>03774         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( nCellKey&lt;intKey ){
<a name="l03775"></a>03775           c = -1;
<a name="l03776"></a>03776         }<span class="keywordflow">else</span>{
<a name="l03777"></a>03777           assert( nCellKey&gt;intKey );
<a name="l03778"></a>03778           c = +1;
<a name="l03779"></a>03779         }
<a name="l03780"></a>03780       }<span class="keywordflow">else</span>{
<a name="l03781"></a>03781         <span class="keywordtype">int</span> available;
<a name="l03782"></a>03782         pCellKey = (<span class="keywordtype">void</span> *)<a class="code" href="btree_8c.html#aff0623acff7dd97641bdd820289d5255">fetchPayload</a>(pCur, &amp;available, 0);
<a name="l03783"></a>03783         nCellKey = pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>;
<a name="l03784"></a>03784         <span class="keywordflow">if</span>( available&gt;=nCellKey ){
<a name="l03785"></a>03785           c = <a class="code" href="vdbe_8h.html#ad4cc2261adcd9523c071abf47847dafa">sqlite3VdbeRecordCompare</a>(nCellKey, pCellKey, pIdxKey);
<a name="l03786"></a>03786         }<span class="keywordflow">else</span>{
<a name="l03787"></a>03787           pCellKey = <a class="code" href="malloc_8c.html#a8c1a33577a57524c7c6eef3d9e64e742">sqlite3Malloc</a>( nCellKey );
<a name="l03788"></a>03788           <span class="keywordflow">if</span>( pCellKey==0 ){
<a name="l03789"></a>03789             rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l03790"></a>03790             <span class="keywordflow">goto</span> moveto_finish;
<a name="l03791"></a>03791           }
<a name="l03792"></a>03792           rc = <a class="code" href="btree_8c.html#aed214bf6f1ee501ac77d819ef9fe12ee">sqlite3BtreeKey</a>(pCur, 0, nCellKey, (<span class="keywordtype">void</span> *)pCellKey);
<a name="l03793"></a>03793           c = <a class="code" href="vdbe_8h.html#ad4cc2261adcd9523c071abf47847dafa">sqlite3VdbeRecordCompare</a>(nCellKey, pCellKey, pIdxKey);
<a name="l03794"></a>03794           <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pCellKey);
<a name="l03795"></a>03795           <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> moveto_finish;
<a name="l03796"></a>03796         }
<a name="l03797"></a>03797       }
<a name="l03798"></a>03798       <span class="keywordflow">if</span>( c==0 ){
<a name="l03799"></a>03799         pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a> = nCellKey;
<a name="l03800"></a>03800         <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> &amp;&amp; !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l03801"></a>03801           lwr = idx;
<a name="l03802"></a>03802           upr = lwr - 1;
<a name="l03803"></a>03803           <span class="keywordflow">break</span>;
<a name="l03804"></a>03804         }<span class="keywordflow">else</span>{
<a name="l03805"></a>03805           <span class="keywordflow">if</span>( pRes ) *pRes = 0;
<a name="l03806"></a>03806           rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03807"></a>03807           <span class="keywordflow">goto</span> moveto_finish;
<a name="l03808"></a>03808         }
<a name="l03809"></a>03809       }
<a name="l03810"></a>03810       <span class="keywordflow">if</span>( c&lt;0 ){
<a name="l03811"></a>03811         lwr = idx+1;
<a name="l03812"></a>03812       }<span class="keywordflow">else</span>{
<a name="l03813"></a>03813         upr = idx-1;
<a name="l03814"></a>03814       }
<a name="l03815"></a>03815       <span class="keywordflow">if</span>( lwr&gt;upr ){
<a name="l03816"></a>03816         pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a> = nCellKey;
<a name="l03817"></a>03817         <span class="keywordflow">break</span>;
<a name="l03818"></a>03818       }
<a name="l03819"></a>03819       pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] = (lwr+upr)/2;
<a name="l03820"></a>03820     }
<a name="l03821"></a>03821     assert( lwr==upr+1 );
<a name="l03822"></a>03822     assert( pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> );
<a name="l03823"></a>03823     <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l03824"></a>03824       chldPg = 0;
<a name="l03825"></a>03825     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( lwr&gt;=pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> ){
<a name="l03826"></a>03826       chldPg = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8]);
<a name="l03827"></a>03827     }<span class="keywordflow">else</span>{
<a name="l03828"></a>03828       chldPg = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(<a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, lwr));
<a name="l03829"></a>03829     }
<a name="l03830"></a>03830     <span class="keywordflow">if</span>( chldPg==0 ){
<a name="l03831"></a>03831       assert( pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]&lt;pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> );
<a name="l03832"></a>03832       <span class="keywordflow">if</span>( pRes ) *pRes = c;
<a name="l03833"></a>03833       rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03834"></a>03834       <span class="keywordflow">goto</span> moveto_finish;
<a name="l03835"></a>03835     }
<a name="l03836"></a>03836     pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>] = lwr;
<a name="l03837"></a>03837     pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = 0;
<a name="l03838"></a>03838     pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 0;
<a name="l03839"></a>03839     rc = <a class="code" href="btree_8c.html#a1dbea539dd841af085ba1e1390922237">moveToChild</a>(pCur, chldPg);
<a name="l03840"></a>03840     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> moveto_finish;
<a name="l03841"></a>03841   }
<a name="l03842"></a>03842 moveto_finish:
<a name="l03843"></a>03843   <span class="keywordflow">return</span> rc;
<a name="l03844"></a>03844 }
<a name="l03845"></a>03845 
<a name="l03846"></a>03846 <span class="comment">/*</span>
<a name="l03847"></a>03847 <span class="comment">** In this version of BtreeMoveto, pKey is a packed index record</span>
<a name="l03848"></a>03848 <span class="comment">** such as is generated by the OP_MakeRecord opcode.  Unpack the</span>
<a name="l03849"></a>03849 <span class="comment">** record and then call BtreeMovetoUnpacked() to do the work.</span>
<a name="l03850"></a>03850 <span class="comment">*/</span>
<a name="l03851"></a><a class="code" href="btree_8h.html#a499ef4becb8cb7c6b5aa8fff5b4edb6e">03851</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a0ae0770006edd874a30bcbbe303ee31d">sqlite3BtreeMoveto</a>(
<a name="l03852"></a>03852   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur,     <span class="comment">/* Cursor open on the btree to be searched */</span>
<a name="l03853"></a>03853   <span class="keyword">const</span> <span class="keywordtype">void</span> *pKey,   <span class="comment">/* Packed key if the btree is an index */</span>
<a name="l03854"></a>03854   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> nKey,           <span class="comment">/* Integer key for tables.  Size of pKey for indices */</span>
<a name="l03855"></a>03855   <span class="keywordtype">int</span> bias,           <span class="comment">/* Bias search to the high end */</span>
<a name="l03856"></a>03856   <span class="keywordtype">int</span> *pRes           <span class="comment">/* Write search results here */</span>
<a name="l03857"></a>03857 ){
<a name="l03858"></a>03858   <span class="keywordtype">int</span> rc;                    <span class="comment">/* Status code */</span>
<a name="l03859"></a>03859   <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *pIdxKey;   <span class="comment">/* Unpacked index key */</span>
<a name="l03860"></a>03860   <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> aSpace[16]; <span class="comment">/* Temp space for pIdxKey - to avoid a malloc */</span>
<a name="l03861"></a>03861 
<a name="l03862"></a>03862   <span class="keywordflow">if</span>( pKey ){
<a name="l03863"></a>03863     pIdxKey = <a class="code" href="vdbe_8h.html#a3b886b85d57a0b60bc5be0478f55e8d9">sqlite3VdbeRecordUnpack</a>(pCur-&gt;<a class="code" href="structBtCursor.html#ad2360bda13f959ed70672eb421fdb5ec">pKeyInfo</a>, nKey, pKey,
<a name="l03864"></a>03864                                       aSpace, <span class="keyword">sizeof</span>(aSpace));
<a name="l03865"></a>03865     <span class="keywordflow">if</span>( pIdxKey==0 ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l03866"></a>03866   }<span class="keywordflow">else</span>{
<a name="l03867"></a>03867     pIdxKey = 0;
<a name="l03868"></a>03868   }
<a name="l03869"></a>03869   rc = <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(pCur, pIdxKey, nKey, bias, pRes);
<a name="l03870"></a>03870   <span class="keywordflow">if</span>( pKey ){
<a name="l03871"></a>03871     <a class="code" href="vdbe_8h.html#a92e9ed579bf09eeeb3b4006f669753a0">sqlite3VdbeDeleteUnpackedRecord</a>(pIdxKey);
<a name="l03872"></a>03872   }
<a name="l03873"></a>03873   <span class="keywordflow">return</span> rc;
<a name="l03874"></a>03874 }
<a name="l03875"></a>03875 
<a name="l03876"></a>03876 
<a name="l03877"></a>03877 <span class="comment">/*</span>
<a name="l03878"></a>03878 <span class="comment">** Return TRUE if the cursor is not pointing at an entry of the table.</span>
<a name="l03879"></a>03879 <span class="comment">**</span>
<a name="l03880"></a>03880 <span class="comment">** TRUE will be returned after a call to sqlite3BtreeNext() moves</span>
<a name="l03881"></a>03881 <span class="comment">** past the last entry in the table or sqlite3BtreePrev() moves past</span>
<a name="l03882"></a>03882 <span class="comment">** the first entry.  TRUE is also returned if the table is empty.</span>
<a name="l03883"></a>03883 <span class="comment">*/</span>
<a name="l03884"></a><a class="code" href="btree_8h.html#a1c6a47fb7367107f789e758ed7bf1e5c">03884</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a1f64c2a112c9356bbfc401cd85b797e7">sqlite3BtreeEof</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l03885"></a>03885   <span class="comment">/* TODO: What if the cursor is in CURSOR_REQUIRESEEK but all table entries</span>
<a name="l03886"></a>03886 <span class="comment">  ** have been deleted? This API will need to change to return an error code</span>
<a name="l03887"></a>03887 <span class="comment">  ** as well as the boolean result value.</span>
<a name="l03888"></a>03888 <span class="comment">  */</span>
<a name="l03889"></a>03889   <span class="keywordflow">return</span> (<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a>!=pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>);
<a name="l03890"></a>03890 }
<a name="l03891"></a>03891 
<a name="l03892"></a>03892 <span class="comment">/*</span>
<a name="l03893"></a>03893 <span class="comment">** Return the database connection handle for a cursor.</span>
<a name="l03894"></a>03894 <span class="comment">*/</span>
<a name="l03895"></a><a class="code" href="btree_8h.html#a1cbc97a36a1834c14c756fe18d175919">03895</a> <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="btree_8c.html#aa28173f5b5884dbae8e4ef0ea06dc62f">sqlite3BtreeCursorDb</a>(<span class="keyword">const</span> <a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l03896"></a>03896   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l03897"></a>03897   <span class="keywordflow">return</span> pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l03898"></a>03898 }
<a name="l03899"></a>03899 
<a name="l03900"></a>03900 <span class="comment">/*</span>
<a name="l03901"></a>03901 <span class="comment">** Advance the cursor to the next entry in the database.  If</span>
<a name="l03902"></a>03902 <span class="comment">** successful then set *pRes=0.  If the cursor</span>
<a name="l03903"></a>03903 <span class="comment">** was already pointing to the last entry in the database before</span>
<a name="l03904"></a>03904 <span class="comment">** this routine was called, then set *pRes=1.</span>
<a name="l03905"></a>03905 <span class="comment">*/</span>
<a name="l03906"></a><a class="code" href="btree_8h.html#a907c51cfb227ce9a726735ae9a70eb3a">03906</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#adf99ca89adc2e91557a41d6d11e97039">sqlite3BtreeNext</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <span class="keywordtype">int</span> *pRes){
<a name="l03907"></a>03907   <span class="keywordtype">int</span> rc;
<a name="l03908"></a>03908   <span class="keywordtype">int</span> idx;
<a name="l03909"></a>03909   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l03910"></a>03910 
<a name="l03911"></a>03911   assert( cursorHoldsMutex(pCur) );
<a name="l03912"></a>03912   rc = <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCur);
<a name="l03913"></a>03913   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03914"></a>03914     <span class="keywordflow">return</span> rc;
<a name="l03915"></a>03915   }
<a name="l03916"></a>03916   assert( pRes!=0 );
<a name="l03917"></a>03917   <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>==pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> ){
<a name="l03918"></a>03918     *pRes = 1;
<a name="l03919"></a>03919     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03920"></a>03920   }
<a name="l03921"></a>03921   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a>&gt;0 ){
<a name="l03922"></a>03922     pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a> = 0;
<a name="l03923"></a>03923     *pRes = 0;
<a name="l03924"></a>03924     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03925"></a>03925   }
<a name="l03926"></a>03926   pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a> = 0;
<a name="l03927"></a>03927 
<a name="l03928"></a>03928   pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l03929"></a>03929   idx = ++pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l03930"></a>03930   assert( pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> );
<a name="l03931"></a>03931   assert( idx&lt;=pPage-&gt;nCell );
<a name="l03932"></a>03932 
<a name="l03933"></a>03933   pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = 0;
<a name="l03934"></a>03934   pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 0;
<a name="l03935"></a>03935   <span class="keywordflow">if</span>( idx&gt;=pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> ){
<a name="l03936"></a>03936     <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l03937"></a>03937       rc = <a class="code" href="btree_8c.html#a1dbea539dd841af085ba1e1390922237">moveToChild</a>(pCur, <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8]));
<a name="l03938"></a>03938       <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l03939"></a>03939       rc = <a class="code" href="btree_8c.html#ae612f0a49a92eb71d75f018bd3c55400">moveToLeftmost</a>(pCur);
<a name="l03940"></a>03940       *pRes = 0;
<a name="l03941"></a>03941       <span class="keywordflow">return</span> rc;
<a name="l03942"></a>03942     }
<a name="l03943"></a>03943     <span class="keywordflow">do</span>{
<a name="l03944"></a>03944       <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>==0 ){
<a name="l03945"></a>03945         *pRes = 1;
<a name="l03946"></a>03946         pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>;
<a name="l03947"></a>03947         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03948"></a>03948       }
<a name="l03949"></a>03949       <a class="code" href="btree_8c.html#a4f174cc02f227c14f098998ec6f011a8">sqlite3BtreeMoveToParent</a>(pCur);
<a name="l03950"></a>03950       pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l03951"></a>03951     }<span class="keywordflow">while</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]&gt;=pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> );
<a name="l03952"></a>03952     *pRes = 0;
<a name="l03953"></a>03953     <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> ){
<a name="l03954"></a>03954       rc = <a class="code" href="btree_8c.html#adf99ca89adc2e91557a41d6d11e97039">sqlite3BtreeNext</a>(pCur, pRes);
<a name="l03955"></a>03955     }<span class="keywordflow">else</span>{
<a name="l03956"></a>03956       rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03957"></a>03957     }
<a name="l03958"></a>03958     <span class="keywordflow">return</span> rc;
<a name="l03959"></a>03959   }
<a name="l03960"></a>03960   *pRes = 0;
<a name="l03961"></a>03961   <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l03962"></a>03962     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03963"></a>03963   }
<a name="l03964"></a>03964   rc = <a class="code" href="btree_8c.html#ae612f0a49a92eb71d75f018bd3c55400">moveToLeftmost</a>(pCur);
<a name="l03965"></a>03965   <span class="keywordflow">return</span> rc;
<a name="l03966"></a>03966 }
<a name="l03967"></a>03967 
<a name="l03968"></a>03968 
<a name="l03969"></a>03969 <span class="comment">/*</span>
<a name="l03970"></a>03970 <span class="comment">** Step the cursor to the back to the previous entry in the database.  If</span>
<a name="l03971"></a>03971 <span class="comment">** successful then set *pRes=0.  If the cursor</span>
<a name="l03972"></a>03972 <span class="comment">** was already pointing to the first entry in the database before</span>
<a name="l03973"></a>03973 <span class="comment">** this routine was called, then set *pRes=1.</span>
<a name="l03974"></a>03974 <span class="comment">*/</span>
<a name="l03975"></a><a class="code" href="btree_8h.html#a7674ac4eae8ad34b348c577965f30a93">03975</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#af84d1157958331e8d900f0800409f60b">sqlite3BtreePrevious</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <span class="keywordtype">int</span> *pRes){
<a name="l03976"></a>03976   <span class="keywordtype">int</span> rc;
<a name="l03977"></a>03977   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l03978"></a>03978 
<a name="l03979"></a>03979   assert( cursorHoldsMutex(pCur) );
<a name="l03980"></a>03980   rc = <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCur);
<a name="l03981"></a>03981   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03982"></a>03982     <span class="keywordflow">return</span> rc;
<a name="l03983"></a>03983   }
<a name="l03984"></a>03984   pCur-&gt;<a class="code" href="structBtCursor.html#afff41eb594a5fc2c20b13232e6ff9689">atLast</a> = 0;
<a name="l03985"></a>03985   <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>==pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> ){
<a name="l03986"></a>03986     *pRes = 1;
<a name="l03987"></a>03987     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03988"></a>03988   }
<a name="l03989"></a>03989   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a>&lt;0 ){
<a name="l03990"></a>03990     pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a> = 0;
<a name="l03991"></a>03991     *pRes = 0;
<a name="l03992"></a>03992     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l03993"></a>03993   }
<a name="l03994"></a>03994   pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a> = 0;
<a name="l03995"></a>03995 
<a name="l03996"></a>03996   pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l03997"></a>03997   assert( pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> );
<a name="l03998"></a>03998   <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l03999"></a>03999     <span class="keywordtype">int</span> idx = pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l04000"></a>04000     rc = <a class="code" href="btree_8c.html#a1dbea539dd841af085ba1e1390922237">moveToChild</a>(pCur, <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(<a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, idx)));
<a name="l04001"></a>04001     <span class="keywordflow">if</span>( rc ){
<a name="l04002"></a>04002       <span class="keywordflow">return</span> rc;
<a name="l04003"></a>04003     }
<a name="l04004"></a>04004     rc = <a class="code" href="btree_8c.html#a0f818654466695149ef54b1cdc16887d">moveToRightmost</a>(pCur);
<a name="l04005"></a>04005   }<span class="keywordflow">else</span>{
<a name="l04006"></a>04006     <span class="keywordflow">while</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]==0 ){
<a name="l04007"></a>04007       <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>==0 ){
<a name="l04008"></a>04008         pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>;
<a name="l04009"></a>04009         *pRes = 1;
<a name="l04010"></a>04010         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04011"></a>04011       }
<a name="l04012"></a>04012       <a class="code" href="btree_8c.html#a4f174cc02f227c14f098998ec6f011a8">sqlite3BtreeMoveToParent</a>(pCur);
<a name="l04013"></a>04013     }
<a name="l04014"></a>04014     pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = 0;
<a name="l04015"></a>04015     pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 0;
<a name="l04016"></a>04016 
<a name="l04017"></a>04017     pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]--;
<a name="l04018"></a>04018     pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l04019"></a>04019     <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> &amp;&amp; !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l04020"></a>04020       rc = <a class="code" href="btree_8c.html#af84d1157958331e8d900f0800409f60b">sqlite3BtreePrevious</a>(pCur, pRes);
<a name="l04021"></a>04021     }<span class="keywordflow">else</span>{
<a name="l04022"></a>04022       rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04023"></a>04023     }
<a name="l04024"></a>04024   }
<a name="l04025"></a>04025   *pRes = 0;
<a name="l04026"></a>04026   <span class="keywordflow">return</span> rc;
<a name="l04027"></a>04027 }
<a name="l04028"></a>04028 
<a name="l04029"></a>04029 <span class="comment">/*</span>
<a name="l04030"></a>04030 <span class="comment">** Allocate a new page from the database file.</span>
<a name="l04031"></a>04031 <span class="comment">**</span>
<a name="l04032"></a>04032 <span class="comment">** The new page is marked as dirty.  (In other words, sqlite3PagerWrite()</span>
<a name="l04033"></a>04033 <span class="comment">** has already been called on the new page.)  The new page has also</span>
<a name="l04034"></a>04034 <span class="comment">** been referenced and the calling routine is responsible for calling</span>
<a name="l04035"></a>04035 <span class="comment">** sqlite3PagerUnref() on the new page when it is done.</span>
<a name="l04036"></a>04036 <span class="comment">**</span>
<a name="l04037"></a>04037 <span class="comment">** SQLITE_OK is returned on success.  Any other return value indicates</span>
<a name="l04038"></a>04038 <span class="comment">** an error.  *ppPage and *pPgno are undefined in the event of an error.</span>
<a name="l04039"></a>04039 <span class="comment">** Do not invoke sqlite3PagerUnref() on *ppPage if an error is returned.</span>
<a name="l04040"></a>04040 <span class="comment">**</span>
<a name="l04041"></a>04041 <span class="comment">** If the &quot;nearby&quot; parameter is not 0, then a (feeble) effort is made to </span>
<a name="l04042"></a>04042 <span class="comment">** locate a page close to the page number &quot;nearby&quot;.  This can be used in an</span>
<a name="l04043"></a>04043 <span class="comment">** attempt to keep related pages close to each other in the database file,</span>
<a name="l04044"></a>04044 <span class="comment">** which in turn can make database access faster.</span>
<a name="l04045"></a>04045 <span class="comment">**</span>
<a name="l04046"></a>04046 <span class="comment">** If the &quot;exact&quot; parameter is not 0, and the page-number nearby exists </span>
<a name="l04047"></a>04047 <span class="comment">** anywhere on the free-list, then it is guarenteed to be returned. This</span>
<a name="l04048"></a>04048 <span class="comment">** is only used by auto-vacuum databases when allocating a new table.</span>
<a name="l04049"></a>04049 <span class="comment">*/</span>
<a name="l04050"></a><a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">04050</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(
<a name="l04051"></a>04051   <a class="code" href="structBtShared.html">BtShared</a> *pBt, 
<a name="l04052"></a>04052   <a class="code" href="structMemPage.html">MemPage</a> **ppPage, 
<a name="l04053"></a>04053   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> *pPgno, 
<a name="l04054"></a>04054   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nearby,
<a name="l04055"></a>04055   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> exact
<a name="l04056"></a>04056 ){
<a name="l04057"></a>04057   <a class="code" href="structMemPage.html">MemPage</a> *pPage1;
<a name="l04058"></a>04058   <span class="keywordtype">int</span> rc;
<a name="l04059"></a>04059   <span class="keywordtype">int</span> n;     <span class="comment">/* Number of pages on the freelist */</span>
<a name="l04060"></a>04060   <span class="keywordtype">int</span> k;     <span class="comment">/* Number of leaves on the trunk of the freelist */</span>
<a name="l04061"></a>04061   <a class="code" href="structMemPage.html">MemPage</a> *pTrunk = 0;
<a name="l04062"></a>04062   <a class="code" href="structMemPage.html">MemPage</a> *pPrevTrunk = 0;
<a name="l04063"></a>04063 
<a name="l04064"></a>04064   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l04065"></a>04065   pPage1 = pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>;
<a name="l04066"></a>04066   n = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[36]);
<a name="l04067"></a>04067   <span class="keywordflow">if</span>( n&gt;0 ){
<a name="l04068"></a>04068     <span class="comment">/* There are pages on the freelist.  Reuse one of those pages. */</span>
<a name="l04069"></a>04069     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iTrunk;
<a name="l04070"></a>04070     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> searchList = 0; <span class="comment">/* If the free-list must be searched for &apos;nearby&apos; */</span>
<a name="l04071"></a>04071     
<a name="l04072"></a>04072     <span class="comment">/* If the &apos;exact&apos; parameter was true and a query of the pointer-map</span>
<a name="l04073"></a>04073 <span class="comment">    ** shows that the page &apos;nearby&apos; is somewhere on the free-list, then</span>
<a name="l04074"></a>04074 <span class="comment">    ** the entire-list will be searched for that page.</span>
<a name="l04075"></a>04075 <span class="comment">    */</span>
<a name="l04076"></a>04076 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l04077"></a>04077 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( exact &amp;&amp; nearby&lt;=<a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>) ){
<a name="l04078"></a>04078       <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eType;
<a name="l04079"></a>04079       assert( nearby&gt;0 );
<a name="l04080"></a>04080       assert( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> );
<a name="l04081"></a>04081       rc = <a class="code" href="btree_8c.html#ae91bfd9c1bec807a52a384d2ed01934b">ptrmapGet</a>(pBt, nearby, &amp;eType, 0);
<a name="l04082"></a>04082       <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04083"></a>04083       <span class="keywordflow">if</span>( eType==<a class="code" href="btreeInt_8h.html#a2eb986d0fb6e4c953a5a2579d8a163d4">PTRMAP_FREEPAGE</a> ){
<a name="l04084"></a>04084         searchList = 1;
<a name="l04085"></a>04085       }
<a name="l04086"></a>04086       *pPgno = nearby;
<a name="l04087"></a>04087     }
<a name="l04088"></a>04088 <span class="preprocessor">#endif</span>
<a name="l04089"></a>04089 <span class="preprocessor"></span>
<a name="l04090"></a>04090     <span class="comment">/* Decrement the free-list count by 1. Set iTrunk to the index of the</span>
<a name="l04091"></a>04091 <span class="comment">    ** first free-list trunk page. iPrevTrunk is initially 1.</span>
<a name="l04092"></a>04092 <span class="comment">    */</span>
<a name="l04093"></a>04093     rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage1-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04094"></a>04094     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04095"></a>04095     <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[36], n-1);
<a name="l04096"></a>04096 
<a name="l04097"></a>04097     <span class="comment">/* The code within this loop is run only once if the &apos;searchList&apos; variable</span>
<a name="l04098"></a>04098 <span class="comment">    ** is not true. Otherwise, it runs once for each trunk-page on the</span>
<a name="l04099"></a>04099 <span class="comment">    ** free-list until the page &apos;nearby&apos; is located.</span>
<a name="l04100"></a>04100 <span class="comment">    */</span>
<a name="l04101"></a>04101     <span class="keywordflow">do</span> {
<a name="l04102"></a>04102       pPrevTrunk = pTrunk;
<a name="l04103"></a>04103       <span class="keywordflow">if</span>( pPrevTrunk ){
<a name="l04104"></a>04104         iTrunk = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPrevTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0]);
<a name="l04105"></a>04105       }<span class="keywordflow">else</span>{
<a name="l04106"></a>04106         iTrunk = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[32]);
<a name="l04107"></a>04107       }
<a name="l04108"></a>04108       rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, iTrunk, &amp;pTrunk, 0);
<a name="l04109"></a>04109       <span class="keywordflow">if</span>( rc ){
<a name="l04110"></a>04110         pTrunk = 0;
<a name="l04111"></a>04111         <span class="keywordflow">goto</span> end_allocate_page;
<a name="l04112"></a>04112       }
<a name="l04113"></a>04113 
<a name="l04114"></a>04114       k = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[4]);
<a name="l04115"></a>04115       <span class="keywordflow">if</span>( k==0 &amp;&amp; !searchList ){
<a name="l04116"></a>04116         <span class="comment">/* The trunk has no leaves and the list is not being searched. </span>
<a name="l04117"></a>04117 <span class="comment">        ** So extract the trunk page itself and use it as the newly </span>
<a name="l04118"></a>04118 <span class="comment">        ** allocated page */</span>
<a name="l04119"></a>04119         assert( pPrevTrunk==0 );
<a name="l04120"></a>04120         rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pTrunk-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04121"></a>04121         <span class="keywordflow">if</span>( rc ){
<a name="l04122"></a>04122           <span class="keywordflow">goto</span> end_allocate_page;
<a name="l04123"></a>04123         }
<a name="l04124"></a>04124         *pPgno = iTrunk;
<a name="l04125"></a>04125         memcpy(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[32], &amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0], 4);
<a name="l04126"></a>04126         *ppPage = pTrunk;
<a name="l04127"></a>04127         pTrunk = 0;
<a name="l04128"></a>04128         <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;ALLOCATE: %d trunk - %d free pages left\n&quot;</span>, *pPgno, n-1));
<a name="l04129"></a>04129       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( k&gt;pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>/4 - 2 ){
<a name="l04130"></a>04130         <span class="comment">/* Value of k is out of range.  Database corruption */</span>
<a name="l04131"></a>04131         rc = <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l04132"></a>04132         <span class="keywordflow">goto</span> end_allocate_page;
<a name="l04133"></a>04133 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l04134"></a>04134 <span class="preprocessor"></span>      }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( searchList &amp;&amp; nearby==iTrunk ){
<a name="l04135"></a>04135         <span class="comment">/* The list is being searched and this trunk page is the page</span>
<a name="l04136"></a>04136 <span class="comment">        ** to allocate, regardless of whether it has leaves.</span>
<a name="l04137"></a>04137 <span class="comment">        */</span>
<a name="l04138"></a>04138         assert( *pPgno==iTrunk );
<a name="l04139"></a>04139         *ppPage = pTrunk;
<a name="l04140"></a>04140         searchList = 0;
<a name="l04141"></a>04141         rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pTrunk-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04142"></a>04142         <span class="keywordflow">if</span>( rc ){
<a name="l04143"></a>04143           <span class="keywordflow">goto</span> end_allocate_page;
<a name="l04144"></a>04144         }
<a name="l04145"></a>04145         <span class="keywordflow">if</span>( k==0 ){
<a name="l04146"></a>04146           <span class="keywordflow">if</span>( !pPrevTrunk ){
<a name="l04147"></a>04147             memcpy(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[32], &amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0], 4);
<a name="l04148"></a>04148           }<span class="keywordflow">else</span>{
<a name="l04149"></a>04149             memcpy(&amp;pPrevTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0], &amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0], 4);
<a name="l04150"></a>04150           }
<a name="l04151"></a>04151         }<span class="keywordflow">else</span>{
<a name="l04152"></a>04152           <span class="comment">/* The trunk page is required by the caller but it contains </span>
<a name="l04153"></a>04153 <span class="comment">          ** pointers to free-list leaves. The first leaf becomes a trunk</span>
<a name="l04154"></a>04154 <span class="comment">          ** page in this case.</span>
<a name="l04155"></a>04155 <span class="comment">          */</span>
<a name="l04156"></a>04156           <a class="code" href="structMemPage.html">MemPage</a> *pNewTrunk;
<a name="l04157"></a>04157           <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iNewTrunk = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[8]);
<a name="l04158"></a>04158           rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, iNewTrunk, &amp;pNewTrunk, 0);
<a name="l04159"></a>04159           <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04160"></a>04160             <span class="keywordflow">goto</span> end_allocate_page;
<a name="l04161"></a>04161           }
<a name="l04162"></a>04162           rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pNewTrunk-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04163"></a>04163           <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04164"></a>04164             <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pNewTrunk);
<a name="l04165"></a>04165             <span class="keywordflow">goto</span> end_allocate_page;
<a name="l04166"></a>04166           }
<a name="l04167"></a>04167           memcpy(&amp;pNewTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0], &amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0], 4);
<a name="l04168"></a>04168           <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pNewTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[4], k-1);
<a name="l04169"></a>04169           memcpy(&amp;pNewTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[8], &amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[12], (k-1)*4);
<a name="l04170"></a>04170           <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pNewTrunk);
<a name="l04171"></a>04171           <span class="keywordflow">if</span>( !pPrevTrunk ){
<a name="l04172"></a>04172             <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[32], iNewTrunk);
<a name="l04173"></a>04173           }<span class="keywordflow">else</span>{
<a name="l04174"></a>04174             rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPrevTrunk-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04175"></a>04175             <span class="keywordflow">if</span>( rc ){
<a name="l04176"></a>04176               <span class="keywordflow">goto</span> end_allocate_page;
<a name="l04177"></a>04177             }
<a name="l04178"></a>04178             <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPrevTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0], iNewTrunk);
<a name="l04179"></a>04179           }
<a name="l04180"></a>04180         }
<a name="l04181"></a>04181         pTrunk = 0;
<a name="l04182"></a>04182         <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;ALLOCATE: %d trunk - %d free pages left\n&quot;</span>, *pPgno, n-1));
<a name="l04183"></a>04183 <span class="preprocessor">#endif</span>
<a name="l04184"></a>04184 <span class="preprocessor"></span>      }<span class="keywordflow">else</span>{
<a name="l04185"></a>04185         <span class="comment">/* Extract a leaf from the trunk */</span>
<a name="l04186"></a>04186         <span class="keywordtype">int</span> closest;
<a name="l04187"></a>04187         <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iPage;
<a name="l04188"></a>04188         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *aData = pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l04189"></a>04189         rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pTrunk-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04190"></a>04190         <span class="keywordflow">if</span>( rc ){
<a name="l04191"></a>04191           <span class="keywordflow">goto</span> end_allocate_page;
<a name="l04192"></a>04192         }
<a name="l04193"></a>04193         <span class="keywordflow">if</span>( nearby&gt;0 ){
<a name="l04194"></a>04194           <span class="keywordtype">int</span> i, dist;
<a name="l04195"></a>04195           closest = 0;
<a name="l04196"></a>04196           dist = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;aData[8]) - nearby;
<a name="l04197"></a>04197           <span class="keywordflow">if</span>( dist&lt;0 ) dist = -dist;
<a name="l04198"></a>04198           <span class="keywordflow">for</span>(i=1; i&lt;k; i++){
<a name="l04199"></a>04199             <span class="keywordtype">int</span> d2 = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;aData[8+i*4]) - nearby;
<a name="l04200"></a>04200             <span class="keywordflow">if</span>( d2&lt;0 ) d2 = -d2;
<a name="l04201"></a>04201             <span class="keywordflow">if</span>( d2&lt;dist ){
<a name="l04202"></a>04202               closest = i;
<a name="l04203"></a>04203               dist = d2;
<a name="l04204"></a>04204             }
<a name="l04205"></a>04205           }
<a name="l04206"></a>04206         }<span class="keywordflow">else</span>{
<a name="l04207"></a>04207           closest = 0;
<a name="l04208"></a>04208         }
<a name="l04209"></a>04209 
<a name="l04210"></a>04210         iPage = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;aData[8+closest*4]);
<a name="l04211"></a>04211         <span class="keywordflow">if</span>( !searchList || iPage==nearby ){
<a name="l04212"></a>04212           <span class="keywordtype">int</span> nPage;
<a name="l04213"></a>04213           *pPgno = iPage;
<a name="l04214"></a>04214           nPage = <a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l04215"></a>04215           <span class="keywordflow">if</span>( *pPgno&gt;nPage ){
<a name="l04216"></a>04216             <span class="comment">/* Free page off the end of the file */</span>
<a name="l04217"></a>04217             rc = <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l04218"></a>04218             <span class="keywordflow">goto</span> end_allocate_page;
<a name="l04219"></a>04219           }
<a name="l04220"></a>04220           <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;ALLOCATE: %d was leaf %d of %d on trunk %d&quot;</span>
<a name="l04221"></a>04221                  <span class="stringliteral">&quot;: %d more free pages\n&quot;</span>,
<a name="l04222"></a>04222                  *pPgno, closest+1, k, pTrunk-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, n-1));
<a name="l04223"></a>04223           <span class="keywordflow">if</span>( closest&lt;k-1 ){
<a name="l04224"></a>04224             memcpy(&amp;aData[8+closest*4], &amp;aData[4+k*4], 4);
<a name="l04225"></a>04225           }
<a name="l04226"></a>04226           <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;aData[4], k-1);
<a name="l04227"></a>04227           rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, *pPgno, ppPage, 1);
<a name="l04228"></a>04228           <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04229"></a>04229             <a class="code" href="pager_8c.html#a26856949a137262ff164d78869c3c97a">sqlite3PagerDontRollback</a>((*ppPage)-&gt;pDbPage);
<a name="l04230"></a>04230             rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>((*ppPage)-&gt;pDbPage);
<a name="l04231"></a>04231             <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04232"></a>04232               <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(*ppPage);
<a name="l04233"></a>04233             }
<a name="l04234"></a>04234           }
<a name="l04235"></a>04235           searchList = 0;
<a name="l04236"></a>04236         }
<a name="l04237"></a>04237       }
<a name="l04238"></a>04238       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPrevTrunk);
<a name="l04239"></a>04239       pPrevTrunk = 0;
<a name="l04240"></a>04240     }<span class="keywordflow">while</span>( searchList );
<a name="l04241"></a>04241   }<span class="keywordflow">else</span>{
<a name="l04242"></a>04242     <span class="comment">/* There are no pages on the freelist, so create a new page at the</span>
<a name="l04243"></a>04243 <span class="comment">    ** end of the file */</span>
<a name="l04244"></a>04244     <span class="keywordtype">int</span> nPage = <a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l04245"></a>04245     *pPgno = nPage + 1;
<a name="l04246"></a>04246 
<a name="l04247"></a>04247 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l04248"></a>04248 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a> ){
<a name="l04249"></a>04249       <span class="comment">/* An incr-vacuum has already run within this transaction. So the</span>
<a name="l04250"></a>04250 <span class="comment">      ** page to allocate is not from the physical end of the file, but</span>
<a name="l04251"></a>04251 <span class="comment">      ** at pBt-&gt;nTrunc. </span>
<a name="l04252"></a>04252 <span class="comment">      */</span>
<a name="l04253"></a>04253       *pPgno = pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>+1;
<a name="l04254"></a>04254       <span class="keywordflow">if</span>( *pPgno==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){
<a name="l04255"></a>04255         (*pPgno)++;
<a name="l04256"></a>04256       }
<a name="l04257"></a>04257     }
<a name="l04258"></a>04258     <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> &amp;&amp; <a class="code" href="btreeInt_8h.html#a5236c788e81fad4b3d02e93a63f8f649">PTRMAP_ISPAGE</a>(pBt, *pPgno) ){
<a name="l04259"></a>04259       <span class="comment">/* If *pPgno refers to a pointer-map page, allocate two new pages</span>
<a name="l04260"></a>04260 <span class="comment">      ** at the end of the file instead of one. The first allocated page</span>
<a name="l04261"></a>04261 <span class="comment">      ** becomes a new pointer-map page, the second is used by the caller.</span>
<a name="l04262"></a>04262 <span class="comment">      */</span>
<a name="l04263"></a>04263       <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;ALLOCATE: %d from end of file (pointer-map page)\n&quot;</span>, *pPgno));
<a name="l04264"></a>04264       assert( *pPgno!=<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) );
<a name="l04265"></a>04265       (*pPgno)++;
<a name="l04266"></a>04266       <span class="keywordflow">if</span>( *pPgno==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){ (*pPgno)++; }
<a name="l04267"></a>04267     }
<a name="l04268"></a>04268     <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a> ){
<a name="l04269"></a>04269       pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a> = *pPgno;
<a name="l04270"></a>04270     }
<a name="l04271"></a>04271 <span class="preprocessor">#endif</span>
<a name="l04272"></a>04272 <span class="preprocessor"></span>
<a name="l04273"></a>04273     assert( *pPgno!=<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) );
<a name="l04274"></a>04274     rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, *pPgno, ppPage, 0);
<a name="l04275"></a>04275     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04276"></a>04276     rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>((*ppPage)-&gt;pDbPage);
<a name="l04277"></a>04277     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04278"></a>04278       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(*ppPage);
<a name="l04279"></a>04279     }
<a name="l04280"></a>04280     <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;ALLOCATE: %d from end of file\n&quot;</span>, *pPgno));
<a name="l04281"></a>04281   }
<a name="l04282"></a>04282 
<a name="l04283"></a>04283   assert( *pPgno!=<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) );
<a name="l04284"></a>04284 
<a name="l04285"></a>04285 end_allocate_page:
<a name="l04286"></a>04286   <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pTrunk);
<a name="l04287"></a>04287   <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPrevTrunk);
<a name="l04288"></a>04288   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; <a class="code" href="pager_8c.html#ad26965e228379211944b6a3a27b3038d">sqlite3PagerPageRefcount</a>((*ppPage)-&gt;pDbPage)&gt;1 ){
<a name="l04289"></a>04289     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(*ppPage);
<a name="l04290"></a>04290     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l04291"></a>04291   }
<a name="l04292"></a>04292   <span class="keywordflow">return</span> rc;
<a name="l04293"></a>04293 }
<a name="l04294"></a>04294 
<a name="l04295"></a>04295 <span class="comment">/*</span>
<a name="l04296"></a>04296 <span class="comment">** Add a page of the database file to the freelist.</span>
<a name="l04297"></a>04297 <span class="comment">**</span>
<a name="l04298"></a>04298 <span class="comment">** sqlite3PagerUnref() is NOT called for pPage.</span>
<a name="l04299"></a>04299 <span class="comment">*/</span>
<a name="l04300"></a><a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">04300</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage){
<a name="l04301"></a>04301   <a class="code" href="structBtShared.html">BtShared</a> *pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l04302"></a>04302   <a class="code" href="structMemPage.html">MemPage</a> *pPage1 = pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>;
<a name="l04303"></a>04303   <span class="keywordtype">int</span> rc, n, k;
<a name="l04304"></a>04304 
<a name="l04305"></a>04305   <span class="comment">/* Prepare the page for freeing */</span>
<a name="l04306"></a>04306   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l04307"></a>04307   assert( pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>&gt;1 );
<a name="l04308"></a>04308   pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> = 0;
<a name="l04309"></a>04309 
<a name="l04310"></a>04310   <span class="comment">/* Increment the free page count on pPage1 */</span>
<a name="l04311"></a>04311   rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage1-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04312"></a>04312   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04313"></a>04313   n = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[36]);
<a name="l04314"></a>04314   <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[36], n+1);
<a name="l04315"></a>04315 
<a name="l04316"></a>04316 <span class="preprocessor">#ifdef SQLITE_SECURE_DELETE</span>
<a name="l04317"></a>04317 <span class="preprocessor"></span>  <span class="comment">/* If the SQLITE_SECURE_DELETE compile-time option is enabled, then</span>
<a name="l04318"></a>04318 <span class="comment">  ** always fully overwrite deleted information with zeros.</span>
<a name="l04319"></a>04319 <span class="comment">  */</span>
<a name="l04320"></a>04320   rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04321"></a>04321   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04322"></a>04322   memset(pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>, 0, pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>);
<a name="l04323"></a>04323 <span class="preprocessor">#endif</span>
<a name="l04324"></a>04324 <span class="preprocessor"></span>
<a name="l04325"></a>04325   <span class="comment">/* If the database supports auto-vacuum, write an entry in the pointer-map</span>
<a name="l04326"></a>04326 <span class="comment">  ** to indicate that the page is free.</span>
<a name="l04327"></a>04327 <span class="comment">  */</span>
<a name="l04328"></a>04328   <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l04329"></a>04329     rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, <a class="code" href="btreeInt_8h.html#a2eb986d0fb6e4c953a5a2579d8a163d4">PTRMAP_FREEPAGE</a>, 0);
<a name="l04330"></a>04330     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04331"></a>04331   }
<a name="l04332"></a>04332 
<a name="l04333"></a>04333   <span class="keywordflow">if</span>( n==0 ){
<a name="l04334"></a>04334     <span class="comment">/* This is the first free page */</span>
<a name="l04335"></a>04335     rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04336"></a>04336     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04337"></a>04337     memset(pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>, 0, 8);
<a name="l04338"></a>04338     <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[32], pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l04339"></a>04339     <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FREE-PAGE: %d first\n&quot;</span>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l04340"></a>04340   }<span class="keywordflow">else</span>{
<a name="l04341"></a>04341     <span class="comment">/* Other free pages already exist.  Retrive the first trunk page</span>
<a name="l04342"></a>04342 <span class="comment">    ** of the freelist and find out how many leaves it has. */</span>
<a name="l04343"></a>04343     <a class="code" href="structMemPage.html">MemPage</a> *pTrunk;
<a name="l04344"></a>04344     rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[32]), &amp;pTrunk, 0);
<a name="l04345"></a>04345     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04346"></a>04346     k = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[4]);
<a name="l04347"></a>04347     <span class="keywordflow">if</span>( k&gt;=pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>/4 - 8 ){
<a name="l04348"></a>04348       <span class="comment">/* The trunk is full.  Turn the page being freed into a new</span>
<a name="l04349"></a>04349 <span class="comment">      ** trunk page with no leaves.</span>
<a name="l04350"></a>04350 <span class="comment">      **</span>
<a name="l04351"></a>04351 <span class="comment">      ** Note that the trunk page is not really full until it contains</span>
<a name="l04352"></a>04352 <span class="comment">      ** usableSize/4 - 2 entries, not usableSize/4 - 8 entries as we have</span>
<a name="l04353"></a>04353 <span class="comment">      ** coded.  But due to a coding error in versions of SQLite prior to</span>
<a name="l04354"></a>04354 <span class="comment">      ** 3.6.0, databases with freelist trunk pages holding more than</span>
<a name="l04355"></a>04355 <span class="comment">      ** usableSize/4 - 8 entries will be reported as corrupt.  In order</span>
<a name="l04356"></a>04356 <span class="comment">      ** to maintain backwards compatibility with older versions of SQLite,</span>
<a name="l04357"></a>04357 <span class="comment">      ** we will contain to restrict the number of entries to usableSize/4 - 8</span>
<a name="l04358"></a>04358 <span class="comment">      ** for now.  At some point in the future (once everyone has upgraded</span>
<a name="l04359"></a>04359 <span class="comment">      ** to 3.6.0 or later) we should consider fixing the conditional above</span>
<a name="l04360"></a>04360 <span class="comment">      ** to read &quot;usableSize/4-2&quot; instead of &quot;usableSize/4-8&quot;.</span>
<a name="l04361"></a>04361 <span class="comment">      */</span>
<a name="l04362"></a>04362       rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04363"></a>04363       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04364"></a>04364         <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>, pTrunk-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l04365"></a>04365         <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[4], 0);
<a name="l04366"></a>04366         <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPage1-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[32], pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l04367"></a>04367         <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FREE-PAGE: %d new trunk page replacing %d\n&quot;</span>,
<a name="l04368"></a>04368                 pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, pTrunk-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l04369"></a>04369       }
<a name="l04370"></a>04370     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( k&lt;0 ){
<a name="l04371"></a>04371       rc = <a class="code" href="sqlite3_8h.html#a4b7e972bd61cc8f5fb639011d1807935">SQLITE_CORRUPT</a>;
<a name="l04372"></a>04372     }<span class="keywordflow">else</span>{
<a name="l04373"></a>04373       <span class="comment">/* Add the newly freed page as a leaf on the current trunk */</span>
<a name="l04374"></a>04374       rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pTrunk-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04375"></a>04375       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04376"></a>04376         <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[4], k+1);
<a name="l04377"></a>04377         <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pTrunk-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[8+k*4], pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l04378"></a>04378 <span class="preprocessor">#ifndef SQLITE_SECURE_DELETE</span>
<a name="l04379"></a>04379 <span class="preprocessor"></span>        rc = <a class="code" href="pager_8c.html#a4f9135ca0b47f3b2d19c8ec234d2dfd3">sqlite3PagerDontWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04380"></a>04380 <span class="preprocessor">#endif</span>
<a name="l04381"></a>04381 <span class="preprocessor"></span>      }
<a name="l04382"></a>04382       <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;FREE-PAGE: %d leaf on trunk page %d\n&quot;</span>,pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>,pTrunk-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l04383"></a>04383     }
<a name="l04384"></a>04384     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pTrunk);
<a name="l04385"></a>04385   }
<a name="l04386"></a>04386   <span class="keywordflow">return</span> rc;
<a name="l04387"></a>04387 }
<a name="l04388"></a>04388 
<a name="l04389"></a>04389 <span class="comment">/*</span>
<a name="l04390"></a>04390 <span class="comment">** Free any overflow pages associated with the given Cell.</span>
<a name="l04391"></a>04391 <span class="comment">*/</span>
<a name="l04392"></a><a class="code" href="btree_8c.html#acce36127359eb4baec99dac6d630bd9d">04392</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#acce36127359eb4baec99dac6d630bd9d">clearCell</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pCell){
<a name="l04393"></a>04393   <a class="code" href="structBtShared.html">BtShared</a> *pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l04394"></a>04394   <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l04395"></a>04395   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> ovflPgno;
<a name="l04396"></a>04396   <span class="keywordtype">int</span> rc;
<a name="l04397"></a>04397   <span class="keywordtype">int</span> nOvfl;
<a name="l04398"></a>04398   <span class="keywordtype">int</span> ovflPageSize;
<a name="l04399"></a>04399 
<a name="l04400"></a>04400   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l04401"></a>04401   <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(pPage, pCell, &amp;info);
<a name="l04402"></a>04402   <span class="keywordflow">if</span>( info.<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a>==0 ){
<a name="l04403"></a>04403     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;  <span class="comment">/* No overflow pages. Return without doing anything */</span>
<a name="l04404"></a>04404   }
<a name="l04405"></a>04405   ovflPgno = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pCell[info.<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a>]);
<a name="l04406"></a>04406   ovflPageSize = pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> - 4;
<a name="l04407"></a>04407   nOvfl = (info.<a class="code" href="structCellInfo.html#ac1e3c1b4216a8e778bbac82907bb1485">nPayload</a> - info.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> + ovflPageSize - 1)/ovflPageSize;
<a name="l04408"></a>04408   assert( ovflPgno==0 || nOvfl&gt;0 );
<a name="l04409"></a>04409   <span class="keywordflow">while</span>( nOvfl-- ){
<a name="l04410"></a>04410     <a class="code" href="structMemPage.html">MemPage</a> *pOvfl;
<a name="l04411"></a>04411     <span class="keywordflow">if</span>( ovflPgno==0 || ovflPgno&gt;<a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>) ){
<a name="l04412"></a>04412       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l04413"></a>04413     }
<a name="l04414"></a>04414 
<a name="l04415"></a>04415     rc = <a class="code" href="btree_8c.html#af907f898e049d621e2c9dc1ed1d63cf4">getOverflowPage</a>(pBt, ovflPgno, &amp;pOvfl, (nOvfl==0)?0:&amp;ovflPgno);
<a name="l04416"></a>04416     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04417"></a>04417     rc = <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(pOvfl);
<a name="l04418"></a>04418     <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pOvfl-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04419"></a>04419     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l04420"></a>04420   }
<a name="l04421"></a>04421   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04422"></a>04422 }
<a name="l04423"></a>04423 
<a name="l04424"></a>04424 <span class="comment">/*</span>
<a name="l04425"></a>04425 <span class="comment">** Create the byte sequence used to represent a cell on page pPage</span>
<a name="l04426"></a>04426 <span class="comment">** and write that byte sequence into pCell[].  Overflow pages are</span>
<a name="l04427"></a>04427 <span class="comment">** allocated and filled in as necessary.  The calling procedure</span>
<a name="l04428"></a>04428 <span class="comment">** is responsible for making sure sufficient space has been allocated</span>
<a name="l04429"></a>04429 <span class="comment">** for pCell[].</span>
<a name="l04430"></a>04430 <span class="comment">**</span>
<a name="l04431"></a>04431 <span class="comment">** Note that pCell does not necessary need to point to the pPage-&gt;aData</span>
<a name="l04432"></a>04432 <span class="comment">** area.  pCell might point to some temporary storage.  The cell will</span>
<a name="l04433"></a>04433 <span class="comment">** be constructed in this temporary area then copied into pPage-&gt;aData</span>
<a name="l04434"></a>04434 <span class="comment">** later.</span>
<a name="l04435"></a>04435 <span class="comment">*/</span>
<a name="l04436"></a><a class="code" href="btree_8c.html#ab66a77004cf93954f2aae7e52a4e51a7">04436</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ab66a77004cf93954f2aae7e52a4e51a7">fillInCell</a>(
<a name="l04437"></a>04437   <a class="code" href="structMemPage.html">MemPage</a> *pPage,                <span class="comment">/* The page that contains the cell */</span>
<a name="l04438"></a>04438   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pCell,          <span class="comment">/* Complete text of the cell */</span>
<a name="l04439"></a>04439   <span class="keyword">const</span> <span class="keywordtype">void</span> *pKey, <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> nKey,    <span class="comment">/* The key */</span>
<a name="l04440"></a>04440   <span class="keyword">const</span> <span class="keywordtype">void</span> *pData,<span class="keywordtype">int</span> nData,   <span class="comment">/* The data */</span>
<a name="l04441"></a>04441   <span class="keywordtype">int</span> nZero,                     <span class="comment">/* Extra zero bytes to append to pData */</span>
<a name="l04442"></a>04442   <span class="keywordtype">int</span> *pnSize                    <span class="comment">/* Write cell size here */</span>
<a name="l04443"></a>04443 ){
<a name="l04444"></a>04444   <span class="keywordtype">int</span> nPayload;
<a name="l04445"></a>04445   <span class="keyword">const</span> <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pSrc;
<a name="l04446"></a>04446   <span class="keywordtype">int</span> nSrc, n, rc;
<a name="l04447"></a>04447   <span class="keywordtype">int</span> spaceLeft;
<a name="l04448"></a>04448   <a class="code" href="structMemPage.html">MemPage</a> *pOvfl = 0;
<a name="l04449"></a>04449   <a class="code" href="structMemPage.html">MemPage</a> *pToRelease = 0;
<a name="l04450"></a>04450   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pPrior;
<a name="l04451"></a>04451   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pPayload;
<a name="l04452"></a>04452   <a class="code" href="structBtShared.html">BtShared</a> *pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l04453"></a>04453   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoOvfl = 0;
<a name="l04454"></a>04454   <span class="keywordtype">int</span> nHeader;
<a name="l04455"></a>04455   <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l04456"></a>04456 
<a name="l04457"></a>04457   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l04458"></a>04458 
<a name="l04459"></a>04459   <span class="comment">/* Fill in the header. */</span>
<a name="l04460"></a>04460   nHeader = 0;
<a name="l04461"></a>04461   <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l04462"></a>04462     nHeader += 4;
<a name="l04463"></a>04463   }
<a name="l04464"></a>04464   <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#af7b608d25c2e326f82cc270cd53dd8f8">hasData</a> ){
<a name="l04465"></a>04465     nHeader += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(&amp;pCell[nHeader], nData+nZero);
<a name="l04466"></a>04466   }<span class="keywordflow">else</span>{
<a name="l04467"></a>04467     nData = nZero = 0;
<a name="l04468"></a>04468   }
<a name="l04469"></a>04469   nHeader += <a class="code" href="sqliteInt_8h.html#af9ff87f20562430c246a81af4336d65d">putVarint</a>(&amp;pCell[nHeader], *(<a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a>*)&amp;nKey);
<a name="l04470"></a>04470   <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(pPage, pCell, &amp;info);
<a name="l04471"></a>04471   assert( info.<a class="code" href="structCellInfo.html#a99bb1f87208f793359cf63e3d164025b">nHeader</a>==nHeader );
<a name="l04472"></a>04472   assert( info.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>==nKey );
<a name="l04473"></a>04473   assert( info.<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a>==nData+nZero );
<a name="l04474"></a>04474   
<a name="l04475"></a>04475   <span class="comment">/* Fill in the payload */</span>
<a name="l04476"></a>04476   nPayload = nData + nZero;
<a name="l04477"></a>04477   <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> ){
<a name="l04478"></a>04478     pSrc = pData;
<a name="l04479"></a>04479     nSrc = nData;
<a name="l04480"></a>04480     nData = 0;
<a name="l04481"></a>04481   }<span class="keywordflow">else</span>{
<a name="l04482"></a>04482     nPayload += nKey;
<a name="l04483"></a>04483     pSrc = pKey;
<a name="l04484"></a>04484     nSrc = nKey;
<a name="l04485"></a>04485   }
<a name="l04486"></a>04486   *pnSize = info.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a>;
<a name="l04487"></a>04487   spaceLeft = info.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a>;
<a name="l04488"></a>04488   pPayload = &amp;pCell[nHeader];
<a name="l04489"></a>04489   pPrior = &amp;pCell[info.<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a>];
<a name="l04490"></a>04490 
<a name="l04491"></a>04491   <span class="keywordflow">while</span>( nPayload&gt;0 ){
<a name="l04492"></a>04492     <span class="keywordflow">if</span>( spaceLeft==0 ){
<a name="l04493"></a>04493       <span class="keywordtype">int</span> isExact = 0;
<a name="l04494"></a>04494 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l04495"></a>04495 <span class="preprocessor"></span>      <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoPtrmap = pgnoOvfl; <span class="comment">/* Overflow page pointer-map entry page */</span>
<a name="l04496"></a>04496       <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l04497"></a>04497         <span class="keywordflow">do</span>{
<a name="l04498"></a>04498           pgnoOvfl++;
<a name="l04499"></a>04499         } <span class="keywordflow">while</span>( 
<a name="l04500"></a>04500           <a class="code" href="btreeInt_8h.html#a5236c788e81fad4b3d02e93a63f8f649">PTRMAP_ISPAGE</a>(pBt, pgnoOvfl) || pgnoOvfl==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) 
<a name="l04501"></a>04501         );
<a name="l04502"></a>04502         <span class="keywordflow">if</span>( pgnoOvfl&gt;1 ){
<a name="l04503"></a>04503           <span class="comment">/* isExact = 1; */</span>
<a name="l04504"></a>04504         }
<a name="l04505"></a>04505       }
<a name="l04506"></a>04506 <span class="preprocessor">#endif</span>
<a name="l04507"></a>04507 <span class="preprocessor"></span>      rc = <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(pBt, &amp;pOvfl, &amp;pgnoOvfl, pgnoOvfl, isExact);
<a name="l04508"></a>04508 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l04509"></a>04509 <span class="preprocessor"></span>      <span class="comment">/* If the database supports auto-vacuum, and the second or subsequent</span>
<a name="l04510"></a>04510 <span class="comment">      ** overflow page is being allocated, add an entry to the pointer-map</span>
<a name="l04511"></a>04511 <span class="comment">      ** for that page now. </span>
<a name="l04512"></a>04512 <span class="comment">      **</span>
<a name="l04513"></a>04513 <span class="comment">      ** If this is the first overflow page, then write a partial entry </span>
<a name="l04514"></a>04514 <span class="comment">      ** to the pointer-map. If we write nothing to this pointer-map slot,</span>
<a name="l04515"></a>04515 <span class="comment">      ** then the optimistic overflow chain processing in clearCell()</span>
<a name="l04516"></a>04516 <span class="comment">      ** may misinterpret the uninitialised values and delete the</span>
<a name="l04517"></a>04517 <span class="comment">      ** wrong pages from the database.</span>
<a name="l04518"></a>04518 <span class="comment">      */</span>
<a name="l04519"></a>04519       <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> &amp;&amp; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04520"></a>04520         <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eType = (pgnoPtrmap?<a class="code" href="btreeInt_8h.html#a2ae32756efb02fe2c719669a0bfabe9a">PTRMAP_OVERFLOW2</a>:<a class="code" href="btreeInt_8h.html#add9dc5f20d087b06cce9c19b30794560">PTRMAP_OVERFLOW1</a>);
<a name="l04521"></a>04521         rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, pgnoOvfl, eType, pgnoPtrmap);
<a name="l04522"></a>04522         <span class="keywordflow">if</span>( rc ){
<a name="l04523"></a>04523           <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pOvfl);
<a name="l04524"></a>04524         }
<a name="l04525"></a>04525       }
<a name="l04526"></a>04526 <span class="preprocessor">#endif</span>
<a name="l04527"></a>04527 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( rc ){
<a name="l04528"></a>04528         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pToRelease);
<a name="l04529"></a>04529         <span class="keywordflow">return</span> rc;
<a name="l04530"></a>04530       }
<a name="l04531"></a>04531       <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(pPrior, pgnoOvfl);
<a name="l04532"></a>04532       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pToRelease);
<a name="l04533"></a>04533       pToRelease = pOvfl;
<a name="l04534"></a>04534       pPrior = pOvfl-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l04535"></a>04535       <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(pPrior, 0);
<a name="l04536"></a>04536       pPayload = &amp;pOvfl-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[4];
<a name="l04537"></a>04537       spaceLeft = pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> - 4;
<a name="l04538"></a>04538     }
<a name="l04539"></a>04539     n = nPayload;
<a name="l04540"></a>04540     <span class="keywordflow">if</span>( n&gt;spaceLeft ) n = spaceLeft;
<a name="l04541"></a>04541     <span class="keywordflow">if</span>( nSrc&gt;0 ){
<a name="l04542"></a>04542       <span class="keywordflow">if</span>( n&gt;nSrc ) n = nSrc;
<a name="l04543"></a>04543       assert( pSrc );
<a name="l04544"></a>04544       memcpy(pPayload, pSrc, n);
<a name="l04545"></a>04545     }<span class="keywordflow">else</span>{
<a name="l04546"></a>04546       memset(pPayload, 0, n);
<a name="l04547"></a>04547     }
<a name="l04548"></a>04548     nPayload -= n;
<a name="l04549"></a>04549     pPayload += n;
<a name="l04550"></a>04550     pSrc += n;
<a name="l04551"></a>04551     nSrc -= n;
<a name="l04552"></a>04552     spaceLeft -= n;
<a name="l04553"></a>04553     <span class="keywordflow">if</span>( nSrc==0 ){
<a name="l04554"></a>04554       nSrc = nData;
<a name="l04555"></a>04555       pSrc = pData;
<a name="l04556"></a>04556     }
<a name="l04557"></a>04557   }
<a name="l04558"></a>04558   <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pToRelease);
<a name="l04559"></a>04559   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04560"></a>04560 }
<a name="l04561"></a>04561 
<a name="l04562"></a>04562 <span class="comment">/*</span>
<a name="l04563"></a>04563 <span class="comment">** Remove the i-th cell from pPage.  This routine effects pPage only.</span>
<a name="l04564"></a>04564 <span class="comment">** The cell content is not freed or deallocated.  It is assumed that</span>
<a name="l04565"></a>04565 <span class="comment">** the cell content has been copied someplace else.  This routine just</span>
<a name="l04566"></a>04566 <span class="comment">** removes the reference to the cell from pPage.</span>
<a name="l04567"></a>04567 <span class="comment">**</span>
<a name="l04568"></a>04568 <span class="comment">** &quot;sz&quot; must be the number of bytes in the cell.</span>
<a name="l04569"></a>04569 <span class="comment">*/</span>
<a name="l04570"></a><a class="code" href="btree_8c.html#a7d153c46e2326e23931ac95a72f7a38d">04570</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a7d153c46e2326e23931ac95a72f7a38d">dropCell</a>(<a class="code" href="structMemPage.html">MemPage</a> *pPage, <span class="keywordtype">int</span> idx, <span class="keywordtype">int</span> sz){
<a name="l04571"></a>04571   <span class="keywordtype">int</span> i;          <span class="comment">/* Loop counter */</span>
<a name="l04572"></a>04572   <span class="keywordtype">int</span> pc;         <span class="comment">/* Offset to cell content of cell being deleted */</span>
<a name="l04573"></a>04573   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *data;       <span class="comment">/* pPage-&gt;aData */</span>
<a name="l04574"></a>04574   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *ptr;        <span class="comment">/* Used to move bytes around within data[] */</span>
<a name="l04575"></a>04575 
<a name="l04576"></a>04576   assert( idx&gt;=0 &amp;&amp; idx&lt;pPage-&gt;nCell );
<a name="l04577"></a>04577   assert( sz==cellSize(pPage, idx) );
<a name="l04578"></a>04578   assert( sqlite3PagerIswriteable(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l04579"></a>04579   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l04580"></a>04580   data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l04581"></a>04581   ptr = &amp;data[pPage-&gt;<a class="code" href="structMemPage.html#a324ed834d93c3ae72994fb5730940521">cellOffset</a> + 2*idx];
<a name="l04582"></a>04582   pc = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(ptr);
<a name="l04583"></a>04583   <span class="keywordflow">if</span> ( pc&lt;=10 || pc+sz&gt;pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> ) {
<a name="l04584"></a>04584     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l04585"></a>04585   }
<a name="l04586"></a>04586   <a class="code" href="btree_8c.html#ac7a66d1b107f53d3e9c04a51f6dad514">freeSpace</a>(pPage, pc, sz);
<a name="l04587"></a>04587   <span class="keywordflow">for</span>(i=idx+1; i&lt;pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>; i++, ptr+=2){
<a name="l04588"></a>04588     ptr[0] = ptr[2];
<a name="l04589"></a>04589     ptr[1] = ptr[3];
<a name="l04590"></a>04590   }
<a name="l04591"></a>04591   pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>--;
<a name="l04592"></a>04592   <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+3], pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>);
<a name="l04593"></a>04593   pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> += 2;
<a name="l04594"></a>04594   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04595"></a>04595 }
<a name="l04596"></a>04596 
<a name="l04597"></a>04597 <span class="comment">/*</span>
<a name="l04598"></a>04598 <span class="comment">** Insert a new cell on pPage at cell index &quot;i&quot;.  pCell points to the</span>
<a name="l04599"></a>04599 <span class="comment">** content of the cell.</span>
<a name="l04600"></a>04600 <span class="comment">**</span>
<a name="l04601"></a>04601 <span class="comment">** If the cell content will fit on the page, then put it there.  If it</span>
<a name="l04602"></a>04602 <span class="comment">** will not fit, then make a copy of the cell content into pTemp if</span>
<a name="l04603"></a>04603 <span class="comment">** pTemp is not null.  Regardless of pTemp, allocate a new entry</span>
<a name="l04604"></a>04604 <span class="comment">** in pPage-&gt;aOvfl[] and make it point to the cell content (either</span>
<a name="l04605"></a>04605 <span class="comment">** in pTemp or the original pCell) and also record its index. </span>
<a name="l04606"></a>04606 <span class="comment">** Allocating a new entry in pPage-&gt;aCell[] implies that </span>
<a name="l04607"></a>04607 <span class="comment">** pPage-&gt;nOverflow is incremented.</span>
<a name="l04608"></a>04608 <span class="comment">**</span>
<a name="l04609"></a>04609 <span class="comment">** If nSkip is non-zero, then do not copy the first nSkip bytes of the</span>
<a name="l04610"></a>04610 <span class="comment">** cell. The caller will overwrite them after this function returns. If</span>
<a name="l04611"></a>04611 <span class="comment">** nSkip is non-zero, then pCell may not point to an invalid memory location </span>
<a name="l04612"></a>04612 <span class="comment">** (but pCell+nSkip is always valid).</span>
<a name="l04613"></a>04613 <span class="comment">*/</span>
<a name="l04614"></a><a class="code" href="btree_8c.html#ad9f11315b51b8014695e6fdc9a43c505">04614</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ad9f11315b51b8014695e6fdc9a43c505">insertCell</a>(
<a name="l04615"></a>04615   <a class="code" href="structMemPage.html">MemPage</a> *pPage,   <span class="comment">/* Page into which we are copying */</span>
<a name="l04616"></a>04616   <span class="keywordtype">int</span> i,            <span class="comment">/* New cell becomes the i-th cell of the page */</span>
<a name="l04617"></a>04617   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell,        <span class="comment">/* Content of the new cell */</span>
<a name="l04618"></a>04618   <span class="keywordtype">int</span> sz,           <span class="comment">/* Bytes of content in pCell */</span>
<a name="l04619"></a>04619   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pTemp,        <span class="comment">/* Temp storage space for pCell, if needed */</span>
<a name="l04620"></a>04620   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> nSkip          <span class="comment">/* Do not write the first nSkip bytes of the cell */</span>
<a name="l04621"></a>04621 ){
<a name="l04622"></a>04622   <span class="keywordtype">int</span> idx;          <span class="comment">/* Where to write new cell content in data[] */</span>
<a name="l04623"></a>04623   <span class="keywordtype">int</span> j;            <span class="comment">/* Loop counter */</span>
<a name="l04624"></a>04624   <span class="keywordtype">int</span> top;          <span class="comment">/* First byte of content for any cell in data[] */</span>
<a name="l04625"></a>04625   <span class="keywordtype">int</span> end;          <span class="comment">/* First byte past the last cell pointer in data[] */</span>
<a name="l04626"></a>04626   <span class="keywordtype">int</span> ins;          <span class="comment">/* Index in data[] where new cell pointer is inserted */</span>
<a name="l04627"></a>04627   <span class="keywordtype">int</span> hdr;          <span class="comment">/* Offset into data[] of the page header */</span>
<a name="l04628"></a>04628   <span class="keywordtype">int</span> cellOffset;   <span class="comment">/* Address of first cell pointer in data[] */</span>
<a name="l04629"></a>04629   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *data;         <span class="comment">/* The content of the whole page */</span>
<a name="l04630"></a>04630   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *ptr;          <span class="comment">/* Used for moving information around in data[] */</span>
<a name="l04631"></a>04631 
<a name="l04632"></a>04632   assert( i&gt;=0 &amp;&amp; i&lt;=pPage-&gt;nCell+pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a> );
<a name="l04633"></a>04633   assert( sz==<a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pPage, pCell) );
<a name="l04634"></a>04634   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l04635"></a>04635   <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a> || sz+2&gt;pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> ){
<a name="l04636"></a>04636     <span class="keywordflow">if</span>( pTemp ){
<a name="l04637"></a>04637       memcpy(pTemp+nSkip, pCell+nSkip, sz-nSkip);
<a name="l04638"></a>04638       pCell = pTemp;
<a name="l04639"></a>04639     }
<a name="l04640"></a>04640     j = pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>++;
<a name="l04641"></a>04641     assert( j&lt;<span class="keyword">sizeof</span>(pPage-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>)/<span class="keyword">sizeof</span>(pPage-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>[0]) );
<a name="l04642"></a>04642     pPage-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>[j].<a class="code" href="structMemPage_1_1__OvflCell.html#a75c64097a5af396bbdc30e859f33a7c9">pCell</a> = pCell;
<a name="l04643"></a>04643     pPage-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>[j].<a class="code" href="structMemPage_1_1__OvflCell.html#ad10c93756d29693601aa63923a7fbee3">idx</a> = i;
<a name="l04644"></a>04644     pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> = 0;
<a name="l04645"></a>04645   }<span class="keywordflow">else</span>{
<a name="l04646"></a>04646     <span class="keywordtype">int</span> rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l04647"></a>04647     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04648"></a>04648       <span class="keywordflow">return</span> rc;
<a name="l04649"></a>04649     }
<a name="l04650"></a>04650     assert( sqlite3PagerIswriteable(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l04651"></a>04651     data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l04652"></a>04652     hdr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>;
<a name="l04653"></a>04653     top = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]);
<a name="l04654"></a>04654     cellOffset = pPage-&gt;<a class="code" href="structMemPage.html#a324ed834d93c3ae72994fb5730940521">cellOffset</a>;
<a name="l04655"></a>04655     end = cellOffset + 2*pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> + 2;
<a name="l04656"></a>04656     ins = cellOffset + 2*i;
<a name="l04657"></a>04657     <span class="keywordflow">if</span>( end &gt; top - sz ){
<a name="l04658"></a>04658       rc = <a class="code" href="btree_8c.html#a47dc01495c37a948842e1fd7f5ffd98f">defragmentPage</a>(pPage);
<a name="l04659"></a>04659       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04660"></a>04660         <span class="keywordflow">return</span> rc;
<a name="l04661"></a>04661       }
<a name="l04662"></a>04662       top = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]);
<a name="l04663"></a>04663       assert( end + sz &lt;= top );
<a name="l04664"></a>04664     }
<a name="l04665"></a>04665     idx = <a class="code" href="btree_8c.html#a39da5157552cf85c36496f7999a1197f">allocateSpace</a>(pPage, sz);
<a name="l04666"></a>04666     assert( idx&gt;0 );
<a name="l04667"></a>04667     assert( end &lt;= <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]) );
<a name="l04668"></a>04668     <span class="keywordflow">if</span> (idx+sz &gt; pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>) {
<a name="l04669"></a>04669       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l04670"></a>04670     }
<a name="l04671"></a>04671     pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>++;
<a name="l04672"></a>04672     pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> -= 2;
<a name="l04673"></a>04673     memcpy(&amp;data[idx+nSkip], pCell+nSkip, sz-nSkip);
<a name="l04674"></a>04674     <span class="keywordflow">for</span>(j=end-2, ptr=&amp;data[j]; j&gt;ins; j-=2, ptr-=2){
<a name="l04675"></a>04675       ptr[0] = ptr[-2];
<a name="l04676"></a>04676       ptr[1] = ptr[-1];
<a name="l04677"></a>04677     }
<a name="l04678"></a>04678     <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[ins], idx);
<a name="l04679"></a>04679     <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[hdr+3], pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>);
<a name="l04680"></a>04680 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l04681"></a>04681 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l04682"></a>04682       <span class="comment">/* The cell may contain a pointer to an overflow page. If so, write</span>
<a name="l04683"></a>04683 <span class="comment">      ** the entry for the overflow page into the pointer map.</span>
<a name="l04684"></a>04684 <span class="comment">      */</span>
<a name="l04685"></a>04685       <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l04686"></a>04686       <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(pPage, pCell, &amp;info);
<a name="l04687"></a>04687       assert( (info.<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a>+(pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a>?0:info.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>))==info.<a class="code" href="structCellInfo.html#ac1e3c1b4216a8e778bbac82907bb1485">nPayload</a> );
<a name="l04688"></a>04688       <span class="keywordflow">if</span>( (info.<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a>+(pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a>?0:info.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>))&gt;info.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> ){
<a name="l04689"></a>04689         <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoOvfl = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pCell[info.<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a>]);
<a name="l04690"></a>04690         rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>, pgnoOvfl, <a class="code" href="btreeInt_8h.html#add9dc5f20d087b06cce9c19b30794560">PTRMAP_OVERFLOW1</a>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l04691"></a>04691         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">return</span> rc;
<a name="l04692"></a>04692       }
<a name="l04693"></a>04693     }
<a name="l04694"></a>04694 <span class="preprocessor">#endif</span>
<a name="l04695"></a>04695 <span class="preprocessor"></span>  }
<a name="l04696"></a>04696 
<a name="l04697"></a>04697   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04698"></a>04698 }
<a name="l04699"></a>04699 
<a name="l04700"></a>04700 <span class="comment">/*</span>
<a name="l04701"></a>04701 <span class="comment">** Add a list of cells to a page.  The page should be initially empty.</span>
<a name="l04702"></a>04702 <span class="comment">** The cells are guaranteed to fit on the page.</span>
<a name="l04703"></a>04703 <span class="comment">*/</span>
<a name="l04704"></a><a class="code" href="btree_8c.html#af511b4a8276006e01a7a50d009972d88">04704</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#af511b4a8276006e01a7a50d009972d88">assemblePage</a>(
<a name="l04705"></a>04705   <a class="code" href="structMemPage.html">MemPage</a> *pPage,   <span class="comment">/* The page to be assemblied */</span>
<a name="l04706"></a>04706   <span class="keywordtype">int</span> nCell,        <span class="comment">/* The number of cells to add to this page */</span>
<a name="l04707"></a>04707   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> **apCell,      <span class="comment">/* Pointers to cell bodies */</span>
<a name="l04708"></a>04708   <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> *aSize        <span class="comment">/* Sizes of the cells */</span>
<a name="l04709"></a>04709 ){
<a name="l04710"></a>04710   <span class="keywordtype">int</span> i;            <span class="comment">/* Loop counter */</span>
<a name="l04711"></a>04711   <span class="keywordtype">int</span> totalSize;    <span class="comment">/* Total size of all cells */</span>
<a name="l04712"></a>04712   <span class="keywordtype">int</span> hdr;          <span class="comment">/* Index of page header */</span>
<a name="l04713"></a>04713   <span class="keywordtype">int</span> cellptr;      <span class="comment">/* Address of next cell pointer */</span>
<a name="l04714"></a>04714   <span class="keywordtype">int</span> cellbody;     <span class="comment">/* Address of next cell body */</span>
<a name="l04715"></a>04715   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *data;         <span class="comment">/* Data for the page */</span>
<a name="l04716"></a>04716 
<a name="l04717"></a>04717   assert( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==0 );
<a name="l04718"></a>04718   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l04719"></a>04719   totalSize = 0;
<a name="l04720"></a>04720   <span class="keywordflow">for</span>(i=0; i&lt;nCell; i++){
<a name="l04721"></a>04721     totalSize += aSize[i];
<a name="l04722"></a>04722   }
<a name="l04723"></a>04723   assert( totalSize+2*nCell&lt;=pPage-&gt;nFree );
<a name="l04724"></a>04724   assert( pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>==0 );
<a name="l04725"></a>04725   cellptr = pPage-&gt;<a class="code" href="structMemPage.html#a324ed834d93c3ae72994fb5730940521">cellOffset</a>;
<a name="l04726"></a>04726   data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l04727"></a>04727   hdr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>;
<a name="l04728"></a>04728   <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[hdr+3], nCell);
<a name="l04729"></a>04729   <span class="keywordflow">if</span>( nCell ){
<a name="l04730"></a>04730     cellbody = <a class="code" href="btree_8c.html#a39da5157552cf85c36496f7999a1197f">allocateSpace</a>(pPage, totalSize);
<a name="l04731"></a>04731     assert( cellbody&gt;0 );
<a name="l04732"></a>04732     assert( pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> &gt;= 2*nCell );
<a name="l04733"></a>04733     pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> -= 2*nCell;
<a name="l04734"></a>04734     <span class="keywordflow">for</span>(i=0; i&lt;nCell; i++){
<a name="l04735"></a>04735       <a class="code" href="btreeInt_8h.html#a8afb60de946c40e8b5fd64814a2d2140">put2byte</a>(&amp;data[cellptr], cellbody);
<a name="l04736"></a>04736       memcpy(&amp;data[cellbody], apCell[i], aSize[i]);
<a name="l04737"></a>04737       cellptr += 2;
<a name="l04738"></a>04738       cellbody += aSize[i];
<a name="l04739"></a>04739     }
<a name="l04740"></a>04740     assert( cellbody==pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> );
<a name="l04741"></a>04741   }
<a name="l04742"></a>04742   pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> = nCell;
<a name="l04743"></a>04743 }
<a name="l04744"></a>04744 
<a name="l04745"></a>04745 <span class="comment">/*</span>
<a name="l04746"></a>04746 <span class="comment">** The following parameters determine how many adjacent pages get involved</span>
<a name="l04747"></a>04747 <span class="comment">** in a balancing operation.  NN is the number of neighbors on either side</span>
<a name="l04748"></a>04748 <span class="comment">** of the page that participate in the balancing operation.  NB is the</span>
<a name="l04749"></a>04749 <span class="comment">** total number of pages that participate, including the target page and</span>
<a name="l04750"></a>04750 <span class="comment">** NN neighbors on either side.</span>
<a name="l04751"></a>04751 <span class="comment">**</span>
<a name="l04752"></a>04752 <span class="comment">** The minimum value of NN is 1 (of course).  Increasing NN above 1</span>
<a name="l04753"></a>04753 <span class="comment">** (to 2 or 3) gives a modest improvement in SELECT and DELETE performance</span>
<a name="l04754"></a>04754 <span class="comment">** in exchange for a larger degradation in INSERT and UPDATE performance.</span>
<a name="l04755"></a>04755 <span class="comment">** The value of NN appears to give the best results overall.</span>
<a name="l04756"></a>04756 <span class="comment">*/</span>
<a name="l04757"></a><a class="code" href="btree_8c.html#a170755e30c36be4904106b7bb279b1ec">04757</a> <span class="preprocessor">#define NN 1             </span><span class="comment">/* Number of neighbors on either side of pPage */</span>
<a name="l04758"></a><a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">04758</a> <span class="preprocessor">#define NB (NN*2+1)      </span><span class="comment">/* Total pages involved in the balance */</span>
<a name="l04759"></a>04759 
<a name="l04760"></a>04760 <span class="comment">/* Forward reference */</span>
<a name="l04761"></a>04761 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#abee055e19b090d89ef7f3ba60aac24ff">balance</a>(<a class="code" href="structBtCursor.html">BtCursor</a>*, <span class="keywordtype">int</span>);
<a name="l04762"></a>04762 
<a name="l04763"></a>04763 <span class="preprocessor">#ifndef SQLITE_OMIT_QUICKBALANCE</span>
<a name="l04764"></a>04764 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l04765"></a>04765 <span class="comment">** This version of balance() handles the common special case where</span>
<a name="l04766"></a>04766 <span class="comment">** a new entry is being inserted on the extreme right-end of the</span>
<a name="l04767"></a>04767 <span class="comment">** tree, in other words, when the new entry will become the largest</span>
<a name="l04768"></a>04768 <span class="comment">** entry in the tree.</span>
<a name="l04769"></a>04769 <span class="comment">**</span>
<a name="l04770"></a>04770 <span class="comment">** Instead of trying balance the 3 right-most leaf pages, just add</span>
<a name="l04771"></a>04771 <span class="comment">** a new page to the right-hand side and put the one new entry in</span>
<a name="l04772"></a>04772 <span class="comment">** that page.  This leaves the right side of the tree somewhat</span>
<a name="l04773"></a>04773 <span class="comment">** unbalanced.  But odds are that we will be inserting new entries</span>
<a name="l04774"></a>04774 <span class="comment">** at the end soon afterwards so the nearly empty page will quickly</span>
<a name="l04775"></a>04775 <span class="comment">** fill up.  On average.</span>
<a name="l04776"></a>04776 <span class="comment">**</span>
<a name="l04777"></a>04777 <span class="comment">** pPage is the leaf page which is the right-most page in the tree.</span>
<a name="l04778"></a>04778 <span class="comment">** pParent is its parent.  pPage must have a single overflow entry</span>
<a name="l04779"></a>04779 <span class="comment">** which is also the right-most entry on the page.</span>
<a name="l04780"></a>04780 <span class="comment">*/</span>
<a name="l04781"></a><a class="code" href="btree_8c.html#a50075b03f795a0e4ebe6a095a3f7dcf1">04781</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a50075b03f795a0e4ebe6a095a3f7dcf1">balance_quick</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l04782"></a>04782   <span class="keywordtype">int</span> rc;
<a name="l04783"></a>04783   <a class="code" href="structMemPage.html">MemPage</a> *pNew = 0;
<a name="l04784"></a>04784   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoNew;
<a name="l04785"></a>04785   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell;
<a name="l04786"></a>04786   <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> szCell;
<a name="l04787"></a>04787   <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l04788"></a>04788   <a class="code" href="structMemPage.html">MemPage</a> *pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l04789"></a>04789   <a class="code" href="structMemPage.html">MemPage</a> *pParent = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>-1];
<a name="l04790"></a>04790   <a class="code" href="structBtShared.html">BtShared</a> *pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l04791"></a>04791   <span class="keywordtype">int</span> parentIdx = pParent-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>;   <span class="comment">/* pParent new divider cell index */</span>
<a name="l04792"></a>04792   <span class="keywordtype">int</span> parentSize;                   <span class="comment">/* Size of new divider cell */</span>
<a name="l04793"></a>04793   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> parentCell[64];                <span class="comment">/* Space for the new divider cell */</span>
<a name="l04794"></a>04794 
<a name="l04795"></a>04795   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l04796"></a>04796 
<a name="l04797"></a>04797   <span class="comment">/* Allocate a new page. Insert the overflow cell from pPage</span>
<a name="l04798"></a>04798 <span class="comment">  ** into it. Then remove the overflow cell from pPage.</span>
<a name="l04799"></a>04799 <span class="comment">  */</span>
<a name="l04800"></a>04800   rc = <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(pBt, &amp;pNew, &amp;pgnoNew, 0, 0);
<a name="l04801"></a>04801   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04802"></a>04802     pCell = pPage-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>[0].<a class="code" href="structMemPage_1_1__OvflCell.html#a75c64097a5af396bbdc30e859f33a7c9">pCell</a>;
<a name="l04803"></a>04803     szCell = <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pPage, pCell);
<a name="l04804"></a>04804     <a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">zeroPage</a>(pNew, pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0]);
<a name="l04805"></a>04805     <a class="code" href="btree_8c.html#af511b4a8276006e01a7a50d009972d88">assemblePage</a>(pNew, 1, &amp;pCell, &amp;szCell);
<a name="l04806"></a>04806     pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a> = 0;
<a name="l04807"></a>04807   
<a name="l04808"></a>04808     <span class="comment">/* pPage is currently the right-child of pParent. Change this</span>
<a name="l04809"></a>04809 <span class="comment">    ** so that the right-child is the new page allocated above and</span>
<a name="l04810"></a>04810 <span class="comment">    ** pPage is the next-to-right child. </span>
<a name="l04811"></a>04811 <span class="comment">    **</span>
<a name="l04812"></a>04812 <span class="comment">    ** Ignore the return value of the call to fillInCell(). fillInCell()</span>
<a name="l04813"></a>04813 <span class="comment">    ** may only return other than SQLITE_OK if it is required to allocate</span>
<a name="l04814"></a>04814 <span class="comment">    ** one or more overflow pages. Since an internal table B-Tree cell </span>
<a name="l04815"></a>04815 <span class="comment">    ** may never spill over onto an overflow page (it is a maximum of </span>
<a name="l04816"></a>04816 <span class="comment">    ** 13 bytes in size), it is not neccessary to check the return code.</span>
<a name="l04817"></a>04817 <span class="comment">    **</span>
<a name="l04818"></a>04818 <span class="comment">    ** Similarly, the insertCell() function cannot fail if the page</span>
<a name="l04819"></a>04819 <span class="comment">    ** being inserted into is already writable and the cell does not </span>
<a name="l04820"></a>04820 <span class="comment">    ** contain an overflow pointer. So ignore this return code too.</span>
<a name="l04821"></a>04821 <span class="comment">    */</span>
<a name="l04822"></a>04822     assert( pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>&gt;0 );
<a name="l04823"></a>04823     pCell = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>-1);
<a name="l04824"></a>04824     <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(pPage, pCell, &amp;info);
<a name="l04825"></a>04825     <a class="code" href="btree_8c.html#ab66a77004cf93954f2aae7e52a4e51a7">fillInCell</a>(pParent, parentCell, 0, info.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>, 0, 0, 0, &amp;parentSize);
<a name="l04826"></a>04826     assert( parentSize&lt;64 );
<a name="l04827"></a>04827     assert( sqlite3PagerIswriteable(pParent-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l04828"></a>04828     <a class="code" href="btree_8c.html#ad9f11315b51b8014695e6fdc9a43c505">insertCell</a>(pParent, parentIdx, parentCell, parentSize, 0, 4);
<a name="l04829"></a>04829     <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(<a class="code" href="btree_8c.html#a4789c15455047776c4cca9c18cc6ec65">findOverflowCell</a>(pParent,parentIdx), pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l04830"></a>04830     <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pParent-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pParent-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8], pgnoNew);
<a name="l04831"></a>04831   
<a name="l04832"></a>04832     <span class="comment">/* If this is an auto-vacuum database, update the pointer map</span>
<a name="l04833"></a>04833 <span class="comment">    ** with entries for the new page, and any pointer from the </span>
<a name="l04834"></a>04834 <span class="comment">    ** cell on the page to an overflow page.</span>
<a name="l04835"></a>04835 <span class="comment">    */</span>
<a name="l04836"></a>04836     <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l04837"></a>04837       rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, pgnoNew, <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, pParent-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l04838"></a>04838       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04839"></a>04839         rc = <a class="code" href="btree_8c.html#a4cf3751ebbf00f1d6405e916c95fbd6e">ptrmapPutOvfl</a>(pNew, 0);
<a name="l04840"></a>04840       }
<a name="l04841"></a>04841     }
<a name="l04842"></a>04842 
<a name="l04843"></a>04843     <span class="comment">/* Release the reference to the new page. */</span>
<a name="l04844"></a>04844     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pNew);
<a name="l04845"></a>04845   }
<a name="l04846"></a>04846 
<a name="l04847"></a>04847   <span class="comment">/* At this point the pPage-&gt;nFree variable is not set correctly with</span>
<a name="l04848"></a>04848 <span class="comment">  ** respect to the content of the page (because it was set to 0 by </span>
<a name="l04849"></a>04849 <span class="comment">  ** insertCell). So call sqlite3BtreeInitPage() to make sure it is</span>
<a name="l04850"></a>04850 <span class="comment">  ** correct.</span>
<a name="l04851"></a>04851 <span class="comment">  **</span>
<a name="l04852"></a>04852 <span class="comment">  ** This has to be done even if an error will be returned. Normally, if</span>
<a name="l04853"></a>04853 <span class="comment">  ** an error occurs during tree balancing, the contents of MemPage are</span>
<a name="l04854"></a>04854 <span class="comment">  ** not important, as they will be recalculated when the page is rolled</span>
<a name="l04855"></a>04855 <span class="comment">  ** back. But here, in balance_quick(), it is possible that pPage has </span>
<a name="l04856"></a>04856 <span class="comment">  ** not yet been marked dirty or written into the journal file. Therefore</span>
<a name="l04857"></a>04857 <span class="comment">  ** it will not be rolled back and so it is important to make sure that</span>
<a name="l04858"></a>04858 <span class="comment">  ** the page data and contents of MemPage are consistent.</span>
<a name="l04859"></a>04859 <span class="comment">  */</span>
<a name="l04860"></a>04860   pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> = 0;
<a name="l04861"></a>04861   <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(pPage);
<a name="l04862"></a>04862 
<a name="l04863"></a>04863   <span class="comment">/* If everything else succeeded, balance the parent page, in </span>
<a name="l04864"></a>04864 <span class="comment">  ** case the divider cell inserted caused it to become overfull.</span>
<a name="l04865"></a>04865 <span class="comment">  */</span>
<a name="l04866"></a>04866   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04867"></a>04867     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l04868"></a>04868     pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>--;
<a name="l04869"></a>04869     rc = <a class="code" href="btree_8c.html#abee055e19b090d89ef7f3ba60aac24ff">balance</a>(pCur, 0);
<a name="l04870"></a>04870   }
<a name="l04871"></a>04871   <span class="keywordflow">return</span> rc;
<a name="l04872"></a>04872 }
<a name="l04873"></a>04873 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_QUICKBALANCE */</span>
<a name="l04874"></a>04874 
<a name="l04875"></a>04875 <span class="comment">/*</span>
<a name="l04876"></a>04876 <span class="comment">** This routine redistributes Cells on pPage and up to NN*2 siblings</span>
<a name="l04877"></a>04877 <span class="comment">** of pPage so that all pages have about the same amount of free space.</span>
<a name="l04878"></a>04878 <span class="comment">** Usually NN siblings on either side of pPage is used in the balancing,</span>
<a name="l04879"></a>04879 <span class="comment">** though more siblings might come from one side if pPage is the first</span>
<a name="l04880"></a>04880 <span class="comment">** or last child of its parent.  If pPage has fewer than 2*NN siblings</span>
<a name="l04881"></a>04881 <span class="comment">** (something which can only happen if pPage is the root page or a </span>
<a name="l04882"></a>04882 <span class="comment">** child of root) then all available siblings participate in the balancing.</span>
<a name="l04883"></a>04883 <span class="comment">**</span>
<a name="l04884"></a>04884 <span class="comment">** The number of siblings of pPage might be increased or decreased by one or</span>
<a name="l04885"></a>04885 <span class="comment">** two in an effort to keep pages nearly full but not over full. The root page</span>
<a name="l04886"></a>04886 <span class="comment">** is special and is allowed to be nearly empty. If pPage is </span>
<a name="l04887"></a>04887 <span class="comment">** the root page, then the depth of the tree might be increased</span>
<a name="l04888"></a>04888 <span class="comment">** or decreased by one, as necessary, to keep the root page from being</span>
<a name="l04889"></a>04889 <span class="comment">** overfull or completely empty.</span>
<a name="l04890"></a>04890 <span class="comment">**</span>
<a name="l04891"></a>04891 <span class="comment">** Note that when this routine is called, some of the Cells on pPage</span>
<a name="l04892"></a>04892 <span class="comment">** might not actually be stored in pPage-&gt;aData[].  This can happen</span>
<a name="l04893"></a>04893 <span class="comment">** if the page is overfull.  Part of the job of this routine is to</span>
<a name="l04894"></a>04894 <span class="comment">** make sure all Cells for pPage once again fit in pPage-&gt;aData[].</span>
<a name="l04895"></a>04895 <span class="comment">**</span>
<a name="l04896"></a>04896 <span class="comment">** In the course of balancing the siblings of pPage, the parent of pPage</span>
<a name="l04897"></a>04897 <span class="comment">** might become overfull or underfull.  If that happens, then this routine</span>
<a name="l04898"></a>04898 <span class="comment">** is called recursively on the parent.</span>
<a name="l04899"></a>04899 <span class="comment">**</span>
<a name="l04900"></a>04900 <span class="comment">** If this routine fails for any reason, it might leave the database</span>
<a name="l04901"></a>04901 <span class="comment">** in a corrupted state.  So if this routine fails, the database should</span>
<a name="l04902"></a>04902 <span class="comment">** be rolled back.</span>
<a name="l04903"></a>04903 <span class="comment">*/</span>
<a name="l04904"></a><a class="code" href="btree_8c.html#a29b752d2eb8e1766715ed62fb792d486">04904</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a29b752d2eb8e1766715ed62fb792d486">balance_nonroot</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l04905"></a>04905   <a class="code" href="structMemPage.html">MemPage</a> *pPage;              <span class="comment">/* The over or underfull page to balance */</span>
<a name="l04906"></a>04906   <a class="code" href="structMemPage.html">MemPage</a> *pParent;            <span class="comment">/* The parent of pPage */</span>
<a name="l04907"></a>04907   <a class="code" href="structBtShared.html">BtShared</a> *pBt;               <span class="comment">/* The whole database */</span>
<a name="l04908"></a>04908   <span class="keywordtype">int</span> nCell = 0;               <span class="comment">/* Number of cells in apCell[] */</span>
<a name="l04909"></a>04909   <span class="keywordtype">int</span> nMaxCells = 0;           <span class="comment">/* Allocated size of apCell, szCell, aFrom. */</span>
<a name="l04910"></a>04910   <span class="keywordtype">int</span> nOld;                    <span class="comment">/* Number of pages in apOld[] */</span>
<a name="l04911"></a>04911   <span class="keywordtype">int</span> nNew;                    <span class="comment">/* Number of pages in apNew[] */</span>
<a name="l04912"></a>04912   <span class="keywordtype">int</span> nDiv;                    <span class="comment">/* Number of cells in apDiv[] */</span>
<a name="l04913"></a>04913   <span class="keywordtype">int</span> i, j, k;                 <span class="comment">/* Loop counters */</span>
<a name="l04914"></a>04914   <span class="keywordtype">int</span> idx;                     <span class="comment">/* Index of pPage in pParent-&gt;aCell[] */</span>
<a name="l04915"></a>04915   <span class="keywordtype">int</span> nxDiv;                   <span class="comment">/* Next divider slot in pParent-&gt;aCell[] */</span>
<a name="l04916"></a>04916   <span class="keywordtype">int</span> rc;                      <span class="comment">/* The return code */</span>
<a name="l04917"></a>04917   <span class="keywordtype">int</span> leafCorrection;          <span class="comment">/* 4 if pPage is a leaf.  0 if not */</span>
<a name="l04918"></a>04918   <span class="keywordtype">int</span> leafData;                <span class="comment">/* True if pPage is a leaf of a LEAFDATA tree */</span>
<a name="l04919"></a>04919   <span class="keywordtype">int</span> usableSpace;             <span class="comment">/* Bytes in pPage beyond the header */</span>
<a name="l04920"></a>04920   <span class="keywordtype">int</span> pageFlags;               <span class="comment">/* Value of pPage-&gt;aData[0] */</span>
<a name="l04921"></a>04921   <span class="keywordtype">int</span> subtotal;                <span class="comment">/* Subtotal of bytes in cells on one page */</span>
<a name="l04922"></a>04922   <span class="keywordtype">int</span> iSpace1 = 0;             <span class="comment">/* First unused byte of aSpace1[] */</span>
<a name="l04923"></a>04923   <span class="keywordtype">int</span> iSpace2 = 0;             <span class="comment">/* First unused byte of aSpace2[] */</span>
<a name="l04924"></a>04924   <span class="keywordtype">int</span> szScratch;               <span class="comment">/* Size of scratch memory requested */</span>
<a name="l04925"></a>04925   <a class="code" href="structMemPage.html">MemPage</a> *apOld[<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>];          <span class="comment">/* pPage and up to two siblings */</span>
<a name="l04926"></a>04926   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoOld[<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>];            <span class="comment">/* Page numbers for each page in apOld[] */</span>
<a name="l04927"></a>04927   <a class="code" href="structMemPage.html">MemPage</a> *apCopy[<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>];         <span class="comment">/* Private copies of apOld[] pages */</span>
<a name="l04928"></a>04928   <a class="code" href="structMemPage.html">MemPage</a> *apNew[<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>+2];        <span class="comment">/* pPage and up to NB siblings after balancing */</span>
<a name="l04929"></a>04929   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoNew[<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>+2];          <span class="comment">/* Page numbers for each page in apNew[] */</span>
<a name="l04930"></a>04930   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *apDiv[<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>];               <span class="comment">/* Divider cells in pParent */</span>
<a name="l04931"></a>04931   <span class="keywordtype">int</span> cntNew[<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>+2];            <span class="comment">/* Index in aCell[] of cell after i-th page */</span>
<a name="l04932"></a>04932   <span class="keywordtype">int</span> szNew[<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>+2];             <span class="comment">/* Combined size of cells place on i-th page */</span>
<a name="l04933"></a>04933   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> **apCell = 0;             <span class="comment">/* All cells begin balanced */</span>
<a name="l04934"></a>04934   <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> *szCell;                 <span class="comment">/* Local size of all cells in apCell[] */</span>
<a name="l04935"></a>04935   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *aCopy[<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>];         <span class="comment">/* Space for holding data of apCopy[] */</span>
<a name="l04936"></a>04936   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *aSpace1;           <span class="comment">/* Space for copies of dividers cells before balance */</span>
<a name="l04937"></a>04937   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *aSpace2 = 0;       <span class="comment">/* Space for overflow dividers cells after balance */</span>
<a name="l04938"></a>04938   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *aFrom = 0;
<a name="l04939"></a>04939 
<a name="l04940"></a>04940   pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l04941"></a>04941   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l04942"></a>04942   <a class="code" href="btree_8c.html#ad2f62e901555bee1364572b9d1c0c536">VVA_ONLY</a>( pCur-&gt;pagesShuffled = 1 );
<a name="l04943"></a>04943 
<a name="l04944"></a>04944   <span class="comment">/* </span>
<a name="l04945"></a>04945 <span class="comment">  ** Find the parent page.</span>
<a name="l04946"></a>04946 <span class="comment">  */</span>
<a name="l04947"></a>04947   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>&gt;0 );
<a name="l04948"></a>04948   assert( pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> );
<a name="l04949"></a>04949   assert( sqlite3PagerIswriteable(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) || pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==1 );
<a name="l04950"></a>04950   pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l04951"></a>04951   pParent = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>-1];
<a name="l04952"></a>04952   assert( pParent );
<a name="l04953"></a>04953   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=(rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pParent-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>)) ){
<a name="l04954"></a>04954     <span class="keywordflow">return</span> rc;
<a name="l04955"></a>04955   }
<a name="l04956"></a>04956 
<a name="l04957"></a>04957   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;BALANCE: begin page %d child of %d\n&quot;</span>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, pParent-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l04958"></a>04958 
<a name="l04959"></a>04959 <span class="preprocessor">#ifndef SQLITE_OMIT_QUICKBALANCE</span>
<a name="l04960"></a>04960 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l04961"></a>04961 <span class="comment">  ** A special case:  If a new entry has just been inserted into a</span>
<a name="l04962"></a>04962 <span class="comment">  ** table (that is, a btree with integer keys and all data at the leaves)</span>
<a name="l04963"></a>04963 <span class="comment">  ** and the new entry is the right-most entry in the tree (it has the</span>
<a name="l04964"></a>04964 <span class="comment">  ** largest key) then use the special balance_quick() routine for</span>
<a name="l04965"></a>04965 <span class="comment">  ** balancing.  balance_quick() is much faster and results in a tighter</span>
<a name="l04966"></a>04966 <span class="comment">  ** packing of data in the common case.</span>
<a name="l04967"></a>04967 <span class="comment">  */</span>
<a name="l04968"></a>04968   <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> &amp;&amp;
<a name="l04969"></a>04969       pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> &amp;&amp;
<a name="l04970"></a>04970       pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==1 &amp;&amp;
<a name="l04971"></a>04971       pPage-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>[0].<a class="code" href="structMemPage_1_1__OvflCell.html#ad10c93756d29693601aa63923a7fbee3">idx</a>==pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> &amp;&amp;
<a name="l04972"></a>04972       pParent-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>!=1 &amp;&amp;
<a name="l04973"></a>04973       <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pParent-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pParent-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8])==pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>
<a name="l04974"></a>04974   ){
<a name="l04975"></a>04975     assert( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> );
<a name="l04976"></a>04976     <span class="comment">/*</span>
<a name="l04977"></a>04977 <span class="comment">    ** TODO: Check the siblings to the left of pPage. It may be that</span>
<a name="l04978"></a>04978 <span class="comment">    ** they are not full and no new page is required.</span>
<a name="l04979"></a>04979 <span class="comment">    */</span>
<a name="l04980"></a>04980     <span class="keywordflow">return</span> <a class="code" href="btree_8c.html#a50075b03f795a0e4ebe6a095a3f7dcf1">balance_quick</a>(pCur);
<a name="l04981"></a>04981   }
<a name="l04982"></a>04982 <span class="preprocessor">#endif</span>
<a name="l04983"></a>04983 <span class="preprocessor"></span>
<a name="l04984"></a>04984   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=(rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>)) ){
<a name="l04985"></a>04985     <span class="keywordflow">return</span> rc;
<a name="l04986"></a>04986   }
<a name="l04987"></a>04987 
<a name="l04988"></a>04988   <span class="comment">/*</span>
<a name="l04989"></a>04989 <span class="comment">  ** Find the cell in the parent page whose left child points back</span>
<a name="l04990"></a>04990 <span class="comment">  ** to pPage.  The &quot;idx&quot; variable is the index of that cell.  If pPage</span>
<a name="l04991"></a>04991 <span class="comment">  ** is the rightmost child of pParent then set idx to pParent-&gt;nCell </span>
<a name="l04992"></a>04992 <span class="comment">  */</span>
<a name="l04993"></a>04993   idx = pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>-1];
<a name="l04994"></a>04994   <a class="code" href="btree_8c.html#a7ebae49c2037298dc16979e82277ca0a">assertParentIndex</a>(pParent, idx, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l04995"></a>04995 
<a name="l04996"></a>04996   <span class="comment">/*</span>
<a name="l04997"></a>04997 <span class="comment">  ** Initialize variables so that it will be safe to jump</span>
<a name="l04998"></a>04998 <span class="comment">  ** directly to balance_cleanup at any moment.</span>
<a name="l04999"></a>04999 <span class="comment">  */</span>
<a name="l05000"></a>05000   nOld = nNew = 0;
<a name="l05001"></a>05001 
<a name="l05002"></a>05002   <span class="comment">/*</span>
<a name="l05003"></a>05003 <span class="comment">  ** Find sibling pages to pPage and the cells in pParent that divide</span>
<a name="l05004"></a>05004 <span class="comment">  ** the siblings.  An attempt is made to find NN siblings on either</span>
<a name="l05005"></a>05005 <span class="comment">  ** side of pPage.  More siblings are taken from one side, however, if</span>
<a name="l05006"></a>05006 <span class="comment">  ** pPage there are fewer than NN siblings on the other side.  If pParent</span>
<a name="l05007"></a>05007 <span class="comment">  ** has NB or fewer children then all children of pParent are taken.</span>
<a name="l05008"></a>05008 <span class="comment">  */</span>
<a name="l05009"></a>05009   nxDiv = idx - <a class="code" href="btree_8c.html#a170755e30c36be4904106b7bb279b1ec">NN</a>;
<a name="l05010"></a>05010   <span class="keywordflow">if</span>( nxDiv + <a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a> &gt; pParent-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> ){
<a name="l05011"></a>05011     nxDiv = pParent-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> - <a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a> + 1;
<a name="l05012"></a>05012   }
<a name="l05013"></a>05013   <span class="keywordflow">if</span>( nxDiv&lt;0 ){
<a name="l05014"></a>05014     nxDiv = 0;
<a name="l05015"></a>05015   }
<a name="l05016"></a>05016   nDiv = 0;
<a name="l05017"></a>05017   <span class="keywordflow">for</span>(i=0, k=nxDiv; i&lt;<a class="code" href="btree_8c.html#a58e95dc1eb9d6ce16f515e77beeadd58">NB</a>; i++, k++){
<a name="l05018"></a>05018     <span class="keywordflow">if</span>( k&lt;pParent-&gt;nCell ){
<a name="l05019"></a>05019       apDiv[i] = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pParent, k);
<a name="l05020"></a>05020       nDiv++;
<a name="l05021"></a>05021       assert( !pParent-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> );
<a name="l05022"></a>05022       pgnoOld[i] = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(apDiv[i]);
<a name="l05023"></a>05023     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( k==pParent-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> ){
<a name="l05024"></a>05024       pgnoOld[i] = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pParent-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pParent-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8]);
<a name="l05025"></a>05025     }<span class="keywordflow">else</span>{
<a name="l05026"></a>05026       <span class="keywordflow">break</span>;
<a name="l05027"></a>05027     }
<a name="l05028"></a>05028     rc = <a class="code" href="btree_8c.html#a443538c685fb93b3b41ee3497629698e">getAndInitPage</a>(pBt, pgnoOld[i], &amp;apOld[i]);
<a name="l05029"></a>05029     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05030"></a>05030     <span class="comment">/* apOld[i]-&gt;idxParent = k; */</span>
<a name="l05031"></a>05031     apCopy[i] = 0;
<a name="l05032"></a>05032     assert( i==nOld );
<a name="l05033"></a>05033     nOld++;
<a name="l05034"></a>05034     nMaxCells += 1+apOld[i]-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>+apOld[i]-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>;
<a name="l05035"></a>05035   }
<a name="l05036"></a>05036 
<a name="l05037"></a>05037   <span class="comment">/* Make nMaxCells a multiple of 4 in order to preserve 8-byte</span>
<a name="l05038"></a>05038 <span class="comment">  ** alignment */</span>
<a name="l05039"></a>05039   nMaxCells = (nMaxCells + 3)&amp;~3;
<a name="l05040"></a>05040 
<a name="l05041"></a>05041   <span class="comment">/*</span>
<a name="l05042"></a>05042 <span class="comment">  ** Allocate space for memory structures</span>
<a name="l05043"></a>05043 <span class="comment">  */</span>
<a name="l05044"></a>05044   szScratch =
<a name="l05045"></a>05045        nMaxCells*<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)                       <span class="comment">/* apCell */</span>
<a name="l05046"></a>05046      + nMaxCells*<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a>)                       <span class="comment">/* szCell */</span>
<a name="l05047"></a>05047      + (<a class="code" href="btreeInt_8h.html#a633a8f83a91b56a9b1e40ed6696a2c8a">ROUND8</a>(<span class="keyword">sizeof</span>(<a class="code" href="structMemPage.html">MemPage</a>))+pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>)*NB  <span class="comment">/* aCopy */</span>
<a name="l05048"></a>05048      + pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>                               <span class="comment">/* aSpace1 */</span>
<a name="l05049"></a>05049      + (<a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ? nMaxCells : 0);             <span class="comment">/* aFrom */</span>
<a name="l05050"></a>05050   apCell = <a class="code" href="malloc_8c.html#a196b5b179d65a81e14479376f78869b3">sqlite3ScratchMalloc</a>( szScratch ); 
<a name="l05051"></a>05051   <span class="keywordflow">if</span>( apCell==0 ){
<a name="l05052"></a>05052     rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l05053"></a>05053     <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05054"></a>05054   }
<a name="l05055"></a>05055   szCell = (<a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a>*)&amp;apCell[nMaxCells];
<a name="l05056"></a>05056   aCopy[0] = (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)&amp;szCell[nMaxCells];
<a name="l05057"></a>05057   assert( ((aCopy[0] - (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)apCell) &amp; 7)==0 ); <span class="comment">/* 8-byte alignment required */</span>
<a name="l05058"></a>05058   <span class="keywordflow">for</span>(i=1; i&lt;NB; i++){
<a name="l05059"></a>05059     aCopy[i] = &amp;aCopy[i-1][pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>+<a class="code" href="btreeInt_8h.html#a633a8f83a91b56a9b1e40ed6696a2c8a">ROUND8</a>(<span class="keyword">sizeof</span>(<a class="code" href="structMemPage.html">MemPage</a>))];
<a name="l05060"></a>05060     assert( ((aCopy[i] - (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)apCell) &amp; 7)==0 ); <span class="comment">/* 8-byte alignment required */</span>
<a name="l05061"></a>05061   }
<a name="l05062"></a>05062   aSpace1 = &amp;aCopy[NB-1][pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>+<a class="code" href="btreeInt_8h.html#a633a8f83a91b56a9b1e40ed6696a2c8a">ROUND8</a>(<span class="keyword">sizeof</span>(<a class="code" href="structMemPage.html">MemPage</a>))];
<a name="l05063"></a>05063   assert( ((aSpace1 - (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)apCell) &amp; 7)==0 ); <span class="comment">/* 8-byte alignment required */</span>
<a name="l05064"></a>05064   <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l05065"></a>05065     aFrom = &amp;aSpace1[pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>];
<a name="l05066"></a>05066   }
<a name="l05067"></a>05067   aSpace2 = <a class="code" href="pcache_8c.html#a477574c3feb4e18cd674fe9593ae6cb0">sqlite3PageMalloc</a>(pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>);
<a name="l05068"></a>05068   <span class="keywordflow">if</span>( aSpace2==0 ){
<a name="l05069"></a>05069     rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l05070"></a>05070     <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05071"></a>05071   }
<a name="l05072"></a>05072   
<a name="l05073"></a>05073   <span class="comment">/*</span>
<a name="l05074"></a>05074 <span class="comment">  ** Make copies of the content of pPage and its siblings into aOld[].</span>
<a name="l05075"></a>05075 <span class="comment">  ** The rest of this function will use data from the copies rather</span>
<a name="l05076"></a>05076 <span class="comment">  ** that the original pages since the original pages will be in the</span>
<a name="l05077"></a>05077 <span class="comment">  ** process of being overwritten.</span>
<a name="l05078"></a>05078 <span class="comment">  */</span>
<a name="l05079"></a>05079   <span class="keywordflow">for</span>(i=0; i&lt;nOld; i++){
<a name="l05080"></a>05080     <a class="code" href="structMemPage.html">MemPage</a> *p = apCopy[i] = (<a class="code" href="structMemPage.html">MemPage</a>*)aCopy[i];
<a name="l05081"></a>05081     memcpy(p, apOld[i], <span class="keyword">sizeof</span>(<a class="code" href="structMemPage.html">MemPage</a>));
<a name="l05082"></a>05082     p-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a> = (<span class="keywordtype">void</span>*)&amp;p[1];
<a name="l05083"></a>05083     memcpy(p-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>, apOld[i]-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>, pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>);
<a name="l05084"></a>05084   }
<a name="l05085"></a>05085 
<a name="l05086"></a>05086   <span class="comment">/*</span>
<a name="l05087"></a>05087 <span class="comment">  ** Load pointers to all cells on sibling pages and the divider cells</span>
<a name="l05088"></a>05088 <span class="comment">  ** into the local apCell[] array.  Make copies of the divider cells</span>
<a name="l05089"></a>05089 <span class="comment">  ** into space obtained form aSpace1[] and remove the the divider Cells</span>
<a name="l05090"></a>05090 <span class="comment">  ** from pParent.</span>
<a name="l05091"></a>05091 <span class="comment">  **</span>
<a name="l05092"></a>05092 <span class="comment">  ** If the siblings are on leaf pages, then the child pointers of the</span>
<a name="l05093"></a>05093 <span class="comment">  ** divider cells are stripped from the cells before they are copied</span>
<a name="l05094"></a>05094 <span class="comment">  ** into aSpace1[].  In this way, all cells in apCell[] are without</span>
<a name="l05095"></a>05095 <span class="comment">  ** child pointers.  If siblings are not leaves, then all cell in</span>
<a name="l05096"></a>05096 <span class="comment">  ** apCell[] include child pointers.  Either way, all cells in apCell[]</span>
<a name="l05097"></a>05097 <span class="comment">  ** are alike.</span>
<a name="l05098"></a>05098 <span class="comment">  **</span>
<a name="l05099"></a>05099 <span class="comment">  ** leafCorrection:  4 if pPage is a leaf.  0 if pPage is not a leaf.</span>
<a name="l05100"></a>05100 <span class="comment">  **       leafData:  1 if pPage holds key+data and pParent holds only keys.</span>
<a name="l05101"></a>05101 <span class="comment">  */</span>
<a name="l05102"></a>05102   nCell = 0;
<a name="l05103"></a>05103   leafCorrection = pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a>*4;
<a name="l05104"></a>05104   leafData = pPage-&gt;<a class="code" href="structMemPage.html#af7b608d25c2e326f82cc270cd53dd8f8">hasData</a>;
<a name="l05105"></a>05105   <span class="keywordflow">for</span>(i=0; i&lt;nOld; i++){
<a name="l05106"></a>05106     <a class="code" href="structMemPage.html">MemPage</a> *pOld = apCopy[i];
<a name="l05107"></a>05107     <span class="keywordtype">int</span> limit = pOld-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>+pOld-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>;
<a name="l05108"></a>05108     <span class="keywordflow">for</span>(j=0; j&lt;limit; j++){
<a name="l05109"></a>05109       assert( nCell&lt;nMaxCells );
<a name="l05110"></a>05110       apCell[nCell] = <a class="code" href="btree_8c.html#a4789c15455047776c4cca9c18cc6ec65">findOverflowCell</a>(pOld, j);
<a name="l05111"></a>05111       szCell[nCell] = <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pOld, apCell[nCell]);
<a name="l05112"></a>05112       <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l05113"></a>05113         <span class="keywordtype">int</span> a;
<a name="l05114"></a>05114         aFrom[nCell] = i;
<a name="l05115"></a>05115         <span class="keywordflow">for</span>(a=0; a&lt;pOld-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>; a++){
<a name="l05116"></a>05116           <span class="keywordflow">if</span>( pOld-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>[a].<a class="code" href="structMemPage_1_1__OvflCell.html#a75c64097a5af396bbdc30e859f33a7c9">pCell</a>==apCell[nCell] ){
<a name="l05117"></a>05117             aFrom[nCell] = 0xFF;
<a name="l05118"></a>05118             <span class="keywordflow">break</span>;
<a name="l05119"></a>05119           }
<a name="l05120"></a>05120         }
<a name="l05121"></a>05121       }
<a name="l05122"></a>05122       nCell++;
<a name="l05123"></a>05123     }
<a name="l05124"></a>05124     <span class="keywordflow">if</span>( i&lt;nOld-1 ){
<a name="l05125"></a>05125       <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> sz = <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pParent, apDiv[i]);
<a name="l05126"></a>05126       <span class="keywordflow">if</span>( leafData ){
<a name="l05127"></a>05127         <span class="comment">/* With the LEAFDATA flag, pParent cells hold only INTKEYs that</span>
<a name="l05128"></a>05128 <span class="comment">        ** are duplicates of keys on the child pages.  We need to remove</span>
<a name="l05129"></a>05129 <span class="comment">        ** the divider cells from pParent, but the dividers cells are not</span>
<a name="l05130"></a>05130 <span class="comment">        ** added to apCell[] because they are duplicates of child cells.</span>
<a name="l05131"></a>05131 <span class="comment">        */</span>
<a name="l05132"></a>05132         <a class="code" href="btree_8c.html#a7d153c46e2326e23931ac95a72f7a38d">dropCell</a>(pParent, nxDiv, sz);
<a name="l05133"></a>05133       }<span class="keywordflow">else</span>{
<a name="l05134"></a>05134         <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pTemp;
<a name="l05135"></a>05135         assert( nCell&lt;nMaxCells );
<a name="l05136"></a>05136         szCell[nCell] = sz;
<a name="l05137"></a>05137         pTemp = &amp;aSpace1[iSpace1];
<a name="l05138"></a>05138         iSpace1 += sz;
<a name="l05139"></a>05139         assert( sz&lt;=pBt-&gt;pageSize/4 );
<a name="l05140"></a>05140         assert( iSpace1&lt;=pBt-&gt;pageSize );
<a name="l05141"></a>05141         memcpy(pTemp, apDiv[i], sz);
<a name="l05142"></a>05142         apCell[nCell] = pTemp+leafCorrection;
<a name="l05143"></a>05143         <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l05144"></a>05144           aFrom[nCell] = 0xFF;
<a name="l05145"></a>05145         }
<a name="l05146"></a>05146         <a class="code" href="btree_8c.html#a7d153c46e2326e23931ac95a72f7a38d">dropCell</a>(pParent, nxDiv, sz);
<a name="l05147"></a>05147         szCell[nCell] -= leafCorrection;
<a name="l05148"></a>05148         assert( <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pTemp)==pgnoOld[i] );
<a name="l05149"></a>05149         <span class="keywordflow">if</span>( !pOld-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l05150"></a>05150           assert( leafCorrection==0 );
<a name="l05151"></a>05151           <span class="comment">/* The right pointer of the child page pOld becomes the left</span>
<a name="l05152"></a>05152 <span class="comment">          ** pointer of the divider cell */</span>
<a name="l05153"></a>05153           memcpy(apCell[nCell], &amp;pOld-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pOld-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8], 4);
<a name="l05154"></a>05154         }<span class="keywordflow">else</span>{
<a name="l05155"></a>05155           assert( leafCorrection==4 );
<a name="l05156"></a>05156           <span class="keywordflow">if</span>( szCell[nCell]&lt;4 ){
<a name="l05157"></a>05157             <span class="comment">/* Do not allow any cells smaller than 4 bytes. */</span>
<a name="l05158"></a>05158             szCell[nCell] = 4;
<a name="l05159"></a>05159           }
<a name="l05160"></a>05160         }
<a name="l05161"></a>05161         nCell++;
<a name="l05162"></a>05162       }
<a name="l05163"></a>05163     }
<a name="l05164"></a>05164   }
<a name="l05165"></a>05165 
<a name="l05166"></a>05166   <span class="comment">/*</span>
<a name="l05167"></a>05167 <span class="comment">  ** Figure out the number of pages needed to hold all nCell cells.</span>
<a name="l05168"></a>05168 <span class="comment">  ** Store this number in &quot;k&quot;.  Also compute szNew[] which is the total</span>
<a name="l05169"></a>05169 <span class="comment">  ** size of all cells on the i-th page and cntNew[] which is the index</span>
<a name="l05170"></a>05170 <span class="comment">  ** in apCell[] of the cell that divides page i from page i+1.  </span>
<a name="l05171"></a>05171 <span class="comment">  ** cntNew[k] should equal nCell.</span>
<a name="l05172"></a>05172 <span class="comment">  **</span>
<a name="l05173"></a>05173 <span class="comment">  ** Values computed by this block:</span>
<a name="l05174"></a>05174 <span class="comment">  **</span>
<a name="l05175"></a>05175 <span class="comment">  **           k: The total number of sibling pages</span>
<a name="l05176"></a>05176 <span class="comment">  **    szNew[i]: Spaced used on the i-th sibling page.</span>
<a name="l05177"></a>05177 <span class="comment">  **   cntNew[i]: Index in apCell[] and szCell[] for the first cell to</span>
<a name="l05178"></a>05178 <span class="comment">  **              the right of the i-th sibling page.</span>
<a name="l05179"></a>05179 <span class="comment">  ** usableSpace: Number of bytes of space available on each sibling.</span>
<a name="l05180"></a>05180 <span class="comment">  ** </span>
<a name="l05181"></a>05181 <span class="comment">  */</span>
<a name="l05182"></a>05182   usableSpace = pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a> - 12 + leafCorrection;
<a name="l05183"></a>05183   <span class="keywordflow">for</span>(subtotal=k=i=0; i&lt;nCell; i++){
<a name="l05184"></a>05184     assert( i&lt;nMaxCells );
<a name="l05185"></a>05185     subtotal += szCell[i] + 2;
<a name="l05186"></a>05186     <span class="keywordflow">if</span>( subtotal &gt; usableSpace ){
<a name="l05187"></a>05187       szNew[k] = subtotal - szCell[i];
<a name="l05188"></a>05188       cntNew[k] = i;
<a name="l05189"></a>05189       <span class="keywordflow">if</span>( leafData ){ i--; }
<a name="l05190"></a>05190       subtotal = 0;
<a name="l05191"></a>05191       k++;
<a name="l05192"></a>05192     }
<a name="l05193"></a>05193   }
<a name="l05194"></a>05194   szNew[k] = subtotal;
<a name="l05195"></a>05195   cntNew[k] = nCell;
<a name="l05196"></a>05196   k++;
<a name="l05197"></a>05197 
<a name="l05198"></a>05198   <span class="comment">/*</span>
<a name="l05199"></a>05199 <span class="comment">  ** The packing computed by the previous block is biased toward the siblings</span>
<a name="l05200"></a>05200 <span class="comment">  ** on the left side.  The left siblings are always nearly full, while the</span>
<a name="l05201"></a>05201 <span class="comment">  ** right-most sibling might be nearly empty.  This block of code attempts</span>
<a name="l05202"></a>05202 <span class="comment">  ** to adjust the packing of siblings to get a better balance.</span>
<a name="l05203"></a>05203 <span class="comment">  **</span>
<a name="l05204"></a>05204 <span class="comment">  ** This adjustment is more than an optimization.  The packing above might</span>
<a name="l05205"></a>05205 <span class="comment">  ** be so out of balance as to be illegal.  For example, the right-most</span>
<a name="l05206"></a>05206 <span class="comment">  ** sibling might be completely empty.  This adjustment is not optional.</span>
<a name="l05207"></a>05207 <span class="comment">  */</span>
<a name="l05208"></a>05208   <span class="keywordflow">for</span>(i=k-1; i&gt;0; i--){
<a name="l05209"></a>05209     <span class="keywordtype">int</span> szRight = szNew[i];  <span class="comment">/* Size of sibling on the right */</span>
<a name="l05210"></a>05210     <span class="keywordtype">int</span> szLeft = szNew[i-1]; <span class="comment">/* Size of sibling on the left */</span>
<a name="l05211"></a>05211     <span class="keywordtype">int</span> r;              <span class="comment">/* Index of right-most cell in left sibling */</span>
<a name="l05212"></a>05212     <span class="keywordtype">int</span> <a class="code" href="libluasqlite3_8c.html#a8d6141748244c12982deaaf0dafd7449">d</a>;              <span class="comment">/* Index of first cell to the left of right sibling */</span>
<a name="l05213"></a>05213 
<a name="l05214"></a>05214     r = cntNew[i-1] - 1;
<a name="l05215"></a>05215     d = r + 1 - leafData;
<a name="l05216"></a>05216     assert( d&lt;nMaxCells );
<a name="l05217"></a>05217     assert( r&lt;nMaxCells );
<a name="l05218"></a>05218     <span class="keywordflow">while</span>( szRight==0 || szRight+szCell[d]+2&lt;=szLeft-(szCell[r]+2) ){
<a name="l05219"></a>05219       szRight += szCell[d] + 2;
<a name="l05220"></a>05220       szLeft -= szCell[r] + 2;
<a name="l05221"></a>05221       cntNew[i-1]--;
<a name="l05222"></a>05222       r = cntNew[i-1] - 1;
<a name="l05223"></a>05223       d = r + 1 - leafData;
<a name="l05224"></a>05224     }
<a name="l05225"></a>05225     szNew[i] = szRight;
<a name="l05226"></a>05226     szNew[i-1] = szLeft;
<a name="l05227"></a>05227   }
<a name="l05228"></a>05228 
<a name="l05229"></a>05229   <span class="comment">/* Either we found one or more cells (cntnew[0])&gt;0) or we are the</span>
<a name="l05230"></a>05230 <span class="comment">  ** a virtual root page.  A virtual root page is when the real root</span>
<a name="l05231"></a>05231 <span class="comment">  ** page is page 1 and we are the only child of that page.</span>
<a name="l05232"></a>05232 <span class="comment">  */</span>
<a name="l05233"></a>05233   assert( cntNew[0]&gt;0 || (pParent-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>==1 &amp;&amp; pParent-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>==0) );
<a name="l05234"></a>05234 
<a name="l05235"></a>05235   <span class="comment">/*</span>
<a name="l05236"></a>05236 <span class="comment">  ** Allocate k new pages.  Reuse old pages where possible.</span>
<a name="l05237"></a>05237 <span class="comment">  */</span>
<a name="l05238"></a>05238   assert( pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>&gt;1 );
<a name="l05239"></a>05239   pageFlags = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0];
<a name="l05240"></a>05240   <span class="keywordflow">for</span>(i=0; i&lt;k; i++){
<a name="l05241"></a>05241     <a class="code" href="structMemPage.html">MemPage</a> *pNew;
<a name="l05242"></a>05242     <span class="keywordflow">if</span>( i&lt;nOld ){
<a name="l05243"></a>05243       pNew = apNew[i] = apOld[i];
<a name="l05244"></a>05244       pgnoNew[i] = pgnoOld[i];
<a name="l05245"></a>05245       apOld[i] = 0;
<a name="l05246"></a>05246       rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pNew-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l05247"></a>05247       nNew++;
<a name="l05248"></a>05248       <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05249"></a>05249     }<span class="keywordflow">else</span>{
<a name="l05250"></a>05250       assert( i&gt;0 );
<a name="l05251"></a>05251       rc = <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(pBt, &amp;pNew, &amp;pgnoNew[i], pgnoNew[i-1], 0);
<a name="l05252"></a>05252       <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05253"></a>05253       apNew[i] = pNew;
<a name="l05254"></a>05254       nNew++;
<a name="l05255"></a>05255     }
<a name="l05256"></a>05256   }
<a name="l05257"></a>05257 
<a name="l05258"></a>05258   <span class="comment">/* Free any old pages that were not reused as new pages.</span>
<a name="l05259"></a>05259 <span class="comment">  */</span>
<a name="l05260"></a>05260   <span class="keywordflow">while</span>( i&lt;nOld ){
<a name="l05261"></a>05261     rc = <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(apOld[i]);
<a name="l05262"></a>05262     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05263"></a>05263     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(apOld[i]);
<a name="l05264"></a>05264     apOld[i] = 0;
<a name="l05265"></a>05265     i++;
<a name="l05266"></a>05266   }
<a name="l05267"></a>05267 
<a name="l05268"></a>05268   <span class="comment">/*</span>
<a name="l05269"></a>05269 <span class="comment">  ** Put the new pages in accending order.  This helps to</span>
<a name="l05270"></a>05270 <span class="comment">  ** keep entries in the disk file in order so that a scan</span>
<a name="l05271"></a>05271 <span class="comment">  ** of the table is a linear scan through the file.  That</span>
<a name="l05272"></a>05272 <span class="comment">  ** in turn helps the operating system to deliver pages</span>
<a name="l05273"></a>05273 <span class="comment">  ** from the disk more rapidly.</span>
<a name="l05274"></a>05274 <span class="comment">  **</span>
<a name="l05275"></a>05275 <span class="comment">  ** An O(n^2) insertion sort algorithm is used, but since</span>
<a name="l05276"></a>05276 <span class="comment">  ** n is never more than NB (a small constant), that should</span>
<a name="l05277"></a>05277 <span class="comment">  ** not be a problem.</span>
<a name="l05278"></a>05278 <span class="comment">  **</span>
<a name="l05279"></a>05279 <span class="comment">  ** When NB==3, this one optimization makes the database</span>
<a name="l05280"></a>05280 <span class="comment">  ** about 25% faster for large insertions and deletions.</span>
<a name="l05281"></a>05281 <span class="comment">  */</span>
<a name="l05282"></a>05282   <span class="keywordflow">for</span>(i=0; i&lt;k-1; i++){
<a name="l05283"></a>05283     <span class="keywordtype">int</span> minV = pgnoNew[i];
<a name="l05284"></a>05284     <span class="keywordtype">int</span> minI = i;
<a name="l05285"></a>05285     <span class="keywordflow">for</span>(j=i+1; j&lt;k; j++){
<a name="l05286"></a>05286       <span class="keywordflow">if</span>( pgnoNew[j]&lt;(<span class="keywordtype">unsigned</span>)minV ){
<a name="l05287"></a>05287         minI = j;
<a name="l05288"></a>05288         minV = pgnoNew[j];
<a name="l05289"></a>05289       }
<a name="l05290"></a>05290     }
<a name="l05291"></a>05291     <span class="keywordflow">if</span>( minI&gt;i ){
<a name="l05292"></a>05292       <span class="keywordtype">int</span> t;
<a name="l05293"></a>05293       <a class="code" href="structMemPage.html">MemPage</a> *pT;
<a name="l05294"></a>05294       t = pgnoNew[i];
<a name="l05295"></a>05295       pT = apNew[i];
<a name="l05296"></a>05296       pgnoNew[i] = pgnoNew[minI];
<a name="l05297"></a>05297       apNew[i] = apNew[minI];
<a name="l05298"></a>05298       pgnoNew[minI] = t;
<a name="l05299"></a>05299       apNew[minI] = pT;
<a name="l05300"></a>05300     }
<a name="l05301"></a>05301   }
<a name="l05302"></a>05302   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;BALANCE: old: %d %d %d  new: %d(%d) %d(%d) %d(%d) %d(%d) %d(%d)\n&quot;</span>,
<a name="l05303"></a>05303     pgnoOld[0], 
<a name="l05304"></a>05304     nOld&gt;=2 ? pgnoOld[1] : 0,
<a name="l05305"></a>05305     nOld&gt;=3 ? pgnoOld[2] : 0,
<a name="l05306"></a>05306     pgnoNew[0], szNew[0],
<a name="l05307"></a>05307     nNew&gt;=2 ? pgnoNew[1] : 0, nNew&gt;=2 ? szNew[1] : 0,
<a name="l05308"></a>05308     nNew&gt;=3 ? pgnoNew[2] : 0, nNew&gt;=3 ? szNew[2] : 0,
<a name="l05309"></a>05309     nNew&gt;=4 ? pgnoNew[3] : 0, nNew&gt;=4 ? szNew[3] : 0,
<a name="l05310"></a>05310     nNew&gt;=5 ? pgnoNew[4] : 0, nNew&gt;=5 ? szNew[4] : 0));
<a name="l05311"></a>05311 
<a name="l05312"></a>05312   <span class="comment">/*</span>
<a name="l05313"></a>05313 <span class="comment">  ** Evenly distribute the data in apCell[] across the new pages.</span>
<a name="l05314"></a>05314 <span class="comment">  ** Insert divider cells into pParent as necessary.</span>
<a name="l05315"></a>05315 <span class="comment">  */</span>
<a name="l05316"></a>05316   j = 0;
<a name="l05317"></a>05317   <span class="keywordflow">for</span>(i=0; i&lt;nNew; i++){
<a name="l05318"></a>05318     <span class="comment">/* Assemble the new sibling page. */</span>
<a name="l05319"></a>05319     <a class="code" href="structMemPage.html">MemPage</a> *pNew = apNew[i];
<a name="l05320"></a>05320     assert( j&lt;nMaxCells );
<a name="l05321"></a>05321     assert( pNew-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>==pgnoNew[i] );
<a name="l05322"></a>05322     <a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">zeroPage</a>(pNew, pageFlags);
<a name="l05323"></a>05323     <a class="code" href="btree_8c.html#af511b4a8276006e01a7a50d009972d88">assemblePage</a>(pNew, cntNew[i]-j, &amp;apCell[j], &amp;szCell[j]);
<a name="l05324"></a>05324     assert( pNew-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>&gt;0 || (nNew==1 &amp;&amp; cntNew[0]==0) );
<a name="l05325"></a>05325     assert( pNew-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==0 );
<a name="l05326"></a>05326 
<a name="l05327"></a>05327     <span class="comment">/* If this is an auto-vacuum database, update the pointer map entries</span>
<a name="l05328"></a>05328 <span class="comment">    ** that point to the siblings that were rearranged. These can be: left</span>
<a name="l05329"></a>05329 <span class="comment">    ** children of cells, the right-child of the page, or overflow pages</span>
<a name="l05330"></a>05330 <span class="comment">    ** pointed to by cells.</span>
<a name="l05331"></a>05331 <span class="comment">    */</span>
<a name="l05332"></a>05332     <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l05333"></a>05333       <span class="keywordflow">for</span>(k=j; k&lt;cntNew[i]; k++){
<a name="l05334"></a>05334         assert( k&lt;nMaxCells );
<a name="l05335"></a>05335         <span class="keywordflow">if</span>( aFrom[k]==0xFF || apCopy[aFrom[k]]-&gt;pgno!=pNew-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a> ){
<a name="l05336"></a>05336           rc = <a class="code" href="btree_8c.html#a4cf3751ebbf00f1d6405e916c95fbd6e">ptrmapPutOvfl</a>(pNew, k-j);
<a name="l05337"></a>05337           <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; leafCorrection==0 ){
<a name="l05338"></a>05338             rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(apCell[k]), <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, pNew-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l05339"></a>05339           }
<a name="l05340"></a>05340           <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05341"></a>05341             <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05342"></a>05342           }
<a name="l05343"></a>05343         }
<a name="l05344"></a>05344       }
<a name="l05345"></a>05345     }
<a name="l05346"></a>05346 
<a name="l05347"></a>05347     j = cntNew[i];
<a name="l05348"></a>05348 
<a name="l05349"></a>05349     <span class="comment">/* If the sibling page assembled above was not the right-most sibling,</span>
<a name="l05350"></a>05350 <span class="comment">    ** insert a divider cell into the parent page.</span>
<a name="l05351"></a>05351 <span class="comment">    */</span>
<a name="l05352"></a>05352     <span class="keywordflow">if</span>( i&lt;nNew-1 &amp;&amp; j&lt;nCell ){
<a name="l05353"></a>05353       <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell;
<a name="l05354"></a>05354       <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pTemp;
<a name="l05355"></a>05355       <span class="keywordtype">int</span> sz;
<a name="l05356"></a>05356 
<a name="l05357"></a>05357       assert( j&lt;nMaxCells );
<a name="l05358"></a>05358       pCell = apCell[j];
<a name="l05359"></a>05359       sz = szCell[j] + leafCorrection;
<a name="l05360"></a>05360       pTemp = &amp;aSpace2[iSpace2];
<a name="l05361"></a>05361       <span class="keywordflow">if</span>( !pNew-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l05362"></a>05362         memcpy(&amp;pNew-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[8], pCell, 4);
<a name="l05363"></a>05363         <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> 
<a name="l05364"></a>05364          &amp;&amp; (aFrom[j]==0xFF || apCopy[aFrom[j]]-&gt;pgno!=pNew-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>)
<a name="l05365"></a>05365         ){
<a name="l05366"></a>05366           rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pCell), <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, pNew-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l05367"></a>05367           <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05368"></a>05368             <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05369"></a>05369           }
<a name="l05370"></a>05370         }
<a name="l05371"></a>05371       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( leafData ){
<a name="l05372"></a>05372         <span class="comment">/* If the tree is a leaf-data tree, and the siblings are leaves, </span>
<a name="l05373"></a>05373 <span class="comment">        ** then there is no divider cell in apCell[]. Instead, the divider </span>
<a name="l05374"></a>05374 <span class="comment">        ** cell consists of the integer key for the right-most cell of </span>
<a name="l05375"></a>05375 <span class="comment">        ** the sibling-page assembled above only.</span>
<a name="l05376"></a>05376 <span class="comment">        */</span>
<a name="l05377"></a>05377         <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l05378"></a>05378         j--;
<a name="l05379"></a>05379         <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(pNew, apCell[j], &amp;info);
<a name="l05380"></a>05380         pCell = pTemp;
<a name="l05381"></a>05381         <a class="code" href="btree_8c.html#ab66a77004cf93954f2aae7e52a4e51a7">fillInCell</a>(pParent, pCell, 0, info.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>, 0, 0, 0, &amp;sz);
<a name="l05382"></a>05382         pTemp = 0;
<a name="l05383"></a>05383       }<span class="keywordflow">else</span>{
<a name="l05384"></a>05384         pCell -= 4;
<a name="l05385"></a>05385         <span class="comment">/* Obscure case for non-leaf-data trees: If the cell at pCell was</span>
<a name="l05386"></a>05386 <span class="comment">        ** previously stored on a leaf node, and its reported size was 4</span>
<a name="l05387"></a>05387 <span class="comment">        ** bytes, then it may actually be smaller than this </span>
<a name="l05388"></a>05388 <span class="comment">        ** (see sqlite3BtreeParseCellPtr(), 4 bytes is the minimum size of</span>
<a name="l05389"></a>05389 <span class="comment">        ** any cell). But it is important to pass the correct size to </span>
<a name="l05390"></a>05390 <span class="comment">        ** insertCell(), so reparse the cell now.</span>
<a name="l05391"></a>05391 <span class="comment">        **</span>
<a name="l05392"></a>05392 <span class="comment">        ** Note that this can never happen in an SQLite data file, as all</span>
<a name="l05393"></a>05393 <span class="comment">        ** cells are at least 4 bytes. It only happens in b-trees used</span>
<a name="l05394"></a>05394 <span class="comment">        ** to evaluate &quot;IN (SELECT ...)&quot; and similar clauses.</span>
<a name="l05395"></a>05395 <span class="comment">        */</span>
<a name="l05396"></a>05396         <span class="keywordflow">if</span>( szCell[j]==4 ){
<a name="l05397"></a>05397           assert(leafCorrection==4);
<a name="l05398"></a>05398           sz = <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pParent, pCell);
<a name="l05399"></a>05399         }
<a name="l05400"></a>05400       }
<a name="l05401"></a>05401       iSpace2 += sz;
<a name="l05402"></a>05402       assert( sz&lt;=pBt-&gt;pageSize/4 );
<a name="l05403"></a>05403       assert( iSpace2&lt;=pBt-&gt;pageSize );
<a name="l05404"></a>05404       rc = <a class="code" href="btree_8c.html#ad9f11315b51b8014695e6fdc9a43c505">insertCell</a>(pParent, nxDiv, pCell, sz, pTemp, 4);
<a name="l05405"></a>05405       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05406"></a>05406       <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(<a class="code" href="btree_8c.html#a4789c15455047776c4cca9c18cc6ec65">findOverflowCell</a>(pParent,nxDiv), pNew-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l05407"></a>05407 
<a name="l05408"></a>05408       <span class="comment">/* If this is an auto-vacuum database, and not a leaf-data tree,</span>
<a name="l05409"></a>05409 <span class="comment">      ** then update the pointer map with an entry for the overflow page</span>
<a name="l05410"></a>05410 <span class="comment">      ** that the cell just inserted points to (if any).</span>
<a name="l05411"></a>05411 <span class="comment">      */</span>
<a name="l05412"></a>05412       <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> &amp;&amp; !leafData ){
<a name="l05413"></a>05413         rc = <a class="code" href="btree_8c.html#a4cf3751ebbf00f1d6405e916c95fbd6e">ptrmapPutOvfl</a>(pParent, nxDiv);
<a name="l05414"></a>05414         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05415"></a>05415           <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05416"></a>05416         }
<a name="l05417"></a>05417       }
<a name="l05418"></a>05418       j++;
<a name="l05419"></a>05419       nxDiv++;
<a name="l05420"></a>05420     }
<a name="l05421"></a>05421 
<a name="l05422"></a>05422     <span class="comment">/* Set the pointer-map entry for the new sibling page. */</span>
<a name="l05423"></a>05423     <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l05424"></a>05424       rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, pNew-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, pParent-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l05425"></a>05425       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05426"></a>05426         <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05427"></a>05427       }
<a name="l05428"></a>05428     }
<a name="l05429"></a>05429   }
<a name="l05430"></a>05430   assert( j==nCell );
<a name="l05431"></a>05431   assert( nOld&gt;0 );
<a name="l05432"></a>05432   assert( nNew&gt;0 );
<a name="l05433"></a>05433   <span class="keywordflow">if</span>( (pageFlags &amp; <a class="code" href="btreeInt_8h.html#a75a736a457cd09a431cef0c66aa45ce6">PTF_LEAF</a>)==0 ){
<a name="l05434"></a>05434     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *zChild = &amp;apCopy[nOld-1]-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[8];
<a name="l05435"></a>05435     memcpy(&amp;apNew[nNew-1]-&gt;aData[8], zChild, 4);
<a name="l05436"></a>05436     <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l05437"></a>05437       rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(zChild), <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, apNew[nNew-1]-&gt;pgno);
<a name="l05438"></a>05438       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05439"></a>05439         <span class="keywordflow">goto</span> balance_cleanup;
<a name="l05440"></a>05440       }
<a name="l05441"></a>05441     }
<a name="l05442"></a>05442   }
<a name="l05443"></a>05443   <span class="keywordflow">if</span>( nxDiv==pParent-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>+pParent-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a> ){
<a name="l05444"></a>05444     <span class="comment">/* Right-most sibling is the right-most child of pParent */</span>
<a name="l05445"></a>05445     <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pParent-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pParent-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8], pgnoNew[nNew-1]);
<a name="l05446"></a>05446   }<span class="keywordflow">else</span>{
<a name="l05447"></a>05447     <span class="comment">/* Right-most sibling is the left child of the first entry in pParent</span>
<a name="l05448"></a>05448 <span class="comment">    ** past the right-most divider entry */</span>
<a name="l05449"></a>05449     <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(<a class="code" href="btree_8c.html#a4789c15455047776c4cca9c18cc6ec65">findOverflowCell</a>(pParent, nxDiv), pgnoNew[nNew-1]);
<a name="l05450"></a>05450   }
<a name="l05451"></a>05451 
<a name="l05452"></a>05452   <span class="comment">/*</span>
<a name="l05453"></a>05453 <span class="comment">  ** Balance the parent page.  Note that the current page (pPage) might</span>
<a name="l05454"></a>05454 <span class="comment">  ** have been added to the freelist so it might no longer be initialized.</span>
<a name="l05455"></a>05455 <span class="comment">  ** But the parent page will always be initialized.</span>
<a name="l05456"></a>05456 <span class="comment">  */</span>
<a name="l05457"></a>05457   assert( pParent-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> );
<a name="l05458"></a>05458   <a class="code" href="malloc_8c.html#a284ee59ccd166a12506716ef49b2d2a5">sqlite3ScratchFree</a>(apCell);
<a name="l05459"></a>05459   apCell = 0;
<a name="l05460"></a>05460   <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l05461"></a>05461   pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>--;
<a name="l05462"></a>05462   rc = <a class="code" href="btree_8c.html#abee055e19b090d89ef7f3ba60aac24ff">balance</a>(pCur, 0);
<a name="l05463"></a>05463   
<a name="l05464"></a>05464   <span class="comment">/*</span>
<a name="l05465"></a>05465 <span class="comment">  ** Cleanup before returning.</span>
<a name="l05466"></a>05466 <span class="comment">  */</span>
<a name="l05467"></a>05467 balance_cleanup:
<a name="l05468"></a>05468   <a class="code" href="pcache_8c.html#acc509b3b0633dde5f0f65e3964993a6d">sqlite3PageFree</a>(aSpace2);
<a name="l05469"></a>05469   <a class="code" href="malloc_8c.html#a284ee59ccd166a12506716ef49b2d2a5">sqlite3ScratchFree</a>(apCell);
<a name="l05470"></a>05470   <span class="keywordflow">for</span>(i=0; i&lt;nOld; i++){
<a name="l05471"></a>05471     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(apOld[i]);
<a name="l05472"></a>05472   }
<a name="l05473"></a>05473   <span class="keywordflow">for</span>(i=0; i&lt;nNew; i++){
<a name="l05474"></a>05474     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(apNew[i]);
<a name="l05475"></a>05475   }
<a name="l05476"></a>05476 
<a name="l05477"></a>05477   <span class="comment">/* releasePage(pParent); */</span>
<a name="l05478"></a>05478   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;BALANCE: finished with %d: old=%d new=%d cells=%d\n&quot;</span>,
<a name="l05479"></a>05479           pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, nOld, nNew, nCell));
<a name="l05480"></a>05480 
<a name="l05481"></a>05481   <span class="keywordflow">return</span> rc;
<a name="l05482"></a>05482 }
<a name="l05483"></a>05483 
<a name="l05484"></a>05484 <span class="comment">/*</span>
<a name="l05485"></a>05485 <span class="comment">** This routine is called for the root page of a btree when the root</span>
<a name="l05486"></a>05486 <span class="comment">** page contains no cells.  This is an opportunity to make the tree</span>
<a name="l05487"></a>05487 <span class="comment">** shallower by one level.</span>
<a name="l05488"></a>05488 <span class="comment">*/</span>
<a name="l05489"></a><a class="code" href="btree_8c.html#a873be5991fb2758d89943eab33f19ce4">05489</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a873be5991fb2758d89943eab33f19ce4">balance_shallower</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l05490"></a>05490   <a class="code" href="structMemPage.html">MemPage</a> *pPage;              <span class="comment">/* Root page of B-Tree */</span>
<a name="l05491"></a>05491   <a class="code" href="structMemPage.html">MemPage</a> *pChild;             <span class="comment">/* The only child page of pPage */</span>
<a name="l05492"></a>05492   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoChild;              <span class="comment">/* Page number for pChild */</span>
<a name="l05493"></a>05493   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;          <span class="comment">/* Return code from subprocedures */</span>
<a name="l05494"></a>05494   <a class="code" href="structBtShared.html">BtShared</a> *pBt;                  <span class="comment">/* The main BTree structure */</span>
<a name="l05495"></a>05495   <span class="keywordtype">int</span> mxCellPerPage;           <span class="comment">/* Maximum number of cells per page */</span>
<a name="l05496"></a>05496   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> **apCell;                 <span class="comment">/* All cells from pages being balanced */</span>
<a name="l05497"></a>05497   <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> *szCell;                 <span class="comment">/* Local size of all cells */</span>
<a name="l05498"></a>05498 
<a name="l05499"></a>05499   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>==0 );
<a name="l05500"></a>05500   pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0];
<a name="l05501"></a>05501 
<a name="l05502"></a>05502   assert( pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>==0 );
<a name="l05503"></a>05503   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l05504"></a>05504   pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l05505"></a>05505   mxCellPerPage = <a class="code" href="btreeInt_8h.html#a5f4299af45c4457a1fcfcfe188e14017">MX_CELL</a>(pBt);
<a name="l05506"></a>05506   apCell = <a class="code" href="malloc_8c.html#a8c1a33577a57524c7c6eef3d9e64e742">sqlite3Malloc</a>( mxCellPerPage*(<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)+<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a>)) );
<a name="l05507"></a>05507   <span class="keywordflow">if</span>( apCell==0 ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l05508"></a>05508   szCell = (<a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a>*)&amp;apCell[mxCellPerPage];
<a name="l05509"></a>05509   <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l05510"></a>05510     <span class="comment">/* The table is completely empty */</span>
<a name="l05511"></a>05511     <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;BALANCE: empty table %d\n&quot;</span>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l05512"></a>05512   }<span class="keywordflow">else</span>{
<a name="l05513"></a>05513     <span class="comment">/* The root page is empty but has one child.  Transfer the</span>
<a name="l05514"></a>05514 <span class="comment">    ** information from that one child into the root page if it </span>
<a name="l05515"></a>05515 <span class="comment">    ** will fit.  This reduces the depth of the tree by one.</span>
<a name="l05516"></a>05516 <span class="comment">    **</span>
<a name="l05517"></a>05517 <span class="comment">    ** If the root page is page 1, it has less space available than</span>
<a name="l05518"></a>05518 <span class="comment">    ** its child (due to the 100 byte header that occurs at the beginning</span>
<a name="l05519"></a>05519 <span class="comment">    ** of the database fle), so it might not be able to hold all of the </span>
<a name="l05520"></a>05520 <span class="comment">    ** information currently contained in the child.  If this is the </span>
<a name="l05521"></a>05521 <span class="comment">    ** case, then do not do the transfer.  Leave page 1 empty except</span>
<a name="l05522"></a>05522 <span class="comment">    ** for the right-pointer to the child page.  The child page becomes</span>
<a name="l05523"></a>05523 <span class="comment">    ** the virtual root of the tree.</span>
<a name="l05524"></a>05524 <span class="comment">    */</span>
<a name="l05525"></a>05525     <a class="code" href="btree_8c.html#ad2f62e901555bee1364572b9d1c0c536">VVA_ONLY</a>( pCur-&gt;pagesShuffled = 1 );
<a name="l05526"></a>05526     pgnoChild = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8]);
<a name="l05527"></a>05527     assert( pgnoChild&gt;0 );
<a name="l05528"></a>05528     assert( pgnoChild&lt;=<a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>) );
<a name="l05529"></a>05529     rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>, pgnoChild, &amp;pChild, 0);
<a name="l05530"></a>05530     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> end_shallow_balance;
<a name="l05531"></a>05531     <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>==1 ){
<a name="l05532"></a>05532       rc = <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(pChild);
<a name="l05533"></a>05533       <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> end_shallow_balance;
<a name="l05534"></a>05534       assert( pChild-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==0 );
<a name="l05535"></a>05535       <span class="keywordflow">if</span>( pChild-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>&gt;=100 ){
<a name="l05536"></a>05536         <span class="comment">/* The child information will fit on the root page, so do the</span>
<a name="l05537"></a>05537 <span class="comment">        ** copy */</span>
<a name="l05538"></a>05538         <span class="keywordtype">int</span> i;
<a name="l05539"></a>05539         <a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">zeroPage</a>(pPage, pChild-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0]);
<a name="l05540"></a>05540         <span class="keywordflow">for</span>(i=0; i&lt;pChild-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>; i++){
<a name="l05541"></a>05541           apCell[i] = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pChild,i);
<a name="l05542"></a>05542           szCell[i] = <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pChild, apCell[i]);
<a name="l05543"></a>05543         }
<a name="l05544"></a>05544         <a class="code" href="btree_8c.html#af511b4a8276006e01a7a50d009972d88">assemblePage</a>(pPage, pChild-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>, apCell, szCell);
<a name="l05545"></a>05545         <span class="comment">/* Copy the right-pointer of the child to the parent. */</span>
<a name="l05546"></a>05546         <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8], 
<a name="l05547"></a>05547             <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pChild-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pChild-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8]));
<a name="l05548"></a>05548         <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(pChild);
<a name="l05549"></a>05549         <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;BALANCE: child %d transfer to page 1\n&quot;</span>, pChild-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l05550"></a>05550       }<span class="keywordflow">else</span>{
<a name="l05551"></a>05551         <span class="comment">/* The child has more information that will fit on the root.</span>
<a name="l05552"></a>05552 <span class="comment">        ** The tree is already balanced.  Do nothing. */</span>
<a name="l05553"></a>05553         <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;BALANCE: child %d will not fit on page 1\n&quot;</span>, pChild-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l05554"></a>05554       }
<a name="l05555"></a>05555     }<span class="keywordflow">else</span>{
<a name="l05556"></a>05556       memcpy(pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>, pChild-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>, pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>);
<a name="l05557"></a>05557       pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> = 0;
<a name="l05558"></a>05558       rc = <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(pPage);
<a name="l05559"></a>05559       assert( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> );
<a name="l05560"></a>05560       <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(pChild);
<a name="l05561"></a>05561       <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;BALANCE: transfer child %d into root %d\n&quot;</span>,
<a name="l05562"></a>05562               pChild-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l05563"></a>05563     }
<a name="l05564"></a>05564     assert( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==0 );
<a name="l05565"></a>05565 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l05566"></a>05566 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l05567"></a>05567       rc = <a class="code" href="btree_8c.html#adf2ff6d11495ca47f88ace93f5be9d91">setChildPtrmaps</a>(pPage);
<a name="l05568"></a>05568     }
<a name="l05569"></a>05569 <span class="preprocessor">#endif</span>
<a name="l05570"></a>05570 <span class="preprocessor"></span>    <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pChild);
<a name="l05571"></a>05571   }
<a name="l05572"></a>05572 end_shallow_balance:
<a name="l05573"></a>05573   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(apCell);
<a name="l05574"></a>05574   <span class="keywordflow">return</span> rc;
<a name="l05575"></a>05575 }
<a name="l05576"></a>05576 
<a name="l05577"></a>05577 
<a name="l05578"></a>05578 <span class="comment">/*</span>
<a name="l05579"></a>05579 <span class="comment">** The root page is overfull</span>
<a name="l05580"></a>05580 <span class="comment">**</span>
<a name="l05581"></a>05581 <span class="comment">** When this happens, Create a new child page and copy the</span>
<a name="l05582"></a>05582 <span class="comment">** contents of the root into the child.  Then make the root</span>
<a name="l05583"></a>05583 <span class="comment">** page an empty page with rightChild pointing to the new</span>
<a name="l05584"></a>05584 <span class="comment">** child.   Finally, call balance_internal() on the new child</span>
<a name="l05585"></a>05585 <span class="comment">** to cause it to split.</span>
<a name="l05586"></a>05586 <span class="comment">*/</span>
<a name="l05587"></a><a class="code" href="btree_8c.html#aa88585458e70481d4f87c2e7429ba7d6">05587</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aa88585458e70481d4f87c2e7429ba7d6">balance_deeper</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l05588"></a>05588   <span class="keywordtype">int</span> rc;             <span class="comment">/* Return value from subprocedures */</span>
<a name="l05589"></a>05589   <a class="code" href="structMemPage.html">MemPage</a> *pPage;     <span class="comment">/* Pointer to the root page */</span>
<a name="l05590"></a>05590   <a class="code" href="structMemPage.html">MemPage</a> *pChild;    <span class="comment">/* Pointer to a new child page */</span>
<a name="l05591"></a>05591   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoChild;     <span class="comment">/* Page number of the new child page */</span>
<a name="l05592"></a>05592   <a class="code" href="structBtShared.html">BtShared</a> *pBt;         <span class="comment">/* The BTree */</span>
<a name="l05593"></a>05593   <span class="keywordtype">int</span> usableSize;     <span class="comment">/* Total usable size of a page */</span>
<a name="l05594"></a>05594   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *data;           <span class="comment">/* Content of the parent page */</span>
<a name="l05595"></a>05595   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *cdata;          <span class="comment">/* Content of the child page */</span>
<a name="l05596"></a>05596   <span class="keywordtype">int</span> hdr;            <span class="comment">/* Offset to page header in parent */</span>
<a name="l05597"></a>05597   <span class="keywordtype">int</span> cbrk;           <span class="comment">/* Offset to content of first cell in parent */</span>
<a name="l05598"></a>05598 
<a name="l05599"></a>05599   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>==0 );
<a name="l05600"></a>05600   assert( pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0]-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>&gt;0 );
<a name="l05601"></a>05601 
<a name="l05602"></a>05602   <a class="code" href="btree_8c.html#ad2f62e901555bee1364572b9d1c0c536">VVA_ONLY</a>( pCur-&gt;pagesShuffled = 1 );
<a name="l05603"></a>05603   pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[0];
<a name="l05604"></a>05604   pBt = pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>;
<a name="l05605"></a>05605   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l05606"></a>05606   rc = <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(pBt, &amp;pChild, &amp;pgnoChild, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, 0);
<a name="l05607"></a>05607   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l05608"></a>05608   assert( sqlite3PagerIswriteable(pChild-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l05609"></a>05609   usableSize = pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>;
<a name="l05610"></a>05610   data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l05611"></a>05611   hdr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>;
<a name="l05612"></a>05612   cbrk = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]);
<a name="l05613"></a>05613   cdata = pChild-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l05614"></a>05614   memcpy(cdata, &amp;data[hdr], pPage-&gt;<a class="code" href="structMemPage.html#a324ed834d93c3ae72994fb5730940521">cellOffset</a>+2*pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>-hdr);
<a name="l05615"></a>05615   memcpy(&amp;cdata[cbrk], &amp;data[cbrk], usableSize-cbrk);
<a name="l05616"></a>05616   
<a name="l05617"></a>05617   rc = <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(pChild);
<a name="l05618"></a>05618   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05619"></a>05619     <span class="keywordtype">int</span> nCopy = pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>*<span class="keyword">sizeof</span>(pPage-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>[0]);
<a name="l05620"></a>05620     memcpy(pChild-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>, pPage-&gt;<a class="code" href="structMemPage.html#a4ac8901d1b123395f2abf3cc60105586">aOvfl</a>, nCopy);
<a name="l05621"></a>05621     pChild-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a> = pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>;
<a name="l05622"></a>05622     <span class="keywordflow">if</span>( pChild-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a> ){
<a name="l05623"></a>05623       pChild-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> = 0;
<a name="l05624"></a>05624     }
<a name="l05625"></a>05625     assert( pChild-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>==pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> );
<a name="l05626"></a>05626     <a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">zeroPage</a>(pPage, pChild-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0] &amp; ~<a class="code" href="btreeInt_8h.html#a75a736a457cd09a431cef0c66aa45ce6">PTF_LEAF</a>);
<a name="l05627"></a>05627     <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8], pgnoChild);
<a name="l05628"></a>05628     <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;BALANCE: copy root %d into %d\n&quot;</span>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, pChild-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l05629"></a>05629     <span class="keywordflow">if</span>( <a class="code" href="btreeInt_8h.html#acc11e7371a1c5bdbdb9fd01f46fd3ec0">ISAUTOVACUUM</a> ){
<a name="l05630"></a>05630       rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, pChild-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>);
<a name="l05631"></a>05631 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l05632"></a>05632 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05633"></a>05633         rc = <a class="code" href="btree_8c.html#adf2ff6d11495ca47f88ace93f5be9d91">setChildPtrmaps</a>(pChild);
<a name="l05634"></a>05634       }
<a name="l05635"></a>05635 <span class="preprocessor">#endif</span>
<a name="l05636"></a>05636 <span class="preprocessor"></span>    }
<a name="l05637"></a>05637   }
<a name="l05638"></a>05638 
<a name="l05639"></a>05639   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05640"></a>05640     pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>++;
<a name="l05641"></a>05641     pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[1] = pChild;
<a name="l05642"></a>05642     pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[0] = 0;
<a name="l05643"></a>05643     rc = <a class="code" href="btree_8c.html#a29b752d2eb8e1766715ed62fb792d486">balance_nonroot</a>(pCur);
<a name="l05644"></a>05644   }<span class="keywordflow">else</span>{
<a name="l05645"></a>05645     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pChild);
<a name="l05646"></a>05646   }
<a name="l05647"></a>05647 
<a name="l05648"></a>05648   <span class="keywordflow">return</span> rc;
<a name="l05649"></a>05649 }
<a name="l05650"></a>05650 
<a name="l05651"></a>05651 <span class="comment">/*</span>
<a name="l05652"></a>05652 <span class="comment">** The page that pCur currently points to has just been modified in</span>
<a name="l05653"></a>05653 <span class="comment">** some way. This function figures out if this modification means the</span>
<a name="l05654"></a>05654 <span class="comment">** tree needs to be balanced, and if so calls the appropriate balancing </span>
<a name="l05655"></a>05655 <span class="comment">** routine.</span>
<a name="l05656"></a>05656 <span class="comment">** </span>
<a name="l05657"></a>05657 <span class="comment">** Parameter isInsert is true if a new cell was just inserted into the</span>
<a name="l05658"></a>05658 <span class="comment">** page, or false otherwise.</span>
<a name="l05659"></a>05659 <span class="comment">*/</span>
<a name="l05660"></a><a class="code" href="btree_8c.html#abee055e19b090d89ef7f3ba60aac24ff">05660</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#abee055e19b090d89ef7f3ba60aac24ff">balance</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur, <span class="keywordtype">int</span> isInsert){
<a name="l05661"></a>05661   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05662"></a>05662   <a class="code" href="structMemPage.html">MemPage</a> *pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l05663"></a>05663 
<a name="l05664"></a>05664   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l05665"></a>05665   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>==0 ){
<a name="l05666"></a>05666     rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l05667"></a>05667     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>&gt;0 ){
<a name="l05668"></a>05668       rc = <a class="code" href="btree_8c.html#aa88585458e70481d4f87c2e7429ba7d6">balance_deeper</a>(pCur);
<a name="l05669"></a>05669     }
<a name="l05670"></a>05670     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>==0 ){
<a name="l05671"></a>05671       rc = <a class="code" href="btree_8c.html#a873be5991fb2758d89943eab33f19ce4">balance_shallower</a>(pCur);
<a name="l05672"></a>05672     }
<a name="l05673"></a>05673   }<span class="keywordflow">else</span>{
<a name="l05674"></a>05674     <span class="keywordflow">if</span>( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>&gt;0 || 
<a name="l05675"></a>05675         (!isInsert &amp;&amp; pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>&gt;pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3) ){
<a name="l05676"></a>05676       rc = <a class="code" href="btree_8c.html#a29b752d2eb8e1766715ed62fb792d486">balance_nonroot</a>(pCur);
<a name="l05677"></a>05677     }
<a name="l05678"></a>05678   }
<a name="l05679"></a>05679   <span class="keywordflow">return</span> rc;
<a name="l05680"></a>05680 }
<a name="l05681"></a>05681 
<a name="l05682"></a>05682 <span class="comment">/*</span>
<a name="l05683"></a>05683 <span class="comment">** This routine checks all cursors that point to table pgnoRoot.</span>
<a name="l05684"></a>05684 <span class="comment">** If any of those cursors were opened with wrFlag==0 in a different</span>
<a name="l05685"></a>05685 <span class="comment">** database connection (a database connection that shares the pager</span>
<a name="l05686"></a>05686 <span class="comment">** cache with the current connection) and that other connection </span>
<a name="l05687"></a>05687 <span class="comment">** is not in the ReadUncommmitted state, then this routine returns </span>
<a name="l05688"></a>05688 <span class="comment">** SQLITE_LOCKED.</span>
<a name="l05689"></a>05689 <span class="comment">**</span>
<a name="l05690"></a>05690 <span class="comment">** As well as cursors with wrFlag==0, cursors with wrFlag==1 and </span>
<a name="l05691"></a>05691 <span class="comment">** isIncrblobHandle==1 are also considered &apos;read&apos; cursors. Incremental </span>
<a name="l05692"></a>05692 <span class="comment">** blob cursors are used for both reading and writing.</span>
<a name="l05693"></a>05693 <span class="comment">**</span>
<a name="l05694"></a>05694 <span class="comment">** When pgnoRoot is the root page of an intkey table, this function is also</span>
<a name="l05695"></a>05695 <span class="comment">** responsible for invalidating incremental blob cursors when the table row</span>
<a name="l05696"></a>05696 <span class="comment">** on which they are opened is deleted or modified. Cursors are invalidated</span>
<a name="l05697"></a>05697 <span class="comment">** according to the following rules:</span>
<a name="l05698"></a>05698 <span class="comment">**</span>
<a name="l05699"></a>05699 <span class="comment">**   1) When BtreeClearTable() is called to completely delete the contents</span>
<a name="l05700"></a>05700 <span class="comment">**      of a B-Tree table, pExclude is set to zero and parameter iRow is </span>
<a name="l05701"></a>05701 <span class="comment">**      set to non-zero. In this case all incremental blob cursors open</span>
<a name="l05702"></a>05702 <span class="comment">**      on the table rooted at pgnoRoot are invalidated.</span>
<a name="l05703"></a>05703 <span class="comment">**</span>
<a name="l05704"></a>05704 <span class="comment">**   2) When BtreeInsert(), BtreeDelete() or BtreePutData() is called to </span>
<a name="l05705"></a>05705 <span class="comment">**      modify a table row via an SQL statement, pExclude is set to the </span>
<a name="l05706"></a>05706 <span class="comment">**      write cursor used to do the modification and parameter iRow is set</span>
<a name="l05707"></a>05707 <span class="comment">**      to the integer row id of the B-Tree entry being modified. Unless</span>
<a name="l05708"></a>05708 <span class="comment">**      pExclude is itself an incremental blob cursor, then all incremental</span>
<a name="l05709"></a>05709 <span class="comment">**      blob cursors open on row iRow of the B-Tree are invalidated.</span>
<a name="l05710"></a>05710 <span class="comment">**</span>
<a name="l05711"></a>05711 <span class="comment">**   3) If both pExclude and iRow are set to zero, no incremental blob </span>
<a name="l05712"></a>05712 <span class="comment">**      cursors are invalidated.</span>
<a name="l05713"></a>05713 <span class="comment">*/</span>
<a name="l05714"></a><a class="code" href="btree_8c.html#accb60c0dac28fa55737649f0c556eef9">05714</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#accb60c0dac28fa55737649f0c556eef9">checkReadLocks</a>(
<a name="l05715"></a>05715   <a class="code" href="structBtree.html">Btree</a> *pBtree, 
<a name="l05716"></a>05716   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoRoot, 
<a name="l05717"></a>05717   <a class="code" href="structBtCursor.html">BtCursor</a> *pExclude,
<a name="l05718"></a>05718   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> iRow
<a name="l05719"></a>05719 ){
<a name="l05720"></a>05720   <a class="code" href="structBtCursor.html">BtCursor</a> *p;
<a name="l05721"></a>05721   <a class="code" href="structBtShared.html">BtShared</a> *pBt = pBtree-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l05722"></a>05722   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pBtree-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l05723"></a>05723   assert( sqlite3BtreeHoldsMutex(pBtree) );
<a name="l05724"></a>05724   <span class="keywordflow">for</span>(p=pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a>; p; p=p-&gt;<a class="code" href="structBtCursor.html#ad2f8fe3aa7d3fa3309692b3e8a8c2395">pNext</a>){
<a name="l05725"></a>05725     <span class="keywordflow">if</span>( p==pExclude ) <span class="keywordflow">continue</span>;
<a name="l05726"></a>05726     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>!=pgnoRoot ) <span class="keywordflow">continue</span>;
<a name="l05727"></a>05727 <span class="preprocessor">#ifndef SQLITE_OMIT_INCRBLOB</span>
<a name="l05728"></a>05728 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtCursor.html#a539dc1beff0ec303cfd4c94c274c7a9b">isIncrblobHandle</a> &amp;&amp; ( 
<a name="l05729"></a>05729          (!pExclude &amp;&amp; iRow)
<a name="l05730"></a>05730       || (pExclude &amp;&amp; !pExclude-&gt;<a class="code" href="structBtCursor.html#a539dc1beff0ec303cfd4c94c274c7a9b">isIncrblobHandle</a> &amp;&amp; p-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>==iRow)
<a name="l05731"></a>05731     )){
<a name="l05732"></a>05732       p-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> = <a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a>;
<a name="l05733"></a>05733     }
<a name="l05734"></a>05734 <span class="preprocessor">#endif</span>
<a name="l05735"></a>05735 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>!=<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> ) <span class="keywordflow">continue</span>;
<a name="l05736"></a>05736     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtCursor.html#a9482c52d8c85519a3ada18517bf67a47">wrFlag</a>==0 
<a name="l05737"></a>05737 #ifndef SQLITE_OMIT_INCRBLOB
<a name="l05738"></a>05738      || p-&gt;<a class="code" href="structBtCursor.html#a539dc1beff0ec303cfd4c94c274c7a9b">isIncrblobHandle</a>
<a name="l05739"></a>05739 #endif
<a name="l05740"></a>05740     ){
<a name="l05741"></a>05741       <a class="code" href="structsqlite3.html">sqlite3</a> *dbOther = p-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l05742"></a>05742       <span class="keywordflow">if</span>( dbOther==0 ||
<a name="l05743"></a>05743          (dbOther!=db &amp;&amp; (dbOther-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#adb6fa03198bc2e2db034979738ab0c27">SQLITE_ReadUncommitted</a>)==0) ){
<a name="l05744"></a>05744         <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>;
<a name="l05745"></a>05745       }
<a name="l05746"></a>05746     }
<a name="l05747"></a>05747   }
<a name="l05748"></a>05748   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l05749"></a>05749 }
<a name="l05750"></a>05750 
<a name="l05751"></a>05751 <span class="comment">/*</span>
<a name="l05752"></a>05752 <span class="comment">** Insert a new record into the BTree.  The key is given by (pKey,nKey)</span>
<a name="l05753"></a>05753 <span class="comment">** and the data is given by (pData,nData).  The cursor is used only to</span>
<a name="l05754"></a>05754 <span class="comment">** define what table the record should be inserted into.  The cursor</span>
<a name="l05755"></a>05755 <span class="comment">** is left pointing at a random location.</span>
<a name="l05756"></a>05756 <span class="comment">**</span>
<a name="l05757"></a>05757 <span class="comment">** For an INTKEY table, only the nKey value of the key is used.  pKey is</span>
<a name="l05758"></a>05758 <span class="comment">** ignored.  For a ZERODATA table, the pData and nData are both ignored.</span>
<a name="l05759"></a>05759 <span class="comment">*/</span>
<a name="l05760"></a><a class="code" href="btree_8h.html#af5630692a8518cc52d221c2709f0b55f">05760</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ac8350b4906a921dc24f69e4c14b202ff">sqlite3BtreeInsert</a>(
<a name="l05761"></a>05761   <a class="code" href="structBtCursor.html">BtCursor</a> *pCur,                <span class="comment">/* Insert data into the table of this cursor */</span>
<a name="l05762"></a>05762   <span class="keyword">const</span> <span class="keywordtype">void</span> *pKey, <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> nKey,    <span class="comment">/* The key of the new record */</span>
<a name="l05763"></a>05763   <span class="keyword">const</span> <span class="keywordtype">void</span> *pData, <span class="keywordtype">int</span> nData,  <span class="comment">/* The data of the new record */</span>
<a name="l05764"></a>05764   <span class="keywordtype">int</span> nZero,                     <span class="comment">/* Number of extra 0 bytes to append to data */</span>
<a name="l05765"></a>05765   <span class="keywordtype">int</span> appendBias                 <span class="comment">/* True if this is likely an append */</span>
<a name="l05766"></a>05766 ){
<a name="l05767"></a>05767   <span class="keywordtype">int</span> rc;
<a name="l05768"></a>05768   <span class="keywordtype">int</span> loc;
<a name="l05769"></a>05769   <span class="keywordtype">int</span> szNew;
<a name="l05770"></a>05770   <span class="keywordtype">int</span> idx;
<a name="l05771"></a>05771   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l05772"></a>05772   <a class="code" href="structBtree.html">Btree</a> *p = pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>;
<a name="l05773"></a>05773   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l05774"></a>05774   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *oldCell;
<a name="l05775"></a>05775   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *newCell = 0;
<a name="l05776"></a>05776 
<a name="l05777"></a>05777   assert( cursorHoldsMutex(pCur) );
<a name="l05778"></a>05778   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>!=<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l05779"></a>05779     <span class="comment">/* Must start a transaction before doing an insert */</span>
<a name="l05780"></a>05780     rc = pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ? <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a> : <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l05781"></a>05781     <span class="keywordflow">return</span> rc;
<a name="l05782"></a>05782   }
<a name="l05783"></a>05783   assert( !pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> );
<a name="l05784"></a>05784   <span class="keywordflow">if</span>( !pCur-&gt;<a class="code" href="structBtCursor.html#a9482c52d8c85519a3ada18517bf67a47">wrFlag</a> ){
<a name="l05785"></a>05785     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#af2561d6fe38a527e46e24db1952ee53a">SQLITE_PERM</a>;   <span class="comment">/* Cursor not open for writing */</span>
<a name="l05786"></a>05786   }
<a name="l05787"></a>05787   <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#accb60c0dac28fa55737649f0c556eef9">checkReadLocks</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>, pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, pCur, nKey) ){
<a name="l05788"></a>05788     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>; <span class="comment">/* The table pCur points to has a read lock */</span>
<a name="l05789"></a>05789   }
<a name="l05790"></a>05790   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a3906ad079a2cc489d948fcbbe3035e42">CURSOR_FAULT</a> ){
<a name="l05791"></a>05791     <span class="keywordflow">return</span> pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a>;
<a name="l05792"></a>05792   }
<a name="l05793"></a>05793 
<a name="l05794"></a>05794   <span class="comment">/* Save the positions of any other cursors open on this table */</span>
<a name="l05795"></a>05795   <a class="code" href="btree_8c.html#a1b4b9b532ff7779a50f6482c723b3b50">sqlite3BtreeClearCursor</a>(pCur);
<a name="l05796"></a>05796   <span class="keywordflow">if</span>( 
<a name="l05797"></a>05797     <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=(rc = <a class="code" href="btree_8c.html#add0c7a5086792caf465148beaadb913d">saveAllCursors</a>(pBt, pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, pCur)) ||
<a name="l05798"></a>05798     <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=(rc = <a class="code" href="btree_8c.html#a0ae0770006edd874a30bcbbe303ee31d">sqlite3BtreeMoveto</a>(pCur, pKey, nKey, appendBias, &amp;loc))
<a name="l05799"></a>05799   ){
<a name="l05800"></a>05800     <span class="keywordflow">return</span> rc;
<a name="l05801"></a>05801   }
<a name="l05802"></a>05802 
<a name="l05803"></a>05803   pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l05804"></a>05804   assert( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> || nKey&gt;=0 );
<a name="l05805"></a>05805   assert( pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> || !pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> );
<a name="l05806"></a>05806   <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;INSERT: table=%d nkey=%lld ndata=%d page=%d %s\n&quot;</span>,
<a name="l05807"></a>05807           pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, nKey, nData, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>,
<a name="l05808"></a>05808           loc==0 ? <span class="stringliteral">&quot;overwrite&quot;</span> : <span class="stringliteral">&quot;new entry&quot;</span>));
<a name="l05809"></a>05809   assert( pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> );
<a name="l05810"></a>05810   <a class="code" href="btree_8c.html#a392335de1138023e2acc7d684caa9e66">allocateTempSpace</a>(pBt);
<a name="l05811"></a>05811   newCell = pBt-&gt;<a class="code" href="structBtShared.html#a89102c20327da8a304f7e95af557bdf4">pTmpSpace</a>;
<a name="l05812"></a>05812   <span class="keywordflow">if</span>( newCell==0 ) <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l05813"></a>05813   rc = <a class="code" href="btree_8c.html#ab66a77004cf93954f2aae7e52a4e51a7">fillInCell</a>(pPage, newCell, pKey, nKey, pData, nData, nZero, &amp;szNew);
<a name="l05814"></a>05814   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> end_insert;
<a name="l05815"></a>05815   assert( szNew==<a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pPage, newCell) );
<a name="l05816"></a>05816   assert( szNew&lt;=<a class="code" href="btreeInt_8h.html#a62abfe072e83ebc1a16bcb22419cca6c">MX_CELL_SIZE</a>(pBt) );
<a name="l05817"></a>05817   idx = pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l05818"></a>05818   <span class="keywordflow">if</span>( loc==0 &amp;&amp; <a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a>==pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a> ){
<a name="l05819"></a>05819     <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> szOld;
<a name="l05820"></a>05820     assert( idx&lt;pPage-&gt;nCell );
<a name="l05821"></a>05821     rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l05822"></a>05822     <span class="keywordflow">if</span>( rc ){
<a name="l05823"></a>05823       <span class="keywordflow">goto</span> end_insert;
<a name="l05824"></a>05824     }
<a name="l05825"></a>05825     oldCell = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, idx);
<a name="l05826"></a>05826     <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l05827"></a>05827       memcpy(newCell, oldCell, 4);
<a name="l05828"></a>05828     }
<a name="l05829"></a>05829     szOld = <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pPage, oldCell);
<a name="l05830"></a>05830     rc = <a class="code" href="btree_8c.html#acce36127359eb4baec99dac6d630bd9d">clearCell</a>(pPage, oldCell);
<a name="l05831"></a>05831     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> end_insert;
<a name="l05832"></a>05832     rc = <a class="code" href="btree_8c.html#a7d153c46e2326e23931ac95a72f7a38d">dropCell</a>(pPage, idx, szOld);
<a name="l05833"></a>05833     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) {
<a name="l05834"></a>05834       <span class="keywordflow">goto</span> end_insert;
<a name="l05835"></a>05835     }
<a name="l05836"></a>05836   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( loc&lt;0 &amp;&amp; pPage-&gt;nCell&gt;0 ){
<a name="l05837"></a>05837     assert( pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> );
<a name="l05838"></a>05838     idx = ++pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l05839"></a>05839     pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#ace78ab5eb5337b686e31b895feeb0562">nSize</a> = 0;
<a name="l05840"></a>05840     pCur-&gt;<a class="code" href="structBtCursor.html#a7b64ef18751d3076484903e9e9e05098">validNKey</a> = 0;
<a name="l05841"></a>05841   }<span class="keywordflow">else</span>{
<a name="l05842"></a>05842     assert( pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> );
<a name="l05843"></a>05843   }
<a name="l05844"></a>05844   rc = <a class="code" href="btree_8c.html#ad9f11315b51b8014695e6fdc9a43c505">insertCell</a>(pPage, idx, newCell, szNew, 0, 0);
<a name="l05845"></a>05845   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> end_insert;
<a name="l05846"></a>05846   rc = <a class="code" href="btree_8c.html#abee055e19b090d89ef7f3ba60aac24ff">balance</a>(pCur, 1);
<a name="l05847"></a>05847   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05848"></a>05848     <a class="code" href="btree_8c.html#a2b8fb9bf88e10e7e4dedc8da64e7e956">moveToRoot</a>(pCur);
<a name="l05849"></a>05849   }
<a name="l05850"></a>05850 end_insert:
<a name="l05851"></a>05851   <span class="keywordflow">return</span> rc;
<a name="l05852"></a>05852 }
<a name="l05853"></a>05853 
<a name="l05854"></a>05854 <span class="comment">/*</span>
<a name="l05855"></a>05855 <span class="comment">** Delete the entry that the cursor is pointing to.  The cursor</span>
<a name="l05856"></a>05856 <span class="comment">** is left pointing at a arbitrary location.</span>
<a name="l05857"></a>05857 <span class="comment">*/</span>
<a name="l05858"></a><a class="code" href="btree_8h.html#ab6b2022b3f6a3d0422eef88d87f7a2dd">05858</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#af7b69d3ad801b9277863e15be6639a72">sqlite3BtreeDelete</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l05859"></a>05859   <a class="code" href="structMemPage.html">MemPage</a> *pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l05860"></a>05860   <span class="keywordtype">int</span> idx;
<a name="l05861"></a>05861   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pCell;
<a name="l05862"></a>05862   <span class="keywordtype">int</span> rc;
<a name="l05863"></a>05863   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoChild = 0;
<a name="l05864"></a>05864   <a class="code" href="structBtree.html">Btree</a> *p = pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>;
<a name="l05865"></a>05865   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l05866"></a>05866 
<a name="l05867"></a>05867   assert( cursorHoldsMutex(pCur) );
<a name="l05868"></a>05868   assert( pPage-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> );
<a name="l05869"></a>05869   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>!=<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l05870"></a>05870     <span class="comment">/* Must start a transaction before doing a delete */</span>
<a name="l05871"></a>05871     rc = pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ? <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a> : <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l05872"></a>05872     <span class="keywordflow">return</span> rc;
<a name="l05873"></a>05873   }
<a name="l05874"></a>05874   assert( !pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> );
<a name="l05875"></a>05875   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a3906ad079a2cc489d948fcbbe3035e42">CURSOR_FAULT</a> ){
<a name="l05876"></a>05876     <span class="keywordflow">return</span> pCur-&gt;<a class="code" href="structBtCursor.html#a2abe98b913589b9b0770141c9c8b5118">skip</a>;
<a name="l05877"></a>05877   }
<a name="l05878"></a>05878   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]&gt;=pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> ){
<a name="l05879"></a>05879     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;  <span class="comment">/* The cursor is not pointing to anything */</span>
<a name="l05880"></a>05880   }
<a name="l05881"></a>05881   <span class="keywordflow">if</span>( !pCur-&gt;<a class="code" href="structBtCursor.html#a9482c52d8c85519a3ada18517bf67a47">wrFlag</a> ){
<a name="l05882"></a>05882     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#af2561d6fe38a527e46e24db1952ee53a">SQLITE_PERM</a>;   <span class="comment">/* Did not open this cursor for writing */</span>
<a name="l05883"></a>05883   }
<a name="l05884"></a>05884   <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#accb60c0dac28fa55737649f0c556eef9">checkReadLocks</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>, pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, pCur, pCur-&gt;<a class="code" href="structBtCursor.html#a9934b348c6e9f4808d8f98ea78788fbe">info</a>.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>) ){
<a name="l05885"></a>05885     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>; <span class="comment">/* The table pCur points to has a read lock */</span>
<a name="l05886"></a>05886   }
<a name="l05887"></a>05887 
<a name="l05888"></a>05888   <span class="comment">/* Restore the current cursor position (a no-op if the cursor is not in </span>
<a name="l05889"></a>05889 <span class="comment">  ** CURSOR_REQUIRESEEK state) and save the positions of any other cursors </span>
<a name="l05890"></a>05890 <span class="comment">  ** open on the same table. Then call sqlite3PagerWrite() on the page</span>
<a name="l05891"></a>05891 <span class="comment">  ** that the entry will be deleted from.</span>
<a name="l05892"></a>05892 <span class="comment">  */</span>
<a name="l05893"></a>05893   <span class="keywordflow">if</span>( 
<a name="l05894"></a>05894     (rc = <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCur))!=0 ||
<a name="l05895"></a>05895     (rc = <a class="code" href="btree_8c.html#add0c7a5086792caf465148beaadb913d">saveAllCursors</a>(pBt, pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, pCur))!=0 ||
<a name="l05896"></a>05896     (rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>))!=0
<a name="l05897"></a>05897   ){
<a name="l05898"></a>05898     <span class="keywordflow">return</span> rc;
<a name="l05899"></a>05899   }
<a name="l05900"></a>05900 
<a name="l05901"></a>05901   <span class="comment">/* Locate the cell within its page and leave pCell pointing to the</span>
<a name="l05902"></a>05902 <span class="comment">  ** data. The clearCell() call frees any overflow pages associated with the</span>
<a name="l05903"></a>05903 <span class="comment">  ** cell. The cell itself is still intact.</span>
<a name="l05904"></a>05904 <span class="comment">  */</span>
<a name="l05905"></a>05905   idx = pCur-&gt;<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l05906"></a>05906   pCell = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, idx);
<a name="l05907"></a>05907   <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l05908"></a>05908     pgnoChild = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pCell);
<a name="l05909"></a>05909   }
<a name="l05910"></a>05910   rc = <a class="code" href="btree_8c.html#acce36127359eb4baec99dac6d630bd9d">clearCell</a>(pPage, pCell);
<a name="l05911"></a>05911   <span class="keywordflow">if</span>( rc ){
<a name="l05912"></a>05912     <span class="keywordflow">return</span> rc;
<a name="l05913"></a>05913   }
<a name="l05914"></a>05914 
<a name="l05915"></a>05915   <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l05916"></a>05916     <span class="comment">/*</span>
<a name="l05917"></a>05917 <span class="comment">    ** The entry we are about to delete is not a leaf so if we do not</span>
<a name="l05918"></a>05918 <span class="comment">    ** do something we will leave a hole on an internal page.</span>
<a name="l05919"></a>05919 <span class="comment">    ** We have to fill the hole by moving in a cell from a leaf.  The</span>
<a name="l05920"></a>05920 <span class="comment">    ** next Cell after the one to be deleted is guaranteed to exist and</span>
<a name="l05921"></a>05921 <span class="comment">    ** to be a leaf so we can use it.</span>
<a name="l05922"></a>05922 <span class="comment">    */</span>
<a name="l05923"></a>05923     <a class="code" href="structBtCursor.html">BtCursor</a> leafCur;
<a name="l05924"></a>05924     <a class="code" href="structMemPage.html">MemPage</a> *pLeafPage;
<a name="l05925"></a>05925 
<a name="l05926"></a>05926     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pNext;
<a name="l05927"></a>05927     <span class="keywordtype">int</span> notUsed;
<a name="l05928"></a>05928     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *tempCell = 0;
<a name="l05929"></a>05929     assert( !pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> );
<a name="l05930"></a>05930     <a class="code" href="btree_8c.html#adaa34d465164d3fa306adf517af7faeb">sqlite3BtreeGetTempCursor</a>(pCur, &amp;leafCur);
<a name="l05931"></a>05931     rc = <a class="code" href="btree_8c.html#adf99ca89adc2e91557a41d6d11e97039">sqlite3BtreeNext</a>(&amp;leafCur, &amp;notUsed);
<a name="l05932"></a>05932     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05933"></a>05933       assert( leafCur.<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[leafCur.<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]==0 );
<a name="l05934"></a>05934       pLeafPage = leafCur.<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[leafCur.<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l05935"></a>05935       rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pLeafPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l05936"></a>05936     }
<a name="l05937"></a>05937     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05938"></a>05938       <span class="keywordtype">int</span> leafCursorInvalid = 0;
<a name="l05939"></a>05939       <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> szNext;
<a name="l05940"></a>05940       <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;DELETE: table=%d delete internal from %d replace from leaf %d\n&quot;</span>,
<a name="l05941"></a>05941          pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>, pLeafPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l05942"></a>05942       <a class="code" href="btree_8c.html#a7d153c46e2326e23931ac95a72f7a38d">dropCell</a>(pPage, idx, <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pPage, pCell));
<a name="l05943"></a>05943       pNext = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pLeafPage, 0);
<a name="l05944"></a>05944       szNext = <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pLeafPage, pNext);
<a name="l05945"></a>05945       assert( <a class="code" href="btreeInt_8h.html#a62abfe072e83ebc1a16bcb22419cca6c">MX_CELL_SIZE</a>(pBt)&gt;=szNext+4 );
<a name="l05946"></a>05946       <a class="code" href="btree_8c.html#a392335de1138023e2acc7d684caa9e66">allocateTempSpace</a>(pBt);
<a name="l05947"></a>05947       tempCell = pBt-&gt;<a class="code" href="structBtShared.html#a89102c20327da8a304f7e95af557bdf4">pTmpSpace</a>;
<a name="l05948"></a>05948       <span class="keywordflow">if</span>( tempCell==0 ){
<a name="l05949"></a>05949         rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l05950"></a>05950       }
<a name="l05951"></a>05951       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05952"></a>05952         rc = <a class="code" href="btree_8c.html#ad9f11315b51b8014695e6fdc9a43c505">insertCell</a>(pPage, idx, pNext-4, szNext+4, tempCell, 0);
<a name="l05953"></a>05953       }
<a name="l05954"></a>05954 
<a name="l05955"></a>05955 
<a name="l05956"></a>05956       <span class="comment">/* The &quot;if&quot; statement in the next code block is critical.  The</span>
<a name="l05957"></a>05957 <span class="comment">      ** slightest error in that statement would allow SQLite to operate</span>
<a name="l05958"></a>05958 <span class="comment">      ** correctly most of the time but produce very rare failures.  To</span>
<a name="l05959"></a>05959 <span class="comment">      ** guard against this, the following macros help to verify that</span>
<a name="l05960"></a>05960 <span class="comment">      ** the &quot;if&quot; statement is well tested.</span>
<a name="l05961"></a>05961 <span class="comment">      */</span>
<a name="l05962"></a>05962       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==0 &amp;&amp; pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>&lt;pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3 
<a name="l05963"></a>05963                  &amp;&amp; pLeafPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>+2+szNext &gt; pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3 );
<a name="l05964"></a>05964       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==0 &amp;&amp; pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>==pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3 
<a name="l05965"></a>05965                  &amp;&amp; pLeafPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>+2+szNext &gt; pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3 );
<a name="l05966"></a>05966       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>==0 &amp;&amp; pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>==pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3+1 
<a name="l05967"></a>05967                  &amp;&amp; pLeafPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>+2+szNext &gt; pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3 );
<a name="l05968"></a>05968       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>&gt;0 &amp;&amp; pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>&lt;=pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3
<a name="l05969"></a>05969                  &amp;&amp; pLeafPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>+2+szNext &gt; pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3 );
<a name="l05970"></a>05970       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( (pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>&gt;0 || (pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> &gt; pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3))
<a name="l05971"></a>05971                  &amp;&amp; pLeafPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>+2+szNext == pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3 );
<a name="l05972"></a>05972 
<a name="l05973"></a>05973 
<a name="l05974"></a>05974       <span class="keywordflow">if</span>( (pPage-&gt;<a class="code" href="structMemPage.html#a3f7fa1a1eba3af840ef887e8ddd6d2cc">nOverflow</a>&gt;0 || (pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a> &gt; pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3)) &amp;&amp;
<a name="l05975"></a>05975           (pLeafPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>+2+szNext &gt; pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3)
<a name="l05976"></a>05976       ){
<a name="l05977"></a>05977         <span class="comment">/* This branch is taken if the internal node is now either overflowing</span>
<a name="l05978"></a>05978 <span class="comment">        ** or underfull and the leaf node will be underfull after the just cell </span>
<a name="l05979"></a>05979 <span class="comment">        ** copied to the internal node is deleted from it. This is a special</span>
<a name="l05980"></a>05980 <span class="comment">        ** case because the call to balance() to correct the internal node</span>
<a name="l05981"></a>05981 <span class="comment">        ** may change the tree structure and invalidate the contents of</span>
<a name="l05982"></a>05982 <span class="comment">        ** the leafCur.apPage[] and leafCur.aiIdx[] arrays, which will be</span>
<a name="l05983"></a>05983 <span class="comment">        ** used by the balance() required to correct the underfull leaf</span>
<a name="l05984"></a>05984 <span class="comment">        ** node.</span>
<a name="l05985"></a>05985 <span class="comment">        **</span>
<a name="l05986"></a>05986 <span class="comment">        ** The formula used in the expression above are based on facets of</span>
<a name="l05987"></a>05987 <span class="comment">        ** the SQLite file-format that do not change over time.</span>
<a name="l05988"></a>05988 <span class="comment">        */</span>
<a name="l05989"></a>05989         <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>==pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3+1 );
<a name="l05990"></a>05990         <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pLeafPage-&gt;<a class="code" href="structMemPage.html#a3418a9aee707f57a73d8470f8a1228a8">nFree</a>+2+szNext==pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>*2/3+1 );
<a name="l05991"></a>05991         leafCursorInvalid = 1;
<a name="l05992"></a>05992       }        
<a name="l05993"></a>05993 
<a name="l05994"></a>05994       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l05995"></a>05995         <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(<a class="code" href="btree_8c.html#a4789c15455047776c4cca9c18cc6ec65">findOverflowCell</a>(pPage, idx), pgnoChild);
<a name="l05996"></a>05996         <a class="code" href="btree_8c.html#ad2f62e901555bee1364572b9d1c0c536">VVA_ONLY</a>( pCur-&gt;pagesShuffled = 0 );
<a name="l05997"></a>05997         rc = <a class="code" href="btree_8c.html#abee055e19b090d89ef7f3ba60aac24ff">balance</a>(pCur, 0);
<a name="l05998"></a>05998       }
<a name="l05999"></a>05999 
<a name="l06000"></a>06000       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; leafCursorInvalid ){
<a name="l06001"></a>06001         <span class="comment">/* The leaf-node is now underfull and so the tree needs to be </span>
<a name="l06002"></a>06002 <span class="comment">        ** rebalanced. However, the balance() operation on the internal</span>
<a name="l06003"></a>06003 <span class="comment">        ** node above may have modified the structure of the B-Tree and</span>
<a name="l06004"></a>06004 <span class="comment">        ** so the current contents of leafCur.apPage[] and leafCur.aiIdx[]</span>
<a name="l06005"></a>06005 <span class="comment">        ** may not be trusted.</span>
<a name="l06006"></a>06006 <span class="comment">        **</span>
<a name="l06007"></a>06007 <span class="comment">        ** It is not possible to copy the ancestry from pCur, as the same</span>
<a name="l06008"></a>06008 <span class="comment">        ** balance() call has invalidated the pCur-&gt;apPage[] and aiIdx[]</span>
<a name="l06009"></a>06009 <span class="comment">        ** arrays. </span>
<a name="l06010"></a>06010 <span class="comment">        **</span>
<a name="l06011"></a>06011 <span class="comment">        ** The call to saveCursorPosition() below internally saves the </span>
<a name="l06012"></a>06012 <span class="comment">        ** key that leafCur is currently pointing to. Currently, there</span>
<a name="l06013"></a>06013 <span class="comment">        ** are two copies of that key in the tree - one here on the leaf</span>
<a name="l06014"></a>06014 <span class="comment">        ** page and one on some internal node in the tree. The copy on</span>
<a name="l06015"></a>06015 <span class="comment">        ** the leaf node is always the next key in tree-order after the </span>
<a name="l06016"></a>06016 <span class="comment">        ** copy on the internal node. So, the call to sqlite3BtreeNext()</span>
<a name="l06017"></a>06017 <span class="comment">        ** calls restoreCursorPosition() to point the cursor to the copy</span>
<a name="l06018"></a>06018 <span class="comment">        ** stored on the internal node, then advances to the next entry,</span>
<a name="l06019"></a>06019 <span class="comment">        ** which happens to be the copy of the key on the internal node.</span>
<a name="l06020"></a>06020 <span class="comment">        ** Net effect: leafCur is pointing back to the duplicate cell</span>
<a name="l06021"></a>06021 <span class="comment">        ** that needs to be removed, and the leafCur.apPage[] and</span>
<a name="l06022"></a>06022 <span class="comment">        ** leafCur.aiIdx[] arrays are correct.</span>
<a name="l06023"></a>06023 <span class="comment">        */</span>
<a name="l06024"></a>06024         <a class="code" href="btree_8c.html#ad2f62e901555bee1364572b9d1c0c536">VVA_ONLY</a>( <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> leafPgno = pLeafPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a> );
<a name="l06025"></a>06025         rc = <a class="code" href="btree_8c.html#a1fd19e15f7d2a03087f0c1f287dda917">saveCursorPosition</a>(&amp;leafCur);
<a name="l06026"></a>06026         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06027"></a>06027           rc = <a class="code" href="btree_8c.html#adf99ca89adc2e91557a41d6d11e97039">sqlite3BtreeNext</a>(&amp;leafCur, &amp;notUsed);
<a name="l06028"></a>06028         }
<a name="l06029"></a>06029         pLeafPage = leafCur.<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[leafCur.<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l06030"></a>06030         assert( pLeafPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>==leafPgno );
<a name="l06031"></a>06031         assert( leafCur.<a class="code" href="structBtCursor.html#a037a739198de5bee22ca203d34e90af1">aiIdx</a>[leafCur.<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]==0 );
<a name="l06032"></a>06032       }
<a name="l06033"></a>06033 
<a name="l06034"></a>06034       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06035"></a>06035         <a class="code" href="btree_8c.html#a7d153c46e2326e23931ac95a72f7a38d">dropCell</a>(pLeafPage, 0, szNext);
<a name="l06036"></a>06036         <a class="code" href="btree_8c.html#ad2f62e901555bee1364572b9d1c0c536">VVA_ONLY</a>( leafCur.pagesShuffled = 0 );
<a name="l06037"></a>06037         rc = <a class="code" href="btree_8c.html#abee055e19b090d89ef7f3ba60aac24ff">balance</a>(&amp;leafCur, 0);
<a name="l06038"></a>06038         assert( leafCursorInvalid || !leafCur.pagesShuffled
<a name="l06039"></a>06039                                    || !pCur-&gt;pagesShuffled );
<a name="l06040"></a>06040       }
<a name="l06041"></a>06041     }
<a name="l06042"></a>06042     <a class="code" href="btree_8c.html#a411511352dae53cda562b7b575831e82">sqlite3BtreeReleaseTempCursor</a>(&amp;leafCur);
<a name="l06043"></a>06043   }<span class="keywordflow">else</span>{
<a name="l06044"></a>06044     <a class="code" href="btree_8c.html#a638b671f4fa00cd5267c8df6c19c4477">TRACE</a>((<span class="stringliteral">&quot;DELETE: table=%d delete from leaf %d\n&quot;</span>,
<a name="l06045"></a>06045        pCur-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, pPage-&gt;<a class="code" href="structMemPage.html#ad2b0c532abc799bbcf3b43df4f0b0546">pgno</a>));
<a name="l06046"></a>06046     <a class="code" href="btree_8c.html#a7d153c46e2326e23931ac95a72f7a38d">dropCell</a>(pPage, idx, <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pPage, pCell));
<a name="l06047"></a>06047     rc = <a class="code" href="btree_8c.html#abee055e19b090d89ef7f3ba60aac24ff">balance</a>(pCur, 0);
<a name="l06048"></a>06048   }
<a name="l06049"></a>06049   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06050"></a>06050     <a class="code" href="btree_8c.html#a2b8fb9bf88e10e7e4dedc8da64e7e956">moveToRoot</a>(pCur);
<a name="l06051"></a>06051   }
<a name="l06052"></a>06052   <span class="keywordflow">return</span> rc;
<a name="l06053"></a>06053 }
<a name="l06054"></a>06054 
<a name="l06055"></a>06055 <span class="comment">/*</span>
<a name="l06056"></a>06056 <span class="comment">** Create a new BTree table.  Write into *piTable the page</span>
<a name="l06057"></a>06057 <span class="comment">** number for the root page of the new table.</span>
<a name="l06058"></a>06058 <span class="comment">**</span>
<a name="l06059"></a>06059 <span class="comment">** The type of type is determined by the flags parameter.  Only the</span>
<a name="l06060"></a>06060 <span class="comment">** following values of flags are currently in use.  Other values for</span>
<a name="l06061"></a>06061 <span class="comment">** flags might not work:</span>
<a name="l06062"></a>06062 <span class="comment">**</span>
<a name="l06063"></a>06063 <span class="comment">**     BTREE_INTKEY|BTREE_LEAFDATA     Used for SQL tables with rowid keys</span>
<a name="l06064"></a>06064 <span class="comment">**     BTREE_ZERODATA                  Used for SQL indices</span>
<a name="l06065"></a>06065 <span class="comment">*/</span>
<a name="l06066"></a><a class="code" href="btree_8c.html#a053b16db56b9bbefbb34654732d158e3">06066</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a053b16db56b9bbefbb34654732d158e3">btreeCreateTable</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> *piTable, <span class="keywordtype">int</span> flags){
<a name="l06067"></a>06067   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l06068"></a>06068   <a class="code" href="structMemPage.html">MemPage</a> *pRoot;
<a name="l06069"></a>06069   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoRoot;
<a name="l06070"></a>06070   <span class="keywordtype">int</span> rc;
<a name="l06071"></a>06071 
<a name="l06072"></a>06072   assert( sqlite3BtreeHoldsMutex(p) );
<a name="l06073"></a>06073   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>!=<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l06074"></a>06074     <span class="comment">/* Must start a transaction first */</span>
<a name="l06075"></a>06075     rc = pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ? <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a> : <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l06076"></a>06076     <span class="keywordflow">return</span> rc;
<a name="l06077"></a>06077   }
<a name="l06078"></a>06078   assert( !pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> );
<a name="l06079"></a>06079 
<a name="l06080"></a>06080 <span class="preprocessor">#ifdef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06081"></a>06081 <span class="preprocessor"></span>  rc = <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(pBt, &amp;pRoot, &amp;pgnoRoot, 1, 0);
<a name="l06082"></a>06082   <span class="keywordflow">if</span>( rc ){
<a name="l06083"></a>06083     <span class="keywordflow">return</span> rc;
<a name="l06084"></a>06084   }
<a name="l06085"></a>06085 <span class="preprocessor">#else</span>
<a name="l06086"></a>06086 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l06087"></a>06087     <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoMove;      <span class="comment">/* Move a page here to make room for the root-page */</span>
<a name="l06088"></a>06088     <a class="code" href="structMemPage.html">MemPage</a> *pPageMove; <span class="comment">/* The page to move to. */</span>
<a name="l06089"></a>06089 
<a name="l06090"></a>06090     <span class="comment">/* Creating a new table may probably require moving an existing database</span>
<a name="l06091"></a>06091 <span class="comment">    ** to make room for the new tables root page. In case this page turns</span>
<a name="l06092"></a>06092 <span class="comment">    ** out to be an overflow page, delete all overflow page-map caches</span>
<a name="l06093"></a>06093 <span class="comment">    ** held by open cursors.</span>
<a name="l06094"></a>06094 <span class="comment">    */</span>
<a name="l06095"></a>06095     <a class="code" href="btree_8c.html#ae54a9c06fff6f71d61f77b1f08f3e09c">invalidateAllOverflowCache</a>(pBt);
<a name="l06096"></a>06096 
<a name="l06097"></a>06097     <span class="comment">/* Read the value of meta[3] from the database to determine where the</span>
<a name="l06098"></a>06098 <span class="comment">    ** root page of the new table should go. meta[3] is the largest root-page</span>
<a name="l06099"></a>06099 <span class="comment">    ** created so far, so the new root-page is (meta[3]+1).</span>
<a name="l06100"></a>06100 <span class="comment">    */</span>
<a name="l06101"></a>06101     rc = <a class="code" href="btree_8c.html#a927b663f431cd2f4edfac55d7018cbb6">sqlite3BtreeGetMeta</a>(p, 4, &amp;pgnoRoot);
<a name="l06102"></a>06102     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06103"></a>06103       <span class="keywordflow">return</span> rc;
<a name="l06104"></a>06104     }
<a name="l06105"></a>06105     pgnoRoot++;
<a name="l06106"></a>06106 
<a name="l06107"></a>06107     <span class="comment">/* The new root-page may not be allocated on a pointer-map page, or the</span>
<a name="l06108"></a>06108 <span class="comment">    ** PENDING_BYTE page.</span>
<a name="l06109"></a>06109 <span class="comment">    */</span>
<a name="l06110"></a>06110     <span class="keywordflow">while</span>( pgnoRoot==<a class="code" href="btreeInt_8h.html#af4119a9a3bb0a5df2c67d813e9bea637">PTRMAP_PAGENO</a>(pBt, pgnoRoot) ||
<a name="l06111"></a>06111         pgnoRoot==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){
<a name="l06112"></a>06112       pgnoRoot++;
<a name="l06113"></a>06113     }
<a name="l06114"></a>06114     assert( pgnoRoot&gt;=3 );
<a name="l06115"></a>06115 
<a name="l06116"></a>06116     <span class="comment">/* Allocate a page. The page that currently resides at pgnoRoot will</span>
<a name="l06117"></a>06117 <span class="comment">    ** be moved to the allocated page (unless the allocated page happens</span>
<a name="l06118"></a>06118 <span class="comment">    ** to reside at pgnoRoot).</span>
<a name="l06119"></a>06119 <span class="comment">    */</span>
<a name="l06120"></a>06120     rc = <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(pBt, &amp;pPageMove, &amp;pgnoMove, pgnoRoot, 1);
<a name="l06121"></a>06121     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06122"></a>06122       <span class="keywordflow">return</span> rc;
<a name="l06123"></a>06123     }
<a name="l06124"></a>06124 
<a name="l06125"></a>06125     <span class="keywordflow">if</span>( pgnoMove!=pgnoRoot ){
<a name="l06126"></a>06126       <span class="comment">/* pgnoRoot is the page that will be used for the root-page of</span>
<a name="l06127"></a>06127 <span class="comment">      ** the new table (assuming an error did not occur). But we were</span>
<a name="l06128"></a>06128 <span class="comment">      ** allocated pgnoMove. If required (i.e. if it was not allocated</span>
<a name="l06129"></a>06129 <span class="comment">      ** by extending the file), the current page at position pgnoMove</span>
<a name="l06130"></a>06130 <span class="comment">      ** is already journaled.</span>
<a name="l06131"></a>06131 <span class="comment">      */</span>
<a name="l06132"></a>06132       <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eType;
<a name="l06133"></a>06133       <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iPtrPage;
<a name="l06134"></a>06134 
<a name="l06135"></a>06135       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPageMove);
<a name="l06136"></a>06136 
<a name="l06137"></a>06137       <span class="comment">/* Move the page currently at pgnoRoot to pgnoMove. */</span>
<a name="l06138"></a>06138       rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, pgnoRoot, &amp;pRoot, 0);
<a name="l06139"></a>06139       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06140"></a>06140         <span class="keywordflow">return</span> rc;
<a name="l06141"></a>06141       }
<a name="l06142"></a>06142       rc = <a class="code" href="btree_8c.html#ae91bfd9c1bec807a52a384d2ed01934b">ptrmapGet</a>(pBt, pgnoRoot, &amp;eType, &amp;iPtrPage);
<a name="l06143"></a>06143       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> || eType==<a class="code" href="btreeInt_8h.html#a5379d8ad602ca2c25996e08e33a5e9a9">PTRMAP_ROOTPAGE</a> || eType==<a class="code" href="btreeInt_8h.html#a2eb986d0fb6e4c953a5a2579d8a163d4">PTRMAP_FREEPAGE</a> ){
<a name="l06144"></a>06144         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pRoot);
<a name="l06145"></a>06145         <span class="keywordflow">return</span> rc;
<a name="l06146"></a>06146       }
<a name="l06147"></a>06147       assert( eType!=<a class="code" href="btreeInt_8h.html#a5379d8ad602ca2c25996e08e33a5e9a9">PTRMAP_ROOTPAGE</a> );
<a name="l06148"></a>06148       assert( eType!=<a class="code" href="btreeInt_8h.html#a2eb986d0fb6e4c953a5a2579d8a163d4">PTRMAP_FREEPAGE</a> );
<a name="l06149"></a>06149       rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pRoot-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l06150"></a>06150       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06151"></a>06151         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pRoot);
<a name="l06152"></a>06152         <span class="keywordflow">return</span> rc;
<a name="l06153"></a>06153       }
<a name="l06154"></a>06154       rc = <a class="code" href="btree_8c.html#af8fb5934ff87b02845c89350c57fd2bc">relocatePage</a>(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);
<a name="l06155"></a>06155       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pRoot);
<a name="l06156"></a>06156 
<a name="l06157"></a>06157       <span class="comment">/* Obtain the page at pgnoRoot */</span>
<a name="l06158"></a>06158       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06159"></a>06159         <span class="keywordflow">return</span> rc;
<a name="l06160"></a>06160       }
<a name="l06161"></a>06161       rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, pgnoRoot, &amp;pRoot, 0);
<a name="l06162"></a>06162       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06163"></a>06163         <span class="keywordflow">return</span> rc;
<a name="l06164"></a>06164       }
<a name="l06165"></a>06165       rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pRoot-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l06166"></a>06166       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06167"></a>06167         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pRoot);
<a name="l06168"></a>06168         <span class="keywordflow">return</span> rc;
<a name="l06169"></a>06169       }
<a name="l06170"></a>06170     }<span class="keywordflow">else</span>{
<a name="l06171"></a>06171       pRoot = pPageMove;
<a name="l06172"></a>06172     } 
<a name="l06173"></a>06173 
<a name="l06174"></a>06174     <span class="comment">/* Update the pointer-map and meta-data with the new root-page number. */</span>
<a name="l06175"></a>06175     rc = <a class="code" href="btree_8c.html#aa055beeb089a94945477b5914156265b">ptrmapPut</a>(pBt, pgnoRoot, <a class="code" href="btreeInt_8h.html#a5379d8ad602ca2c25996e08e33a5e9a9">PTRMAP_ROOTPAGE</a>, 0);
<a name="l06176"></a>06176     <span class="keywordflow">if</span>( rc ){
<a name="l06177"></a>06177       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pRoot);
<a name="l06178"></a>06178       <span class="keywordflow">return</span> rc;
<a name="l06179"></a>06179     }
<a name="l06180"></a>06180     rc = <a class="code" href="btree_8c.html#add955e8fdc68f4bc7a07d070984a3802">sqlite3BtreeUpdateMeta</a>(p, 4, pgnoRoot);
<a name="l06181"></a>06181     <span class="keywordflow">if</span>( rc ){
<a name="l06182"></a>06182       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pRoot);
<a name="l06183"></a>06183       <span class="keywordflow">return</span> rc;
<a name="l06184"></a>06184     }
<a name="l06185"></a>06185 
<a name="l06186"></a>06186   }<span class="keywordflow">else</span>{
<a name="l06187"></a>06187     rc = <a class="code" href="btree_8c.html#ae84ce1103eabfe9455a6a59e6cec4a33">allocateBtreePage</a>(pBt, &amp;pRoot, &amp;pgnoRoot, 1, 0);
<a name="l06188"></a>06188     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l06189"></a>06189   }
<a name="l06190"></a>06190 <span class="preprocessor">#endif</span>
<a name="l06191"></a>06191 <span class="preprocessor"></span>  assert( sqlite3PagerIswriteable(pRoot-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>) );
<a name="l06192"></a>06192   <a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">zeroPage</a>(pRoot, flags | <a class="code" href="btreeInt_8h.html#a75a736a457cd09a431cef0c66aa45ce6">PTF_LEAF</a>);
<a name="l06193"></a>06193   <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pRoot-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l06194"></a>06194   *piTable = (int)pgnoRoot;
<a name="l06195"></a>06195   <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l06196"></a>06196 }
<a name="l06197"></a><a class="code" href="btree_8h.html#a4c3fa87d4859776dd0f549fff6a790dd">06197</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a1084bedd105ea21f99beef334bbddd80">sqlite3BtreeCreateTable</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> *piTable, <span class="keywordtype">int</span> flags){
<a name="l06198"></a>06198   <span class="keywordtype">int</span> rc;
<a name="l06199"></a>06199   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l06200"></a>06200   p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l06201"></a>06201   rc = <a class="code" href="btree_8c.html#a053b16db56b9bbefbb34654732d158e3">btreeCreateTable</a>(p, piTable, flags);
<a name="l06202"></a>06202   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06203"></a>06203   <span class="keywordflow">return</span> rc;
<a name="l06204"></a>06204 }
<a name="l06205"></a>06205 
<a name="l06206"></a>06206 <span class="comment">/*</span>
<a name="l06207"></a>06207 <span class="comment">** Erase the given database page and all its children.  Return</span>
<a name="l06208"></a>06208 <span class="comment">** the page to the freelist.</span>
<a name="l06209"></a>06209 <span class="comment">*/</span>
<a name="l06210"></a><a class="code" href="btree_8c.html#a46c174d93956e9f53271513ee9f90217">06210</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a46c174d93956e9f53271513ee9f90217">clearDatabasePage</a>(
<a name="l06211"></a>06211   <a class="code" href="structBtShared.html">BtShared</a> *pBt,           <span class="comment">/* The BTree that contains the table */</span>
<a name="l06212"></a>06212   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgno,            <span class="comment">/* Page number to clear */</span>
<a name="l06213"></a>06213   <a class="code" href="structMemPage.html">MemPage</a> *pParent,     <span class="comment">/* Parent page.  NULL for the root */</span>
<a name="l06214"></a>06214   <span class="keywordtype">int</span> freePageFlag,     <span class="comment">/* Deallocate page if true */</span>
<a name="l06215"></a>06215   <span class="keywordtype">int</span> *pnChange
<a name="l06216"></a>06216 ){
<a name="l06217"></a>06217   <a class="code" href="structMemPage.html">MemPage</a> *pPage = 0;
<a name="l06218"></a>06218   <span class="keywordtype">int</span> rc;
<a name="l06219"></a>06219   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pCell;
<a name="l06220"></a>06220   <span class="keywordtype">int</span> i;
<a name="l06221"></a>06221 
<a name="l06222"></a>06222   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pBt-&gt;<a class="code" href="structBtShared.html#a454c31d726220bbed43c165e370460c8">mutex</a>) );
<a name="l06223"></a>06223   <span class="keywordflow">if</span>( pgno&gt;<a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>) ){
<a name="l06224"></a>06224     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l06225"></a>06225   }
<a name="l06226"></a>06226 
<a name="l06227"></a>06227   rc = <a class="code" href="btree_8c.html#a443538c685fb93b3b41ee3497629698e">getAndInitPage</a>(pBt, pgno, &amp;pPage);
<a name="l06228"></a>06228   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> cleardatabasepage_out;
<a name="l06229"></a>06229   <span class="keywordflow">for</span>(i=0; i&lt;pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>; i++){
<a name="l06230"></a>06230     pCell = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage, i);
<a name="l06231"></a>06231     <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l06232"></a>06232       rc = <a class="code" href="btree_8c.html#a46c174d93956e9f53271513ee9f90217">clearDatabasePage</a>(pBt, <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pCell), pPage, 1, pnChange);
<a name="l06233"></a>06233       <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> cleardatabasepage_out;
<a name="l06234"></a>06234     }
<a name="l06235"></a>06235     rc = <a class="code" href="btree_8c.html#acce36127359eb4baec99dac6d630bd9d">clearCell</a>(pPage, pCell);
<a name="l06236"></a>06236     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> cleardatabasepage_out;
<a name="l06237"></a>06237   }
<a name="l06238"></a>06238   <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l06239"></a>06239     rc = <a class="code" href="btree_8c.html#a46c174d93956e9f53271513ee9f90217">clearDatabasePage</a>(pBt, <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[8]), pPage, 1, pnChange);
<a name="l06240"></a>06240     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> cleardatabasepage_out;
<a name="l06241"></a>06241   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pnChange ){
<a name="l06242"></a>06242     assert( pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> );
<a name="l06243"></a>06243     *pnChange += pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a>;
<a name="l06244"></a>06244   }
<a name="l06245"></a>06245   <span class="keywordflow">if</span>( freePageFlag ){
<a name="l06246"></a>06246     rc = <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(pPage);
<a name="l06247"></a>06247   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( (rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pPage-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>))==0 ){
<a name="l06248"></a>06248     <a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">zeroPage</a>(pPage, pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[0] | <a class="code" href="btreeInt_8h.html#a75a736a457cd09a431cef0c66aa45ce6">PTF_LEAF</a>);
<a name="l06249"></a>06249   }
<a name="l06250"></a>06250 
<a name="l06251"></a>06251 cleardatabasepage_out:
<a name="l06252"></a>06252   <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06253"></a>06253   <span class="keywordflow">return</span> rc;
<a name="l06254"></a>06254 }
<a name="l06255"></a>06255 
<a name="l06256"></a>06256 <span class="comment">/*</span>
<a name="l06257"></a>06257 <span class="comment">** Delete all information from a single table in the database.  iTable is</span>
<a name="l06258"></a>06258 <span class="comment">** the page number of the root of the table.  After this routine returns,</span>
<a name="l06259"></a>06259 <span class="comment">** the root page is empty, but still exists.</span>
<a name="l06260"></a>06260 <span class="comment">**</span>
<a name="l06261"></a>06261 <span class="comment">** This routine will fail with SQLITE_LOCKED if there are any open</span>
<a name="l06262"></a>06262 <span class="comment">** read cursors on the table.  Open write cursors are moved to the</span>
<a name="l06263"></a>06263 <span class="comment">** root of the table.</span>
<a name="l06264"></a>06264 <span class="comment">**</span>
<a name="l06265"></a>06265 <span class="comment">** If pnChange is not NULL, then table iTable must be an intkey table. The</span>
<a name="l06266"></a>06266 <span class="comment">** integer value pointed to by pnChange is incremented by the number of</span>
<a name="l06267"></a>06267 <span class="comment">** entries in the table.</span>
<a name="l06268"></a>06268 <span class="comment">*/</span>
<a name="l06269"></a><a class="code" href="btree_8h.html#aa791a64591cbd609222299328e9d39eb">06269</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a460a707ac90ca3a7ff013b102cf68b2c">sqlite3BtreeClearTable</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> iTable, <span class="keywordtype">int</span> *pnChange){
<a name="l06270"></a>06270   <span class="keywordtype">int</span> rc;
<a name="l06271"></a>06271   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l06272"></a>06272   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l06273"></a>06273   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l06274"></a>06274   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>!=<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l06275"></a>06275     rc = pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ? <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a> : <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l06276"></a>06276   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( (rc = <a class="code" href="btree_8c.html#accb60c0dac28fa55737649f0c556eef9">checkReadLocks</a>(p, iTable, 0, 1))!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06277"></a>06277     <span class="comment">/* nothing to do */</span>
<a name="l06278"></a>06278   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=(rc = <a class="code" href="btree_8c.html#add0c7a5086792caf465148beaadb913d">saveAllCursors</a>(pBt, iTable, 0)) ){
<a name="l06279"></a>06279     <span class="comment">/* nothing to do */</span>
<a name="l06280"></a>06280   }<span class="keywordflow">else</span>{
<a name="l06281"></a>06281     rc = <a class="code" href="btree_8c.html#a46c174d93956e9f53271513ee9f90217">clearDatabasePage</a>(pBt, (<a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a>)iTable, 0, 0, pnChange);
<a name="l06282"></a>06282   }
<a name="l06283"></a>06283   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06284"></a>06284   <span class="keywordflow">return</span> rc;
<a name="l06285"></a>06285 }
<a name="l06286"></a>06286 
<a name="l06287"></a>06287 <span class="comment">/*</span>
<a name="l06288"></a>06288 <span class="comment">** Erase all information in a table and add the root of the table to</span>
<a name="l06289"></a>06289 <span class="comment">** the freelist.  Except, the root of the principle table (the one on</span>
<a name="l06290"></a>06290 <span class="comment">** page 1) is never added to the freelist.</span>
<a name="l06291"></a>06291 <span class="comment">**</span>
<a name="l06292"></a>06292 <span class="comment">** This routine will fail with SQLITE_LOCKED if there are any open</span>
<a name="l06293"></a>06293 <span class="comment">** cursors on the table.</span>
<a name="l06294"></a>06294 <span class="comment">**</span>
<a name="l06295"></a>06295 <span class="comment">** If AUTOVACUUM is enabled and the page at iTable is not the last</span>
<a name="l06296"></a>06296 <span class="comment">** root page in the database file, then the last root page </span>
<a name="l06297"></a>06297 <span class="comment">** in the database file is moved into the slot formerly occupied by</span>
<a name="l06298"></a>06298 <span class="comment">** iTable and that last slot formerly occupied by the last root page</span>
<a name="l06299"></a>06299 <span class="comment">** is added to the freelist instead of iTable.  In this say, all</span>
<a name="l06300"></a>06300 <span class="comment">** root pages are kept at the beginning of the database file, which</span>
<a name="l06301"></a>06301 <span class="comment">** is necessary for AUTOVACUUM to work right.  *piMoved is set to the </span>
<a name="l06302"></a>06302 <span class="comment">** page number that used to be the last root page in the file before</span>
<a name="l06303"></a>06303 <span class="comment">** the move.  If no page gets moved, *piMoved is set to 0.</span>
<a name="l06304"></a>06304 <span class="comment">** The last root page is recorded in meta[3] and the value of</span>
<a name="l06305"></a>06305 <span class="comment">** meta[3] is updated by this procedure.</span>
<a name="l06306"></a>06306 <span class="comment">*/</span>
<a name="l06307"></a><a class="code" href="btree_8c.html#a806c68109c8aae30455b3ca0655cfb9d">06307</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a806c68109c8aae30455b3ca0655cfb9d">btreeDropTable</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> iTable, <span class="keywordtype">int</span> *piMoved){
<a name="l06308"></a>06308   <span class="keywordtype">int</span> rc;
<a name="l06309"></a>06309   <a class="code" href="structMemPage.html">MemPage</a> *pPage = 0;
<a name="l06310"></a>06310   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l06311"></a>06311 
<a name="l06312"></a>06312   assert( sqlite3BtreeHoldsMutex(p) );
<a name="l06313"></a>06313   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>!=<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l06314"></a>06314     <span class="keywordflow">return</span> pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ? <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a> : <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l06315"></a>06315   }
<a name="l06316"></a>06316 
<a name="l06317"></a>06317   <span class="comment">/* It is illegal to drop a table if any cursors are open on the</span>
<a name="l06318"></a>06318 <span class="comment">  ** database. This is because in auto-vacuum mode the backend may</span>
<a name="l06319"></a>06319 <span class="comment">  ** need to move another root-page to fill a gap left by the deleted</span>
<a name="l06320"></a>06320 <span class="comment">  ** root page. If an open cursor was using this page a problem would </span>
<a name="l06321"></a>06321 <span class="comment">  ** occur.</span>
<a name="l06322"></a>06322 <span class="comment">  */</span>
<a name="l06323"></a>06323   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a> ){
<a name="l06324"></a>06324     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>;
<a name="l06325"></a>06325   }
<a name="l06326"></a>06326 
<a name="l06327"></a>06327   rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, (<a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a>)iTable, &amp;pPage, 0);
<a name="l06328"></a>06328   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">return</span> rc;
<a name="l06329"></a>06329   rc = <a class="code" href="btree_8c.html#a460a707ac90ca3a7ff013b102cf68b2c">sqlite3BtreeClearTable</a>(p, iTable, 0);
<a name="l06330"></a>06330   <span class="keywordflow">if</span>( rc ){
<a name="l06331"></a>06331     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06332"></a>06332     <span class="keywordflow">return</span> rc;
<a name="l06333"></a>06333   }
<a name="l06334"></a>06334 
<a name="l06335"></a>06335   *piMoved = 0;
<a name="l06336"></a>06336 
<a name="l06337"></a>06337   <span class="keywordflow">if</span>( iTable&gt;1 ){
<a name="l06338"></a>06338 <span class="preprocessor">#ifdef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06339"></a>06339 <span class="preprocessor"></span>    rc = <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(pPage);
<a name="l06340"></a>06340     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06341"></a>06341 <span class="preprocessor">#else</span>
<a name="l06342"></a>06342 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l06343"></a>06343       <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> maxRootPgno;
<a name="l06344"></a>06344       rc = <a class="code" href="btree_8c.html#a927b663f431cd2f4edfac55d7018cbb6">sqlite3BtreeGetMeta</a>(p, 4, &amp;maxRootPgno);
<a name="l06345"></a>06345       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06346"></a>06346         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06347"></a>06347         <span class="keywordflow">return</span> rc;
<a name="l06348"></a>06348       }
<a name="l06349"></a>06349 
<a name="l06350"></a>06350       <span class="keywordflow">if</span>( iTable==maxRootPgno ){
<a name="l06351"></a>06351         <span class="comment">/* If the table being dropped is the table with the largest root-page</span>
<a name="l06352"></a>06352 <span class="comment">        ** number in the database, put the root page on the free list. </span>
<a name="l06353"></a>06353 <span class="comment">        */</span>
<a name="l06354"></a>06354         rc = <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(pPage);
<a name="l06355"></a>06355         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06356"></a>06356         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06357"></a>06357           <span class="keywordflow">return</span> rc;
<a name="l06358"></a>06358         }
<a name="l06359"></a>06359       }<span class="keywordflow">else</span>{
<a name="l06360"></a>06360         <span class="comment">/* The table being dropped does not have the largest root-page</span>
<a name="l06361"></a>06361 <span class="comment">        ** number in the database. So move the page that does into the </span>
<a name="l06362"></a>06362 <span class="comment">        ** gap left by the deleted root-page.</span>
<a name="l06363"></a>06363 <span class="comment">        */</span>
<a name="l06364"></a>06364         <a class="code" href="structMemPage.html">MemPage</a> *pMove;
<a name="l06365"></a>06365         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06366"></a>06366         rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, maxRootPgno, &amp;pMove, 0);
<a name="l06367"></a>06367         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06368"></a>06368           <span class="keywordflow">return</span> rc;
<a name="l06369"></a>06369         }
<a name="l06370"></a>06370         rc = <a class="code" href="btree_8c.html#af8fb5934ff87b02845c89350c57fd2bc">relocatePage</a>(pBt, pMove, <a class="code" href="btreeInt_8h.html#a5379d8ad602ca2c25996e08e33a5e9a9">PTRMAP_ROOTPAGE</a>, 0, iTable, 0);
<a name="l06371"></a>06371         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pMove);
<a name="l06372"></a>06372         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06373"></a>06373           <span class="keywordflow">return</span> rc;
<a name="l06374"></a>06374         }
<a name="l06375"></a>06375         rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, maxRootPgno, &amp;pMove, 0);
<a name="l06376"></a>06376         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06377"></a>06377           <span class="keywordflow">return</span> rc;
<a name="l06378"></a>06378         }
<a name="l06379"></a>06379         rc = <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(pMove);
<a name="l06380"></a>06380         <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pMove);
<a name="l06381"></a>06381         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06382"></a>06382           <span class="keywordflow">return</span> rc;
<a name="l06383"></a>06383         }
<a name="l06384"></a>06384         *piMoved = maxRootPgno;
<a name="l06385"></a>06385       }
<a name="l06386"></a>06386 
<a name="l06387"></a>06387       <span class="comment">/* Set the new &apos;max-root-page&apos; value in the database header. This</span>
<a name="l06388"></a>06388 <span class="comment">      ** is the old value less one, less one more if that happens to</span>
<a name="l06389"></a>06389 <span class="comment">      ** be a root-page number, less one again if that is the</span>
<a name="l06390"></a>06390 <span class="comment">      ** PENDING_BYTE_PAGE.</span>
<a name="l06391"></a>06391 <span class="comment">      */</span>
<a name="l06392"></a>06392       maxRootPgno--;
<a name="l06393"></a>06393       <span class="keywordflow">if</span>( maxRootPgno==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) ){
<a name="l06394"></a>06394         maxRootPgno--;
<a name="l06395"></a>06395       }
<a name="l06396"></a>06396       <span class="keywordflow">if</span>( maxRootPgno==<a class="code" href="btreeInt_8h.html#af4119a9a3bb0a5df2c67d813e9bea637">PTRMAP_PAGENO</a>(pBt, maxRootPgno) ){
<a name="l06397"></a>06397         maxRootPgno--;
<a name="l06398"></a>06398       }
<a name="l06399"></a>06399       assert( maxRootPgno!=<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt) );
<a name="l06400"></a>06400 
<a name="l06401"></a>06401       rc = <a class="code" href="btree_8c.html#add955e8fdc68f4bc7a07d070984a3802">sqlite3BtreeUpdateMeta</a>(p, 4, maxRootPgno);
<a name="l06402"></a>06402     }<span class="keywordflow">else</span>{
<a name="l06403"></a>06403       rc = <a class="code" href="btree_8c.html#ae50e49ba10bc838bd9b7939573779ead">freePage</a>(pPage);
<a name="l06404"></a>06404       <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06405"></a>06405     }
<a name="l06406"></a>06406 <span class="preprocessor">#endif</span>
<a name="l06407"></a>06407 <span class="preprocessor"></span>  }<span class="keywordflow">else</span>{
<a name="l06408"></a>06408     <span class="comment">/* If sqlite3BtreeDropTable was called on page 1. */</span>
<a name="l06409"></a>06409     <a class="code" href="btree_8c.html#a1c974ee71f86cb74370ca21e5e6cdb14">zeroPage</a>(pPage, <a class="code" href="btreeInt_8h.html#a140a8063c22071245b2a0469b31ee35b">PTF_INTKEY</a>|<a class="code" href="btreeInt_8h.html#a75a736a457cd09a431cef0c66aa45ce6">PTF_LEAF</a> );
<a name="l06410"></a>06410     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06411"></a>06411   }
<a name="l06412"></a>06412   <span class="keywordflow">return</span> rc;  
<a name="l06413"></a>06413 }
<a name="l06414"></a><a class="code" href="btree_8h.html#a5f4dea82150e1aa188aa9c40b31400a9">06414</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ac250178f8867eca8fa7161c524a712d9">sqlite3BtreeDropTable</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> iTable, <span class="keywordtype">int</span> *piMoved){
<a name="l06415"></a>06415   <span class="keywordtype">int</span> rc;
<a name="l06416"></a>06416   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l06417"></a>06417   p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l06418"></a>06418   rc = <a class="code" href="btree_8c.html#a806c68109c8aae30455b3ca0655cfb9d">btreeDropTable</a>(p, iTable, piMoved);
<a name="l06419"></a>06419   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06420"></a>06420   <span class="keywordflow">return</span> rc;
<a name="l06421"></a>06421 }
<a name="l06422"></a>06422 
<a name="l06423"></a>06423 
<a name="l06424"></a>06424 <span class="comment">/*</span>
<a name="l06425"></a>06425 <span class="comment">** Read the meta-information out of a database file.  Meta[0]</span>
<a name="l06426"></a>06426 <span class="comment">** is the number of free pages currently in the database.  Meta[1]</span>
<a name="l06427"></a>06427 <span class="comment">** through meta[15] are available for use by higher layers.  Meta[0]</span>
<a name="l06428"></a>06428 <span class="comment">** is read-only, the others are read/write.</span>
<a name="l06429"></a>06429 <span class="comment">** </span>
<a name="l06430"></a>06430 <span class="comment">** The schema layer numbers meta values differently.  At the schema</span>
<a name="l06431"></a>06431 <span class="comment">** layer (and the SetCookie and ReadCookie opcodes) the number of</span>
<a name="l06432"></a>06432 <span class="comment">** free pages is not visible.  So Cookie[0] is the same as Meta[1].</span>
<a name="l06433"></a>06433 <span class="comment">*/</span>
<a name="l06434"></a><a class="code" href="btree_8h.html#a8fc3d016156fee7c081af864bc25866c">06434</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a927b663f431cd2f4edfac55d7018cbb6">sqlite3BtreeGetMeta</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> idx, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> *pMeta){
<a name="l06435"></a>06435   <a class="code" href="structPgHdr.html">DbPage</a> *pDbPage;
<a name="l06436"></a>06436   <span class="keywordtype">int</span> rc;
<a name="l06437"></a>06437   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pP1;
<a name="l06438"></a>06438   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l06439"></a>06439 
<a name="l06440"></a>06440   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l06441"></a>06441   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l06442"></a>06442 
<a name="l06443"></a>06443   <span class="comment">/* Reading a meta-data value requires a read-lock on page 1 (and hence</span>
<a name="l06444"></a>06444 <span class="comment">  ** the sqlite_master table. We grab this lock regardless of whether or</span>
<a name="l06445"></a>06445 <span class="comment">  ** not the SQLITE_ReadUncommitted flag is set (the table rooted at page</span>
<a name="l06446"></a>06446 <span class="comment">  ** 1 is treated as a special case by queryTableLock() and lockTable()).</span>
<a name="l06447"></a>06447 <span class="comment">  */</span>
<a name="l06448"></a>06448   rc = <a class="code" href="btree_8c.html#a950bafa2f267025f9e7369992a6aa026">queryTableLock</a>(p, 1, <a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a>);
<a name="l06449"></a>06449   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06450"></a>06450     <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06451"></a>06451     <span class="keywordflow">return</span> rc;
<a name="l06452"></a>06452   }
<a name="l06453"></a>06453 
<a name="l06454"></a>06454   assert( idx&gt;=0 &amp;&amp; idx&lt;=15 );
<a name="l06455"></a>06455   <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a> ){
<a name="l06456"></a>06456     <span class="comment">/* The b-tree is already holding a reference to page 1 of the database</span>
<a name="l06457"></a>06457 <span class="comment">    ** file. In this case the required meta-data value can be read directly</span>
<a name="l06458"></a>06458 <span class="comment">    ** from the page data of this reference. This is slightly faster than</span>
<a name="l06459"></a>06459 <span class="comment">    ** requesting a new reference from the pager layer.</span>
<a name="l06460"></a>06460 <span class="comment">    */</span>
<a name="l06461"></a>06461     pP1 = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l06462"></a>06462   }<span class="keywordflow">else</span>{
<a name="l06463"></a>06463     <span class="comment">/* The b-tree does not have a reference to page 1 of the database file.</span>
<a name="l06464"></a>06464 <span class="comment">    ** Obtain one from the pager layer.</span>
<a name="l06465"></a>06465 <span class="comment">    */</span>
<a name="l06466"></a>06466     rc = <a class="code" href="pager_8h.html#ac690af087310cf9d64d04d8559be402e">sqlite3PagerGet</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, 1, &amp;pDbPage);
<a name="l06467"></a>06467     <span class="keywordflow">if</span>( rc ){
<a name="l06468"></a>06468       <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06469"></a>06469       <span class="keywordflow">return</span> rc;
<a name="l06470"></a>06470     }
<a name="l06471"></a>06471     pP1 = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pDbPage);
<a name="l06472"></a>06472   }
<a name="l06473"></a>06473   *pMeta = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pP1[36 + idx*4]);
<a name="l06474"></a>06474 
<a name="l06475"></a>06475   <span class="comment">/* If the b-tree is not holding a reference to page 1, then one was </span>
<a name="l06476"></a>06476 <span class="comment">  ** requested from the pager layer in the above block. Release it now.</span>
<a name="l06477"></a>06477 <span class="comment">  */</span>
<a name="l06478"></a>06478   <span class="keywordflow">if</span>( !pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a> ){
<a name="l06479"></a>06479     <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pDbPage);
<a name="l06480"></a>06480   }
<a name="l06481"></a>06481 
<a name="l06482"></a>06482   <span class="comment">/* If autovacuumed is disabled in this build but we are trying to </span>
<a name="l06483"></a>06483 <span class="comment">  ** access an autovacuumed database, then make the database readonly. </span>
<a name="l06484"></a>06484 <span class="comment">  */</span>
<a name="l06485"></a>06485 <span class="preprocessor">#ifdef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06486"></a>06486 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( idx==4 &amp;&amp; *pMeta&gt;0 ) pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> = 1;
<a name="l06487"></a>06487 <span class="preprocessor">#endif</span>
<a name="l06488"></a>06488 <span class="preprocessor"></span>
<a name="l06489"></a>06489   <span class="comment">/* Grab the read-lock on page 1. */</span>
<a name="l06490"></a>06490   rc = <a class="code" href="btree_8c.html#a089cf86fc7bb3c6873eb1cc4ae547578">lockTable</a>(p, 1, <a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a>);
<a name="l06491"></a>06491   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06492"></a>06492   <span class="keywordflow">return</span> rc;
<a name="l06493"></a>06493 }
<a name="l06494"></a>06494 
<a name="l06495"></a>06495 <span class="comment">/*</span>
<a name="l06496"></a>06496 <span class="comment">** Write meta-information back into the database.  Meta[0] is</span>
<a name="l06497"></a>06497 <span class="comment">** read-only and may not be written.</span>
<a name="l06498"></a>06498 <span class="comment">*/</span>
<a name="l06499"></a><a class="code" href="btree_8h.html#a1de58a75bb3663cc91e701ae9688d7a3">06499</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#add955e8fdc68f4bc7a07d070984a3802">sqlite3BtreeUpdateMeta</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> idx, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> iMeta){
<a name="l06500"></a>06500   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l06501"></a>06501   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pP1;
<a name="l06502"></a>06502   <span class="keywordtype">int</span> rc;
<a name="l06503"></a>06503   assert( idx&gt;=1 &amp;&amp; idx&lt;=15 );
<a name="l06504"></a>06504   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l06505"></a>06505   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l06506"></a>06506   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>!=<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l06507"></a>06507     rc = pBt-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> ? <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a> : <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l06508"></a>06508   }<span class="keywordflow">else</span>{
<a name="l06509"></a>06509     assert( pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>!=0 );
<a name="l06510"></a>06510     pP1 = pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l06511"></a>06511     rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#add322c1aed91e95d8dfe3ac3535d65b4">pDbPage</a>);
<a name="l06512"></a>06512     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06513"></a>06513       <a class="code" href="btreeInt_8h.html#ab6c3700f2c3a64c8ae48cf5b07b6941d">put4byte</a>(&amp;pP1[36 + idx*4], iMeta);
<a name="l06514"></a>06514 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06515"></a>06515 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( idx==7 ){
<a name="l06516"></a>06516         assert( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> || iMeta==0 );
<a name="l06517"></a>06517         assert( iMeta==0 || iMeta==1 );
<a name="l06518"></a>06518         pBt-&gt;<a class="code" href="structBtShared.html#a8d8ba06335a63d8a36294a0f1ae8377a">incrVacuum</a> = iMeta;
<a name="l06519"></a>06519       }
<a name="l06520"></a>06520 <span class="preprocessor">#endif</span>
<a name="l06521"></a>06521 <span class="preprocessor"></span>    }
<a name="l06522"></a>06522   }
<a name="l06523"></a>06523   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06524"></a>06524   <span class="keywordflow">return</span> rc;
<a name="l06525"></a>06525 }
<a name="l06526"></a>06526 
<a name="l06527"></a>06527 <span class="comment">/*</span>
<a name="l06528"></a>06528 <span class="comment">** Return the flag byte at the beginning of the page that the cursor</span>
<a name="l06529"></a>06529 <span class="comment">** is currently pointing to.</span>
<a name="l06530"></a>06530 <span class="comment">*/</span>
<a name="l06531"></a><a class="code" href="btree_8h.html#ad34e75f45d59a85da5549f5d02ea42e2">06531</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a723642d632e53c6ab42c61b504d1059f">sqlite3BtreeFlags</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l06532"></a>06532   <span class="comment">/* TODO: What about CURSOR_REQUIRESEEK state? Probably need to call</span>
<a name="l06533"></a>06533 <span class="comment">  ** restoreCursorPosition() here.</span>
<a name="l06534"></a>06534 <span class="comment">  */</span>
<a name="l06535"></a>06535   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l06536"></a>06536   <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCur);
<a name="l06537"></a>06537   pPage = pCur-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCur-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>];
<a name="l06538"></a>06538   assert( cursorHoldsMutex(pCur) );
<a name="l06539"></a>06539   assert( pPage-&gt;<a class="code" href="structMemPage.html#a949df1156f7392592eaeb64389068f99">pBt</a>==pCur-&gt;<a class="code" href="structBtCursor.html#a61c245712549192f7644e5ac23c00b74">pBt</a> );
<a name="l06540"></a>06540   <span class="keywordflow">return</span> pPage ? pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>] : 0;
<a name="l06541"></a>06541 }
<a name="l06542"></a>06542 
<a name="l06543"></a>06543 
<a name="l06544"></a>06544 <span class="comment">/*</span>
<a name="l06545"></a>06545 <span class="comment">** Return the pager associated with a BTree.  This routine is used for</span>
<a name="l06546"></a>06546 <span class="comment">** testing and debugging only.</span>
<a name="l06547"></a>06547 <span class="comment">*/</span>
<a name="l06548"></a><a class="code" href="btree_8h.html#a98d7f5b6172b1e03eac9956ec43d168a">06548</a> <a class="code" href="structPager.html">Pager</a> *<a class="code" href="btree_8c.html#aba94a511fed188b724c1c956e55dbd57">sqlite3BtreePager</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l06549"></a>06549   <span class="keywordflow">return</span> p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>;
<a name="l06550"></a>06550 }
<a name="l06551"></a>06551 
<a name="l06552"></a>06552 <span class="preprocessor">#ifndef SQLITE_OMIT_INTEGRITY_CHECK</span>
<a name="l06553"></a>06553 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l06554"></a>06554 <span class="comment">** Append a message to the error message string.</span>
<a name="l06555"></a>06555 <span class="comment">*/</span>
<a name="l06556"></a><a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">06556</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(
<a name="l06557"></a>06557   <a class="code" href="structIntegrityCk.html">IntegrityCk</a> *pCheck,
<a name="l06558"></a>06558   <span class="keywordtype">char</span> *zMsg1,
<a name="l06559"></a>06559   <span class="keyword">const</span> <span class="keywordtype">char</span> *zFormat,
<a name="l06560"></a>06560   ...
<a name="l06561"></a>06561 ){
<a name="l06562"></a>06562   va_list ap;
<a name="l06563"></a>06563   <span class="keywordflow">if</span>( !pCheck-&gt;<a class="code" href="structIntegrityCk.html#a9daa97cdcb1366c503451ab2af9e7ba6">mxErr</a> ) <span class="keywordflow">return</span>;
<a name="l06564"></a>06564   pCheck-&gt;<a class="code" href="structIntegrityCk.html#a9daa97cdcb1366c503451ab2af9e7ba6">mxErr</a>--;
<a name="l06565"></a>06565   pCheck-&gt;<a class="code" href="structIntegrityCk.html#a52c815a1d19be87d0ab4dc0a4e4d38e2">nErr</a>++;
<a name="l06566"></a>06566   va_start(ap, zFormat);
<a name="l06567"></a>06567   <span class="keywordflow">if</span>( pCheck-&gt;<a class="code" href="structIntegrityCk.html#a1e9b79bb1d7b22a840001333200a950e">errMsg</a>.<a class="code" href="structStrAccum.html#a88bf779588ca597a41fde3e41186e003">nChar</a> ){
<a name="l06568"></a>06568     <a class="code" href="printf_8c.html#a0c10b703cb7677994e49831d0a7c0338">sqlite3StrAccumAppend</a>(&amp;pCheck-&gt;<a class="code" href="structIntegrityCk.html#a1e9b79bb1d7b22a840001333200a950e">errMsg</a>, <span class="stringliteral">&quot;\n&quot;</span>, 1);
<a name="l06569"></a>06569   }
<a name="l06570"></a>06570   <span class="keywordflow">if</span>( zMsg1 ){
<a name="l06571"></a>06571     <a class="code" href="printf_8c.html#a0c10b703cb7677994e49831d0a7c0338">sqlite3StrAccumAppend</a>(&amp;pCheck-&gt;<a class="code" href="structIntegrityCk.html#a1e9b79bb1d7b22a840001333200a950e">errMsg</a>, zMsg1, -1);
<a name="l06572"></a>06572   }
<a name="l06573"></a>06573   <a class="code" href="printf_8c.html#a23bffa4cc63372a2a9a14c88a4594e9a">sqlite3VXPrintf</a>(&amp;pCheck-&gt;<a class="code" href="structIntegrityCk.html#a1e9b79bb1d7b22a840001333200a950e">errMsg</a>, 1, zFormat, ap);
<a name="l06574"></a>06574   va_end(ap);
<a name="l06575"></a>06575   <span class="keywordflow">if</span>( pCheck-&gt;<a class="code" href="structIntegrityCk.html#a1e9b79bb1d7b22a840001333200a950e">errMsg</a>.<a class="code" href="structStrAccum.html#a6bc89e5ed8495ddcddadf0940f236c84">mallocFailed</a> ){
<a name="l06576"></a>06576     pCheck-&gt;<a class="code" href="structIntegrityCk.html#a8e448c1d6483a0326a7ec39291782030">mallocFailed</a> = 1;
<a name="l06577"></a>06577   }
<a name="l06578"></a>06578 }
<a name="l06579"></a>06579 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_INTEGRITY_CHECK */</span>
<a name="l06580"></a>06580 
<a name="l06581"></a>06581 <span class="preprocessor">#ifndef SQLITE_OMIT_INTEGRITY_CHECK</span>
<a name="l06582"></a>06582 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l06583"></a>06583 <span class="comment">** Add 1 to the reference count for page iPage.  If this is the second</span>
<a name="l06584"></a>06584 <span class="comment">** reference to the page, add an error message to pCheck-&gt;zErrMsg.</span>
<a name="l06585"></a>06585 <span class="comment">** Return 1 if there are 2 ore more references to the page and 0 if</span>
<a name="l06586"></a>06586 <span class="comment">** if this is the first reference to the page.</span>
<a name="l06587"></a>06587 <span class="comment">**</span>
<a name="l06588"></a>06588 <span class="comment">** Also check that the page number is in bounds.</span>
<a name="l06589"></a>06589 <span class="comment">*/</span>
<a name="l06590"></a><a class="code" href="btree_8c.html#a86e3937685c8cfd1ff1b8300ef97c90b">06590</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a86e3937685c8cfd1ff1b8300ef97c90b">checkRef</a>(<a class="code" href="structIntegrityCk.html">IntegrityCk</a> *pCheck, <span class="keywordtype">int</span> iPage, <span class="keywordtype">char</span> *zContext){
<a name="l06591"></a>06591   <span class="keywordflow">if</span>( iPage==0 ) <span class="keywordflow">return</span> 1;
<a name="l06592"></a>06592   <span class="keywordflow">if</span>( iPage&gt;pCheck-&gt;<a class="code" href="structIntegrityCk.html#ad93d80e8c589258d19a1e8efd7ce8bcd">nPage</a> || iPage&lt;0 ){
<a name="l06593"></a>06593     <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext, <span class="stringliteral">&quot;invalid page number %d&quot;</span>, iPage);
<a name="l06594"></a>06594     <span class="keywordflow">return</span> 1;
<a name="l06595"></a>06595   }
<a name="l06596"></a>06596   <span class="keywordflow">if</span>( pCheck-&gt;<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a>[iPage]==1 ){
<a name="l06597"></a>06597     <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext, <span class="stringliteral">&quot;2nd reference to page %d&quot;</span>, iPage);
<a name="l06598"></a>06598     <span class="keywordflow">return</span> 1;
<a name="l06599"></a>06599   }
<a name="l06600"></a>06600   <span class="keywordflow">return</span>  (pCheck-&gt;<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a>[iPage]++)&gt;1;
<a name="l06601"></a>06601 }
<a name="l06602"></a>06602 
<a name="l06603"></a>06603 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06604"></a>06604 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l06605"></a>06605 <span class="comment">** Check that the entry in the pointer-map for page iChild maps to </span>
<a name="l06606"></a>06606 <span class="comment">** page iParent, pointer type ptrType. If not, append an error message</span>
<a name="l06607"></a>06607 <span class="comment">** to pCheck.</span>
<a name="l06608"></a>06608 <span class="comment">*/</span>
<a name="l06609"></a><a class="code" href="btree_8c.html#a1a0b6cfc7b15f6f3f9ba963067bf699a">06609</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a1a0b6cfc7b15f6f3f9ba963067bf699a">checkPtrmap</a>(
<a name="l06610"></a>06610   <a class="code" href="structIntegrityCk.html">IntegrityCk</a> *pCheck,   <span class="comment">/* Integrity check context */</span>
<a name="l06611"></a>06611   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iChild,           <span class="comment">/* Child page number */</span>
<a name="l06612"></a>06612   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> eType,              <span class="comment">/* Expected pointer map type */</span>
<a name="l06613"></a>06613   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iParent,          <span class="comment">/* Expected pointer map parent page number */</span>
<a name="l06614"></a>06614   <span class="keywordtype">char</span> *zContext         <span class="comment">/* Context description (used for error msg) */</span>
<a name="l06615"></a>06615 ){
<a name="l06616"></a>06616   <span class="keywordtype">int</span> rc;
<a name="l06617"></a>06617   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> ePtrmapType;
<a name="l06618"></a>06618   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iPtrmapParent;
<a name="l06619"></a>06619 
<a name="l06620"></a>06620   rc = <a class="code" href="btree_8c.html#ae91bfd9c1bec807a52a384d2ed01934b">ptrmapGet</a>(pCheck-&gt;<a class="code" href="structIntegrityCk.html#a65f03f54514f504bd871bb2ccd3da188">pBt</a>, iChild, &amp;ePtrmapType, &amp;iPtrmapParent);
<a name="l06621"></a>06621   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06622"></a>06622     <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext, <span class="stringliteral">&quot;Failed to read ptrmap key=%d&quot;</span>, iChild);
<a name="l06623"></a>06623     <span class="keywordflow">return</span>;
<a name="l06624"></a>06624   }
<a name="l06625"></a>06625 
<a name="l06626"></a>06626   <span class="keywordflow">if</span>( ePtrmapType!=eType || iPtrmapParent!=iParent ){
<a name="l06627"></a>06627     <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext, 
<a name="l06628"></a>06628       <span class="stringliteral">&quot;Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)&quot;</span>, 
<a name="l06629"></a>06629       iChild, eType, iParent, ePtrmapType, iPtrmapParent);
<a name="l06630"></a>06630   }
<a name="l06631"></a>06631 }
<a name="l06632"></a>06632 <span class="preprocessor">#endif</span>
<a name="l06633"></a>06633 <span class="preprocessor"></span>
<a name="l06634"></a>06634 <span class="comment">/*</span>
<a name="l06635"></a>06635 <span class="comment">** Check the integrity of the freelist or of an overflow page list.</span>
<a name="l06636"></a>06636 <span class="comment">** Verify that the number of pages on the list is N.</span>
<a name="l06637"></a>06637 <span class="comment">*/</span>
<a name="l06638"></a><a class="code" href="btree_8c.html#af31aaf3c60e4f749f0dff6b8b907b159">06638</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#af31aaf3c60e4f749f0dff6b8b907b159">checkList</a>(
<a name="l06639"></a>06639   <a class="code" href="structIntegrityCk.html">IntegrityCk</a> *pCheck,  <span class="comment">/* Integrity checking context */</span>
<a name="l06640"></a>06640   <span class="keywordtype">int</span> isFreeList,       <span class="comment">/* True for a freelist.  False for overflow page list */</span>
<a name="l06641"></a>06641   <span class="keywordtype">int</span> iPage,            <span class="comment">/* Page number for first page in the list */</span>
<a name="l06642"></a>06642   <span class="keywordtype">int</span> N,                <span class="comment">/* Expected number of pages in the list */</span>
<a name="l06643"></a>06643   <span class="keywordtype">char</span> *zContext        <span class="comment">/* Context for error messages */</span>
<a name="l06644"></a>06644 ){
<a name="l06645"></a>06645   <span class="keywordtype">int</span> i;
<a name="l06646"></a>06646   <span class="keywordtype">int</span> expected = N;
<a name="l06647"></a>06647   <span class="keywordtype">int</span> iFirst = iPage;
<a name="l06648"></a>06648   <span class="keywordflow">while</span>( N-- &gt; 0 &amp;&amp; pCheck-&gt;<a class="code" href="structIntegrityCk.html#a9daa97cdcb1366c503451ab2af9e7ba6">mxErr</a> ){
<a name="l06649"></a>06649     <a class="code" href="structPgHdr.html">DbPage</a> *pOvflPage;
<a name="l06650"></a>06650     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pOvflData;
<a name="l06651"></a>06651     <span class="keywordflow">if</span>( iPage&lt;1 ){
<a name="l06652"></a>06652       <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext,
<a name="l06653"></a>06653          <span class="stringliteral">&quot;%d of %d pages missing from overflow list starting at %d&quot;</span>,
<a name="l06654"></a>06654           N+1, expected, iFirst);
<a name="l06655"></a>06655       <span class="keywordflow">break</span>;
<a name="l06656"></a>06656     }
<a name="l06657"></a>06657     <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#a86e3937685c8cfd1ff1b8300ef97c90b">checkRef</a>(pCheck, iPage, zContext) ) <span class="keywordflow">break</span>;
<a name="l06658"></a>06658     <span class="keywordflow">if</span>( <a class="code" href="pager_8h.html#ac690af087310cf9d64d04d8559be402e">sqlite3PagerGet</a>(pCheck-&gt;<a class="code" href="structIntegrityCk.html#a87e7f8b012b61b61fae359269cbacce4">pPager</a>, (<a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a>)iPage, &amp;pOvflPage) ){
<a name="l06659"></a>06659       <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext, <span class="stringliteral">&quot;failed to get page %d&quot;</span>, iPage);
<a name="l06660"></a>06660       <span class="keywordflow">break</span>;
<a name="l06661"></a>06661     }
<a name="l06662"></a>06662     pOvflData = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pOvflPage);
<a name="l06663"></a>06663     <span class="keywordflow">if</span>( isFreeList ){
<a name="l06664"></a>06664       <span class="keywordtype">int</span> n = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pOvflData[4]);
<a name="l06665"></a>06665 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06666"></a>06666 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( pCheck-&gt;<a class="code" href="structIntegrityCk.html#a65f03f54514f504bd871bb2ccd3da188">pBt</a>-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l06667"></a>06667         <a class="code" href="btree_8c.html#a1a0b6cfc7b15f6f3f9ba963067bf699a">checkPtrmap</a>(pCheck, iPage, <a class="code" href="btreeInt_8h.html#a2eb986d0fb6e4c953a5a2579d8a163d4">PTRMAP_FREEPAGE</a>, 0, zContext);
<a name="l06668"></a>06668       }
<a name="l06669"></a>06669 <span class="preprocessor">#endif</span>
<a name="l06670"></a>06670 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( n&gt;pCheck-&gt;<a class="code" href="structIntegrityCk.html#a65f03f54514f504bd871bb2ccd3da188">pBt</a>-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>/4-2 ){
<a name="l06671"></a>06671         <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext,
<a name="l06672"></a>06672            <span class="stringliteral">&quot;freelist leaf count too big on page %d&quot;</span>, iPage);
<a name="l06673"></a>06673         N--;
<a name="l06674"></a>06674       }<span class="keywordflow">else</span>{
<a name="l06675"></a>06675         <span class="keywordflow">for</span>(i=0; i&lt;n; i++){
<a name="l06676"></a>06676           <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iFreePage = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pOvflData[8+i*4]);
<a name="l06677"></a>06677 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06678"></a>06678 <span class="preprocessor"></span>          <span class="keywordflow">if</span>( pCheck-&gt;<a class="code" href="structIntegrityCk.html#a65f03f54514f504bd871bb2ccd3da188">pBt</a>-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l06679"></a>06679             <a class="code" href="btree_8c.html#a1a0b6cfc7b15f6f3f9ba963067bf699a">checkPtrmap</a>(pCheck, iFreePage, <a class="code" href="btreeInt_8h.html#a2eb986d0fb6e4c953a5a2579d8a163d4">PTRMAP_FREEPAGE</a>, 0, zContext);
<a name="l06680"></a>06680           }
<a name="l06681"></a>06681 <span class="preprocessor">#endif</span>
<a name="l06682"></a>06682 <span class="preprocessor"></span>          <a class="code" href="btree_8c.html#a86e3937685c8cfd1ff1b8300ef97c90b">checkRef</a>(pCheck, iFreePage, zContext);
<a name="l06683"></a>06683         }
<a name="l06684"></a>06684         N -= n;
<a name="l06685"></a>06685       }
<a name="l06686"></a>06686     }
<a name="l06687"></a>06687 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06688"></a>06688 <span class="preprocessor"></span>    <span class="keywordflow">else</span>{
<a name="l06689"></a>06689       <span class="comment">/* If this database supports auto-vacuum and iPage is not the last</span>
<a name="l06690"></a>06690 <span class="comment">      ** page in this overflow list, check that the pointer-map entry for</span>
<a name="l06691"></a>06691 <span class="comment">      ** the following page matches iPage.</span>
<a name="l06692"></a>06692 <span class="comment">      */</span>
<a name="l06693"></a>06693       <span class="keywordflow">if</span>( pCheck-&gt;<a class="code" href="structIntegrityCk.html#a65f03f54514f504bd871bb2ccd3da188">pBt</a>-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> &amp;&amp; N&gt;0 ){
<a name="l06694"></a>06694         i = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pOvflData);
<a name="l06695"></a>06695         <a class="code" href="btree_8c.html#a1a0b6cfc7b15f6f3f9ba963067bf699a">checkPtrmap</a>(pCheck, i, <a class="code" href="btreeInt_8h.html#a2ae32756efb02fe2c719669a0bfabe9a">PTRMAP_OVERFLOW2</a>, iPage, zContext);
<a name="l06696"></a>06696       }
<a name="l06697"></a>06697     }
<a name="l06698"></a>06698 <span class="preprocessor">#endif</span>
<a name="l06699"></a>06699 <span class="preprocessor"></span>    iPage = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pOvflData);
<a name="l06700"></a>06700     <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pOvflPage);
<a name="l06701"></a>06701   }
<a name="l06702"></a>06702 }
<a name="l06703"></a>06703 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_INTEGRITY_CHECK */</span>
<a name="l06704"></a>06704 
<a name="l06705"></a>06705 <span class="preprocessor">#ifndef SQLITE_OMIT_INTEGRITY_CHECK</span>
<a name="l06706"></a>06706 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l06707"></a>06707 <span class="comment">** Do various sanity checks on a single page of a tree.  Return</span>
<a name="l06708"></a>06708 <span class="comment">** the tree depth.  Root pages return 0.  Parents of root pages</span>
<a name="l06709"></a>06709 <span class="comment">** return 1, and so forth.</span>
<a name="l06710"></a>06710 <span class="comment">** </span>
<a name="l06711"></a>06711 <span class="comment">** These checks are done:</span>
<a name="l06712"></a>06712 <span class="comment">**</span>
<a name="l06713"></a>06713 <span class="comment">**      1.  Make sure that cells and freeblocks do not overlap</span>
<a name="l06714"></a>06714 <span class="comment">**          but combine to completely cover the page.</span>
<a name="l06715"></a>06715 <span class="comment">**  NO  2.  Make sure cell keys are in order.</span>
<a name="l06716"></a>06716 <span class="comment">**  NO  3.  Make sure no key is less than or equal to zLowerBound.</span>
<a name="l06717"></a>06717 <span class="comment">**  NO  4.  Make sure no key is greater than or equal to zUpperBound.</span>
<a name="l06718"></a>06718 <span class="comment">**      5.  Check the integrity of overflow pages.</span>
<a name="l06719"></a>06719 <span class="comment">**      6.  Recursively call checkTreePage on all children.</span>
<a name="l06720"></a>06720 <span class="comment">**      7.  Verify that the depth of all children is the same.</span>
<a name="l06721"></a>06721 <span class="comment">**      8.  Make sure this page is at least 33% full or else it is</span>
<a name="l06722"></a>06722 <span class="comment">**          the root of the tree.</span>
<a name="l06723"></a>06723 <span class="comment">*/</span>
<a name="l06724"></a><a class="code" href="btree_8c.html#a1aa25393186cb6c3f26899737be87147">06724</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a1aa25393186cb6c3f26899737be87147">checkTreePage</a>(
<a name="l06725"></a>06725   <a class="code" href="structIntegrityCk.html">IntegrityCk</a> *pCheck,  <span class="comment">/* Context for the sanity check */</span>
<a name="l06726"></a>06726   <span class="keywordtype">int</span> iPage,            <span class="comment">/* Page number of the page to check */</span>
<a name="l06727"></a>06727   <a class="code" href="structMemPage.html">MemPage</a> *pParent,     <span class="comment">/* Parent page */</span>
<a name="l06728"></a>06728   <span class="keywordtype">char</span> *zParentContext  <span class="comment">/* Parent context */</span>
<a name="l06729"></a>06729 ){
<a name="l06730"></a>06730   <a class="code" href="structMemPage.html">MemPage</a> *pPage;
<a name="l06731"></a>06731   <span class="keywordtype">int</span> i, rc, depth, d2, pgno, cnt;
<a name="l06732"></a>06732   <span class="keywordtype">int</span> hdr, cellStart;
<a name="l06733"></a>06733   <span class="keywordtype">int</span> nCell;
<a name="l06734"></a>06734   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *data;
<a name="l06735"></a>06735   <a class="code" href="structBtShared.html">BtShared</a> *pBt;
<a name="l06736"></a>06736   <span class="keywordtype">int</span> usableSize;
<a name="l06737"></a>06737   <span class="keywordtype">char</span> zContext[100];
<a name="l06738"></a>06738   <span class="keywordtype">char</span> *hit = 0;
<a name="l06739"></a>06739 
<a name="l06740"></a>06740   <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zContext), zContext, <span class="stringliteral">&quot;Page %d: &quot;</span>, iPage);
<a name="l06741"></a>06741 
<a name="l06742"></a>06742   <span class="comment">/* Check that the page exists</span>
<a name="l06743"></a>06743 <span class="comment">  */</span>
<a name="l06744"></a>06744   pBt = pCheck-&gt;<a class="code" href="structIntegrityCk.html#a65f03f54514f504bd871bb2ccd3da188">pBt</a>;
<a name="l06745"></a>06745   usableSize = pBt-&gt;<a class="code" href="structBtShared.html#a23a86524192c39758c4ef2b585244187">usableSize</a>;
<a name="l06746"></a>06746   <span class="keywordflow">if</span>( iPage==0 ) <span class="keywordflow">return</span> 0;
<a name="l06747"></a>06747   <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#a86e3937685c8cfd1ff1b8300ef97c90b">checkRef</a>(pCheck, iPage, zParentContext) ) <span class="keywordflow">return</span> 0;
<a name="l06748"></a>06748   <span class="keywordflow">if</span>( (rc = <a class="code" href="btree_8c.html#af643a96e59049cbf53d42004e2807335">sqlite3BtreeGetPage</a>(pBt, (<a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a>)iPage, &amp;pPage, 0))!=0 ){
<a name="l06749"></a>06749     <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext,
<a name="l06750"></a>06750        <span class="stringliteral">&quot;unable to get the page. error code=%d&quot;</span>, rc);
<a name="l06751"></a>06751     <span class="keywordflow">return</span> 0;
<a name="l06752"></a>06752   }
<a name="l06753"></a>06753   <span class="keywordflow">if</span>( (rc = <a class="code" href="btree_8c.html#a6bd53cc52eb7920b1ab1d0510212bfa0">sqlite3BtreeInitPage</a>(pPage))!=0 ){
<a name="l06754"></a>06754     <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext, 
<a name="l06755"></a>06755                    <span class="stringliteral">&quot;sqlite3BtreeInitPage() returns error code %d&quot;</span>, rc);
<a name="l06756"></a>06756     <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06757"></a>06757     <span class="keywordflow">return</span> 0;
<a name="l06758"></a>06758   }
<a name="l06759"></a>06759 
<a name="l06760"></a>06760   <span class="comment">/* Check out all the cells.</span>
<a name="l06761"></a>06761 <span class="comment">  */</span>
<a name="l06762"></a>06762   depth = 0;
<a name="l06763"></a>06763   <span class="keywordflow">for</span>(i=0; i&lt;pPage-&gt;<a class="code" href="structMemPage.html#a35d1d8f836201b82b1eb778ce0e324f4">nCell</a> &amp;&amp; pCheck-&gt;<a class="code" href="structIntegrityCk.html#a9daa97cdcb1366c503451ab2af9e7ba6">mxErr</a>; i++){
<a name="l06764"></a>06764     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *pCell;
<a name="l06765"></a>06765     <span class="keywordtype">int</span> sz;
<a name="l06766"></a>06766     <a class="code" href="structCellInfo.html">CellInfo</a> info;
<a name="l06767"></a>06767 
<a name="l06768"></a>06768     <span class="comment">/* Check payload overflow pages</span>
<a name="l06769"></a>06769 <span class="comment">    */</span>
<a name="l06770"></a>06770     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zContext), zContext,
<a name="l06771"></a>06771              <span class="stringliteral">&quot;On tree page %d cell %d: &quot;</span>, iPage, i);
<a name="l06772"></a>06772     pCell = <a class="code" href="btree_8c.html#adcb94212d5f55b413664d999ea94a449">findCell</a>(pPage,i);
<a name="l06773"></a>06773     <a class="code" href="btree_8c.html#ae2285665a12313e10d16f7fd8280a4fb">sqlite3BtreeParseCellPtr</a>(pPage, pCell, &amp;info);
<a name="l06774"></a>06774     sz = info.<a class="code" href="structCellInfo.html#af2301ed16c35633ec6b5d7792734a4bf">nData</a>;
<a name="l06775"></a>06775     <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> ) sz += info.<a class="code" href="structCellInfo.html#a542b041b9a54a13f7c6f2fe63e7542c0">nKey</a>;
<a name="l06776"></a>06776     assert( sz==info.<a class="code" href="structCellInfo.html#ac1e3c1b4216a8e778bbac82907bb1485">nPayload</a> );
<a name="l06777"></a>06777     <span class="keywordflow">if</span>( sz&gt;info.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> ){
<a name="l06778"></a>06778       <span class="keywordtype">int</span> nPage = (sz - info.<a class="code" href="structCellInfo.html#a8cedbcc2c94916fe5798b502c614bb08">nLocal</a> + usableSize - 5)/(usableSize - 4);
<a name="l06779"></a>06779       <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> pgnoOvfl = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pCell[info.<a class="code" href="structCellInfo.html#af7be0161f1c67600aeba783a68972f70">iOverflow</a>]);
<a name="l06780"></a>06780 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06781"></a>06781 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l06782"></a>06782         <a class="code" href="btree_8c.html#a1a0b6cfc7b15f6f3f9ba963067bf699a">checkPtrmap</a>(pCheck, pgnoOvfl, <a class="code" href="btreeInt_8h.html#add9dc5f20d087b06cce9c19b30794560">PTRMAP_OVERFLOW1</a>, iPage, zContext);
<a name="l06783"></a>06783       }
<a name="l06784"></a>06784 <span class="preprocessor">#endif</span>
<a name="l06785"></a>06785 <span class="preprocessor"></span>      <a class="code" href="btree_8c.html#af31aaf3c60e4f749f0dff6b8b907b159">checkList</a>(pCheck, 0, pgnoOvfl, nPage, zContext);
<a name="l06786"></a>06786     }
<a name="l06787"></a>06787 
<a name="l06788"></a>06788     <span class="comment">/* Check sanity of left child page.</span>
<a name="l06789"></a>06789 <span class="comment">    */</span>
<a name="l06790"></a>06790     <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l06791"></a>06791       pgno = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(pCell);
<a name="l06792"></a>06792 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06793"></a>06793 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l06794"></a>06794         <a class="code" href="btree_8c.html#a1a0b6cfc7b15f6f3f9ba963067bf699a">checkPtrmap</a>(pCheck, pgno, <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, iPage, zContext);
<a name="l06795"></a>06795       }
<a name="l06796"></a>06796 <span class="preprocessor">#endif</span>
<a name="l06797"></a>06797 <span class="preprocessor"></span>      d2 = <a class="code" href="btree_8c.html#a1aa25393186cb6c3f26899737be87147">checkTreePage</a>(pCheck,pgno,pPage,zContext);
<a name="l06798"></a>06798       <span class="keywordflow">if</span>( i&gt;0 &amp;&amp; d2!=depth ){
<a name="l06799"></a>06799         <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, zContext, <span class="stringliteral">&quot;Child page depth differs&quot;</span>);
<a name="l06800"></a>06800       }
<a name="l06801"></a>06801       depth = d2;
<a name="l06802"></a>06802     }
<a name="l06803"></a>06803   }
<a name="l06804"></a>06804   <span class="keywordflow">if</span>( !pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a> ){
<a name="l06805"></a>06805     pgno = <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>+8]);
<a name="l06806"></a>06806     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(<span class="keyword">sizeof</span>(zContext), zContext, 
<a name="l06807"></a>06807                      <span class="stringliteral">&quot;On page %d at right child: &quot;</span>, iPage);
<a name="l06808"></a>06808 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06809"></a>06809 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> ){
<a name="l06810"></a>06810       <a class="code" href="btree_8c.html#a1a0b6cfc7b15f6f3f9ba963067bf699a">checkPtrmap</a>(pCheck, pgno, <a class="code" href="btreeInt_8h.html#a09d6838ead22ba112b9122486ee11116">PTRMAP_BTREE</a>, iPage, 0);
<a name="l06811"></a>06811     }
<a name="l06812"></a>06812 <span class="preprocessor">#endif</span>
<a name="l06813"></a>06813 <span class="preprocessor"></span>    <a class="code" href="btree_8c.html#a1aa25393186cb6c3f26899737be87147">checkTreePage</a>(pCheck, pgno, pPage, zContext);
<a name="l06814"></a>06814   }
<a name="l06815"></a>06815  
<a name="l06816"></a>06816   <span class="comment">/* Check for complete coverage of the page</span>
<a name="l06817"></a>06817 <span class="comment">  */</span>
<a name="l06818"></a>06818   data = pPage-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>;
<a name="l06819"></a>06819   hdr = pPage-&gt;<a class="code" href="structMemPage.html#a01967a1a593980fb71c8ccf3393ae156">hdrOffset</a>;
<a name="l06820"></a>06820   hit = <a class="code" href="pcache_8c.html#a477574c3feb4e18cd674fe9593ae6cb0">sqlite3PageMalloc</a>( pBt-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a> );
<a name="l06821"></a>06821   <span class="keywordflow">if</span>( hit==0 ){
<a name="l06822"></a>06822     pCheck-&gt;<a class="code" href="structIntegrityCk.html#a8e448c1d6483a0326a7ec39291782030">mallocFailed</a> = 1;
<a name="l06823"></a>06823   }<span class="keywordflow">else</span>{
<a name="l06824"></a>06824     <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> contentOffset = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+5]);
<a name="l06825"></a>06825     <span class="keywordflow">if</span> (contentOffset &gt; usableSize) {
<a name="l06826"></a>06826       <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, 0, 
<a name="l06827"></a>06827                      <span class="stringliteral">&quot;Corruption detected in header on page %d&quot;</span>,iPage,0);
<a name="l06828"></a>06828       <span class="keywordflow">goto</span> check_page_abort;
<a name="l06829"></a>06829     }
<a name="l06830"></a>06830     memset(hit+contentOffset, 0, usableSize-contentOffset);
<a name="l06831"></a>06831     memset(hit, 1, contentOffset);
<a name="l06832"></a>06832     nCell = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+3]);
<a name="l06833"></a>06833     cellStart = hdr + 12 - 4*pPage-&gt;<a class="code" href="structMemPage.html#af18504bd0a2e7d39d9b485d434af0447">leaf</a>;
<a name="l06834"></a>06834     <span class="keywordflow">for</span>(i=0; i&lt;nCell; i++){
<a name="l06835"></a>06835       <span class="keywordtype">int</span> pc = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[cellStart+i*2]);
<a name="l06836"></a>06836       <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> size = 1024;
<a name="l06837"></a>06837       <span class="keywordtype">int</span> j;
<a name="l06838"></a>06838       <span class="keywordflow">if</span>( pc&lt;=usableSize ){
<a name="l06839"></a>06839         size = <a class="code" href="btree_8c.html#a6c95c9aac1c8a00490e36674f43e76ec">cellSizePtr</a>(pPage, &amp;data[pc]);
<a name="l06840"></a>06840       }
<a name="l06841"></a>06841       <span class="keywordflow">if</span>( (pc+size-1)&gt;=usableSize || pc&lt;0 ){
<a name="l06842"></a>06842         <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, 0, 
<a name="l06843"></a>06843             <span class="stringliteral">&quot;Corruption detected in cell %d on page %d&quot;</span>,i,iPage,0);
<a name="l06844"></a>06844       }<span class="keywordflow">else</span>{
<a name="l06845"></a>06845         <span class="keywordflow">for</span>(j=pc+size-1; j&gt;=pc; j--) hit[j]++;
<a name="l06846"></a>06846       }
<a name="l06847"></a>06847     }
<a name="l06848"></a>06848     <span class="keywordflow">for</span>(cnt=0, i=<a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[hdr+1]); i&gt;0 &amp;&amp; i&lt;usableSize &amp;&amp; cnt&lt;10000; 
<a name="l06849"></a>06849            cnt++){
<a name="l06850"></a>06850       <span class="keywordtype">int</span> size = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[i+2]);
<a name="l06851"></a>06851       <span class="keywordtype">int</span> j;
<a name="l06852"></a>06852       <span class="keywordflow">if</span>( (i+size-1)&gt;=usableSize || i&lt;0 ){
<a name="l06853"></a>06853         <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, 0,  
<a name="l06854"></a>06854             <span class="stringliteral">&quot;Corruption detected in cell %d on page %d&quot;</span>,i,iPage,0);
<a name="l06855"></a>06855       }<span class="keywordflow">else</span>{
<a name="l06856"></a>06856         <span class="keywordflow">for</span>(j=i+size-1; j&gt;=i; j--) hit[j]++;
<a name="l06857"></a>06857       }
<a name="l06858"></a>06858       i = <a class="code" href="btreeInt_8h.html#a54c839cb25c8e144fa5b8d8959a1d840">get2byte</a>(&amp;data[i]);
<a name="l06859"></a>06859     }
<a name="l06860"></a>06860     <span class="keywordflow">for</span>(i=cnt=0; i&lt;usableSize; i++){
<a name="l06861"></a>06861       <span class="keywordflow">if</span>( hit[i]==0 ){
<a name="l06862"></a>06862         cnt++;
<a name="l06863"></a>06863       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( hit[i]&gt;1 ){
<a name="l06864"></a>06864         <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, 0,
<a name="l06865"></a>06865           <span class="stringliteral">&quot;Multiple uses for byte %d of page %d&quot;</span>, i, iPage);
<a name="l06866"></a>06866         <span class="keywordflow">break</span>;
<a name="l06867"></a>06867       }
<a name="l06868"></a>06868     }
<a name="l06869"></a>06869     <span class="keywordflow">if</span>( cnt!=data[hdr+7] ){
<a name="l06870"></a>06870       <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(pCheck, 0, 
<a name="l06871"></a>06871           <span class="stringliteral">&quot;Fragmented space is %d byte reported as %d on page %d&quot;</span>,
<a name="l06872"></a>06872           cnt, data[hdr+7], iPage);
<a name="l06873"></a>06873     }
<a name="l06874"></a>06874   }
<a name="l06875"></a>06875 check_page_abort:
<a name="l06876"></a>06876   <span class="keywordflow">if</span> (hit) <a class="code" href="pcache_8c.html#acc509b3b0633dde5f0f65e3964993a6d">sqlite3PageFree</a>(hit);
<a name="l06877"></a>06877 
<a name="l06878"></a>06878   <a class="code" href="btree_8c.html#a92c6fb14f9bcf117440c35116c26d6c4">releasePage</a>(pPage);
<a name="l06879"></a>06879   <span class="keywordflow">return</span> depth+1;
<a name="l06880"></a>06880 }
<a name="l06881"></a>06881 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_INTEGRITY_CHECK */</span>
<a name="l06882"></a>06882 
<a name="l06883"></a>06883 <span class="preprocessor">#ifndef SQLITE_OMIT_INTEGRITY_CHECK</span>
<a name="l06884"></a>06884 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l06885"></a>06885 <span class="comment">** This routine does a complete check of the given BTree file.  aRoot[] is</span>
<a name="l06886"></a>06886 <span class="comment">** an array of pages numbers were each page number is the root page of</span>
<a name="l06887"></a>06887 <span class="comment">** a table.  nRoot is the number of entries in aRoot.</span>
<a name="l06888"></a>06888 <span class="comment">**</span>
<a name="l06889"></a>06889 <span class="comment">** Write the number of error seen in *pnErr.  Except for some memory</span>
<a name="l06890"></a>06890 <span class="comment">** allocation errors,  nn error message is held in memory obtained from</span>
<a name="l06891"></a>06891 <span class="comment">** malloc is returned if *pnErr is non-zero.  If *pnErr==0 then NULL is</span>
<a name="l06892"></a>06892 <span class="comment">** returned.</span>
<a name="l06893"></a>06893 <span class="comment">*/</span>
<a name="l06894"></a><a class="code" href="btree_8h.html#a493202e751f59ad16ad6e875028f9dae">06894</a> <span class="keywordtype">char</span> *<a class="code" href="btree_8c.html#ae5fa1180c69f3527516c08636efc36e5">sqlite3BtreeIntegrityCheck</a>(
<a name="l06895"></a>06895   <a class="code" href="structBtree.html">Btree</a> *p,     <span class="comment">/* The btree to be checked */</span>
<a name="l06896"></a>06896   <span class="keywordtype">int</span> *aRoot,   <span class="comment">/* An array of root pages numbers for individual trees */</span>
<a name="l06897"></a>06897   <span class="keywordtype">int</span> nRoot,    <span class="comment">/* Number of entries in aRoot[] */</span>
<a name="l06898"></a>06898   <span class="keywordtype">int</span> mxErr,    <span class="comment">/* Stop reporting errors after this many */</span>
<a name="l06899"></a>06899   <span class="keywordtype">int</span> *pnErr    <span class="comment">/* Write number of errors seen to this variable */</span>
<a name="l06900"></a>06900 ){
<a name="l06901"></a>06901   <span class="keywordtype">int</span> i;
<a name="l06902"></a>06902   <span class="keywordtype">int</span> nRef;
<a name="l06903"></a>06903   <a class="code" href="structIntegrityCk.html">IntegrityCk</a> sCheck;
<a name="l06904"></a>06904   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l06905"></a>06905   <span class="keywordtype">char</span> zErr[100];
<a name="l06906"></a>06906 
<a name="l06907"></a>06907   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l06908"></a>06908   pBt-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l06909"></a>06909   nRef = <a class="code" href="pager_8c.html#a05500bf4ea783ce94abc20c6153730e5">sqlite3PagerRefcount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l06910"></a>06910   <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#a6bfd699c64823f0b858a0a77c10f92f1">lockBtreeWithRetry</a>(p)!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l06911"></a>06911     *pnErr = 1;
<a name="l06912"></a>06912     <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06913"></a>06913     <span class="keywordflow">return</span> <a class="code" href="malloc_8c.html#aa75e87f512f3cb7a48175b26dba47ebb">sqlite3DbStrDup</a>(0, <span class="stringliteral">&quot;cannot acquire a read lock on the database&quot;</span>);
<a name="l06914"></a>06914   }
<a name="l06915"></a>06915   sCheck.<a class="code" href="structIntegrityCk.html#a65f03f54514f504bd871bb2ccd3da188">pBt</a> = pBt;
<a name="l06916"></a>06916   sCheck.<a class="code" href="structIntegrityCk.html#a87e7f8b012b61b61fae359269cbacce4">pPager</a> = pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>;
<a name="l06917"></a>06917   sCheck.<a class="code" href="structIntegrityCk.html#ad93d80e8c589258d19a1e8efd7ce8bcd">nPage</a> = <a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(sCheck.<a class="code" href="structIntegrityCk.html#a87e7f8b012b61b61fae359269cbacce4">pPager</a>);
<a name="l06918"></a>06918   sCheck.<a class="code" href="structIntegrityCk.html#a9daa97cdcb1366c503451ab2af9e7ba6">mxErr</a> = mxErr;
<a name="l06919"></a>06919   sCheck.<a class="code" href="structIntegrityCk.html#a52c815a1d19be87d0ab4dc0a4e4d38e2">nErr</a> = 0;
<a name="l06920"></a>06920   sCheck.<a class="code" href="structIntegrityCk.html#a8e448c1d6483a0326a7ec39291782030">mallocFailed</a> = 0;
<a name="l06921"></a>06921   *pnErr = 0;
<a name="l06922"></a>06922 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06923"></a>06923 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>!=0 ){
<a name="l06924"></a>06924     sCheck.<a class="code" href="structIntegrityCk.html#ad93d80e8c589258d19a1e8efd7ce8bcd">nPage</a> = pBt-&gt;<a class="code" href="structBtShared.html#a437874e1af5d6015e1a2b0e766061930">nTrunc</a>;
<a name="l06925"></a>06925   }
<a name="l06926"></a>06926 <span class="preprocessor">#endif</span>
<a name="l06927"></a>06927 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( sCheck.<a class="code" href="structIntegrityCk.html#ad93d80e8c589258d19a1e8efd7ce8bcd">nPage</a>==0 ){
<a name="l06928"></a>06928     <a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">unlockBtreeIfUnused</a>(pBt);
<a name="l06929"></a>06929     <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06930"></a>06930     <span class="keywordflow">return</span> 0;
<a name="l06931"></a>06931   }
<a name="l06932"></a>06932   sCheck.<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a> = <a class="code" href="malloc_8c.html#a8c1a33577a57524c7c6eef3d9e64e742">sqlite3Malloc</a>( (sCheck.<a class="code" href="structIntegrityCk.html#ad93d80e8c589258d19a1e8efd7ce8bcd">nPage</a>+1)*<span class="keyword">sizeof</span>(sCheck.<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a>[0]) );
<a name="l06933"></a>06933   <span class="keywordflow">if</span>( !sCheck.<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a> ){
<a name="l06934"></a>06934     <a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">unlockBtreeIfUnused</a>(pBt);
<a name="l06935"></a>06935     *pnErr = 1;
<a name="l06936"></a>06936     <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06937"></a>06937     <span class="keywordflow">return</span> 0;
<a name="l06938"></a>06938   }
<a name="l06939"></a>06939   <span class="keywordflow">for</span>(i=0; i&lt;=sCheck.<a class="code" href="structIntegrityCk.html#ad93d80e8c589258d19a1e8efd7ce8bcd">nPage</a>; i++){ sCheck.<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a>[i] = 0; }
<a name="l06940"></a>06940   i = <a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBt);
<a name="l06941"></a>06941   <span class="keywordflow">if</span>( i&lt;=sCheck.<a class="code" href="structIntegrityCk.html#ad93d80e8c589258d19a1e8efd7ce8bcd">nPage</a> ){
<a name="l06942"></a>06942     sCheck.<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a>[i] = 1;
<a name="l06943"></a>06943   }
<a name="l06944"></a>06944   <a class="code" href="printf_8c.html#a95c01e03a1fabc2d47c648e6aed7a2c5">sqlite3StrAccumInit</a>(&amp;sCheck.<a class="code" href="structIntegrityCk.html#a1e9b79bb1d7b22a840001333200a950e">errMsg</a>, zErr, <span class="keyword">sizeof</span>(zErr), 20000);
<a name="l06945"></a>06945 
<a name="l06946"></a>06946   <span class="comment">/* Check the integrity of the freelist</span>
<a name="l06947"></a>06947 <span class="comment">  */</span>
<a name="l06948"></a>06948   <a class="code" href="btree_8c.html#af31aaf3c60e4f749f0dff6b8b907b159">checkList</a>(&amp;sCheck, 1, <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[32]),
<a name="l06949"></a>06949             <a class="code" href="btreeInt_8h.html#ad45c36cb6dcc01158438a66014a133c7">get4byte</a>(&amp;pBt-&gt;<a class="code" href="structBtShared.html#a296dffd1c698ec175fee109718f32d5d">pPage1</a>-&gt;<a class="code" href="structMemPage.html#a2d873eff563d2208be0c24959140a4b0">aData</a>[36]), <span class="stringliteral">&quot;Main freelist: &quot;</span>);
<a name="l06950"></a>06950 
<a name="l06951"></a>06951   <span class="comment">/* Check all the tables.</span>
<a name="l06952"></a>06952 <span class="comment">  */</span>
<a name="l06953"></a>06953   <span class="keywordflow">for</span>(i=0; i&lt;nRoot &amp;&amp; sCheck.<a class="code" href="structIntegrityCk.html#a9daa97cdcb1366c503451ab2af9e7ba6">mxErr</a>; i++){
<a name="l06954"></a>06954     <span class="keywordflow">if</span>( aRoot[i]==0 ) <span class="keywordflow">continue</span>;
<a name="l06955"></a>06955 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06956"></a>06956 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a> &amp;&amp; aRoot[i]&gt;1 ){
<a name="l06957"></a>06957       <a class="code" href="btree_8c.html#a1a0b6cfc7b15f6f3f9ba963067bf699a">checkPtrmap</a>(&amp;sCheck, aRoot[i], <a class="code" href="btreeInt_8h.html#a5379d8ad602ca2c25996e08e33a5e9a9">PTRMAP_ROOTPAGE</a>, 0, 0);
<a name="l06958"></a>06958     }
<a name="l06959"></a>06959 <span class="preprocessor">#endif</span>
<a name="l06960"></a>06960 <span class="preprocessor"></span>    <a class="code" href="btree_8c.html#a1aa25393186cb6c3f26899737be87147">checkTreePage</a>(&amp;sCheck, aRoot[i], 0, <span class="stringliteral">&quot;List of tree roots: &quot;</span>);
<a name="l06961"></a>06961   }
<a name="l06962"></a>06962 
<a name="l06963"></a>06963   <span class="comment">/* Make sure every page in the file is referenced</span>
<a name="l06964"></a>06964 <span class="comment">  */</span>
<a name="l06965"></a>06965   <span class="keywordflow">for</span>(i=1; i&lt;=sCheck.<a class="code" href="structIntegrityCk.html#ad93d80e8c589258d19a1e8efd7ce8bcd">nPage</a> &amp;&amp; sCheck.<a class="code" href="structIntegrityCk.html#a9daa97cdcb1366c503451ab2af9e7ba6">mxErr</a>; i++){
<a name="l06966"></a>06966 <span class="preprocessor">#ifdef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l06967"></a>06967 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( sCheck.<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a>[i]==0 ){
<a name="l06968"></a>06968       <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(&amp;sCheck, 0, <span class="stringliteral">&quot;Page %d is never used&quot;</span>, i);
<a name="l06969"></a>06969     }
<a name="l06970"></a>06970 <span class="preprocessor">#else</span>
<a name="l06971"></a>06971 <span class="preprocessor"></span>    <span class="comment">/* If the database supports auto-vacuum, make sure no tables contain</span>
<a name="l06972"></a>06972 <span class="comment">    ** references to pointer-map pages.</span>
<a name="l06973"></a>06973 <span class="comment">    */</span>
<a name="l06974"></a>06974     <span class="keywordflow">if</span>( sCheck.<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a>[i]==0 &amp;&amp; 
<a name="l06975"></a>06975        (<a class="code" href="btreeInt_8h.html#af4119a9a3bb0a5df2c67d813e9bea637">PTRMAP_PAGENO</a>(pBt, i)!=i || !pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a>) ){
<a name="l06976"></a>06976       <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(&amp;sCheck, 0, <span class="stringliteral">&quot;Page %d is never used&quot;</span>, i);
<a name="l06977"></a>06977     }
<a name="l06978"></a>06978     <span class="keywordflow">if</span>( sCheck.<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a>[i]!=0 &amp;&amp; 
<a name="l06979"></a>06979        (<a class="code" href="btreeInt_8h.html#af4119a9a3bb0a5df2c67d813e9bea637">PTRMAP_PAGENO</a>(pBt, i)==i &amp;&amp; pBt-&gt;<a class="code" href="structBtShared.html#a770c4f6244d4350f27029cb909902a61">autoVacuum</a>) ){
<a name="l06980"></a>06980       <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(&amp;sCheck, 0, <span class="stringliteral">&quot;Pointer map page %d is referenced&quot;</span>, i);
<a name="l06981"></a>06981     }
<a name="l06982"></a>06982 <span class="preprocessor">#endif</span>
<a name="l06983"></a>06983 <span class="preprocessor"></span>  }
<a name="l06984"></a>06984 
<a name="l06985"></a>06985   <span class="comment">/* Make sure this analysis did not leave any unref() pages</span>
<a name="l06986"></a>06986 <span class="comment">  */</span>
<a name="l06987"></a>06987   <a class="code" href="btree_8c.html#ada198bfad4d2c61e88bd9317e98cc96c">unlockBtreeIfUnused</a>(pBt);
<a name="l06988"></a>06988   <span class="keywordflow">if</span>( nRef != <a class="code" href="pager_8c.html#a05500bf4ea783ce94abc20c6153730e5">sqlite3PagerRefcount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>) ){
<a name="l06989"></a>06989     <a class="code" href="btree_8c.html#a126e5fde53e03508de62ccf66f6c1762">checkAppendMsg</a>(&amp;sCheck, 0, 
<a name="l06990"></a>06990       <span class="stringliteral">&quot;Outstanding page count goes from %d to %d during this analysis&quot;</span>,
<a name="l06991"></a>06991       nRef, <a class="code" href="pager_8c.html#a05500bf4ea783ce94abc20c6153730e5">sqlite3PagerRefcount</a>(pBt-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>)
<a name="l06992"></a>06992     );
<a name="l06993"></a>06993   }
<a name="l06994"></a>06994 
<a name="l06995"></a>06995   <span class="comment">/* Clean  up and report errors.</span>
<a name="l06996"></a>06996 <span class="comment">  */</span>
<a name="l06997"></a>06997   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l06998"></a>06998   <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(sCheck.<a class="code" href="structIntegrityCk.html#a8bf40e4a2f13ad3e101f1a4dd7a08ff6">anRef</a>);
<a name="l06999"></a>06999   <span class="keywordflow">if</span>( sCheck.<a class="code" href="structIntegrityCk.html#a8e448c1d6483a0326a7ec39291782030">mallocFailed</a> ){
<a name="l07000"></a>07000     <a class="code" href="printf_8c.html#a21598e5cf362166e3620d6437f26063d">sqlite3StrAccumReset</a>(&amp;sCheck.<a class="code" href="structIntegrityCk.html#a1e9b79bb1d7b22a840001333200a950e">errMsg</a>);
<a name="l07001"></a>07001     *pnErr = sCheck.<a class="code" href="structIntegrityCk.html#a52c815a1d19be87d0ab4dc0a4e4d38e2">nErr</a>+1;
<a name="l07002"></a>07002     <span class="keywordflow">return</span> 0;
<a name="l07003"></a>07003   }
<a name="l07004"></a>07004   *pnErr = sCheck.<a class="code" href="structIntegrityCk.html#a52c815a1d19be87d0ab4dc0a4e4d38e2">nErr</a>;
<a name="l07005"></a>07005   <span class="keywordflow">if</span>( sCheck.<a class="code" href="structIntegrityCk.html#a52c815a1d19be87d0ab4dc0a4e4d38e2">nErr</a>==0 ) <a class="code" href="printf_8c.html#a21598e5cf362166e3620d6437f26063d">sqlite3StrAccumReset</a>(&amp;sCheck.<a class="code" href="structIntegrityCk.html#a1e9b79bb1d7b22a840001333200a950e">errMsg</a>);
<a name="l07006"></a>07006   <span class="keywordflow">return</span> <a class="code" href="printf_8c.html#a15c033b0fde7ec2d50a78c3543e52b9f">sqlite3StrAccumFinish</a>(&amp;sCheck.<a class="code" href="structIntegrityCk.html#a1e9b79bb1d7b22a840001333200a950e">errMsg</a>);
<a name="l07007"></a>07007 }
<a name="l07008"></a>07008 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_INTEGRITY_CHECK */</span>
<a name="l07009"></a>07009 
<a name="l07010"></a>07010 <span class="comment">/*</span>
<a name="l07011"></a>07011 <span class="comment">** Return the full pathname of the underlying database file.</span>
<a name="l07012"></a>07012 <span class="comment">**</span>
<a name="l07013"></a>07013 <span class="comment">** The pager filename is invariant as long as the pager is</span>
<a name="l07014"></a>07014 <span class="comment">** open so it is safe to access without the BtShared mutex.</span>
<a name="l07015"></a>07015 <span class="comment">*/</span>
<a name="l07016"></a><a class="code" href="btree_8h.html#ab337095274be2fb005784128f2568abf">07016</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="btree_8c.html#ae559bdc5deaabdec6e91bf5477cbaa47">sqlite3BtreeGetFilename</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l07017"></a>07017   assert( p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>!=0 );
<a name="l07018"></a>07018   <span class="keywordflow">return</span> <a class="code" href="pager_8c.html#a847887e627ae6a0ac767663f8b1da8e5">sqlite3PagerFilename</a>(p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l07019"></a>07019 }
<a name="l07020"></a>07020 
<a name="l07021"></a>07021 <span class="comment">/*</span>
<a name="l07022"></a>07022 <span class="comment">** Return the pathname of the directory that contains the database file.</span>
<a name="l07023"></a>07023 <span class="comment">**</span>
<a name="l07024"></a>07024 <span class="comment">** The pager directory name is invariant as long as the pager is</span>
<a name="l07025"></a>07025 <span class="comment">** open so it is safe to access without the BtShared mutex.</span>
<a name="l07026"></a>07026 <span class="comment">*/</span>
<a name="l07027"></a><a class="code" href="btree_8h.html#a02810b2781b4e0b116dfb0da782f2273">07027</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="btree_8c.html#ac25feffedc6fcd95915b0cf30f7965b3">sqlite3BtreeGetDirname</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l07028"></a>07028   assert( p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>!=0 );
<a name="l07029"></a>07029   <span class="keywordflow">return</span> <a class="code" href="pager_8c.html#ac868339d2f25f8c98a38f9fb24448c47">sqlite3PagerDirname</a>(p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l07030"></a>07030 }
<a name="l07031"></a>07031 
<a name="l07032"></a>07032 <span class="comment">/*</span>
<a name="l07033"></a>07033 <span class="comment">** Return the pathname of the journal file for this database. The return</span>
<a name="l07034"></a>07034 <span class="comment">** value of this routine is the same regardless of whether the journal file</span>
<a name="l07035"></a>07035 <span class="comment">** has been created or not.</span>
<a name="l07036"></a>07036 <span class="comment">**</span>
<a name="l07037"></a>07037 <span class="comment">** The pager journal filename is invariant as long as the pager is</span>
<a name="l07038"></a>07038 <span class="comment">** open so it is safe to access without the BtShared mutex.</span>
<a name="l07039"></a>07039 <span class="comment">*/</span>
<a name="l07040"></a><a class="code" href="btree_8h.html#a123e15707cd5ba056d5ef5f1e868313d">07040</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="btree_8c.html#aeb149d6e7384787932d54485512cd97d">sqlite3BtreeGetJournalname</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l07041"></a>07041   assert( p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>!=0 );
<a name="l07042"></a>07042   <span class="keywordflow">return</span> <a class="code" href="pager_8c.html#a610e31b7e30c507fe0a6373743655d5e">sqlite3PagerJournalname</a>(p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l07043"></a>07043 }
<a name="l07044"></a>07044 
<a name="l07045"></a>07045 <span class="preprocessor">#ifndef SQLITE_OMIT_VACUUM</span>
<a name="l07046"></a>07046 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l07047"></a>07047 <span class="comment">** Copy the complete content of pBtFrom into pBtTo.  A transaction</span>
<a name="l07048"></a>07048 <span class="comment">** must be active for both files.</span>
<a name="l07049"></a>07049 <span class="comment">**</span>
<a name="l07050"></a>07050 <span class="comment">** The size of file pTo may be reduced by this operation.</span>
<a name="l07051"></a>07051 <span class="comment">** If anything goes wrong, the transaction on pTo is rolled back. </span>
<a name="l07052"></a>07052 <span class="comment">**</span>
<a name="l07053"></a>07053 <span class="comment">** If successful, CommitPhaseOne() may be called on pTo before returning. </span>
<a name="l07054"></a>07054 <span class="comment">** The caller should finish committing the transaction on pTo by calling</span>
<a name="l07055"></a>07055 <span class="comment">** sqlite3BtreeCommit().</span>
<a name="l07056"></a>07056 <span class="comment">*/</span>
<a name="l07057"></a><a class="code" href="btree_8c.html#a4849501aaa4a52fc66edd227845bcf89">07057</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a4849501aaa4a52fc66edd227845bcf89">btreeCopyFile</a>(<a class="code" href="structBtree.html">Btree</a> *pTo, <a class="code" href="structBtree.html">Btree</a> *pFrom){
<a name="l07058"></a>07058   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l07059"></a>07059   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> i;
<a name="l07060"></a>07060 
<a name="l07061"></a>07061   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nFromPage;     <span class="comment">/* Number of pages in pFrom */</span>
<a name="l07062"></a>07062   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nToPage;       <span class="comment">/* Number of pages in pTo */</span>
<a name="l07063"></a>07063   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> nNewPage;      <span class="comment">/* Number of pages in pTo after the copy */</span>
<a name="l07064"></a>07064 
<a name="l07065"></a>07065   <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iSkip;         <span class="comment">/* Pending byte page in pTo */</span>
<a name="l07066"></a>07066   <span class="keywordtype">int</span> nToPageSize;    <span class="comment">/* Page size of pTo in bytes */</span>
<a name="l07067"></a>07067   <span class="keywordtype">int</span> nFromPageSize;  <span class="comment">/* Page size of pFrom in bytes */</span>
<a name="l07068"></a>07068 
<a name="l07069"></a>07069   <a class="code" href="structBtShared.html">BtShared</a> *pBtTo = pTo-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l07070"></a>07070   <a class="code" href="structBtShared.html">BtShared</a> *pBtFrom = pFrom-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l07071"></a>07071   pBtTo-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = pTo-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l07072"></a>07072   pBtFrom-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = pFrom-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l07073"></a>07073 
<a name="l07074"></a>07074   nToPageSize = pBtTo-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>;
<a name="l07075"></a>07075   nFromPageSize = pBtFrom-&gt;<a class="code" href="structBtShared.html#a8be98772b09fbebf55284fdc1526c9b9">pageSize</a>;
<a name="l07076"></a>07076 
<a name="l07077"></a>07077   <span class="keywordflow">if</span>( pTo-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>!=<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> || pFrom-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>!=<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> ){
<a name="l07078"></a>07078     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l07079"></a>07079   }
<a name="l07080"></a>07080   <span class="keywordflow">if</span>( pBtTo-&gt;<a class="code" href="structBtShared.html#a8f8b52dee390e5606e8e2a8511530de7">pCursor</a> ){
<a name="l07081"></a>07081     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l07082"></a>07082   }
<a name="l07083"></a>07083 
<a name="l07084"></a>07084   nToPage = <a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBtTo-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l07085"></a>07085   nFromPage = <a class="code" href="btree_8c.html#a07738a63ba05b2f6937d860ad26da286">pagerPagecount</a>(pBtFrom-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l07086"></a>07086   iSkip = <a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBtTo);
<a name="l07087"></a>07087 
<a name="l07088"></a>07088   <span class="comment">/* Variable nNewPage is the number of pages required to store the</span>
<a name="l07089"></a>07089 <span class="comment">  ** contents of pFrom using the current page-size of pTo.</span>
<a name="l07090"></a>07090 <span class="comment">  */</span>
<a name="l07091"></a>07091   nNewPage = ((<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)nFromPage * (<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)nFromPageSize + (<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)nToPageSize - 1) / 
<a name="l07092"></a>07092       (<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)nToPageSize;
<a name="l07093"></a>07093 
<a name="l07094"></a>07094   <span class="keywordflow">for</span>(i=1; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; (i&lt;=nToPage || i&lt;=nNewPage); i++){
<a name="l07095"></a>07095 
<a name="l07096"></a>07096     <span class="comment">/* Journal the original page.</span>
<a name="l07097"></a>07097 <span class="comment">    **</span>
<a name="l07098"></a>07098 <span class="comment">    ** iSkip is the page number of the locking page (PENDING_BYTE_PAGE)</span>
<a name="l07099"></a>07099 <span class="comment">    ** in database *pTo (before the copy). This page is never written </span>
<a name="l07100"></a>07100 <span class="comment">    ** into the journal file. Unless i==iSkip or the page was not</span>
<a name="l07101"></a>07101 <span class="comment">    ** present in pTo before the copy operation, journal page i from pTo.</span>
<a name="l07102"></a>07102 <span class="comment">    */</span>
<a name="l07103"></a>07103     <span class="keywordflow">if</span>( i!=iSkip &amp;&amp; i&lt;=nToPage ){
<a name="l07104"></a>07104       <a class="code" href="structPgHdr.html">DbPage</a> *pDbPage = 0;
<a name="l07105"></a>07105       rc = <a class="code" href="pager_8h.html#ac690af087310cf9d64d04d8559be402e">sqlite3PagerGet</a>(pBtTo-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, i, &amp;pDbPage);
<a name="l07106"></a>07106       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l07107"></a>07107         rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pDbPage);
<a name="l07108"></a>07108         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; i&gt;nFromPage ){
<a name="l07109"></a>07109           <span class="comment">/* Yeah.  It seems wierd to call DontWrite() right after Write(). But</span>
<a name="l07110"></a>07110 <span class="comment">          ** that is because the names of those procedures do not exactly </span>
<a name="l07111"></a>07111 <span class="comment">          ** represent what they do.  Write() really means &quot;put this page in the</span>
<a name="l07112"></a>07112 <span class="comment">          ** rollback journal and mark it as dirty so that it will be written</span>
<a name="l07113"></a>07113 <span class="comment">          ** to the database file later.&quot;  DontWrite() undoes the second part of</span>
<a name="l07114"></a>07114 <span class="comment">          ** that and prevents the page from being written to the database. The</span>
<a name="l07115"></a>07115 <span class="comment">          ** page is still on the rollback journal, though.  And that is the </span>
<a name="l07116"></a>07116 <span class="comment">          ** whole point of this block: to put pages on the rollback journal. </span>
<a name="l07117"></a>07117 <span class="comment">          */</span>
<a name="l07118"></a>07118           rc = <a class="code" href="pager_8c.html#a4f9135ca0b47f3b2d19c8ec234d2dfd3">sqlite3PagerDontWrite</a>(pDbPage);
<a name="l07119"></a>07119         }
<a name="l07120"></a>07120         <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pDbPage);
<a name="l07121"></a>07121       }
<a name="l07122"></a>07122     }
<a name="l07123"></a>07123 
<a name="l07124"></a>07124     <span class="comment">/* Overwrite the data in page i of the target database */</span>
<a name="l07125"></a>07125     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; i!=iSkip &amp;&amp; i&lt;=nNewPage ){
<a name="l07126"></a>07126 
<a name="l07127"></a>07127       <a class="code" href="structPgHdr.html">DbPage</a> *pToPage = 0;
<a name="l07128"></a>07128       <a class="code" href="sqlite3_8h.html#a0a4d3e6c1ad46f90e746b920ab6ca0d2">sqlite3_int64</a> iOff;
<a name="l07129"></a>07129 
<a name="l07130"></a>07130       rc = <a class="code" href="pager_8h.html#ac690af087310cf9d64d04d8559be402e">sqlite3PagerGet</a>(pBtTo-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, i, &amp;pToPage);
<a name="l07131"></a>07131       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l07132"></a>07132         rc = <a class="code" href="pager_8c.html#a97d748e41915cfbed53c07bedaf36217">sqlite3PagerWrite</a>(pToPage);
<a name="l07133"></a>07133       }
<a name="l07134"></a>07134 
<a name="l07135"></a>07135       <span class="keywordflow">for</span>(
<a name="l07136"></a>07136         iOff=(i-1)*nToPageSize; 
<a name="l07137"></a>07137         rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; iOff&lt;i*nToPageSize; 
<a name="l07138"></a>07138         iOff += nFromPageSize
<a name="l07139"></a>07139       ){
<a name="l07140"></a>07140         <a class="code" href="structPgHdr.html">DbPage</a> *pFromPage = 0;
<a name="l07141"></a>07141         <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iFrom = (iOff/nFromPageSize)+1;
<a name="l07142"></a>07142 
<a name="l07143"></a>07143         <span class="keywordflow">if</span>( iFrom==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBtFrom) ){
<a name="l07144"></a>07144           <span class="keywordflow">continue</span>;
<a name="l07145"></a>07145         }
<a name="l07146"></a>07146 
<a name="l07147"></a>07147         rc = <a class="code" href="pager_8h.html#ac690af087310cf9d64d04d8559be402e">sqlite3PagerGet</a>(pBtFrom-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, iFrom, &amp;pFromPage);
<a name="l07148"></a>07148         <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l07149"></a>07149           <span class="keywordtype">char</span> *zTo = <a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pToPage);
<a name="l07150"></a>07150           <span class="keywordtype">char</span> *zFrom = <a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pFromPage);
<a name="l07151"></a>07151           <span class="keywordtype">int</span> nCopy;
<a name="l07152"></a>07152 
<a name="l07153"></a>07153           <span class="keywordflow">if</span>( nFromPageSize&gt;=nToPageSize ){
<a name="l07154"></a>07154             zFrom += ((i-1)*nToPageSize - ((iFrom-1)*nFromPageSize));
<a name="l07155"></a>07155             nCopy = nToPageSize;
<a name="l07156"></a>07156           }<span class="keywordflow">else</span>{
<a name="l07157"></a>07157             zTo += (((iFrom-1)*nFromPageSize) - (i-1)*nToPageSize);
<a name="l07158"></a>07158             nCopy = nFromPageSize;
<a name="l07159"></a>07159           }
<a name="l07160"></a>07160 
<a name="l07161"></a>07161           memcpy(zTo, zFrom, nCopy);
<a name="l07162"></a>07162           <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pFromPage);
<a name="l07163"></a>07163         }
<a name="l07164"></a>07164       }
<a name="l07165"></a>07165 
<a name="l07166"></a>07166       <span class="keywordflow">if</span>( pToPage ){
<a name="l07167"></a>07167         <a class="code" href="structMemPage.html">MemPage</a> *p = (<a class="code" href="structMemPage.html">MemPage</a> *)<a class="code" href="pager_8c.html#a439dda936e73b4bceae7d0a7950d2af6">sqlite3PagerGetExtra</a>(pToPage);
<a name="l07168"></a>07168         p-&gt;<a class="code" href="structMemPage.html#a3ab4ace46245be0fb2fb19eaa2862019">isInit</a> = 0;
<a name="l07169"></a>07169         <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pToPage);
<a name="l07170"></a>07170       }
<a name="l07171"></a>07171     }
<a name="l07172"></a>07172   }
<a name="l07173"></a>07173 
<a name="l07174"></a>07174   <span class="comment">/* If things have worked so far, the database file may need to be </span>
<a name="l07175"></a>07175 <span class="comment">  ** truncated. The complex part is that it may need to be truncated to</span>
<a name="l07176"></a>07176 <span class="comment">  ** a size that is not an integer multiple of nToPageSize - the current</span>
<a name="l07177"></a>07177 <span class="comment">  ** page size used by the pager associated with B-Tree pTo.</span>
<a name="l07178"></a>07178 <span class="comment">  **</span>
<a name="l07179"></a>07179 <span class="comment">  ** For example, say the page-size of pTo is 2048 bytes and the original </span>
<a name="l07180"></a>07180 <span class="comment">  ** number of pages is 5 (10 KB file). If pFrom has a page size of 1024 </span>
<a name="l07181"></a>07181 <span class="comment">  ** bytes and 9 pages, then the file needs to be truncated to 9KB.</span>
<a name="l07182"></a>07182 <span class="comment">  */</span>
<a name="l07183"></a>07183   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l07184"></a>07184     <span class="keywordflow">if</span>( nFromPageSize!=nToPageSize ){
<a name="l07185"></a>07185       <a class="code" href="structsqlite3__file.html">sqlite3_file</a> *pFile = <a class="code" href="pager_8c.html#a46f35421146c2d9d2740052b1d6f711f">sqlite3PagerFile</a>(pBtTo-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l07186"></a>07186       <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> iSize = (<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)nFromPageSize * (<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)nFromPage;
<a name="l07187"></a>07187       <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> iNow = (<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)((nToPage&gt;nNewPage)?nToPage:nNewPage) * (<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)nToPageSize; 
<a name="l07188"></a>07188       <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> iPending = ((<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBtTo)-1) *(<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)nToPageSize;
<a name="l07189"></a>07189   
<a name="l07190"></a>07190       assert( iSize&lt;=iNow );
<a name="l07191"></a>07191   
<a name="l07192"></a>07192       <span class="comment">/* Commit phase one syncs the journal file associated with pTo </span>
<a name="l07193"></a>07193 <span class="comment">      ** containing the original data. It does not sync the database file</span>
<a name="l07194"></a>07194 <span class="comment">      ** itself. After doing this it is safe to use OsTruncate() and other</span>
<a name="l07195"></a>07195 <span class="comment">      ** file APIs on the database file directly.</span>
<a name="l07196"></a>07196 <span class="comment">      */</span>
<a name="l07197"></a>07197       pBtTo-&gt;<a class="code" href="structBtShared.html#a93dafa672793f6117a336d5987951c8e">db</a> = pTo-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>;
<a name="l07198"></a>07198       rc = <a class="code" href="pager_8c.html#a97867dfbbcc9f163e9146c56af2c6918">sqlite3PagerCommitPhaseOne</a>(pBtTo-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, 0, 0, 1);
<a name="l07199"></a>07199       <span class="keywordflow">if</span>( iSize&lt;iNow &amp;&amp; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l07200"></a>07200         rc = <a class="code" href="os_8c.html#ac9663a9bea01b912890e14e536f181a9">sqlite3OsTruncate</a>(pFile, iSize);
<a name="l07201"></a>07201       }
<a name="l07202"></a>07202   
<a name="l07203"></a>07203       <span class="comment">/* The loop that copied data from database pFrom to pTo did not</span>
<a name="l07204"></a>07204 <span class="comment">      ** populate the locking page of database pTo. If the page-size of</span>
<a name="l07205"></a>07205 <span class="comment">      ** pFrom is smaller than that of pTo, this means some data will</span>
<a name="l07206"></a>07206 <span class="comment">      ** not have been copied. </span>
<a name="l07207"></a>07207 <span class="comment">      **</span>
<a name="l07208"></a>07208 <span class="comment">      ** This block copies the missing data from database pFrom to pTo </span>
<a name="l07209"></a>07209 <span class="comment">      ** using file APIs. This is safe because at this point we know that</span>
<a name="l07210"></a>07210 <span class="comment">      ** all of the original data from pTo has been synced into the </span>
<a name="l07211"></a>07211 <span class="comment">      ** journal file. At this point it would be safe to do anything at</span>
<a name="l07212"></a>07212 <span class="comment">      ** all to the database file except truncate it to zero bytes.</span>
<a name="l07213"></a>07213 <span class="comment">      */</span>
<a name="l07214"></a>07214       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; nFromPageSize&lt;nToPageSize &amp;&amp; iSize&gt;iPending){
<a name="l07215"></a>07215         <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> iOff;
<a name="l07216"></a>07216         <span class="keywordflow">for</span>(
<a name="l07217"></a>07217           iOff=iPending; 
<a name="l07218"></a>07218           rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; iOff&lt;(iPending+nToPageSize); 
<a name="l07219"></a>07219           iOff += nFromPageSize
<a name="l07220"></a>07220         ){
<a name="l07221"></a>07221           <a class="code" href="structPgHdr.html">DbPage</a> *pFromPage = 0;
<a name="l07222"></a>07222           <a class="code" href="pager_8h.html#aec0c653e8dd16e4639caf2f8ea54f55c">Pgno</a> iFrom = (iOff/nFromPageSize)+1;
<a name="l07223"></a>07223   
<a name="l07224"></a>07224           <span class="keywordflow">if</span>( iFrom==<a class="code" href="btreeInt_8h.html#aeb787f0e765b267007078818f7e289a1">PENDING_BYTE_PAGE</a>(pBtFrom) || iFrom&gt;nFromPage ){
<a name="l07225"></a>07225             <span class="keywordflow">continue</span>;
<a name="l07226"></a>07226           }
<a name="l07227"></a>07227   
<a name="l07228"></a>07228           rc = <a class="code" href="pager_8h.html#ac690af087310cf9d64d04d8559be402e">sqlite3PagerGet</a>(pBtFrom-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, iFrom, &amp;pFromPage);
<a name="l07229"></a>07229           <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l07230"></a>07230             <span class="keywordtype">char</span> *zFrom = <a class="code" href="pager_8c.html#aa508a0d08e749afa9401c94bd8e879ce">sqlite3PagerGetData</a>(pFromPage);
<a name="l07231"></a>07231             rc = <a class="code" href="os_8c.html#ab2aa7b80aa192c498f721ad60860315e">sqlite3OsWrite</a>(pFile, zFrom, nFromPageSize, iOff);
<a name="l07232"></a>07232             <a class="code" href="pager_8c.html#ab9e715de76adb85486807fecf1e44a7d">sqlite3PagerUnref</a>(pFromPage);
<a name="l07233"></a>07233           }
<a name="l07234"></a>07234         }
<a name="l07235"></a>07235       }
<a name="l07236"></a>07236   
<a name="l07237"></a>07237       <span class="comment">/* Sync the database file */</span>
<a name="l07238"></a>07238       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l07239"></a>07239         rc = <a class="code" href="pager_8c.html#a16dbd8db2aea72223aab3f539cba9e51">sqlite3PagerSync</a>(pBtTo-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>);
<a name="l07240"></a>07240       }
<a name="l07241"></a>07241     }<span class="keywordflow">else</span>{
<a name="l07242"></a>07242       rc = <a class="code" href="pager_8c.html#aaaf36f54c150ce62f12ee70a0b9c3375">sqlite3PagerTruncate</a>(pBtTo-&gt;<a class="code" href="structBtShared.html#ab79703fc47a16446274457588d7eb989">pPager</a>, nNewPage);
<a name="l07243"></a>07243     }
<a name="l07244"></a>07244     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l07245"></a>07245       pBtTo-&gt;<a class="code" href="structBtShared.html#a0e728415ef91a26a8a1c6c9a6a9d8cd0">pageSizeFixed</a> = 0;
<a name="l07246"></a>07246     }
<a name="l07247"></a>07247   }
<a name="l07248"></a>07248 
<a name="l07249"></a>07249   <span class="keywordflow">if</span>( rc ){
<a name="l07250"></a>07250     <a class="code" href="btree_8c.html#a447e8e3e0dc60f5adaa0f1f13980fc2d">sqlite3BtreeRollback</a>(pTo);
<a name="l07251"></a>07251   }
<a name="l07252"></a>07252 
<a name="l07253"></a>07253   <span class="keywordflow">return</span> rc;  
<a name="l07254"></a>07254 }
<a name="l07255"></a><a class="code" href="btree_8h.html#adc265a571cfd1b41d66c0c72147d7716">07255</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#af3a0de9254d12ec3136b9a838d22d783">sqlite3BtreeCopyFile</a>(<a class="code" href="structBtree.html">Btree</a> *pTo, <a class="code" href="structBtree.html">Btree</a> *pFrom){
<a name="l07256"></a>07256   <span class="keywordtype">int</span> rc;
<a name="l07257"></a>07257   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(pTo);
<a name="l07258"></a>07258   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(pFrom);
<a name="l07259"></a>07259   rc = <a class="code" href="btree_8c.html#a4849501aaa4a52fc66edd227845bcf89">btreeCopyFile</a>(pTo, pFrom);
<a name="l07260"></a>07260   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(pFrom);
<a name="l07261"></a>07261   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(pTo);
<a name="l07262"></a>07262   <span class="keywordflow">return</span> rc;
<a name="l07263"></a>07263 }
<a name="l07264"></a>07264 
<a name="l07265"></a>07265 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VACUUM */</span>
<a name="l07266"></a>07266 
<a name="l07267"></a>07267 <span class="comment">/*</span>
<a name="l07268"></a>07268 <span class="comment">** Return non-zero if a transaction is active.</span>
<a name="l07269"></a>07269 <span class="comment">*/</span>
<a name="l07270"></a><a class="code" href="btree_8h.html#ab71b821fc572c0539bb2e0e6fb004e03">07270</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aeff539aa1765b2b7a18313c3cc26d0ba">sqlite3BtreeIsInTrans</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l07271"></a>07271   assert( p==0 || <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l07272"></a>07272   <span class="keywordflow">return</span> (p &amp;&amp; (p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a>));
<a name="l07273"></a>07273 }
<a name="l07274"></a>07274 
<a name="l07275"></a>07275 <span class="comment">/*</span>
<a name="l07276"></a>07276 <span class="comment">** Return non-zero if a statement transaction is active.</span>
<a name="l07277"></a>07277 <span class="comment">*/</span>
<a name="l07278"></a><a class="code" href="btree_8h.html#a9d8f6c2e05e75d5672f48820f718fd22">07278</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ab0fb6d779e98974c2bcb108d7944cc28">sqlite3BtreeIsInStmt</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l07279"></a>07279   assert( sqlite3BtreeHoldsMutex(p) );
<a name="l07280"></a>07280   <span class="keywordflow">return</span> (p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a> &amp;&amp; p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>-&gt;<a class="code" href="structBtShared.html#ab050a6b7688fa15a810ebc737502fb78">inStmt</a>);
<a name="l07281"></a>07281 }
<a name="l07282"></a>07282 
<a name="l07283"></a>07283 <span class="comment">/*</span>
<a name="l07284"></a>07284 <span class="comment">** Return non-zero if a read (or write) transaction is active.</span>
<a name="l07285"></a>07285 <span class="comment">*/</span>
<a name="l07286"></a><a class="code" href="btree_8h.html#a0cda9d36e59755a6bd34c543d146495f">07286</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a20e1df2d86a8c694741f1fc2e2821b28">sqlite3BtreeIsInReadTrans</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l07287"></a>07287   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l07288"></a>07288   <span class="keywordflow">return</span> (p &amp;&amp; (p-&gt;<a class="code" href="structBtree.html#a50007448960c05dfd1fdc7db3e277685">inTrans</a>!=<a class="code" href="btreeInt_8h.html#a3d84378ff00b1fab57bdf5017f4f6ce0">TRANS_NONE</a>));
<a name="l07289"></a>07289 }
<a name="l07290"></a>07290 
<a name="l07291"></a>07291 <span class="comment">/*</span>
<a name="l07292"></a>07292 <span class="comment">** This function returns a pointer to a blob of memory associated with</span>
<a name="l07293"></a>07293 <span class="comment">** a single shared-btree. The memory is used by client code for its own</span>
<a name="l07294"></a>07294 <span class="comment">** purposes (for example, to store a high-level schema associated with </span>
<a name="l07295"></a>07295 <span class="comment">** the shared-btree). The btree layer manages reference counting issues.</span>
<a name="l07296"></a>07296 <span class="comment">**</span>
<a name="l07297"></a>07297 <span class="comment">** The first time this is called on a shared-btree, nBytes bytes of memory</span>
<a name="l07298"></a>07298 <span class="comment">** are allocated, zeroed, and returned to the caller. For each subsequent </span>
<a name="l07299"></a>07299 <span class="comment">** call the nBytes parameter is ignored and a pointer to the same blob</span>
<a name="l07300"></a>07300 <span class="comment">** of memory returned. </span>
<a name="l07301"></a>07301 <span class="comment">**</span>
<a name="l07302"></a>07302 <span class="comment">** If the nBytes parameter is 0 and the blob of memory has not yet been</span>
<a name="l07303"></a>07303 <span class="comment">** allocated, a null pointer is returned. If the blob has already been</span>
<a name="l07304"></a>07304 <span class="comment">** allocated, it is returned as normal.</span>
<a name="l07305"></a>07305 <span class="comment">**</span>
<a name="l07306"></a>07306 <span class="comment">** Just before the shared-btree is closed, the function passed as the </span>
<a name="l07307"></a>07307 <span class="comment">** xFree argument when the memory allocation was made is invoked on the </span>
<a name="l07308"></a>07308 <span class="comment">** blob of allocated memory. This function should not call sqlite3_free()</span>
<a name="l07309"></a>07309 <span class="comment">** on the memory, the btree layer does that.</span>
<a name="l07310"></a>07310 <span class="comment">*/</span>
<a name="l07311"></a><a class="code" href="btree_8h.html#acd0607ef97bffe5c191b721284b3c5e1">07311</a> <span class="keywordtype">void</span> *<a class="code" href="btree_8c.html#a27b03e6c5ebff6bb368c13d7f1352839">sqlite3BtreeSchema</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> nBytes, <span class="keywordtype">void</span>(*<a class="code" href="icu_8c.html#a33364592b0ec053767ef4d1781939073">xFree</a>)(<span class="keywordtype">void</span> *)){
<a name="l07312"></a>07312   <a class="code" href="structBtShared.html">BtShared</a> *pBt = p-&gt;<a class="code" href="structBtree.html#a63bab5d744d48d14368af048dddf2f20">pBt</a>;
<a name="l07313"></a>07313   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l07314"></a>07314   <span class="keywordflow">if</span>( !pBt-&gt;<a class="code" href="structBtShared.html#aea3ccb6775c768fbd4f3e29df8cb925d">pSchema</a> &amp;&amp; nBytes ){
<a name="l07315"></a>07315     pBt-&gt;<a class="code" href="structBtShared.html#aea3ccb6775c768fbd4f3e29df8cb925d">pSchema</a> = <a class="code" href="malloc_8c.html#aa88ccfc5604fb4bd9b60b3ca4f9f58d4">sqlite3MallocZero</a>(nBytes);
<a name="l07316"></a>07316     pBt-&gt;<a class="code" href="structBtShared.html#a7c4816c63acea30ed44ffc58b468463e">xFreeSchema</a> = <a class="code" href="icu_8c.html#a33364592b0ec053767ef4d1781939073">xFree</a>;
<a name="l07317"></a>07317   }
<a name="l07318"></a>07318   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l07319"></a>07319   <span class="keywordflow">return</span> pBt-&gt;<a class="code" href="structBtShared.html#aea3ccb6775c768fbd4f3e29df8cb925d">pSchema</a>;
<a name="l07320"></a>07320 }
<a name="l07321"></a>07321 
<a name="l07322"></a>07322 <span class="comment">/*</span>
<a name="l07323"></a>07323 <span class="comment">** Return true if another user of the same shared btree as the argument</span>
<a name="l07324"></a>07324 <span class="comment">** handle holds an exclusive lock on the sqlite_master table.</span>
<a name="l07325"></a>07325 <span class="comment">*/</span>
<a name="l07326"></a><a class="code" href="btree_8h.html#ad62ec4257042e3328a4463bde5aa9b14">07326</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#a2b2573d96fb0f726092bdffef068f44d">sqlite3BtreeSchemaLocked</a>(<a class="code" href="structBtree.html">Btree</a> *p){
<a name="l07327"></a>07327   <span class="keywordtype">int</span> rc;
<a name="l07328"></a>07328   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(p-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l07329"></a>07329   <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l07330"></a>07330   rc = (<a class="code" href="btree_8c.html#a950bafa2f267025f9e7369992a6aa026">queryTableLock</a>(p, <a class="code" href="sqliteInt_8h.html#a55c81f26551028f4d36e84190993eaed">MASTER_ROOT</a>, <a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a>)!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>);
<a name="l07331"></a>07331   <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l07332"></a>07332   <span class="keywordflow">return</span> rc;
<a name="l07333"></a>07333 }
<a name="l07334"></a>07334 
<a name="l07335"></a>07335 
<a name="l07336"></a>07336 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l07337"></a>07337 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l07338"></a>07338 <span class="comment">** Obtain a lock on the table whose root page is iTab.  The</span>
<a name="l07339"></a>07339 <span class="comment">** lock is a write lock if isWritelock is true or a read lock</span>
<a name="l07340"></a>07340 <span class="comment">** if it is false.</span>
<a name="l07341"></a>07341 <span class="comment">*/</span>
<a name="l07342"></a><a class="code" href="btree_8h.html#a207a6d5fc223206d29d96c8b756d1c3e">07342</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#ac35d9d8d0f266255426a432a77d08942">sqlite3BtreeLockTable</a>(<a class="code" href="structBtree.html">Btree</a> *p, <span class="keywordtype">int</span> iTab, <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> isWriteLock){
<a name="l07343"></a>07343   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l07344"></a>07344   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structBtree.html#a114f157127c76a1fbad8292e4b39c4dd">sharable</a> ){
<a name="l07345"></a>07345     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> lockType = <a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a> + isWriteLock;
<a name="l07346"></a>07346     assert( <a class="code" href="btreeInt_8h.html#a5b9b681ff830ce05cc03c3ad38019817">READ_LOCK</a>+1==<a class="code" href="btreeInt_8h.html#ac917241e9ac8d772d244a2a5bfcf4506">WRITE_LOCK</a> );
<a name="l07347"></a>07347     assert( isWriteLock==0 || isWriteLock==1 );
<a name="l07348"></a>07348     <a class="code" href="btree_8h.html#a56a39b11f155ee99c00f24e119d6d78a">sqlite3BtreeEnter</a>(p);
<a name="l07349"></a>07349     rc = <a class="code" href="btree_8c.html#a950bafa2f267025f9e7369992a6aa026">queryTableLock</a>(p, iTab, lockType);
<a name="l07350"></a>07350     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l07351"></a>07351       rc = <a class="code" href="btree_8c.html#a089cf86fc7bb3c6873eb1cc4ae547578">lockTable</a>(p, iTab, lockType);
<a name="l07352"></a>07352     }
<a name="l07353"></a>07353     <a class="code" href="btree_8h.html#a9fe50dc54d10997ed95d1999ec173236">sqlite3BtreeLeave</a>(p);
<a name="l07354"></a>07354   }
<a name="l07355"></a>07355   <span class="keywordflow">return</span> rc;
<a name="l07356"></a>07356 }
<a name="l07357"></a>07357 <span class="preprocessor">#endif</span>
<a name="l07358"></a>07358 <span class="preprocessor"></span>
<a name="l07359"></a>07359 <span class="preprocessor">#ifndef SQLITE_OMIT_INCRBLOB</span>
<a name="l07360"></a>07360 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l07361"></a>07361 <span class="comment">** Argument pCsr must be a cursor opened for writing on an </span>
<a name="l07362"></a>07362 <span class="comment">** INTKEY table currently pointing at a valid table entry. </span>
<a name="l07363"></a>07363 <span class="comment">** This function modifies the data stored as part of that entry.</span>
<a name="l07364"></a>07364 <span class="comment">** Only the data content may only be modified, it is not possible</span>
<a name="l07365"></a>07365 <span class="comment">** to change the length of the data stored.</span>
<a name="l07366"></a>07366 <span class="comment">*/</span>
<a name="l07367"></a><a class="code" href="btree_8h.html#a0e6509b021232418e9e613e4c763657e">07367</a> <span class="keywordtype">int</span> <a class="code" href="btree_8c.html#aaa41f4fd4d084006d21f5637ae93901c">sqlite3BtreePutData</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCsr, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> offset, <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> amt, <span class="keywordtype">void</span> *z){
<a name="l07368"></a>07368   assert( cursorHoldsMutex(pCsr) );
<a name="l07369"></a>07369   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pCsr-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l07370"></a>07370   assert(pCsr-&gt;<a class="code" href="structBtCursor.html#a539dc1beff0ec303cfd4c94c274c7a9b">isIncrblobHandle</a>);
<a name="l07371"></a>07371 
<a name="l07372"></a>07372   <a class="code" href="btree_8c.html#a291b3e39e6c5a36b58cdc5a60b8c72bd">restoreCursorPosition</a>(pCsr);
<a name="l07373"></a>07373   assert( pCsr-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>!=<a class="code" href="btreeInt_8h.html#aa6b8c9600c6ffb4faf986e971f674800">CURSOR_REQUIRESEEK</a> );
<a name="l07374"></a>07374   <span class="keywordflow">if</span>( pCsr-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>!=<a class="code" href="btreeInt_8h.html#af9edc0fa22d6d6b71468317c6cb527e3">CURSOR_VALID</a> ){
<a name="l07375"></a>07375     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab0c18279e950b695575a4667c7bb38b7">SQLITE_ABORT</a>;
<a name="l07376"></a>07376   }
<a name="l07377"></a>07377 
<a name="l07378"></a>07378   <span class="comment">/* Check some preconditions: </span>
<a name="l07379"></a>07379 <span class="comment">  **   (a) the cursor is open for writing,</span>
<a name="l07380"></a>07380 <span class="comment">  **   (b) there is no read-lock on the table being modified and</span>
<a name="l07381"></a>07381 <span class="comment">  **   (c) the cursor points at a valid row of an intKey table.</span>
<a name="l07382"></a>07382 <span class="comment">  */</span>
<a name="l07383"></a>07383   <span class="keywordflow">if</span>( !pCsr-&gt;<a class="code" href="structBtCursor.html#a9482c52d8c85519a3ada18517bf67a47">wrFlag</a> ){
<a name="l07384"></a>07384     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a>;
<a name="l07385"></a>07385   }
<a name="l07386"></a>07386   assert( !pCsr-&gt;<a class="code" href="structBtCursor.html#a61c245712549192f7644e5ac23c00b74">pBt</a>-&gt;<a class="code" href="structBtShared.html#ac8e55afc249f7ffa3d0f5dd5637d3825">readOnly</a> 
<a name="l07387"></a>07387           &amp;&amp; pCsr-&gt;<a class="code" href="structBtCursor.html#a61c245712549192f7644e5ac23c00b74">pBt</a>-&gt;<a class="code" href="structBtShared.html#aeaa6c0f33b83434ecee4bd8c4c8df48e">inTransaction</a>==<a class="code" href="btreeInt_8h.html#a44233c5892ed8292d0e28a52cfacd8a2">TRANS_WRITE</a> );
<a name="l07388"></a>07388   <span class="keywordflow">if</span>( <a class="code" href="btree_8c.html#accb60c0dac28fa55737649f0c556eef9">checkReadLocks</a>(pCsr-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>, pCsr-&gt;<a class="code" href="structBtCursor.html#a0b038f63a5b1b9df0b892e0773ffdd29">pgnoRoot</a>, pCsr, 0) ){
<a name="l07389"></a>07389     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>; <span class="comment">/* The table pCur points to has a read lock */</span>
<a name="l07390"></a>07390   }
<a name="l07391"></a>07391   <span class="keywordflow">if</span>( pCsr-&gt;<a class="code" href="structBtCursor.html#a30ab5e7109965b34a08562a7b7e6de15">eState</a>==<a class="code" href="btreeInt_8h.html#a39a7993b31f6905d938c6074efd0083c">CURSOR_INVALID</a> || !pCsr-&gt;<a class="code" href="structBtCursor.html#ad3414d944f9578e86e26c6158f92096b">apPage</a>[pCsr-&gt;<a class="code" href="structBtCursor.html#ad4362a71baf655b0957a02324586853b">iPage</a>]-&gt;<a class="code" href="structMemPage.html#a46784c3c4708c7a582cff81a29c55323">intKey</a> ){
<a name="l07392"></a>07392     <span class="keywordflow">return</span> <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l07393"></a>07393   }
<a name="l07394"></a>07394 
<a name="l07395"></a>07395   <span class="keywordflow">return</span> <a class="code" href="btree_8c.html#a7a651412aed8c025c2be2433f731a9a9">accessPayload</a>(pCsr, offset, amt, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)z, 0, 1);
<a name="l07396"></a>07396 }
<a name="l07397"></a>07397 
<a name="l07398"></a>07398 <span class="comment">/* </span>
<a name="l07399"></a>07399 <span class="comment">** Set a flag on this cursor to cache the locations of pages from the </span>
<a name="l07400"></a>07400 <span class="comment">** overflow list for the current row. This is used by cursors opened</span>
<a name="l07401"></a>07401 <span class="comment">** for incremental blob IO only.</span>
<a name="l07402"></a>07402 <span class="comment">**</span>
<a name="l07403"></a>07403 <span class="comment">** This function sets a flag only. The actual page location cache</span>
<a name="l07404"></a>07404 <span class="comment">** (stored in BtCursor.aOverflow[]) is allocated and used by function</span>
<a name="l07405"></a>07405 <span class="comment">** accessPayload() (the worker function for sqlite3BtreeData() and</span>
<a name="l07406"></a>07406 <span class="comment">** sqlite3BtreePutData()).</span>
<a name="l07407"></a>07407 <span class="comment">*/</span>
<a name="l07408"></a><a class="code" href="btree_8h.html#aa7ad456223e9d842822b015394f63e88">07408</a> <span class="keywordtype">void</span> <a class="code" href="btree_8c.html#a05efe0da93ae407220fd202dd6480520">sqlite3BtreeCacheOverflow</a>(<a class="code" href="structBtCursor.html">BtCursor</a> *pCur){
<a name="l07409"></a>07409   assert( cursorHoldsMutex(pCur) );
<a name="l07410"></a>07410   assert( <a class="code" href="mutex_8h.html#ab92b5e853fc83d5aaa9a5d25e1883d3d">sqlite3_mutex_held</a>(pCur-&gt;<a class="code" href="structBtCursor.html#a2ad810542eaf99c9919c585624bead6f">pBtree</a>-&gt;<a class="code" href="structBtree.html#a2b3cfec48b6e9fcfd641d433816ae5c3">db</a>-&gt;<a class="code" href="structsqlite3.html#a6328497ac0393204ab5f5083f05731c9">mutex</a>) );
<a name="l07411"></a>07411   assert(!pCur-&gt;<a class="code" href="structBtCursor.html#a539dc1beff0ec303cfd4c94c274c7a9b">isIncrblobHandle</a>);
<a name="l07412"></a>07412   assert(!pCur-&gt;<a class="code" href="structBtCursor.html#ae2dbcc15e63d349774a7ad6caef4d096">aOverflow</a>);
<a name="l07413"></a>07413   pCur-&gt;<a class="code" href="structBtCursor.html#a539dc1beff0ec303cfd4c94c274c7a9b">isIncrblobHandle</a> = 1;
<a name="l07414"></a>07414 }
<a name="l07415"></a>07415 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:52 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
