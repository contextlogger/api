<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: where.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>where.c</h1><a href="where_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">** 2001 September 15</span>
<a name="l00003"></a>00003 <span class="comment">**</span>
<a name="l00004"></a>00004 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00005"></a>00005 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00006"></a>00006 <span class="comment">**</span>
<a name="l00007"></a>00007 <span class="comment">**    May you do good and not evil.</span>
<a name="l00008"></a>00008 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00009"></a>00009 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">*************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment">** This module contains C code that generates VDBE code used to process</span>
<a name="l00013"></a>00013 <span class="comment">** the WHERE clause of SQL statements.  This module is responsible for</span>
<a name="l00014"></a>00014 <span class="comment">** generating the code that loops through a table looking for applicable</span>
<a name="l00015"></a>00015 <span class="comment">** rows.  Indices are selected and used to speed the search when doing</span>
<a name="l00016"></a>00016 <span class="comment">** so is applicable.  Because this module is responsible for selecting</span>
<a name="l00017"></a>00017 <span class="comment">** indices, you might also think of this module as the &quot;query optimizer&quot;.</span>
<a name="l00018"></a>00018 <span class="comment">**</span>
<a name="l00019"></a>00019 <span class="comment">** $Id: where.c,v 1.328 2008/11/03 09:06:06 danielk1977 Exp $</span>
<a name="l00020"></a>00020 <span class="comment">*/</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="sqliteInt_8h.html">sqliteInt.h</a>&quot;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/*</span>
<a name="l00024"></a>00024 <span class="comment">** The number of bits in a Bitmask.  &quot;BMS&quot; means &quot;BitMask Size&quot;.</span>
<a name="l00025"></a>00025 <span class="comment">*/</span>
<a name="l00026"></a><a class="code" href="where_8c.html#a61ebf73c36e0aa88593c8fdb76891407">00026</a> <span class="preprocessor">#define BMS  (sizeof(Bitmask)*8)</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="comment">/*</span>
<a name="l00029"></a>00029 <span class="comment">** Trace output macros</span>
<a name="l00030"></a>00030 <span class="comment">*/</span>
<a name="l00031"></a>00031 <span class="preprocessor">#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="keywordtype">int</span> sqlite3WhereTrace = 0;
<a name="l00033"></a>00033 <span class="preprocessor">#endif</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#if 0</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor"># define WHERETRACE(X)  if(sqlite3WhereTrace) sqlite3DebugPrintf X</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00037"></a><a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">00037</a> <span class="preprocessor"></span><span class="preprocessor"># define WHERETRACE(X)</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="comment">/* Forward reference</span>
<a name="l00041"></a>00041 <span class="comment">*/</span>
<a name="l00042"></a><a class="code" href="where_8c.html#a2880c8b8c060a7eb96187563b8f986ac">00042</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structWhereClause.html">WhereClause</a> <a class="code" href="structWhereClause.html">WhereClause</a>;
<a name="l00043"></a><a class="code" href="where_8c.html#a3922700196d086392d942278b386bcad">00043</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structExprMaskSet.html">ExprMaskSet</a> <a class="code" href="structExprMaskSet.html">ExprMaskSet</a>;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="comment">/*</span>
<a name="l00046"></a>00046 <span class="comment">** The query generator uses an array of instances of this structure to</span>
<a name="l00047"></a>00047 <span class="comment">** help it analyze the subexpressions of the WHERE clause.  Each WHERE</span>
<a name="l00048"></a>00048 <span class="comment">** clause subexpression is separated from the others by an AND operator.</span>
<a name="l00049"></a>00049 <span class="comment">**</span>
<a name="l00050"></a>00050 <span class="comment">** All WhereTerms are collected into a single WhereClause structure.  </span>
<a name="l00051"></a>00051 <span class="comment">** The following identity holds:</span>
<a name="l00052"></a>00052 <span class="comment">**</span>
<a name="l00053"></a>00053 <span class="comment">**        WhereTerm.pWC-&gt;a[WhereTerm.idx] == WhereTerm</span>
<a name="l00054"></a>00054 <span class="comment">**</span>
<a name="l00055"></a>00055 <span class="comment">** When a term is of the form:</span>
<a name="l00056"></a>00056 <span class="comment">**</span>
<a name="l00057"></a>00057 <span class="comment">**              X &lt;op&gt; &lt;expr&gt;</span>
<a name="l00058"></a>00058 <span class="comment">**</span>
<a name="l00059"></a>00059 <span class="comment">** where X is a column name and &lt;op&gt; is one of certain operators,</span>
<a name="l00060"></a>00060 <span class="comment">** then WhereTerm.leftCursor and WhereTerm.leftColumn record the</span>
<a name="l00061"></a>00061 <span class="comment">** cursor number and column number for X.  WhereTerm.operator records</span>
<a name="l00062"></a>00062 <span class="comment">** the &lt;op&gt; using a bitmask encoding defined by WO_xxx below.  The</span>
<a name="l00063"></a>00063 <span class="comment">** use of a bitmask encoding for the operator allows us to search</span>
<a name="l00064"></a>00064 <span class="comment">** quickly for terms that match any of several different operators.</span>
<a name="l00065"></a>00065 <span class="comment">**</span>
<a name="l00066"></a>00066 <span class="comment">** prereqRight and prereqAll record sets of cursor numbers,</span>
<a name="l00067"></a>00067 <span class="comment">** but they do so indirectly.  A single ExprMaskSet structure translates</span>
<a name="l00068"></a>00068 <span class="comment">** cursor number into bits and the translated bit is stored in the prereq</span>
<a name="l00069"></a>00069 <span class="comment">** fields.  The translation is used in order to maximize the number of</span>
<a name="l00070"></a>00070 <span class="comment">** bits that will fit in a Bitmask.  The VDBE cursor numbers might be</span>
<a name="l00071"></a>00071 <span class="comment">** spread out over the non-negative integers.  For example, the cursor</span>
<a name="l00072"></a>00072 <span class="comment">** numbers might be 3, 8, 9, 10, 20, 23, 41, and 45.  The ExprMaskSet</span>
<a name="l00073"></a>00073 <span class="comment">** translates these sparse cursor numbers into consecutive integers</span>
<a name="l00074"></a>00074 <span class="comment">** beginning with 0 in order to make the best possible use of the available</span>
<a name="l00075"></a>00075 <span class="comment">** bits in the Bitmask.  So, in the example above, the cursor numbers</span>
<a name="l00076"></a>00076 <span class="comment">** would be mapped into integers 0 through 7.</span>
<a name="l00077"></a>00077 <span class="comment">*/</span>
<a name="l00078"></a><a class="code" href="where_8c.html#a906a4daea45d621051094ae99ab9b24d">00078</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structWhereTerm.html">WhereTerm</a> <a class="code" href="structWhereTerm.html">WhereTerm</a>;
<a name="l00079"></a><a class="code" href="structWhereTerm.html">00079</a> <span class="keyword">struct </span><a class="code" href="structWhereTerm.html">WhereTerm</a> {
<a name="l00080"></a><a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">00080</a>   <a class="code" href="structExpr.html">Expr</a> *<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>;            <span class="comment">/* Pointer to the subexpression */</span>
<a name="l00081"></a><a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">00081</a>   <a class="code" href="sqliteInt_8h.html#a7b32340f65cd15f029caad258fb3355c">i16</a> <a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a>;            <span class="comment">/* Disable pWC-&gt;a[iParent] when this term disabled */</span>
<a name="l00082"></a><a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">00082</a>   <a class="code" href="sqliteInt_8h.html#a7b32340f65cd15f029caad258fb3355c">i16</a> <a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a>;         <span class="comment">/* Cursor number of X in &quot;X &lt;op&gt; &lt;expr&gt;&quot; */</span>
<a name="l00083"></a><a class="code" href="structWhereTerm.html#a48ece896af5482c14c5041fe51a193c2">00083</a>   <a class="code" href="sqliteInt_8h.html#a7b32340f65cd15f029caad258fb3355c">i16</a> <a class="code" href="structWhereTerm.html#a48ece896af5482c14c5041fe51a193c2">leftColumn</a>;         <span class="comment">/* Column number of X in &quot;X &lt;op&gt; &lt;expr&gt;&quot; */</span>
<a name="l00084"></a><a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">00084</a>   <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> <a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>;          <span class="comment">/* A WO_xx value describing &lt;op&gt; */</span>
<a name="l00085"></a><a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">00085</a>   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> <a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a>;               <span class="comment">/* Bit flags.  See below */</span>
<a name="l00086"></a><a class="code" href="structWhereTerm.html#af83cf7bae7760b9b1ca398338a35c32a">00086</a>   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> <a class="code" href="structWhereTerm.html#af83cf7bae7760b9b1ca398338a35c32a">nChild</a>;              <span class="comment">/* Number of children that must disable us */</span>
<a name="l00087"></a><a class="code" href="structWhereTerm.html#a1fb0a9ede5a12d6d2f7886431b348fb3">00087</a>   <a class="code" href="structWhereClause.html">WhereClause</a> *<a class="code" href="structWhereTerm.html#a1fb0a9ede5a12d6d2f7886431b348fb3">pWC</a>;       <span class="comment">/* The clause this term is part of */</span>
<a name="l00088"></a><a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">00088</a>   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> <a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a>;    <span class="comment">/* Bitmask of tables used by pRight */</span>
<a name="l00089"></a><a class="code" href="structWhereTerm.html#a49b700336b005067352366cfc40de07f">00089</a>   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> <a class="code" href="structWhereTerm.html#a49b700336b005067352366cfc40de07f">prereqAll</a>;      <span class="comment">/* Bitmask of tables referenced by p */</span>
<a name="l00090"></a>00090 };
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="comment">/*</span>
<a name="l00093"></a>00093 <span class="comment">** Allowed values of WhereTerm.flags</span>
<a name="l00094"></a>00094 <span class="comment">*/</span>
<a name="l00095"></a><a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">00095</a> <span class="preprocessor">#define TERM_DYNAMIC    0x01   </span><span class="comment">/* Need to call sqlite3ExprDelete(db, pExpr) */</span>
<a name="l00096"></a><a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">00096</a> <span class="preprocessor">#define TERM_VIRTUAL    0x02   </span><span class="comment">/* Added by the optimizer.  Do not code */</span>
<a name="l00097"></a><a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">00097</a> <span class="preprocessor">#define TERM_CODED      0x04   </span><span class="comment">/* This term is already coded */</span>
<a name="l00098"></a><a class="code" href="where_8c.html#ac25e3e7f766c9b899cc5138fc2c12b36">00098</a> <span class="preprocessor">#define TERM_COPIED     0x08   </span><span class="comment">/* Has a child */</span>
<a name="l00099"></a><a class="code" href="where_8c.html#a9b5399695c087886c9f9ff8a93557217">00099</a> <span class="preprocessor">#define TERM_OR_OK      0x10   </span><span class="comment">/* Used during OR-clause processing */</span>
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">/*</span>
<a name="l00102"></a>00102 <span class="comment">** An instance of the following structure holds all information about a</span>
<a name="l00103"></a>00103 <span class="comment">** WHERE clause.  Mostly this is a container for one or more WhereTerms.</span>
<a name="l00104"></a>00104 <span class="comment">*/</span>
<a name="l00105"></a><a class="code" href="structWhereClause.html">00105</a> <span class="keyword">struct </span><a class="code" href="structWhereClause.html">WhereClause</a> {
<a name="l00106"></a><a class="code" href="structWhereClause.html#a3ff6dfc93e7b9b97a9bf9a0618a1d542">00106</a>   <a class="code" href="structParse.html">Parse</a> *<a class="code" href="structWhereClause.html#a3ff6dfc93e7b9b97a9bf9a0618a1d542">pParse</a>;           <span class="comment">/* The parser context */</span>
<a name="l00107"></a><a class="code" href="structWhereClause.html#a9d38e1e4952bf032ccb08f81af126919">00107</a>   <a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *<a class="code" href="structWhereClause.html#a9d38e1e4952bf032ccb08f81af126919">pMaskSet</a>;   <span class="comment">/* Mapping of table indices to bitmasks */</span>
<a name="l00108"></a><a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">00108</a>   <span class="keywordtype">int</span> <a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>;               <span class="comment">/* Number of terms */</span>
<a name="l00109"></a><a class="code" href="structWhereClause.html#ac92b93d65d4c3d9216707a049a4edb1c">00109</a>   <span class="keywordtype">int</span> <a class="code" href="structWhereClause.html#ac92b93d65d4c3d9216707a049a4edb1c">nSlot</a>;               <span class="comment">/* Number of entries in a[] */</span>
<a name="l00110"></a><a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">00110</a>   <a class="code" href="structWhereTerm.html">WhereTerm</a> *<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>;            <span class="comment">/* Each a[] describes a term of the WHERE cluase */</span>
<a name="l00111"></a><a class="code" href="structWhereClause.html#ae96843aaa804b6dc0b96632d7cd63644">00111</a>   <a class="code" href="structWhereTerm.html">WhereTerm</a> <a class="code" href="structWhereClause.html#ae96843aaa804b6dc0b96632d7cd63644">aStatic</a>[10];   <span class="comment">/* Initial static space for a[] */</span>
<a name="l00112"></a>00112 };
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="comment">/*</span>
<a name="l00115"></a>00115 <span class="comment">** An instance of the following structure keeps track of a mapping</span>
<a name="l00116"></a>00116 <span class="comment">** between VDBE cursor numbers and bits of the bitmasks in WhereTerm.</span>
<a name="l00117"></a>00117 <span class="comment">**</span>
<a name="l00118"></a>00118 <span class="comment">** The VDBE cursor numbers are small integers contained in </span>
<a name="l00119"></a>00119 <span class="comment">** SrcList_item.iCursor and Expr.iTable fields.  For any given WHERE </span>
<a name="l00120"></a>00120 <span class="comment">** clause, the cursor numbers might not begin with 0 and they might</span>
<a name="l00121"></a>00121 <span class="comment">** contain gaps in the numbering sequence.  But we want to make maximum</span>
<a name="l00122"></a>00122 <span class="comment">** use of the bits in our bitmasks.  This structure provides a mapping</span>
<a name="l00123"></a>00123 <span class="comment">** from the sparse cursor numbers into consecutive integers beginning</span>
<a name="l00124"></a>00124 <span class="comment">** with 0.</span>
<a name="l00125"></a>00125 <span class="comment">**</span>
<a name="l00126"></a>00126 <span class="comment">** If ExprMaskSet.ix[A]==B it means that The A-th bit of a Bitmask</span>
<a name="l00127"></a>00127 <span class="comment">** corresponds VDBE cursor number B.  The A-th bit of a bitmask is 1&lt;&lt;A.</span>
<a name="l00128"></a>00128 <span class="comment">**</span>
<a name="l00129"></a>00129 <span class="comment">** For example, if the WHERE clause expression used these VDBE</span>
<a name="l00130"></a>00130 <span class="comment">** cursors:  4, 5, 8, 29, 57, 73.  Then the  ExprMaskSet structure</span>
<a name="l00131"></a>00131 <span class="comment">** would map those cursor numbers into bits 0 through 5.</span>
<a name="l00132"></a>00132 <span class="comment">**</span>
<a name="l00133"></a>00133 <span class="comment">** Note that the mapping is not necessarily ordered.  In the example</span>
<a name="l00134"></a>00134 <span class="comment">** above, the mapping might go like this:  4-&gt;3, 5-&gt;1, 8-&gt;2, 29-&gt;0,</span>
<a name="l00135"></a>00135 <span class="comment">** 57-&gt;5, 73-&gt;4.  Or one of 719 other combinations might be used. It</span>
<a name="l00136"></a>00136 <span class="comment">** does not really matter.  What is important is that sparse cursor</span>
<a name="l00137"></a>00137 <span class="comment">** numbers all get mapped into bit numbers that begin with 0 and contain</span>
<a name="l00138"></a>00138 <span class="comment">** no gaps.</span>
<a name="l00139"></a>00139 <span class="comment">*/</span>
<a name="l00140"></a><a class="code" href="structExprMaskSet.html">00140</a> <span class="keyword">struct </span><a class="code" href="structExprMaskSet.html">ExprMaskSet</a> {
<a name="l00141"></a><a class="code" href="structExprMaskSet.html#a0846525ec0a860fe22183977733b58a4">00141</a>   <span class="keywordtype">int</span> <a class="code" href="structExprMaskSet.html#a0846525ec0a860fe22183977733b58a4">n</a>;                        <span class="comment">/* Number of assigned cursor values */</span>
<a name="l00142"></a><a class="code" href="structExprMaskSet.html#a008a7e543ae6ba9341582d42fdb55393">00142</a>   <span class="keywordtype">int</span> <a class="code" href="structExprMaskSet.html#a008a7e543ae6ba9341582d42fdb55393">ix</a>[<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)*8];    <span class="comment">/* Cursor assigned to each bit */</span>
<a name="l00143"></a>00143 };
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="comment">/*</span>
<a name="l00147"></a>00147 <span class="comment">** Bitmasks for the operators that indices are able to exploit.  An</span>
<a name="l00148"></a>00148 <span class="comment">** OR-ed combination of these values can be used when searching for</span>
<a name="l00149"></a>00149 <span class="comment">** terms in the where clause.</span>
<a name="l00150"></a>00150 <span class="comment">*/</span>
<a name="l00151"></a><a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">00151</a> <span class="preprocessor">#define WO_IN     1</span>
<a name="l00152"></a><a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">00152</a> <span class="preprocessor"></span><span class="preprocessor">#define WO_EQ     2</span>
<a name="l00153"></a><a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">00153</a> <span class="preprocessor"></span><span class="preprocessor">#define WO_LT     (WO_EQ&lt;&lt;(TK_LT-TK_EQ))</span>
<a name="l00154"></a><a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">00154</a> <span class="preprocessor"></span><span class="preprocessor">#define WO_LE     (WO_EQ&lt;&lt;(TK_LE-TK_EQ))</span>
<a name="l00155"></a><a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">00155</a> <span class="preprocessor"></span><span class="preprocessor">#define WO_GT     (WO_EQ&lt;&lt;(TK_GT-TK_EQ))</span>
<a name="l00156"></a><a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">00156</a> <span class="preprocessor"></span><span class="preprocessor">#define WO_GE     (WO_EQ&lt;&lt;(TK_GE-TK_EQ))</span>
<a name="l00157"></a><a class="code" href="where_8c.html#a044f3cbfa74e455ad7fa96547d5ada56">00157</a> <span class="preprocessor"></span><span class="preprocessor">#define WO_MATCH  64</span>
<a name="l00158"></a><a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">00158</a> <span class="preprocessor"></span><span class="preprocessor">#define WO_ISNULL 128</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a>00160 <span class="comment">/*</span>
<a name="l00161"></a>00161 <span class="comment">** Value for flags returned by bestIndex().  </span>
<a name="l00162"></a>00162 <span class="comment">**</span>
<a name="l00163"></a>00163 <span class="comment">** The least significant byte is reserved as a mask for WO_ values above.</span>
<a name="l00164"></a>00164 <span class="comment">** The WhereLevel.flags field is usually set to WO_IN|WO_EQ|WO_ISNULL.</span>
<a name="l00165"></a>00165 <span class="comment">** But if the table is the right table of a left join, WhereLevel.flags</span>
<a name="l00166"></a>00166 <span class="comment">** is set to WO_IN|WO_EQ.  The WhereLevel.flags field can then be used as</span>
<a name="l00167"></a>00167 <span class="comment">** the &quot;op&quot; parameter to findTerm when we are resolving equality constraints.</span>
<a name="l00168"></a>00168 <span class="comment">** ISNULL constraints will then not be used on the right table of a left</span>
<a name="l00169"></a>00169 <span class="comment">** join.  Tickets #2177 and #2189.</span>
<a name="l00170"></a>00170 <span class="comment">*/</span>
<a name="l00171"></a><a class="code" href="where_8c.html#aa8869a9d16dddbebfe2dc07ff275063e">00171</a> <span class="preprocessor">#define WHERE_ROWID_EQ     0x000100   </span><span class="comment">/* rowid=EXPR or rowid IN (...) */</span>
<a name="l00172"></a><a class="code" href="where_8c.html#a44adb93652f7601ac8e7b47d1e6b31d4">00172</a> <span class="preprocessor">#define WHERE_ROWID_RANGE  0x000200   </span><span class="comment">/* rowid&lt;EXPR and/or rowid&gt;EXPR */</span>
<a name="l00173"></a><a class="code" href="where_8c.html#ae64de71ae51ba0f8f4e5fd4d54b9b3f8">00173</a> <span class="preprocessor">#define WHERE_COLUMN_EQ    0x001000   </span><span class="comment">/* x=EXPR or x IN (...) */</span>
<a name="l00174"></a><a class="code" href="where_8c.html#a474e72ece833680b7b68a9b2ce914126">00174</a> <span class="preprocessor">#define WHERE_COLUMN_RANGE 0x002000   </span><span class="comment">/* x&lt;EXPR and/or x&gt;EXPR */</span>
<a name="l00175"></a><a class="code" href="where_8c.html#aa47b246748768d7d65cd3a0d0daede7e">00175</a> <span class="preprocessor">#define WHERE_COLUMN_IN    0x004000   </span><span class="comment">/* x IN (...) */</span>
<a name="l00176"></a><a class="code" href="where_8c.html#a235d99551db0e21a521bef747223a2cd">00176</a> <span class="preprocessor">#define WHERE_TOP_LIMIT    0x010000   </span><span class="comment">/* x&lt;EXPR or x&lt;=EXPR constraint */</span>
<a name="l00177"></a><a class="code" href="where_8c.html#af6653107415b1dec957976e08d65e528">00177</a> <span class="preprocessor">#define WHERE_BTM_LIMIT    0x020000   </span><span class="comment">/* x&gt;EXPR or x&gt;=EXPR constraint */</span>
<a name="l00178"></a><a class="code" href="where_8c.html#a5c7e944406bbba33acde54aa3fcee124">00178</a> <span class="preprocessor">#define WHERE_IDX_ONLY     0x080000   </span><span class="comment">/* Use index only - omit table */</span>
<a name="l00179"></a><a class="code" href="where_8c.html#a4caa356cdd5bf6be70e0a2426bfbda2e">00179</a> <span class="preprocessor">#define WHERE_ORDERBY      0x100000   </span><span class="comment">/* Output will appear in correct order */</span>
<a name="l00180"></a><a class="code" href="where_8c.html#a63bbf40b47f87166909e9353514c796e">00180</a> <span class="preprocessor">#define WHERE_REVERSE      0x200000   </span><span class="comment">/* Scan in reverse order */</span>
<a name="l00181"></a><a class="code" href="where_8c.html#a0e422237e7eec9ee479fc178a89a7c83">00181</a> <span class="preprocessor">#define WHERE_UNIQUE       0x400000   </span><span class="comment">/* Selects no more than one row */</span>
<a name="l00182"></a><a class="code" href="where_8c.html#af3727628c957ea47b9cc55af600af579">00182</a> <span class="preprocessor">#define WHERE_VIRTUALTABLE 0x800000   </span><span class="comment">/* Use virtual-table processing */</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="comment">/*</span>
<a name="l00185"></a>00185 <span class="comment">** Initialize a preallocated WhereClause structure.</span>
<a name="l00186"></a>00186 <span class="comment">*/</span>
<a name="l00187"></a><a class="code" href="where_8c.html#aa1a7a509852a1a70634cb58355f643bc">00187</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#aa1a7a509852a1a70634cb58355f643bc">whereClauseInit</a>(
<a name="l00188"></a>00188   <a class="code" href="structWhereClause.html">WhereClause</a> *pWC,        <span class="comment">/* The WhereClause to be initialized */</span>
<a name="l00189"></a>00189   <a class="code" href="structParse.html">Parse</a> *pParse,           <span class="comment">/* The parsing context */</span>
<a name="l00190"></a>00190   <a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet    <span class="comment">/* Mapping from table indices to bitmasks */</span>
<a name="l00191"></a>00191 ){
<a name="l00192"></a>00192   pWC-&gt;<a class="code" href="structWhereClause.html#a3ff6dfc93e7b9b97a9bf9a0618a1d542">pParse</a> = pParse;
<a name="l00193"></a>00193   pWC-&gt;<a class="code" href="structWhereClause.html#a9d38e1e4952bf032ccb08f81af126919">pMaskSet</a> = pMaskSet;
<a name="l00194"></a>00194   pWC-&gt;<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a> = 0;
<a name="l00195"></a>00195   pWC-&gt;<a class="code" href="structWhereClause.html#ac92b93d65d4c3d9216707a049a4edb1c">nSlot</a> = <a class="code" href="shell_8c.html#a4654592395032f4996615903e6dbc81d">ArraySize</a>(pWC-&gt;<a class="code" href="structWhereClause.html#ae96843aaa804b6dc0b96632d7cd63644">aStatic</a>);
<a name="l00196"></a>00196   pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a> = pWC-&gt;<a class="code" href="structWhereClause.html#ae96843aaa804b6dc0b96632d7cd63644">aStatic</a>;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="comment">/*</span>
<a name="l00200"></a>00200 <span class="comment">** Deallocate a WhereClause structure.  The WhereClause structure</span>
<a name="l00201"></a>00201 <span class="comment">** itself is not freed.  This routine is the inverse of whereClauseInit().</span>
<a name="l00202"></a>00202 <span class="comment">*/</span>
<a name="l00203"></a><a class="code" href="where_8c.html#adb29ca8d094e2324f7fc20962502d8c9">00203</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#adb29ca8d094e2324f7fc20962502d8c9">whereClauseClear</a>(<a class="code" href="structWhereClause.html">WhereClause</a> *pWC){
<a name="l00204"></a>00204   <span class="keywordtype">int</span> i;
<a name="l00205"></a>00205   <a class="code" href="structWhereTerm.html">WhereTerm</a> *a;
<a name="l00206"></a>00206   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pWC-&gt;<a class="code" href="structWhereClause.html#a3ff6dfc93e7b9b97a9bf9a0618a1d542">pParse</a>-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00207"></a>00207   <span class="keywordflow">for</span>(i=pWC-&gt;<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>-1, a=pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>; i&gt;=0; i--, a++){
<a name="l00208"></a>00208     <span class="keywordflow">if</span>( a-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">TERM_DYNAMIC</a> ){
<a name="l00209"></a>00209       <a class="code" href="expr_8c.html#a8503bb02b6cb0343caf2391ca8cfc266">sqlite3ExprDelete</a>(db, a-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>);
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211   }
<a name="l00212"></a>00212   <span class="keywordflow">if</span>( pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>!=pWC-&gt;<a class="code" href="structWhereClause.html#ae96843aaa804b6dc0b96632d7cd63644">aStatic</a> ){
<a name="l00213"></a>00213     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>);
<a name="l00214"></a>00214   }
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="comment">/*</span>
<a name="l00218"></a>00218 <span class="comment">** Add a new entries to the WhereClause structure.  Increase the allocated</span>
<a name="l00219"></a>00219 <span class="comment">** space as necessary.</span>
<a name="l00220"></a>00220 <span class="comment">**</span>
<a name="l00221"></a>00221 <span class="comment">** If the flags argument includes TERM_DYNAMIC, then responsibility</span>
<a name="l00222"></a>00222 <span class="comment">** for freeing the expression p is assumed by the WhereClause object.</span>
<a name="l00223"></a>00223 <span class="comment">**</span>
<a name="l00224"></a>00224 <span class="comment">** WARNING:  This routine might reallocate the space used to store</span>
<a name="l00225"></a>00225 <span class="comment">** WhereTerms.  All pointers to WhereTerms should be invalidated after</span>
<a name="l00226"></a>00226 <span class="comment">** calling this routine.  Such pointers may be reinitialized by referencing</span>
<a name="l00227"></a>00227 <span class="comment">** the pWC-&gt;a[] array.</span>
<a name="l00228"></a>00228 <span class="comment">*/</span>
<a name="l00229"></a><a class="code" href="where_8c.html#ab5ba6610a2a2c7adf47874998581187a">00229</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#ab5ba6610a2a2c7adf47874998581187a">whereClauseInsert</a>(<a class="code" href="structWhereClause.html">WhereClause</a> *pWC, <a class="code" href="structExpr.html">Expr</a> *p, <span class="keywordtype">int</span> flags){
<a name="l00230"></a>00230   <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm;
<a name="l00231"></a>00231   <span class="keywordtype">int</span> idx;
<a name="l00232"></a>00232   <span class="keywordflow">if</span>( pWC-&gt;<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>&gt;=pWC-&gt;<a class="code" href="structWhereClause.html#ac92b93d65d4c3d9216707a049a4edb1c">nSlot</a> ){
<a name="l00233"></a>00233     <a class="code" href="structWhereTerm.html">WhereTerm</a> *pOld = pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>;
<a name="l00234"></a>00234     <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pWC-&gt;<a class="code" href="structWhereClause.html#a3ff6dfc93e7b9b97a9bf9a0618a1d542">pParse</a>-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00235"></a>00235     pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a> = <a class="code" href="malloc_8c.html#a043f868d32456bd7cdca4a62837277c1">sqlite3DbMallocRaw</a>(db, <span class="keyword">sizeof</span>(pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[0])*pWC-&gt;<a class="code" href="structWhereClause.html#ac92b93d65d4c3d9216707a049a4edb1c">nSlot</a>*2 );
<a name="l00236"></a>00236     <span class="keywordflow">if</span>( pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>==0 ){
<a name="l00237"></a>00237       <span class="keywordflow">if</span>( flags &amp; <a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">TERM_DYNAMIC</a> ){
<a name="l00238"></a>00238         <a class="code" href="expr_8c.html#a8503bb02b6cb0343caf2391ca8cfc266">sqlite3ExprDelete</a>(db, p);
<a name="l00239"></a>00239       }
<a name="l00240"></a>00240       pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a> = pOld;
<a name="l00241"></a>00241       <span class="keywordflow">return</span> 0;
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243     memcpy(pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>, pOld, <span class="keyword">sizeof</span>(pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[0])*pWC-&gt;<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>);
<a name="l00244"></a>00244     <span class="keywordflow">if</span>( pOld!=pWC-&gt;<a class="code" href="structWhereClause.html#ae96843aaa804b6dc0b96632d7cd63644">aStatic</a> ){
<a name="l00245"></a>00245       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pOld);
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247     pWC-&gt;<a class="code" href="structWhereClause.html#ac92b93d65d4c3d9216707a049a4edb1c">nSlot</a> *= 2;
<a name="l00248"></a>00248   }
<a name="l00249"></a>00249   pTerm = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idx = pWC-&gt;<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>];
<a name="l00250"></a>00250   pWC-&gt;<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>++;
<a name="l00251"></a>00251   pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a> = p;
<a name="l00252"></a>00252   pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> = flags;
<a name="l00253"></a>00253   pTerm-&gt;<a class="code" href="structWhereTerm.html#a1fb0a9ede5a12d6d2f7886431b348fb3">pWC</a> = pWC;
<a name="l00254"></a>00254   pTerm-&gt;<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a> = -1;
<a name="l00255"></a>00255   <span class="keywordflow">return</span> idx;
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="comment">/*</span>
<a name="l00259"></a>00259 <span class="comment">** This routine identifies subexpressions in the WHERE clause where</span>
<a name="l00260"></a>00260 <span class="comment">** each subexpression is separated by the AND operator or some other</span>
<a name="l00261"></a>00261 <span class="comment">** operator specified in the op parameter.  The WhereClause structure</span>
<a name="l00262"></a>00262 <span class="comment">** is filled with pointers to subexpressions.  For example:</span>
<a name="l00263"></a>00263 <span class="comment">**</span>
<a name="l00264"></a>00264 <span class="comment">**    WHERE  a==&apos;hello&apos; AND coalesce(b,11)&lt;10 AND (c+12!=d OR c==22)</span>
<a name="l00265"></a>00265 <span class="comment">**           \________/     \_______________/     \________________/</span>
<a name="l00266"></a>00266 <span class="comment">**            slot[0]            slot[1]               slot[2]</span>
<a name="l00267"></a>00267 <span class="comment">**</span>
<a name="l00268"></a>00268 <span class="comment">** The original WHERE clause in pExpr is unaltered.  All this routine</span>
<a name="l00269"></a>00269 <span class="comment">** does is make slot[] entries point to substructure within pExpr.</span>
<a name="l00270"></a>00270 <span class="comment">**</span>
<a name="l00271"></a>00271 <span class="comment">** In the previous sentence and in the diagram, &quot;slot[]&quot; refers to</span>
<a name="l00272"></a>00272 <span class="comment">** the WhereClause.a[] array.  This array grows as needed to contain</span>
<a name="l00273"></a>00273 <span class="comment">** all terms of the WHERE clause.</span>
<a name="l00274"></a>00274 <span class="comment">*/</span>
<a name="l00275"></a><a class="code" href="where_8c.html#a11081d7feda10bb8c57f960b1a4609ac">00275</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#a11081d7feda10bb8c57f960b1a4609ac">whereSplit</a>(<a class="code" href="structWhereClause.html">WhereClause</a> *pWC, <a class="code" href="structExpr.html">Expr</a> *pExpr, <span class="keywordtype">int</span> op){
<a name="l00276"></a>00276   <span class="keywordflow">if</span>( pExpr==0 ) <span class="keywordflow">return</span>;
<a name="l00277"></a>00277   <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=op ){
<a name="l00278"></a>00278     <a class="code" href="where_8c.html#ab5ba6610a2a2c7adf47874998581187a">whereClauseInsert</a>(pWC, pExpr, 0);
<a name="l00279"></a>00279   }<span class="keywordflow">else</span>{
<a name="l00280"></a>00280     <a class="code" href="where_8c.html#a11081d7feda10bb8c57f960b1a4609ac">whereSplit</a>(pWC, pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>, op);
<a name="l00281"></a>00281     <a class="code" href="where_8c.html#a11081d7feda10bb8c57f960b1a4609ac">whereSplit</a>(pWC, pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>, op);
<a name="l00282"></a>00282   }
<a name="l00283"></a>00283 }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 <span class="comment">/*</span>
<a name="l00286"></a>00286 <span class="comment">** Initialize an expression mask set</span>
<a name="l00287"></a>00287 <span class="comment">*/</span>
<a name="l00288"></a><a class="code" href="where_8c.html#a1d379b4d6777b14ba479796030ab4f88">00288</a> <span class="preprocessor">#define initMaskSet(P)  memset(P, 0, sizeof(*P))</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span>
<a name="l00290"></a>00290 <span class="comment">/*</span>
<a name="l00291"></a>00291 <span class="comment">** Return the bitmask for the given cursor number.  Return 0 if</span>
<a name="l00292"></a>00292 <span class="comment">** iCursor is not in the set.</span>
<a name="l00293"></a>00293 <span class="comment">*/</span>
<a name="l00294"></a><a class="code" href="where_8c.html#a330443df7684d9bca657260aea158e0c">00294</a> <span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> <a class="code" href="where_8c.html#a330443df7684d9bca657260aea158e0c">getMask</a>(<a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet, <span class="keywordtype">int</span> iCursor){
<a name="l00295"></a>00295   <span class="keywordtype">int</span> i;
<a name="l00296"></a>00296   <span class="keywordflow">for</span>(i=0; i&lt;pMaskSet-&gt;<a class="code" href="structExprMaskSet.html#a0846525ec0a860fe22183977733b58a4">n</a>; i++){
<a name="l00297"></a>00297     <span class="keywordflow">if</span>( pMaskSet-&gt;<a class="code" href="structExprMaskSet.html#a008a7e543ae6ba9341582d42fdb55393">ix</a>[i]==iCursor ){
<a name="l00298"></a>00298       <span class="keywordflow">return</span> ((<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)1)&lt;&lt;i;
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300   }
<a name="l00301"></a>00301   <span class="keywordflow">return</span> 0;
<a name="l00302"></a>00302 }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="comment">/*</span>
<a name="l00305"></a>00305 <span class="comment">** Create a new mask for cursor iCursor.</span>
<a name="l00306"></a>00306 <span class="comment">**</span>
<a name="l00307"></a>00307 <span class="comment">** There is one cursor per table in the FROM clause.  The number of</span>
<a name="l00308"></a>00308 <span class="comment">** tables in the FROM clause is limited by a test early in the</span>
<a name="l00309"></a>00309 <span class="comment">** sqlite3WhereBegin() routine.  So we know that the pMaskSet-&gt;ix[]</span>
<a name="l00310"></a>00310 <span class="comment">** array will never overflow.</span>
<a name="l00311"></a>00311 <span class="comment">*/</span>
<a name="l00312"></a><a class="code" href="where_8c.html#acd7499fefa31a0ab4cc44d81f0844e4c">00312</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#acd7499fefa31a0ab4cc44d81f0844e4c">createMask</a>(<a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet, <span class="keywordtype">int</span> iCursor){
<a name="l00313"></a>00313   assert( pMaskSet-&gt;<a class="code" href="structExprMaskSet.html#a0846525ec0a860fe22183977733b58a4">n</a> &lt; <a class="code" href="shell_8c.html#a4654592395032f4996615903e6dbc81d">ArraySize</a>(pMaskSet-&gt;<a class="code" href="structExprMaskSet.html#a008a7e543ae6ba9341582d42fdb55393">ix</a>) );
<a name="l00314"></a>00314   pMaskSet-&gt;<a class="code" href="structExprMaskSet.html#a008a7e543ae6ba9341582d42fdb55393">ix</a>[pMaskSet-&gt;<a class="code" href="structExprMaskSet.html#a0846525ec0a860fe22183977733b58a4">n</a>++] = iCursor;
<a name="l00315"></a>00315 }
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="comment">/*</span>
<a name="l00318"></a>00318 <span class="comment">** This routine walks (recursively) an expression tree and generates</span>
<a name="l00319"></a>00319 <span class="comment">** a bitmask indicating which tables are used in that expression</span>
<a name="l00320"></a>00320 <span class="comment">** tree.</span>
<a name="l00321"></a>00321 <span class="comment">**</span>
<a name="l00322"></a>00322 <span class="comment">** In order for this routine to work, the calling function must have</span>
<a name="l00323"></a>00323 <span class="comment">** previously invoked sqlite3ResolveExprNames() on the expression.  See</span>
<a name="l00324"></a>00324 <span class="comment">** the header comment on that routine for additional information.</span>
<a name="l00325"></a>00325 <span class="comment">** The sqlite3ResolveExprNames() routines looks for column names and</span>
<a name="l00326"></a>00326 <span class="comment">** sets their opcodes to TK_COLUMN and their Expr.iTable fields to</span>
<a name="l00327"></a>00327 <span class="comment">** the VDBE cursor number of the table.  This routine just has to</span>
<a name="l00328"></a>00328 <span class="comment">** translate the cursor numbers into bitmask values and OR all</span>
<a name="l00329"></a>00329 <span class="comment">** the bitmasks together.</span>
<a name="l00330"></a>00330 <span class="comment">*/</span>
<a name="l00331"></a>00331 <span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> <a class="code" href="where_8c.html#a4603d18d6a033428e40f6a4a569fc1d7">exprListTableUsage</a>(<a class="code" href="structExprMaskSet.html">ExprMaskSet</a>*, <a class="code" href="structExprList.html">ExprList</a>*);
<a name="l00332"></a>00332 <span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> <a class="code" href="where_8c.html#a68e4862e13547abdff68d645754ecb38">exprSelectTableUsage</a>(<a class="code" href="structExprMaskSet.html">ExprMaskSet</a>*, <a class="code" href="structSelect.html">Select</a>*);
<a name="l00333"></a><a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">00333</a> <span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(<a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet, <a class="code" href="structExpr.html">Expr</a> *p){
<a name="l00334"></a>00334   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> mask = 0;
<a name="l00335"></a>00335   <span class="keywordflow">if</span>( p==0 ) <span class="keywordflow">return</span> 0;
<a name="l00336"></a>00336   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> ){
<a name="l00337"></a>00337     mask = <a class="code" href="where_8c.html#a330443df7684d9bca657260aea158e0c">getMask</a>(pMaskSet, p-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a>);
<a name="l00338"></a>00338     <span class="keywordflow">return</span> mask;
<a name="l00339"></a>00339   }
<a name="l00340"></a>00340   mask = <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, p-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>);
<a name="l00341"></a>00341   mask |= <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, p-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>);
<a name="l00342"></a>00342   mask |= <a class="code" href="where_8c.html#a4603d18d6a033428e40f6a4a569fc1d7">exprListTableUsage</a>(pMaskSet, p-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>);
<a name="l00343"></a>00343   mask |= <a class="code" href="where_8c.html#a68e4862e13547abdff68d645754ecb38">exprSelectTableUsage</a>(pMaskSet, p-&gt;<a class="code" href="structExpr.html#a54e5186fdf157f8b4ae178919d8ff6b3">pSelect</a>);
<a name="l00344"></a>00344   <span class="keywordflow">return</span> mask;
<a name="l00345"></a>00345 }
<a name="l00346"></a><a class="code" href="where_8c.html#a4603d18d6a033428e40f6a4a569fc1d7">00346</a> <span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> <a class="code" href="where_8c.html#a4603d18d6a033428e40f6a4a569fc1d7">exprListTableUsage</a>(<a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet, <a class="code" href="structExprList.html">ExprList</a> *pList){
<a name="l00347"></a>00347   <span class="keywordtype">int</span> i;
<a name="l00348"></a>00348   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> mask = 0;
<a name="l00349"></a>00349   <span class="keywordflow">if</span>( pList ){
<a name="l00350"></a>00350     <span class="keywordflow">for</span>(i=0; i&lt;pList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>; i++){
<a name="l00351"></a>00351       mask |= <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>);
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353   }
<a name="l00354"></a>00354   <span class="keywordflow">return</span> mask;
<a name="l00355"></a>00355 }
<a name="l00356"></a><a class="code" href="where_8c.html#a68e4862e13547abdff68d645754ecb38">00356</a> <span class="keyword">static</span> <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> <a class="code" href="where_8c.html#a68e4862e13547abdff68d645754ecb38">exprSelectTableUsage</a>(<a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet, <a class="code" href="structSelect.html">Select</a> *pS){
<a name="l00357"></a>00357   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> mask = 0;
<a name="l00358"></a>00358   <span class="keywordflow">while</span>( pS ){
<a name="l00359"></a>00359     mask |= <a class="code" href="where_8c.html#a4603d18d6a033428e40f6a4a569fc1d7">exprListTableUsage</a>(pMaskSet, pS-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>);
<a name="l00360"></a>00360     mask |= <a class="code" href="where_8c.html#a4603d18d6a033428e40f6a4a569fc1d7">exprListTableUsage</a>(pMaskSet, pS-&gt;<a class="code" href="structSelect.html#a5b625c7495468ae56ca2f214a76231a0">pGroupBy</a>);
<a name="l00361"></a>00361     mask |= <a class="code" href="where_8c.html#a4603d18d6a033428e40f6a4a569fc1d7">exprListTableUsage</a>(pMaskSet, pS-&gt;<a class="code" href="structSelect.html#a73c474cd4a9a9b9aa4e3187d8bf2d886">pOrderBy</a>);
<a name="l00362"></a>00362     mask |= <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, pS-&gt;<a class="code" href="structSelect.html#a0562c1e19acde263a04af015611d8ce8">pWhere</a>);
<a name="l00363"></a>00363     mask |= <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, pS-&gt;<a class="code" href="structSelect.html#ad09e0b115e6e1599e3075b87dfa6e66e">pHaving</a>);
<a name="l00364"></a>00364     pS = pS-&gt;<a class="code" href="structSelect.html#a51d1a253b0aba5a54b11b3bf3896d056">pPrior</a>;
<a name="l00365"></a>00365   }
<a name="l00366"></a>00366   <span class="keywordflow">return</span> mask;
<a name="l00367"></a>00367 }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="comment">/*</span>
<a name="l00370"></a>00370 <span class="comment">** Return TRUE if the given operator is one of the operators that is</span>
<a name="l00371"></a>00371 <span class="comment">** allowed for an indexable WHERE clause term.  The allowed operators are</span>
<a name="l00372"></a>00372 <span class="comment">** &quot;=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;, and &quot;IN&quot;.</span>
<a name="l00373"></a>00373 <span class="comment">*/</span>
<a name="l00374"></a><a class="code" href="where_8c.html#a9cb0a678e7e89071cde7e9ad6a5b6aef">00374</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#a9cb0a678e7e89071cde7e9ad6a5b6aef">allowedOp</a>(<span class="keywordtype">int</span> op){
<a name="l00375"></a>00375   assert( <a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a>&gt;<a class="code" href="parse_8h.html#a57801ac8a2967e8778d3a94d6a8ba240">TK_EQ</a> &amp;&amp; <a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a>&lt;<a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a> );
<a name="l00376"></a>00376   assert( <a class="code" href="parse_8h.html#a8ae3cd6a51a9c976e55f803363ac40d1">TK_LT</a>&gt;<a class="code" href="parse_8h.html#a57801ac8a2967e8778d3a94d6a8ba240">TK_EQ</a> &amp;&amp; <a class="code" href="parse_8h.html#a8ae3cd6a51a9c976e55f803363ac40d1">TK_LT</a>&lt;<a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a> );
<a name="l00377"></a>00377   assert( <a class="code" href="parse_8h.html#ab2968df89b2ff434e31d618a3ac9c2ff">TK_LE</a>&gt;<a class="code" href="parse_8h.html#a57801ac8a2967e8778d3a94d6a8ba240">TK_EQ</a> &amp;&amp; <a class="code" href="parse_8h.html#ab2968df89b2ff434e31d618a3ac9c2ff">TK_LE</a>&lt;<a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a> );
<a name="l00378"></a>00378   assert( <a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a>==<a class="code" href="parse_8h.html#a57801ac8a2967e8778d3a94d6a8ba240">TK_EQ</a>+4 );
<a name="l00379"></a>00379   <span class="keywordflow">return</span> op==<a class="code" href="parse_8h.html#a6437312264a013b5bf1539ffe8a65e94">TK_IN</a> || (op&gt;=<a class="code" href="parse_8h.html#a57801ac8a2967e8778d3a94d6a8ba240">TK_EQ</a> &amp;&amp; op&lt;=<a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a>) || op==<a class="code" href="parse_8h.html#ae43d2177d750e150adf5cfaa64db421c">TK_ISNULL</a>;
<a name="l00380"></a>00380 }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="comment">/*</span>
<a name="l00383"></a>00383 <span class="comment">** Swap two objects of type T.</span>
<a name="l00384"></a>00384 <span class="comment">*/</span>
<a name="l00385"></a><a class="code" href="where_8c.html#af95aa5062b37d3fc83465c811b377a44">00385</a> <span class="preprocessor">#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}</span>
<a name="l00386"></a>00386 <span class="preprocessor"></span>
<a name="l00387"></a>00387 <span class="comment">/*</span>
<a name="l00388"></a>00388 <span class="comment">** Commute a comparison operator.  Expressions of the form &quot;X op Y&quot;</span>
<a name="l00389"></a>00389 <span class="comment">** are converted into &quot;Y op X&quot;.</span>
<a name="l00390"></a>00390 <span class="comment">**</span>
<a name="l00391"></a>00391 <span class="comment">** If a collation sequence is associated with either the left or right</span>
<a name="l00392"></a>00392 <span class="comment">** side of the comparison, it remains associated with the same side after</span>
<a name="l00393"></a>00393 <span class="comment">** the commutation. So &quot;Y collate NOCASE op X&quot; becomes </span>
<a name="l00394"></a>00394 <span class="comment">** &quot;X collate NOCASE op Y&quot;. This is because any collation sequence on</span>
<a name="l00395"></a>00395 <span class="comment">** the left hand side of a comparison overrides any collation sequence </span>
<a name="l00396"></a>00396 <span class="comment">** attached to the right. For the same reason the EP_ExpCollate flag</span>
<a name="l00397"></a>00397 <span class="comment">** is not commuted.</span>
<a name="l00398"></a>00398 <span class="comment">*/</span>
<a name="l00399"></a><a class="code" href="where_8c.html#ab6bc22735005ef5fc9bd51cd269f54be">00399</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#ab6bc22735005ef5fc9bd51cd269f54be">exprCommute</a>(<a class="code" href="structParse.html">Parse</a> *pParse, <a class="code" href="structExpr.html">Expr</a> *pExpr){
<a name="l00400"></a>00400   <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> expRight = (pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a8504ef15835e9661eeb00e1cbe530b33">EP_ExpCollate</a>);
<a name="l00401"></a>00401   <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> expLeft = (pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a8504ef15835e9661eeb00e1cbe530b33">EP_ExpCollate</a>);
<a name="l00402"></a>00402   assert( <a class="code" href="where_8c.html#a9cb0a678e7e89071cde7e9ad6a5b6aef">allowedOp</a>(pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>) &amp;&amp; pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#a6437312264a013b5bf1539ffe8a65e94">TK_IN</a> );
<a name="l00403"></a>00403   pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>-&gt;<a class="code" href="structExpr.html#a4ef09e21aaa9d61567b89714e25abfb9">pColl</a> = <a class="code" href="expr_8c.html#adb1b59cdd498beb6607df500bb414d93">sqlite3ExprCollSeq</a>(pParse, pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>);
<a name="l00404"></a>00404   pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>-&gt;<a class="code" href="structExpr.html#a4ef09e21aaa9d61567b89714e25abfb9">pColl</a> = <a class="code" href="expr_8c.html#adb1b59cdd498beb6607df500bb414d93">sqlite3ExprCollSeq</a>(pParse, pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>);
<a name="l00405"></a>00405   <a class="code" href="epoc-btprox_8cpp.html#ac0a175517dd38f43b0dbd572e077a7c2">SWAP</a>(<a class="code" href="structCollSeq.html">CollSeq</a>*,pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>-&gt;<a class="code" href="structExpr.html#a4ef09e21aaa9d61567b89714e25abfb9">pColl</a>,pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>-&gt;<a class="code" href="structExpr.html#a4ef09e21aaa9d61567b89714e25abfb9">pColl</a>);
<a name="l00406"></a>00406   pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> = (pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> &amp; ~<a class="code" href="sqliteInt_8h.html#a8504ef15835e9661eeb00e1cbe530b33">EP_ExpCollate</a>) | expLeft;
<a name="l00407"></a>00407   pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> = (pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> &amp; ~<a class="code" href="sqliteInt_8h.html#a8504ef15835e9661eeb00e1cbe530b33">EP_ExpCollate</a>) | expRight;
<a name="l00408"></a>00408   <a class="code" href="epoc-btprox_8cpp.html#ac0a175517dd38f43b0dbd572e077a7c2">SWAP</a>(<a class="code" href="structExpr.html">Expr</a>*,pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>,pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>);
<a name="l00409"></a>00409   <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>&gt;=<a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a> ){
<a name="l00410"></a>00410     assert( <a class="code" href="parse_8h.html#a8ae3cd6a51a9c976e55f803363ac40d1">TK_LT</a>==<a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a>+2 );
<a name="l00411"></a>00411     assert( <a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a>==<a class="code" href="parse_8h.html#ab2968df89b2ff434e31d618a3ac9c2ff">TK_LE</a>+2 );
<a name="l00412"></a>00412     assert( <a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a>&gt;<a class="code" href="parse_8h.html#a57801ac8a2967e8778d3a94d6a8ba240">TK_EQ</a> );
<a name="l00413"></a>00413     assert( <a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a>&lt;<a class="code" href="parse_8h.html#ab2968df89b2ff434e31d618a3ac9c2ff">TK_LE</a> );
<a name="l00414"></a>00414     assert( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>&gt;=<a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a> &amp;&amp; pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>&lt;=<a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a> );
<a name="l00415"></a>00415     pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a> = ((pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>-<a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a>)^2)+<a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a>;
<a name="l00416"></a>00416   }
<a name="l00417"></a>00417 }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419 <span class="comment">/*</span>
<a name="l00420"></a>00420 <span class="comment">** Translate from TK_xx operator to WO_xx bitmask.</span>
<a name="l00421"></a>00421 <span class="comment">*/</span>
<a name="l00422"></a><a class="code" href="where_8c.html#aeb40a13ab59ab419831882068668c52f">00422</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#aeb40a13ab59ab419831882068668c52f">operatorMask</a>(<span class="keywordtype">int</span> op){
<a name="l00423"></a>00423   <span class="keywordtype">int</span> c;
<a name="l00424"></a>00424   assert( <a class="code" href="where_8c.html#a9cb0a678e7e89071cde7e9ad6a5b6aef">allowedOp</a>(op) );
<a name="l00425"></a>00425   <span class="keywordflow">if</span>( op==<a class="code" href="parse_8h.html#a6437312264a013b5bf1539ffe8a65e94">TK_IN</a> ){
<a name="l00426"></a>00426     c = <a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a>;
<a name="l00427"></a>00427   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( op==<a class="code" href="parse_8h.html#ae43d2177d750e150adf5cfaa64db421c">TK_ISNULL</a> ){
<a name="l00428"></a>00428     c = <a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a>;
<a name="l00429"></a>00429   }<span class="keywordflow">else</span>{
<a name="l00430"></a>00430     c = <a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a>&lt;&lt;(op-<a class="code" href="parse_8h.html#a57801ac8a2967e8778d3a94d6a8ba240">TK_EQ</a>);
<a name="l00431"></a>00431   }
<a name="l00432"></a>00432   assert( op!=<a class="code" href="parse_8h.html#ae43d2177d750e150adf5cfaa64db421c">TK_ISNULL</a> || c==<a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a> );
<a name="l00433"></a>00433   assert( op!=<a class="code" href="parse_8h.html#a6437312264a013b5bf1539ffe8a65e94">TK_IN</a> || c==<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a> );
<a name="l00434"></a>00434   assert( op!=<a class="code" href="parse_8h.html#a57801ac8a2967e8778d3a94d6a8ba240">TK_EQ</a> || c==<a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a> );
<a name="l00435"></a>00435   assert( op!=<a class="code" href="parse_8h.html#a8ae3cd6a51a9c976e55f803363ac40d1">TK_LT</a> || c==<a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a> );
<a name="l00436"></a>00436   assert( op!=<a class="code" href="parse_8h.html#ab2968df89b2ff434e31d618a3ac9c2ff">TK_LE</a> || c==<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a> );
<a name="l00437"></a>00437   assert( op!=<a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a> || c==<a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a> );
<a name="l00438"></a>00438   assert( op!=<a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a> || c==<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a> );
<a name="l00439"></a>00439   <span class="keywordflow">return</span> c;
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="comment">/*</span>
<a name="l00443"></a>00443 <span class="comment">** Search for a term in the WHERE clause that is of the form &quot;X &lt;op&gt; &lt;expr&gt;&quot;</span>
<a name="l00444"></a>00444 <span class="comment">** where X is a reference to the iColumn of table iCur and &lt;op&gt; is one of</span>
<a name="l00445"></a>00445 <span class="comment">** the WO_xx operator codes specified by the op parameter.</span>
<a name="l00446"></a>00446 <span class="comment">** Return a pointer to the term.  Return 0 if not found.</span>
<a name="l00447"></a>00447 <span class="comment">*/</span>
<a name="l00448"></a><a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">00448</a> <span class="keyword">static</span> <a class="code" href="structWhereTerm.html">WhereTerm</a> *<a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(
<a name="l00449"></a>00449   <a class="code" href="structWhereClause.html">WhereClause</a> *pWC,     <span class="comment">/* The WHERE clause to be searched */</span>
<a name="l00450"></a>00450   <span class="keywordtype">int</span> iCur,             <span class="comment">/* Cursor number of LHS */</span>
<a name="l00451"></a>00451   <span class="keywordtype">int</span> iColumn,          <span class="comment">/* Column number of LHS */</span>
<a name="l00452"></a>00452   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> notReady,     <span class="comment">/* RHS must not overlap with this mask */</span>
<a name="l00453"></a>00453   <a class="code" href="sqliteInt_8h.html#a20f2299e322dcbde37cb07b16910b843">u16</a> op,               <span class="comment">/* Mask of WO_xx values describing operator */</span>
<a name="l00454"></a>00454   <a class="code" href="structIndex.html">Index</a> *pIdx           <span class="comment">/* Must be compatible with this index, if not NULL */</span>
<a name="l00455"></a>00455 ){
<a name="l00456"></a>00456   <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm;
<a name="l00457"></a>00457   <span class="keywordtype">int</span> k;
<a name="l00458"></a>00458   assert( iCur&gt;=0 );
<a name="l00459"></a>00459   <span class="keywordflow">for</span>(pTerm=pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>, k=pWC-&gt;<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>; k; k--, pTerm++){
<a name="l00460"></a>00460     <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a>==iCur
<a name="l00461"></a>00461        &amp;&amp; (pTerm-&gt;<a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a> &amp; notReady)==0
<a name="l00462"></a>00462        &amp;&amp; pTerm-&gt;<a class="code" href="structWhereTerm.html#a48ece896af5482c14c5041fe51a193c2">leftColumn</a>==iColumn
<a name="l00463"></a>00463        &amp;&amp; (pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; op)!=0
<a name="l00464"></a>00464     ){
<a name="l00465"></a>00465       <span class="keywordflow">if</span>( pIdx &amp;&amp; pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>!=<a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a> ){
<a name="l00466"></a>00466         <a class="code" href="structExpr.html">Expr</a> *pX = pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>;
<a name="l00467"></a>00467         <a class="code" href="structCollSeq.html">CollSeq</a> *pColl;
<a name="l00468"></a>00468         <span class="keywordtype">char</span> idxaff;
<a name="l00469"></a>00469         <span class="keywordtype">int</span> j;
<a name="l00470"></a>00470         <a class="code" href="structParse.html">Parse</a> *pParse = pWC-&gt;<a class="code" href="structWhereClause.html#a3ff6dfc93e7b9b97a9bf9a0618a1d542">pParse</a>;
<a name="l00471"></a>00471 
<a name="l00472"></a>00472         idxaff = pIdx-&gt;<a class="code" href="structIndex.html#a01c6d4da27cba325ca58f333f87a6f44">pTable</a>-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>[iColumn].<a class="code" href="structColumn.html#ac9d6fe31c45888cecaf3f5ad5b93bf23">affinity</a>;
<a name="l00473"></a>00473         <span class="keywordflow">if</span>( !<a class="code" href="expr_8c.html#af1ed6d672d560de3249e5370b777ab45">sqlite3IndexAffinityOk</a>(pX, idxaff) ) <span class="keywordflow">continue</span>;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         <span class="comment">/* Figure out the collation sequence required from an index for</span>
<a name="l00476"></a>00476 <span class="comment">        ** it to be useful for optimising expression pX. Store this</span>
<a name="l00477"></a>00477 <span class="comment">        ** value in variable pColl.</span>
<a name="l00478"></a>00478 <span class="comment">        */</span>
<a name="l00479"></a>00479         assert(pX-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>);
<a name="l00480"></a>00480         pColl = <a class="code" href="expr_8c.html#afd37ebd89d0c7c38e0d5fd842424b173">sqlite3BinaryCompareCollSeq</a>(pParse, pX-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>, pX-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>);
<a name="l00481"></a>00481         <span class="keywordflow">if</span>( !pColl ){
<a name="l00482"></a>00482           pColl = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a2e5d7e7ac07c33b11c936b181d07789a">pDfltColl</a>;
<a name="l00483"></a>00483         }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485         <span class="keywordflow">for</span>(j=0; pIdx-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[j]!=iColumn; j++){
<a name="l00486"></a>00486           <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a43cb5602f3d807a6688b065e5ce0250e">NEVER</a>(j&gt;=pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>) ) <span class="keywordflow">return</span> 0;
<a name="l00487"></a>00487         }
<a name="l00488"></a>00488         <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(pColl-&gt;<a class="code" href="structCollSeq.html#a48d6d5f71d4f8a3ab122903464e8b4a1">zName</a>, pIdx-&gt;<a class="code" href="structIndex.html#ab690ebb96c0329896b0fe2ab56813b88">azColl</a>[j]) ) <span class="keywordflow">continue</span>;
<a name="l00489"></a>00489       }
<a name="l00490"></a>00490       <span class="keywordflow">return</span> pTerm;
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492   }
<a name="l00493"></a>00493   <span class="keywordflow">return</span> 0;
<a name="l00494"></a>00494 }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 <span class="comment">/* Forward reference */</span>
<a name="l00497"></a>00497 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#acb10e48c9a4184a4edd9bfd5b14ad0b7">exprAnalyze</a>(<a class="code" href="structSrcList.html">SrcList</a>*, <a class="code" href="structWhereClause.html">WhereClause</a>*, <span class="keywordtype">int</span>);
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="comment">/*</span>
<a name="l00500"></a>00500 <span class="comment">** Call exprAnalyze on all terms in a WHERE clause.  </span>
<a name="l00501"></a>00501 <span class="comment">**</span>
<a name="l00502"></a>00502 <span class="comment">**</span>
<a name="l00503"></a>00503 <span class="comment">*/</span>
<a name="l00504"></a><a class="code" href="where_8c.html#a2e7a957af98e240fa68e34d6ff639437">00504</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#a2e7a957af98e240fa68e34d6ff639437">exprAnalyzeAll</a>(
<a name="l00505"></a>00505   <a class="code" href="structSrcList.html">SrcList</a> *pTabList,       <span class="comment">/* the FROM clause */</span>
<a name="l00506"></a>00506   <a class="code" href="structWhereClause.html">WhereClause</a> *pWC         <span class="comment">/* the WHERE clause to be analyzed */</span>
<a name="l00507"></a>00507 ){
<a name="l00508"></a>00508   <span class="keywordtype">int</span> i;
<a name="l00509"></a>00509   <span class="keywordflow">for</span>(i=pWC-&gt;<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>-1; i&gt;=0; i--){
<a name="l00510"></a>00510     <a class="code" href="where_8c.html#acb10e48c9a4184a4edd9bfd5b14ad0b7">exprAnalyze</a>(pTabList, pWC, i);
<a name="l00511"></a>00511   }
<a name="l00512"></a>00512 }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 <span class="preprocessor">#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION</span>
<a name="l00515"></a>00515 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00516"></a>00516 <span class="comment">** Check to see if the given expression is a LIKE or GLOB operator that</span>
<a name="l00517"></a>00517 <span class="comment">** can be optimized using inequality constraints.  Return TRUE if it is</span>
<a name="l00518"></a>00518 <span class="comment">** so and false if not.</span>
<a name="l00519"></a>00519 <span class="comment">**</span>
<a name="l00520"></a>00520 <span class="comment">** In order for the operator to be optimizible, the RHS must be a string</span>
<a name="l00521"></a>00521 <span class="comment">** literal that does not begin with a wildcard.  </span>
<a name="l00522"></a>00522 <span class="comment">*/</span>
<a name="l00523"></a><a class="code" href="where_8c.html#af264699b46d5f9b4bd023a12eb2be74c">00523</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#af264699b46d5f9b4bd023a12eb2be74c">isLikeOrGlob</a>(
<a name="l00524"></a>00524   <a class="code" href="structParse.html">Parse</a> *pParse,    <span class="comment">/* Parsing and code generating context */</span>
<a name="l00525"></a>00525   <a class="code" href="structExpr.html">Expr</a> *pExpr,      <span class="comment">/* Test this expression */</span>
<a name="l00526"></a>00526   <span class="keywordtype">int</span> *pnPattern,   <span class="comment">/* Number of non-wildcard prefix characters */</span>
<a name="l00527"></a>00527   <span class="keywordtype">int</span> *pisComplete, <span class="comment">/* True if the only wildcard is % in the last character */</span>
<a name="l00528"></a>00528   <span class="keywordtype">int</span> *pnoCase      <span class="comment">/* True if uppercase is equivalent to lowercase */</span>
<a name="l00529"></a>00529 ){
<a name="l00530"></a>00530   <span class="keyword">const</span> <span class="keywordtype">char</span> *z;
<a name="l00531"></a>00531   <a class="code" href="structExpr.html">Expr</a> *pRight, *pLeft;
<a name="l00532"></a>00532   <a class="code" href="structExprList.html">ExprList</a> *pList;
<a name="l00533"></a>00533   <span class="keywordtype">int</span> c, cnt;
<a name="l00534"></a>00534   <span class="keywordtype">char</span> wc[3];
<a name="l00535"></a>00535   <a class="code" href="structCollSeq.html">CollSeq</a> *pColl;
<a name="l00536"></a>00536   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   <span class="keywordflow">if</span>( !<a class="code" href="func_8c.html#aebbb64cbaaf901be061b49bbe71e2d3c">sqlite3IsLikeFunction</a>(db, pExpr, pnoCase, wc) ){
<a name="l00539"></a>00539     <span class="keywordflow">return</span> 0;
<a name="l00540"></a>00540   }
<a name="l00541"></a>00541 <span class="preprocessor">#ifdef SQLITE_EBCDIC</span>
<a name="l00542"></a>00542 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( *pnoCase ) <span class="keywordflow">return</span> 0;
<a name="l00543"></a>00543 <span class="preprocessor">#endif</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span>  pList = pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>;
<a name="l00545"></a>00545   pRight = pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[0].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l00546"></a>00546   <span class="keywordflow">if</span>( pRight-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#a9810f9bc21f26ee9b8d7b374534ff54b">TK_STRING</a>
<a name="l00547"></a>00547    &amp;&amp; (pRight-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#a43ed276edd91747f89f75a4da3547d49">TK_REGISTER</a> || pRight-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>!=<a class="code" href="parse_8h.html#a9810f9bc21f26ee9b8d7b374534ff54b">TK_STRING</a>) ){
<a name="l00548"></a>00548     <span class="keywordflow">return</span> 0;
<a name="l00549"></a>00549   }
<a name="l00550"></a>00550   pLeft = pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[1].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l00551"></a>00551   <span class="keywordflow">if</span>( pLeft-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> ){
<a name="l00552"></a>00552     <span class="keywordflow">return</span> 0;
<a name="l00553"></a>00553   }
<a name="l00554"></a>00554   pColl = <a class="code" href="expr_8c.html#adb1b59cdd498beb6607df500bb414d93">sqlite3ExprCollSeq</a>(pParse, pLeft);
<a name="l00555"></a>00555   assert( pColl!=0 || pLeft-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>==-1 );
<a name="l00556"></a>00556   <span class="keywordflow">if</span>( pColl==0 ){
<a name="l00557"></a>00557     <span class="comment">/* No collation is defined for the ROWID.  Use the default. */</span>
<a name="l00558"></a>00558     pColl = db-&gt;<a class="code" href="structsqlite3.html#a2e5d7e7ac07c33b11c936b181d07789a">pDfltColl</a>;
<a name="l00559"></a>00559   }
<a name="l00560"></a>00560   <span class="keywordflow">if</span>( (pColl-&gt;<a class="code" href="structCollSeq.html#ae8e3e561c3ff15d81758530573ceb5f9">type</a>!=<a class="code" href="sqliteInt_8h.html#af405dbf9578aec65bff6a2fa48467841">SQLITE_COLL_BINARY</a> || *pnoCase) &amp;&amp;
<a name="l00561"></a>00561       (pColl-&gt;<a class="code" href="structCollSeq.html#ae8e3e561c3ff15d81758530573ceb5f9">type</a>!=<a class="code" href="sqliteInt_8h.html#a71cd920365aa35118d16b16290f3bafb">SQLITE_COLL_NOCASE</a> || !*pnoCase) ){
<a name="l00562"></a>00562     <span class="keywordflow">return</span> 0;
<a name="l00563"></a>00563   }
<a name="l00564"></a>00564   <a class="code" href="expr_8c.html#a92038f7d457d24604fc5a0a9d2898fc2">sqlite3DequoteExpr</a>(db, pRight);
<a name="l00565"></a>00565   z = (<span class="keywordtype">char</span> *)pRight-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>;
<a name="l00566"></a>00566   cnt = 0;
<a name="l00567"></a>00567   <span class="keywordflow">if</span>( z ){
<a name="l00568"></a>00568     <span class="keywordflow">while</span>( (c=z[cnt])!=0 &amp;&amp; c!=wc[0] &amp;&amp; c!=wc[1] &amp;&amp; c!=wc[2] ){ cnt++; }
<a name="l00569"></a>00569   }
<a name="l00570"></a>00570   <span class="keywordflow">if</span>( cnt==0 || 255==(<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>)z[cnt] ){
<a name="l00571"></a>00571     <span class="keywordflow">return</span> 0;
<a name="l00572"></a>00572   }
<a name="l00573"></a>00573   *pisComplete = z[cnt]==wc[0] &amp;&amp; z[cnt+1]==0;
<a name="l00574"></a>00574   *pnPattern = cnt;
<a name="l00575"></a>00575   <span class="keywordflow">return</span> 1;
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_LIKE_OPTIMIZATION */</span>
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l00581"></a>00581 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00582"></a>00582 <span class="comment">** Check to see if the given expression is of the form</span>
<a name="l00583"></a>00583 <span class="comment">**</span>
<a name="l00584"></a>00584 <span class="comment">**         column MATCH expr</span>
<a name="l00585"></a>00585 <span class="comment">**</span>
<a name="l00586"></a>00586 <span class="comment">** If it is then return TRUE.  If not, return FALSE.</span>
<a name="l00587"></a>00587 <span class="comment">*/</span>
<a name="l00588"></a><a class="code" href="where_8c.html#aca81ee8f18d68ba146e343c7b49152a3">00588</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#aca81ee8f18d68ba146e343c7b49152a3">isMatchOfColumn</a>(
<a name="l00589"></a>00589   <a class="code" href="structExpr.html">Expr</a> *pExpr      <span class="comment">/* Test this expression */</span>
<a name="l00590"></a>00590 ){
<a name="l00591"></a>00591   <a class="code" href="structExprList.html">ExprList</a> *pList;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#a3f3d91dcf238a34b77f1146c26c28f9b">TK_FUNCTION</a> ){
<a name="l00594"></a>00594     <span class="keywordflow">return</span> 0;
<a name="l00595"></a>00595   }
<a name="l00596"></a>00596   <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>.<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a>!=5 ||
<a name="l00597"></a>00597        <a class="code" href="sqliteInt_8h.html#acd3b8a2e2ada99c161975ac30cb50877">sqlite3StrNICmp</a>((<span class="keyword">const</span> <span class="keywordtype">char</span>*)pExpr-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>,<span class="stringliteral">&quot;match&quot;</span>,5)!=0 ){
<a name="l00598"></a>00598     <span class="keywordflow">return</span> 0;
<a name="l00599"></a>00599   }
<a name="l00600"></a>00600   pList = pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>;
<a name="l00601"></a>00601   <span class="keywordflow">if</span>( pList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>!=2 ){
<a name="l00602"></a>00602     <span class="keywordflow">return</span> 0;
<a name="l00603"></a>00603   }
<a name="l00604"></a>00604   <span class="keywordflow">if</span>( pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[1].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a> != <a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> ){
<a name="l00605"></a>00605     <span class="keywordflow">return</span> 0;
<a name="l00606"></a>00606   }
<a name="l00607"></a>00607   <span class="keywordflow">return</span> 1;
<a name="l00608"></a>00608 }
<a name="l00609"></a>00609 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l00610"></a>00610 
<a name="l00611"></a>00611 <span class="comment">/*</span>
<a name="l00612"></a>00612 <span class="comment">** If the pBase expression originated in the ON or USING clause of</span>
<a name="l00613"></a>00613 <span class="comment">** a join, then transfer the appropriate markings over to derived.</span>
<a name="l00614"></a>00614 <span class="comment">*/</span>
<a name="l00615"></a><a class="code" href="where_8c.html#a47436cb058c53d38e19c4169f1e9c0d3">00615</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#a47436cb058c53d38e19c4169f1e9c0d3">transferJoinMarkings</a>(<a class="code" href="structExpr.html">Expr</a> *pDerived, <a class="code" href="structExpr.html">Expr</a> *pBase){
<a name="l00616"></a>00616   pDerived-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> |= pBase-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a6bd31d1397219a9745a840e48dd49a53">EP_FromJoin</a>;
<a name="l00617"></a>00617   pDerived-&gt;<a class="code" href="structExpr.html#a6e13614e1f45a1d50a3dae4b669a0cfa">iRightJoinTable</a> = pBase-&gt;<a class="code" href="structExpr.html#a6e13614e1f45a1d50a3dae4b669a0cfa">iRightJoinTable</a>;
<a name="l00618"></a>00618 }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <span class="preprocessor">#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) &amp;&amp; !defined(SQLITE_OMIT_SUBQUERY)</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00622"></a>00622 <span class="comment">** Return TRUE if the given term of an OR clause can be converted</span>
<a name="l00623"></a>00623 <span class="comment">** into an IN clause.  The iCursor and iColumn define the left-hand</span>
<a name="l00624"></a>00624 <span class="comment">** side of the IN clause.</span>
<a name="l00625"></a>00625 <span class="comment">**</span>
<a name="l00626"></a>00626 <span class="comment">** The context is that we have multiple OR-connected equality terms</span>
<a name="l00627"></a>00627 <span class="comment">** like this:</span>
<a name="l00628"></a>00628 <span class="comment">**</span>
<a name="l00629"></a>00629 <span class="comment">**           a=&lt;expr1&gt; OR  a=&lt;expr2&gt; OR b=&lt;expr3&gt;  OR ...</span>
<a name="l00630"></a>00630 <span class="comment">**</span>
<a name="l00631"></a>00631 <span class="comment">** The pOrTerm input to this routine corresponds to a single term of</span>
<a name="l00632"></a>00632 <span class="comment">** this OR clause.  In order for the term to be a candidate for</span>
<a name="l00633"></a>00633 <span class="comment">** conversion to an IN operator, the following must be true:</span>
<a name="l00634"></a>00634 <span class="comment">**</span>
<a name="l00635"></a>00635 <span class="comment">**     *  The left-hand side of the term must be the column which</span>
<a name="l00636"></a>00636 <span class="comment">**        is identified by iCursor and iColumn.</span>
<a name="l00637"></a>00637 <span class="comment">**</span>
<a name="l00638"></a>00638 <span class="comment">**     *  If the right-hand side is also a column, then the affinities</span>
<a name="l00639"></a>00639 <span class="comment">**        of both right and left sides must be such that no type</span>
<a name="l00640"></a>00640 <span class="comment">**        conversions are required on the right.  (Ticket #2249)</span>
<a name="l00641"></a>00641 <span class="comment">**</span>
<a name="l00642"></a>00642 <span class="comment">** If both of these conditions are true, then return true.  Otherwise</span>
<a name="l00643"></a>00643 <span class="comment">** return false.</span>
<a name="l00644"></a>00644 <span class="comment">*/</span>
<a name="l00645"></a><a class="code" href="where_8c.html#a8c1fae1ffa38a81e19827122890d0982">00645</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#a8c1fae1ffa38a81e19827122890d0982">orTermIsOptCandidate</a>(<a class="code" href="structWhereTerm.html">WhereTerm</a> *pOrTerm, <span class="keywordtype">int</span> iCursor, <span class="keywordtype">int</span> iColumn){
<a name="l00646"></a>00646   <span class="keywordtype">int</span> affLeft, affRight;
<a name="l00647"></a>00647   assert( pOrTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>==<a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a> );
<a name="l00648"></a>00648   <span class="keywordflow">if</span>( pOrTerm-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a>!=iCursor ){
<a name="l00649"></a>00649     <span class="keywordflow">return</span> 0;
<a name="l00650"></a>00650   }
<a name="l00651"></a>00651   <span class="keywordflow">if</span>( pOrTerm-&gt;<a class="code" href="structWhereTerm.html#a48ece896af5482c14c5041fe51a193c2">leftColumn</a>!=iColumn ){
<a name="l00652"></a>00652     <span class="keywordflow">return</span> 0;
<a name="l00653"></a>00653   }
<a name="l00654"></a>00654   affRight = <a class="code" href="expr_8c.html#a001a9524be21cb8410c66a4744cce476">sqlite3ExprAffinity</a>(pOrTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>);
<a name="l00655"></a>00655   <span class="keywordflow">if</span>( affRight==0 ){
<a name="l00656"></a>00656     <span class="keywordflow">return</span> 1;
<a name="l00657"></a>00657   }
<a name="l00658"></a>00658   affLeft = <a class="code" href="expr_8c.html#a001a9524be21cb8410c66a4744cce476">sqlite3ExprAffinity</a>(pOrTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>);
<a name="l00659"></a>00659   <span class="keywordflow">if</span>( affRight!=affLeft ){
<a name="l00660"></a>00660     <span class="keywordflow">return</span> 0;
<a name="l00661"></a>00661   }
<a name="l00662"></a>00662   <span class="keywordflow">return</span> 1;
<a name="l00663"></a>00663 }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 <span class="comment">/*</span>
<a name="l00666"></a>00666 <span class="comment">** Return true if the given term of an OR clause can be ignored during</span>
<a name="l00667"></a>00667 <span class="comment">** a check to make sure all OR terms are candidates for optimization.</span>
<a name="l00668"></a>00668 <span class="comment">** In other words, return true if a call to the orTermIsOptCandidate()</span>
<a name="l00669"></a>00669 <span class="comment">** above returned false but it is not necessary to disqualify the</span>
<a name="l00670"></a>00670 <span class="comment">** optimization.</span>
<a name="l00671"></a>00671 <span class="comment">**</span>
<a name="l00672"></a>00672 <span class="comment">** Suppose the original OR phrase was this:</span>
<a name="l00673"></a>00673 <span class="comment">**</span>
<a name="l00674"></a>00674 <span class="comment">**           a=4  OR  a=11  OR  a=b</span>
<a name="l00675"></a>00675 <span class="comment">**</span>
<a name="l00676"></a>00676 <span class="comment">** During analysis, the third term gets flipped around and duplicate</span>
<a name="l00677"></a>00677 <span class="comment">** so that we are left with this:</span>
<a name="l00678"></a>00678 <span class="comment">**</span>
<a name="l00679"></a>00679 <span class="comment">**           a=4  OR  a=11  OR  a=b  OR  b=a</span>
<a name="l00680"></a>00680 <span class="comment">**</span>
<a name="l00681"></a>00681 <span class="comment">** Since the last two terms are duplicates, only one of them</span>
<a name="l00682"></a>00682 <span class="comment">** has to qualify in order for the whole phrase to qualify.  When</span>
<a name="l00683"></a>00683 <span class="comment">** this routine is called, we know that pOrTerm did not qualify.</span>
<a name="l00684"></a>00684 <span class="comment">** This routine merely checks to see if pOrTerm has a duplicate that</span>
<a name="l00685"></a>00685 <span class="comment">** might qualify.  If there is a duplicate that has not yet been</span>
<a name="l00686"></a>00686 <span class="comment">** disqualified, then return true.  If there are no duplicates, or</span>
<a name="l00687"></a>00687 <span class="comment">** the duplicate has also been disqualified, return false.</span>
<a name="l00688"></a>00688 <span class="comment">*/</span>
<a name="l00689"></a><a class="code" href="where_8c.html#acc50eccdcf6572309224c080e869e623">00689</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#acc50eccdcf6572309224c080e869e623">orTermHasOkDuplicate</a>(<a class="code" href="structWhereClause.html">WhereClause</a> *pOr, <a class="code" href="structWhereTerm.html">WhereTerm</a> *pOrTerm){
<a name="l00690"></a>00690   <span class="keywordflow">if</span>( pOrTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#ac25e3e7f766c9b899cc5138fc2c12b36">TERM_COPIED</a> ){
<a name="l00691"></a>00691     <span class="comment">/* This is the original term.  The duplicate is to the left had</span>
<a name="l00692"></a>00692 <span class="comment">    ** has not yet been analyzed and thus has not yet been disqualified. */</span>
<a name="l00693"></a>00693     <span class="keywordflow">return</span> 1;
<a name="l00694"></a>00694   }
<a name="l00695"></a>00695   <span class="keywordflow">if</span>( (pOrTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a>)!=0
<a name="l00696"></a>00696      &amp;&amp; (pOr-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[pOrTerm-&gt;<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a>].<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a9b5399695c087886c9f9ff8a93557217">TERM_OR_OK</a>)!=0 ){
<a name="l00697"></a>00697     <span class="comment">/* This is a duplicate term.  The original qualified so this one</span>
<a name="l00698"></a>00698 <span class="comment">    ** does not have to. */</span>
<a name="l00699"></a>00699     <span class="keywordflow">return</span> 1;
<a name="l00700"></a>00700   }
<a name="l00701"></a>00701   <span class="comment">/* This is either a singleton term or else it is a duplicate for</span>
<a name="l00702"></a>00702 <span class="comment">  ** which the original did not qualify.  Either way we are done for. */</span>
<a name="l00703"></a>00703   <span class="keywordflow">return</span> 0;
<a name="l00704"></a>00704 }
<a name="l00705"></a>00705 <span class="preprocessor">#endif </span><span class="comment">/* !SQLITE_OMIT_OR_OPTIMIZATION &amp;&amp; !SQLITE_OMIT_SUBQUERY */</span>
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 <span class="comment">/*</span>
<a name="l00708"></a>00708 <span class="comment">** The input to this routine is an WhereTerm structure with only the</span>
<a name="l00709"></a>00709 <span class="comment">** &quot;pExpr&quot; field filled in.  The job of this routine is to analyze the</span>
<a name="l00710"></a>00710 <span class="comment">** subexpression and populate all the other fields of the WhereTerm</span>
<a name="l00711"></a>00711 <span class="comment">** structure.</span>
<a name="l00712"></a>00712 <span class="comment">**</span>
<a name="l00713"></a>00713 <span class="comment">** If the expression is of the form &quot;&lt;expr&gt; &lt;op&gt; X&quot; it gets commuted</span>
<a name="l00714"></a>00714 <span class="comment">** to the standard form of &quot;X &lt;op&gt; &lt;expr&gt;&quot;.  If the expression is of</span>
<a name="l00715"></a>00715 <span class="comment">** the form &quot;X &lt;op&gt; Y&quot; where both X and Y are columns, then the original</span>
<a name="l00716"></a>00716 <span class="comment">** expression is unchanged and a new virtual expression of the form</span>
<a name="l00717"></a>00717 <span class="comment">** &quot;Y &lt;op&gt; X&quot; is added to the WHERE clause and analyzed separately.</span>
<a name="l00718"></a>00718 <span class="comment">*/</span>
<a name="l00719"></a><a class="code" href="where_8c.html#acb10e48c9a4184a4edd9bfd5b14ad0b7">00719</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#acb10e48c9a4184a4edd9bfd5b14ad0b7">exprAnalyze</a>(
<a name="l00720"></a>00720   <a class="code" href="structSrcList.html">SrcList</a> *pSrc,            <span class="comment">/* the FROM clause */</span>
<a name="l00721"></a>00721   <a class="code" href="structWhereClause.html">WhereClause</a> *pWC,         <span class="comment">/* the WHERE clause */</span>
<a name="l00722"></a>00722   <span class="keywordtype">int</span> idxTerm               <span class="comment">/* Index of the term to be analyzed */</span>
<a name="l00723"></a>00723 ){
<a name="l00724"></a>00724   <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm;
<a name="l00725"></a>00725   <a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet;
<a name="l00726"></a>00726   <a class="code" href="structExpr.html">Expr</a> *pExpr;
<a name="l00727"></a>00727   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> prereqLeft;
<a name="l00728"></a>00728   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> prereqAll;
<a name="l00729"></a>00729   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> extraRight = 0;
<a name="l00730"></a>00730   <span class="keywordtype">int</span> nPattern;
<a name="l00731"></a>00731   <span class="keywordtype">int</span> isComplete;
<a name="l00732"></a>00732   <span class="keywordtype">int</span> noCase;
<a name="l00733"></a>00733   <span class="keywordtype">int</span> op;
<a name="l00734"></a>00734   <a class="code" href="structParse.html">Parse</a> *pParse = pWC-&gt;<a class="code" href="structWhereClause.html#a3ff6dfc93e7b9b97a9bf9a0618a1d542">pParse</a>;
<a name="l00735"></a>00735   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00738"></a>00738     <span class="keywordflow">return</span>;
<a name="l00739"></a>00739   }
<a name="l00740"></a>00740   pTerm = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxTerm];
<a name="l00741"></a>00741   pMaskSet = pWC-&gt;<a class="code" href="structWhereClause.html#a9d38e1e4952bf032ccb08f81af126919">pMaskSet</a>;
<a name="l00742"></a>00742   pExpr = pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>;
<a name="l00743"></a>00743   prereqLeft = <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>);
<a name="l00744"></a>00744   op = pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>;
<a name="l00745"></a>00745   <span class="keywordflow">if</span>( op==<a class="code" href="parse_8h.html#a6437312264a013b5bf1539ffe8a65e94">TK_IN</a> ){
<a name="l00746"></a>00746     assert( pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>==0 );
<a name="l00747"></a>00747     pTerm-&gt;<a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a> = <a class="code" href="where_8c.html#a4603d18d6a033428e40f6a4a569fc1d7">exprListTableUsage</a>(pMaskSet, pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>)
<a name="l00748"></a>00748                           | <a class="code" href="where_8c.html#a68e4862e13547abdff68d645754ecb38">exprSelectTableUsage</a>(pMaskSet, pExpr-&gt;<a class="code" href="structExpr.html#a54e5186fdf157f8b4ae178919d8ff6b3">pSelect</a>);
<a name="l00749"></a>00749   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( op==<a class="code" href="parse_8h.html#ae43d2177d750e150adf5cfaa64db421c">TK_ISNULL</a> ){
<a name="l00750"></a>00750     pTerm-&gt;<a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a> = 0;
<a name="l00751"></a>00751   }<span class="keywordflow">else</span>{
<a name="l00752"></a>00752     pTerm-&gt;<a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a> = <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>);
<a name="l00753"></a>00753   }
<a name="l00754"></a>00754   prereqAll = <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, pExpr);
<a name="l00755"></a>00755   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a70ceb3fd7e20d6b0565b359158c7f1d7">ExprHasProperty</a>(pExpr, <a class="code" href="sqliteInt_8h.html#a6bd31d1397219a9745a840e48dd49a53">EP_FromJoin</a>) ){
<a name="l00756"></a>00756     <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> x = <a class="code" href="where_8c.html#a330443df7684d9bca657260aea158e0c">getMask</a>(pMaskSet, pExpr-&gt;<a class="code" href="structExpr.html#a6e13614e1f45a1d50a3dae4b669a0cfa">iRightJoinTable</a>);
<a name="l00757"></a>00757     prereqAll |= x;
<a name="l00758"></a>00758     extraRight = x-1;  <span class="comment">/* ON clause terms may not be used with an index</span>
<a name="l00759"></a>00759 <span class="comment">                       ** on left table of a LEFT JOIN.  Ticket #3015 */</span>
<a name="l00760"></a>00760   }
<a name="l00761"></a>00761   pTerm-&gt;<a class="code" href="structWhereTerm.html#a49b700336b005067352366cfc40de07f">prereqAll</a> = prereqAll;
<a name="l00762"></a>00762   pTerm-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a> = -1;
<a name="l00763"></a>00763   pTerm-&gt;<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a> = -1;
<a name="l00764"></a>00764   pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> = 0;
<a name="l00765"></a>00765   <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#a9cb0a678e7e89071cde7e9ad6a5b6aef">allowedOp</a>(op) &amp;&amp; (pTerm-&gt;<a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a> &amp; prereqLeft)==0 ){
<a name="l00766"></a>00766     <a class="code" href="structExpr.html">Expr</a> *pLeft = pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>;
<a name="l00767"></a>00767     <a class="code" href="structExpr.html">Expr</a> *pRight = pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>;
<a name="l00768"></a>00768     <span class="keywordflow">if</span>( pLeft-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> ){
<a name="l00769"></a>00769       pTerm-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a> = pLeft-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a>;
<a name="l00770"></a>00770       pTerm-&gt;<a class="code" href="structWhereTerm.html#a48ece896af5482c14c5041fe51a193c2">leftColumn</a> = pLeft-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>;
<a name="l00771"></a>00771       pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> = <a class="code" href="where_8c.html#aeb40a13ab59ab419831882068668c52f">operatorMask</a>(op);
<a name="l00772"></a>00772     }
<a name="l00773"></a>00773     <span class="keywordflow">if</span>( pRight &amp;&amp; pRight-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> ){
<a name="l00774"></a>00774       <a class="code" href="structWhereTerm.html">WhereTerm</a> *pNew;
<a name="l00775"></a>00775       <a class="code" href="structExpr.html">Expr</a> *pDup;
<a name="l00776"></a>00776       <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a>&gt;=0 ){
<a name="l00777"></a>00777         <span class="keywordtype">int</span> idxNew;
<a name="l00778"></a>00778         pDup = <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db, pExpr);
<a name="l00779"></a>00779         <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00780"></a>00780           <a class="code" href="expr_8c.html#a8503bb02b6cb0343caf2391ca8cfc266">sqlite3ExprDelete</a>(db, pDup);
<a name="l00781"></a>00781           <span class="keywordflow">return</span>;
<a name="l00782"></a>00782         }
<a name="l00783"></a>00783         idxNew = <a class="code" href="where_8c.html#ab5ba6610a2a2c7adf47874998581187a">whereClauseInsert</a>(pWC, pDup, <a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a>|<a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">TERM_DYNAMIC</a>);
<a name="l00784"></a>00784         <span class="keywordflow">if</span>( idxNew==0 ) <span class="keywordflow">return</span>;
<a name="l00785"></a>00785         pNew = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxNew];
<a name="l00786"></a>00786         pNew-&gt;<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a> = idxTerm;
<a name="l00787"></a>00787         pTerm = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxTerm];
<a name="l00788"></a>00788         pTerm-&gt;<a class="code" href="structWhereTerm.html#af83cf7bae7760b9b1ca398338a35c32a">nChild</a> = 1;
<a name="l00789"></a>00789         pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> |= <a class="code" href="where_8c.html#ac25e3e7f766c9b899cc5138fc2c12b36">TERM_COPIED</a>;
<a name="l00790"></a>00790       }<span class="keywordflow">else</span>{
<a name="l00791"></a>00791         pDup = pExpr;
<a name="l00792"></a>00792         pNew = pTerm;
<a name="l00793"></a>00793       }
<a name="l00794"></a>00794       <a class="code" href="where_8c.html#ab6bc22735005ef5fc9bd51cd269f54be">exprCommute</a>(pParse, pDup);
<a name="l00795"></a>00795       pLeft = pDup-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>;
<a name="l00796"></a>00796       pNew-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a> = pLeft-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a>;
<a name="l00797"></a>00797       pNew-&gt;<a class="code" href="structWhereTerm.html#a48ece896af5482c14c5041fe51a193c2">leftColumn</a> = pLeft-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>;
<a name="l00798"></a>00798       pNew-&gt;<a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a> = prereqLeft;
<a name="l00799"></a>00799       pNew-&gt;<a class="code" href="structWhereTerm.html#a49b700336b005067352366cfc40de07f">prereqAll</a> = prereqAll;
<a name="l00800"></a>00800       pNew-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> = <a class="code" href="where_8c.html#aeb40a13ab59ab419831882068668c52f">operatorMask</a>(pDup-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>);
<a name="l00801"></a>00801     }
<a name="l00802"></a>00802   }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 <span class="preprocessor">#ifndef SQLITE_OMIT_BETWEEN_OPTIMIZATION</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>  <span class="comment">/* If a term is the BETWEEN operator, create two new virtual terms</span>
<a name="l00806"></a>00806 <span class="comment">  ** that define the range that the BETWEEN implements.</span>
<a name="l00807"></a>00807 <span class="comment">  */</span>
<a name="l00808"></a>00808   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#a76049c3c0572b163887c79a666688d62">TK_BETWEEN</a> ){
<a name="l00809"></a>00809     <a class="code" href="structExprList.html">ExprList</a> *pList = pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>;
<a name="l00810"></a>00810     <span class="keywordtype">int</span> i;
<a name="l00811"></a>00811     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> ops[] = {<a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a>, <a class="code" href="parse_8h.html#ab2968df89b2ff434e31d618a3ac9c2ff">TK_LE</a>};
<a name="l00812"></a>00812     assert( pList!=0 );
<a name="l00813"></a>00813     assert( pList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>==2 );
<a name="l00814"></a>00814     <span class="keywordflow">for</span>(i=0; i&lt;2; i++){
<a name="l00815"></a>00815       <a class="code" href="structExpr.html">Expr</a> *pNewExpr;
<a name="l00816"></a>00816       <span class="keywordtype">int</span> idxNew;
<a name="l00817"></a>00817       pNewExpr = <a class="code" href="expr_8c.html#a1033316115be02c18a6fd8946f3e4a61">sqlite3Expr</a>(db, ops[i], <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db, pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>),
<a name="l00818"></a>00818                              <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db, pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>), 0);
<a name="l00819"></a>00819       idxNew = <a class="code" href="where_8c.html#ab5ba6610a2a2c7adf47874998581187a">whereClauseInsert</a>(pWC, pNewExpr, <a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a>|<a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">TERM_DYNAMIC</a>);
<a name="l00820"></a>00820       <a class="code" href="where_8c.html#acb10e48c9a4184a4edd9bfd5b14ad0b7">exprAnalyze</a>(pSrc, pWC, idxNew);
<a name="l00821"></a>00821       pTerm = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxTerm];
<a name="l00822"></a>00822       pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxNew].<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a> = idxTerm;
<a name="l00823"></a>00823     }
<a name="l00824"></a>00824     pTerm-&gt;<a class="code" href="structWhereTerm.html#af83cf7bae7760b9b1ca398338a35c32a">nChild</a> = 2;
<a name="l00825"></a>00825   }
<a name="l00826"></a>00826 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_BETWEEN_OPTIMIZATION */</span>
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 <span class="preprocessor">#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) &amp;&amp; !defined(SQLITE_OMIT_SUBQUERY)</span>
<a name="l00829"></a>00829 <span class="preprocessor"></span>  <span class="comment">/* Attempt to convert OR-connected terms into an IN operator so that</span>
<a name="l00830"></a>00830 <span class="comment">  ** they can make use of indices.  Example:</span>
<a name="l00831"></a>00831 <span class="comment">  **</span>
<a name="l00832"></a>00832 <span class="comment">  **      x = expr1  OR  expr2 = x  OR  x = expr3</span>
<a name="l00833"></a>00833 <span class="comment">  **</span>
<a name="l00834"></a>00834 <span class="comment">  ** is converted into</span>
<a name="l00835"></a>00835 <span class="comment">  **</span>
<a name="l00836"></a>00836 <span class="comment">  **      x IN (expr1,expr2,expr3)</span>
<a name="l00837"></a>00837 <span class="comment">  **</span>
<a name="l00838"></a>00838 <span class="comment">  ** This optimization must be omitted if OMIT_SUBQUERY is defined because</span>
<a name="l00839"></a>00839 <span class="comment">  ** the compiler for the the IN operator is part of sub-queries.</span>
<a name="l00840"></a>00840 <span class="comment">  */</span>
<a name="l00841"></a>00841   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#ad3dfdf2c4de4a655e9111a0ab43e29b3">TK_OR</a> ){
<a name="l00842"></a>00842     <span class="keywordtype">int</span> ok;
<a name="l00843"></a>00843     <span class="keywordtype">int</span> i, j;
<a name="l00844"></a>00844     <span class="keywordtype">int</span> iColumn, iCursor;
<a name="l00845"></a>00845     <a class="code" href="structWhereClause.html">WhereClause</a> sOr;
<a name="l00846"></a>00846     <a class="code" href="structWhereTerm.html">WhereTerm</a> *pOrTerm;
<a name="l00847"></a>00847 
<a name="l00848"></a>00848     assert( (pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">TERM_DYNAMIC</a>)==0 );
<a name="l00849"></a>00849     <a class="code" href="where_8c.html#aa1a7a509852a1a70634cb58355f643bc">whereClauseInit</a>(&amp;sOr, pWC-&gt;<a class="code" href="structWhereClause.html#a3ff6dfc93e7b9b97a9bf9a0618a1d542">pParse</a>, pMaskSet);
<a name="l00850"></a>00850     <a class="code" href="where_8c.html#a11081d7feda10bb8c57f960b1a4609ac">whereSplit</a>(&amp;sOr, pExpr, <a class="code" href="parse_8h.html#ad3dfdf2c4de4a655e9111a0ab43e29b3">TK_OR</a>);
<a name="l00851"></a>00851     <a class="code" href="where_8c.html#a2e7a957af98e240fa68e34d6ff639437">exprAnalyzeAll</a>(pSrc, &amp;sOr);
<a name="l00852"></a>00852     assert( sOr.<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>&gt;=2 );
<a name="l00853"></a>00853     j = 0;
<a name="l00854"></a>00854     <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ) <span class="keywordflow">goto</span> or_not_possible;
<a name="l00855"></a>00855     <span class="keywordflow">do</span>{
<a name="l00856"></a>00856       assert( j&lt;sOr.<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a> );
<a name="l00857"></a>00857       iColumn = sOr.<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[j].<a class="code" href="structWhereTerm.html#a48ece896af5482c14c5041fe51a193c2">leftColumn</a>;
<a name="l00858"></a>00858       iCursor = sOr.<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[j].<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a>;
<a name="l00859"></a>00859       ok = iCursor&gt;=0;
<a name="l00860"></a>00860       <span class="keywordflow">for</span>(i=sOr.<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>-1, pOrTerm=sOr.<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>; i&gt;=0 &amp;&amp; ok; i--, pOrTerm++){
<a name="l00861"></a>00861         <span class="keywordflow">if</span>( pOrTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>!=<a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a> ){
<a name="l00862"></a>00862           <span class="keywordflow">goto</span> or_not_possible;
<a name="l00863"></a>00863         }
<a name="l00864"></a>00864         <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#a8c1fae1ffa38a81e19827122890d0982">orTermIsOptCandidate</a>(pOrTerm, iCursor, iColumn) ){
<a name="l00865"></a>00865           pOrTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> |= <a class="code" href="where_8c.html#a9b5399695c087886c9f9ff8a93557217">TERM_OR_OK</a>;
<a name="l00866"></a>00866         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#acc50eccdcf6572309224c080e869e623">orTermHasOkDuplicate</a>(&amp;sOr, pOrTerm) ){
<a name="l00867"></a>00867           pOrTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp;= ~<a class="code" href="where_8c.html#a9b5399695c087886c9f9ff8a93557217">TERM_OR_OK</a>;
<a name="l00868"></a>00868         }<span class="keywordflow">else</span>{
<a name="l00869"></a>00869           ok = 0;
<a name="l00870"></a>00870         }
<a name="l00871"></a>00871       }
<a name="l00872"></a>00872     }<span class="keywordflow">while</span>( !ok &amp;&amp; (sOr.<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[j++].<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#ac25e3e7f766c9b899cc5138fc2c12b36">TERM_COPIED</a>)!=0 &amp;&amp; j&lt;2 );
<a name="l00873"></a>00873     <span class="keywordflow">if</span>( ok ){
<a name="l00874"></a>00874       <a class="code" href="structExprList.html">ExprList</a> *pList = 0;
<a name="l00875"></a>00875       <a class="code" href="structExpr.html">Expr</a> *pNew, *pDup;
<a name="l00876"></a>00876       <a class="code" href="structExpr.html">Expr</a> *pLeft = 0;
<a name="l00877"></a>00877       <span class="keywordflow">for</span>(i=sOr.<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>-1, pOrTerm=sOr.<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>; i&gt;=0; i--, pOrTerm++){
<a name="l00878"></a>00878         <span class="keywordflow">if</span>( (pOrTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a9b5399695c087886c9f9ff8a93557217">TERM_OR_OK</a>)==0 ) <span class="keywordflow">continue</span>;
<a name="l00879"></a>00879         pDup = <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db, pOrTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>);
<a name="l00880"></a>00880         pList = <a class="code" href="expr_8c.html#ab13e5474e1cc01f58f1957f70ecce9f6">sqlite3ExprListAppend</a>(pWC-&gt;<a class="code" href="structWhereClause.html#a3ff6dfc93e7b9b97a9bf9a0618a1d542">pParse</a>, pList, pDup, 0);
<a name="l00881"></a>00881         pLeft = pOrTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>;
<a name="l00882"></a>00882       }
<a name="l00883"></a>00883       assert( pLeft!=0 );
<a name="l00884"></a>00884       pDup = <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db, pLeft);
<a name="l00885"></a>00885       pNew = <a class="code" href="expr_8c.html#a1033316115be02c18a6fd8946f3e4a61">sqlite3Expr</a>(db, <a class="code" href="parse_8h.html#a6437312264a013b5bf1539ffe8a65e94">TK_IN</a>, pDup, 0, 0);
<a name="l00886"></a>00886       <span class="keywordflow">if</span>( pNew ){
<a name="l00887"></a>00887         <span class="keywordtype">int</span> idxNew;
<a name="l00888"></a>00888         <a class="code" href="where_8c.html#a47436cb058c53d38e19c4169f1e9c0d3">transferJoinMarkings</a>(pNew, pExpr);
<a name="l00889"></a>00889         pNew-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a> = pList;
<a name="l00890"></a>00890         idxNew = <a class="code" href="where_8c.html#ab5ba6610a2a2c7adf47874998581187a">whereClauseInsert</a>(pWC, pNew, <a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a>|<a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">TERM_DYNAMIC</a>);
<a name="l00891"></a>00891         <a class="code" href="where_8c.html#acb10e48c9a4184a4edd9bfd5b14ad0b7">exprAnalyze</a>(pSrc, pWC, idxNew);
<a name="l00892"></a>00892         pTerm = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxTerm];
<a name="l00893"></a>00893         pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxNew].<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a> = idxTerm;
<a name="l00894"></a>00894         pTerm-&gt;<a class="code" href="structWhereTerm.html#af83cf7bae7760b9b1ca398338a35c32a">nChild</a> = 1;
<a name="l00895"></a>00895       }<span class="keywordflow">else</span>{
<a name="l00896"></a>00896         <a class="code" href="expr_8c.html#a98a67aead81716e47859051ede821a41">sqlite3ExprListDelete</a>(db, pList);
<a name="l00897"></a>00897       }
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899 or_not_possible:
<a name="l00900"></a>00900     <a class="code" href="where_8c.html#adb29ca8d094e2324f7fc20962502d8c9">whereClauseClear</a>(&amp;sOr);
<a name="l00901"></a>00901   }
<a name="l00902"></a>00902 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_OR_OPTIMIZATION */</span>
<a name="l00903"></a>00903 
<a name="l00904"></a>00904 <span class="preprocessor">#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION</span>
<a name="l00905"></a>00905 <span class="preprocessor"></span>  <span class="comment">/* Add constraints to reduce the search space on a LIKE or GLOB</span>
<a name="l00906"></a>00906 <span class="comment">  ** operator.</span>
<a name="l00907"></a>00907 <span class="comment">  **</span>
<a name="l00908"></a>00908 <span class="comment">  ** A like pattern of the form &quot;x LIKE &apos;abc%&apos;&quot; is changed into constraints</span>
<a name="l00909"></a>00909 <span class="comment">  **</span>
<a name="l00910"></a>00910 <span class="comment">  **          x&gt;=&apos;abc&apos; AND x&lt;&apos;abd&apos; AND x LIKE &apos;abc%&apos;</span>
<a name="l00911"></a>00911 <span class="comment">  **</span>
<a name="l00912"></a>00912 <span class="comment">  ** The last character of the prefix &quot;abc&quot; is incremented to form the</span>
<a name="l00913"></a>00913 <span class="comment">  ** termination condition &quot;abd&quot;.</span>
<a name="l00914"></a>00914 <span class="comment">  */</span>
<a name="l00915"></a>00915   <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#af264699b46d5f9b4bd023a12eb2be74c">isLikeOrGlob</a>(pParse, pExpr, &amp;nPattern, &amp;isComplete, &amp;noCase) ){
<a name="l00916"></a>00916     <a class="code" href="structExpr.html">Expr</a> *pLeft, *pRight;
<a name="l00917"></a>00917     <a class="code" href="structExpr.html">Expr</a> *pStr1, *pStr2;
<a name="l00918"></a>00918     <a class="code" href="structExpr.html">Expr</a> *pNewExpr1, *pNewExpr2;
<a name="l00919"></a>00919     <span class="keywordtype">int</span> idxNew1, idxNew2;
<a name="l00920"></a>00920 
<a name="l00921"></a>00921     pLeft = pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[1].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l00922"></a>00922     pRight = pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[0].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l00923"></a>00923     pStr1 = <a class="code" href="expr_8c.html#aa30fc567fcbf034446870df4e14930bc">sqlite3PExpr</a>(pParse, <a class="code" href="parse_8h.html#a9810f9bc21f26ee9b8d7b374534ff54b">TK_STRING</a>, 0, 0, 0);
<a name="l00924"></a>00924     <span class="keywordflow">if</span>( pStr1 ){
<a name="l00925"></a>00925       <a class="code" href="expr_8c.html#a8361d4d4389799753f72385c4db606e3">sqlite3TokenCopy</a>(db, &amp;pStr1-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>, &amp;pRight-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>);
<a name="l00926"></a>00926       pStr1-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>.<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a> = nPattern;
<a name="l00927"></a>00927       pStr1-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> = <a class="code" href="sqliteInt_8h.html#a7c27c3b0936b60004ae3aa2f83a4aa07">EP_Dequoted</a>;
<a name="l00928"></a>00928     }
<a name="l00929"></a>00929     pStr2 = <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db, pStr1);
<a name="l00930"></a>00930     <span class="keywordflow">if</span>( !db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00931"></a>00931       <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> c, *pC;
<a name="l00932"></a>00932       assert( pStr2-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>.<a class="code" href="structToken.html#a1a4bbef5fb47ea00fc69cbaf8f18c66a">dyn</a> );
<a name="l00933"></a>00933       pC = (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)&amp;pStr2-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>[nPattern-1];
<a name="l00934"></a>00934       c = *pC;
<a name="l00935"></a>00935       <span class="keywordflow">if</span>( noCase ){
<a name="l00936"></a>00936         <span class="keywordflow">if</span>( c==<span class="charliteral">&apos;@&apos;</span> ) isComplete = 0;
<a name="l00937"></a>00937         c = <a class="code" href="global_8c.html#a6bb61005ff51dbe22e7ab8acb9b01e77">sqlite3UpperToLower</a>[c];
<a name="l00938"></a>00938       }
<a name="l00939"></a>00939       *pC = c + 1;
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941     pNewExpr1 = <a class="code" href="expr_8c.html#aa30fc567fcbf034446870df4e14930bc">sqlite3PExpr</a>(pParse, <a class="code" href="parse_8h.html#a8454a03f79a8093f2a6214565089164c">TK_GE</a>, <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db,pLeft), pStr1, 0);
<a name="l00942"></a>00942     idxNew1 = <a class="code" href="where_8c.html#ab5ba6610a2a2c7adf47874998581187a">whereClauseInsert</a>(pWC, pNewExpr1, <a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a>|<a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">TERM_DYNAMIC</a>);
<a name="l00943"></a>00943     <a class="code" href="where_8c.html#acb10e48c9a4184a4edd9bfd5b14ad0b7">exprAnalyze</a>(pSrc, pWC, idxNew1);
<a name="l00944"></a>00944     pNewExpr2 = <a class="code" href="expr_8c.html#aa30fc567fcbf034446870df4e14930bc">sqlite3PExpr</a>(pParse, <a class="code" href="parse_8h.html#a8ae3cd6a51a9c976e55f803363ac40d1">TK_LT</a>, <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db,pLeft), pStr2, 0);
<a name="l00945"></a>00945     idxNew2 = <a class="code" href="where_8c.html#ab5ba6610a2a2c7adf47874998581187a">whereClauseInsert</a>(pWC, pNewExpr2, <a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a>|<a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">TERM_DYNAMIC</a>);
<a name="l00946"></a>00946     <a class="code" href="where_8c.html#acb10e48c9a4184a4edd9bfd5b14ad0b7">exprAnalyze</a>(pSrc, pWC, idxNew2);
<a name="l00947"></a>00947     pTerm = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxTerm];
<a name="l00948"></a>00948     <span class="keywordflow">if</span>( isComplete ){
<a name="l00949"></a>00949       pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxNew1].<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a> = idxTerm;
<a name="l00950"></a>00950       pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxNew2].<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a> = idxTerm;
<a name="l00951"></a>00951       pTerm-&gt;<a class="code" href="structWhereTerm.html#af83cf7bae7760b9b1ca398338a35c32a">nChild</a> = 2;
<a name="l00952"></a>00952     }
<a name="l00953"></a>00953   }
<a name="l00954"></a>00954 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_LIKE_OPTIMIZATION */</span>
<a name="l00955"></a>00955 
<a name="l00956"></a>00956 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l00957"></a>00957 <span class="preprocessor"></span>  <span class="comment">/* Add a WO_MATCH auxiliary term to the constraint set if the</span>
<a name="l00958"></a>00958 <span class="comment">  ** current expression is of the form:  column MATCH expr.</span>
<a name="l00959"></a>00959 <span class="comment">  ** This information is used by the xBestIndex methods of</span>
<a name="l00960"></a>00960 <span class="comment">  ** virtual tables.  The native query optimizer does not attempt</span>
<a name="l00961"></a>00961 <span class="comment">  ** to do anything with MATCH functions.</span>
<a name="l00962"></a>00962 <span class="comment">  */</span>
<a name="l00963"></a>00963   <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#aca81ee8f18d68ba146e343c7b49152a3">isMatchOfColumn</a>(pExpr) ){
<a name="l00964"></a>00964     <span class="keywordtype">int</span> idxNew;
<a name="l00965"></a>00965     <a class="code" href="structExpr.html">Expr</a> *pRight, *pLeft;
<a name="l00966"></a>00966     <a class="code" href="structWhereTerm.html">WhereTerm</a> *pNewTerm;
<a name="l00967"></a>00967     <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> prereqColumn, prereqExpr;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969     pRight = pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[0].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l00970"></a>00970     pLeft = pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[1].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l00971"></a>00971     prereqExpr = <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, pRight);
<a name="l00972"></a>00972     prereqColumn = <a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, pLeft);
<a name="l00973"></a>00973     <span class="keywordflow">if</span>( (prereqExpr &amp; prereqColumn)==0 ){
<a name="l00974"></a>00974       <a class="code" href="structExpr.html">Expr</a> *pNewExpr;
<a name="l00975"></a>00975       pNewExpr = <a class="code" href="expr_8c.html#a1033316115be02c18a6fd8946f3e4a61">sqlite3Expr</a>(db, <a class="code" href="parse_8h.html#a59b56482cb7d18fa9777a7f57517afd0">TK_MATCH</a>, 0, <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db, pRight), 0);
<a name="l00976"></a>00976       idxNew = <a class="code" href="where_8c.html#ab5ba6610a2a2c7adf47874998581187a">whereClauseInsert</a>(pWC, pNewExpr, <a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a>|<a class="code" href="where_8c.html#a42251f85b380653792b9e5aeae3279e7">TERM_DYNAMIC</a>);
<a name="l00977"></a>00977       pNewTerm = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxNew];
<a name="l00978"></a>00978       pNewTerm-&gt;<a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a> = prereqExpr;
<a name="l00979"></a>00979       pNewTerm-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a> = pLeft-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a>;
<a name="l00980"></a>00980       pNewTerm-&gt;<a class="code" href="structWhereTerm.html#a48ece896af5482c14c5041fe51a193c2">leftColumn</a> = pLeft-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>;
<a name="l00981"></a>00981       pNewTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> = <a class="code" href="where_8c.html#a044f3cbfa74e455ad7fa96547d5ada56">WO_MATCH</a>;
<a name="l00982"></a>00982       pNewTerm-&gt;<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a> = idxTerm;
<a name="l00983"></a>00983       pTerm = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[idxTerm];
<a name="l00984"></a>00984       pTerm-&gt;<a class="code" href="structWhereTerm.html#af83cf7bae7760b9b1ca398338a35c32a">nChild</a> = 1;
<a name="l00985"></a>00985       pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> |= <a class="code" href="where_8c.html#ac25e3e7f766c9b899cc5138fc2c12b36">TERM_COPIED</a>;
<a name="l00986"></a>00986       pNewTerm-&gt;<a class="code" href="structWhereTerm.html#a49b700336b005067352366cfc40de07f">prereqAll</a> = pTerm-&gt;<a class="code" href="structWhereTerm.html#a49b700336b005067352366cfc40de07f">prereqAll</a>;
<a name="l00987"></a>00987     }
<a name="l00988"></a>00988   }
<a name="l00989"></a>00989 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l00990"></a>00990 
<a name="l00991"></a>00991   <span class="comment">/* Prevent ON clause terms of a LEFT JOIN from being used to drive</span>
<a name="l00992"></a>00992 <span class="comment">  ** an index for tables to the left of the join.</span>
<a name="l00993"></a>00993 <span class="comment">  */</span>
<a name="l00994"></a>00994   pTerm-&gt;<a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a> |= extraRight;
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 <span class="comment">/*</span>
<a name="l00998"></a>00998 <span class="comment">** Return TRUE if any of the expressions in pList-&gt;a[iFirst...] contain</span>
<a name="l00999"></a>00999 <span class="comment">** a reference to any table other than the iBase table.</span>
<a name="l01000"></a>01000 <span class="comment">*/</span>
<a name="l01001"></a><a class="code" href="where_8c.html#ad447600c4b41293c03f230c89407ffcd">01001</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#ad447600c4b41293c03f230c89407ffcd">referencesOtherTables</a>(
<a name="l01002"></a>01002   <a class="code" href="structExprList.html">ExprList</a> *pList,          <span class="comment">/* Search expressions in ths list */</span>
<a name="l01003"></a>01003   <a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet,    <span class="comment">/* Mapping from tables to bitmaps */</span>
<a name="l01004"></a>01004   <span class="keywordtype">int</span> iFirst,               <span class="comment">/* Be searching with the iFirst-th expression */</span>
<a name="l01005"></a>01005   <span class="keywordtype">int</span> iBase                 <span class="comment">/* Ignore references to this table */</span>
<a name="l01006"></a>01006 ){
<a name="l01007"></a>01007   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> allowed = ~<a class="code" href="where_8c.html#a330443df7684d9bca657260aea158e0c">getMask</a>(pMaskSet, iBase);
<a name="l01008"></a>01008   <span class="keywordflow">while</span>( iFirst&lt;pList-&gt;nExpr ){
<a name="l01009"></a>01009     <span class="keywordflow">if</span>( (<a class="code" href="where_8c.html#a356a3d84fc2daa346147cb7016b70c84">exprTableUsage</a>(pMaskSet, pList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[iFirst++].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>)&amp;allowed)!=0 ){
<a name="l01010"></a>01010       <span class="keywordflow">return</span> 1;
<a name="l01011"></a>01011     }
<a name="l01012"></a>01012   }
<a name="l01013"></a>01013   <span class="keywordflow">return</span> 0;
<a name="l01014"></a>01014 }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 <span class="comment">/*</span>
<a name="l01018"></a>01018 <span class="comment">** This routine decides if pIdx can be used to satisfy the ORDER BY</span>
<a name="l01019"></a>01019 <span class="comment">** clause.  If it can, it returns 1.  If pIdx cannot satisfy the</span>
<a name="l01020"></a>01020 <span class="comment">** ORDER BY clause, this routine returns 0.</span>
<a name="l01021"></a>01021 <span class="comment">**</span>
<a name="l01022"></a>01022 <span class="comment">** pOrderBy is an ORDER BY clause from a SELECT statement.  pTab is the</span>
<a name="l01023"></a>01023 <span class="comment">** left-most table in the FROM clause of that same SELECT statement and</span>
<a name="l01024"></a>01024 <span class="comment">** the table has a cursor number of &quot;base&quot;.  pIdx is an index on pTab.</span>
<a name="l01025"></a>01025 <span class="comment">**</span>
<a name="l01026"></a>01026 <span class="comment">** nEqCol is the number of columns of pIdx that are used as equality</span>
<a name="l01027"></a>01027 <span class="comment">** constraints.  Any of these columns may be missing from the ORDER BY</span>
<a name="l01028"></a>01028 <span class="comment">** clause and the match can still be a success.</span>
<a name="l01029"></a>01029 <span class="comment">**</span>
<a name="l01030"></a>01030 <span class="comment">** All terms of the ORDER BY that match against the index must be either</span>
<a name="l01031"></a>01031 <span class="comment">** ASC or DESC.  (Terms of the ORDER BY clause past the end of a UNIQUE</span>
<a name="l01032"></a>01032 <span class="comment">** index do not need to satisfy this constraint.)  The *pbRev value is</span>
<a name="l01033"></a>01033 <span class="comment">** set to 1 if the ORDER BY clause is all DESC and it is set to 0 if</span>
<a name="l01034"></a>01034 <span class="comment">** the ORDER BY clause is all ASC.</span>
<a name="l01035"></a>01035 <span class="comment">*/</span>
<a name="l01036"></a><a class="code" href="where_8c.html#a59a1e49f6eb3af7de8aecd971451f98d">01036</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#a59a1e49f6eb3af7de8aecd971451f98d">isSortingIndex</a>(
<a name="l01037"></a>01037   <a class="code" href="structParse.html">Parse</a> *pParse,          <span class="comment">/* Parsing context */</span>
<a name="l01038"></a>01038   <a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet,  <span class="comment">/* Mapping from table indices to bitmaps */</span>
<a name="l01039"></a>01039   <a class="code" href="structIndex.html">Index</a> *pIdx,            <span class="comment">/* The index we are testing */</span>
<a name="l01040"></a>01040   <span class="keywordtype">int</span> base,               <span class="comment">/* Cursor number for the table to be sorted */</span>
<a name="l01041"></a>01041   <a class="code" href="structExprList.html">ExprList</a> *pOrderBy,     <span class="comment">/* The ORDER BY clause */</span>
<a name="l01042"></a>01042   <span class="keywordtype">int</span> nEqCol,             <span class="comment">/* Number of index columns with == constraints */</span>
<a name="l01043"></a>01043   <span class="keywordtype">int</span> *pbRev              <span class="comment">/* Set to 1 if ORDER BY is DESC */</span>
<a name="l01044"></a>01044 ){
<a name="l01045"></a>01045   <span class="keywordtype">int</span> i, j;                       <span class="comment">/* Loop counters */</span>
<a name="l01046"></a>01046   <span class="keywordtype">int</span> sortOrder = 0;              <span class="comment">/* XOR of index and ORDER BY sort direction */</span>
<a name="l01047"></a>01047   <span class="keywordtype">int</span> nTerm;                      <span class="comment">/* Number of ORDER BY terms */</span>
<a name="l01048"></a>01048   <span class="keyword">struct </span>ExprList_item *pTerm;    <span class="comment">/* A term of the ORDER BY clause */</span>
<a name="l01049"></a>01049   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l01050"></a>01050 
<a name="l01051"></a>01051   assert( pOrderBy!=0 );
<a name="l01052"></a>01052   nTerm = pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>;
<a name="l01053"></a>01053   assert( nTerm&gt;0 );
<a name="l01054"></a>01054 
<a name="l01055"></a>01055   <span class="comment">/* Match terms of the ORDER BY clause against columns of</span>
<a name="l01056"></a>01056 <span class="comment">  ** the index.</span>
<a name="l01057"></a>01057 <span class="comment">  **</span>
<a name="l01058"></a>01058 <span class="comment">  ** Note that indices have pIdx-&gt;nColumn regular columns plus</span>
<a name="l01059"></a>01059 <span class="comment">  ** one additional column containing the rowid.  The rowid column</span>
<a name="l01060"></a>01060 <span class="comment">  ** of the index is also allowed to match against the ORDER BY</span>
<a name="l01061"></a>01061 <span class="comment">  ** clause.</span>
<a name="l01062"></a>01062 <span class="comment">  */</span>
<a name="l01063"></a>01063   <span class="keywordflow">for</span>(i=j=0, pTerm=pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>; j&lt;nTerm &amp;&amp; i&lt;=pIdx-&gt;nColumn; i++){
<a name="l01064"></a>01064     <a class="code" href="structExpr.html">Expr</a> *pExpr;       <span class="comment">/* The expression of the ORDER BY pTerm */</span>
<a name="l01065"></a>01065     <a class="code" href="structCollSeq.html">CollSeq</a> *pColl;    <span class="comment">/* The collating sequence of pExpr */</span>
<a name="l01066"></a>01066     <span class="keywordtype">int</span> termSortOrder; <span class="comment">/* Sort order for this term */</span>
<a name="l01067"></a>01067     <span class="keywordtype">int</span> iColumn;       <span class="comment">/* The i-th column of the index.  -1 for rowid */</span>
<a name="l01068"></a>01068     <span class="keywordtype">int</span> iSortOrder;    <span class="comment">/* 1 for DESC, 0 for ASC on the i-th index term */</span>
<a name="l01069"></a>01069     <span class="keyword">const</span> <span class="keywordtype">char</span> *zColl; <span class="comment">/* Name of the collating sequence for i-th index term */</span>
<a name="l01070"></a>01070 
<a name="l01071"></a>01071     pExpr = pTerm-&gt;pExpr;
<a name="l01072"></a>01072     <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> || pExpr-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a>!=base ){
<a name="l01073"></a>01073       <span class="comment">/* Can not use an index sort on anything that is not a column in the</span>
<a name="l01074"></a>01074 <span class="comment">      ** left-most table of the FROM clause */</span>
<a name="l01075"></a>01075       <span class="keywordflow">break</span>;
<a name="l01076"></a>01076     }
<a name="l01077"></a>01077     pColl = <a class="code" href="expr_8c.html#adb1b59cdd498beb6607df500bb414d93">sqlite3ExprCollSeq</a>(pParse, pExpr);
<a name="l01078"></a>01078     <span class="keywordflow">if</span>( !pColl ){
<a name="l01079"></a>01079       pColl = db-&gt;<a class="code" href="structsqlite3.html#a2e5d7e7ac07c33b11c936b181d07789a">pDfltColl</a>;
<a name="l01080"></a>01080     }
<a name="l01081"></a>01081     <span class="keywordflow">if</span>( i&lt;pIdx-&gt;nColumn ){
<a name="l01082"></a>01082       iColumn = pIdx-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[i];
<a name="l01083"></a>01083       <span class="keywordflow">if</span>( iColumn==pIdx-&gt;<a class="code" href="structIndex.html#a01c6d4da27cba325ca58f333f87a6f44">pTable</a>-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a> ){
<a name="l01084"></a>01084         iColumn = -1;
<a name="l01085"></a>01085       }
<a name="l01086"></a>01086       iSortOrder = pIdx-&gt;<a class="code" href="structIndex.html#a0a3fc87b53193995f59c9657443e9a99">aSortOrder</a>[i];
<a name="l01087"></a>01087       zColl = pIdx-&gt;<a class="code" href="structIndex.html#ab690ebb96c0329896b0fe2ab56813b88">azColl</a>[i];
<a name="l01088"></a>01088     }<span class="keywordflow">else</span>{
<a name="l01089"></a>01089       iColumn = -1;
<a name="l01090"></a>01090       iSortOrder = 0;
<a name="l01091"></a>01091       zColl = pColl-&gt;<a class="code" href="structCollSeq.html#a48d6d5f71d4f8a3ab122903464e8b4a1">zName</a>;
<a name="l01092"></a>01092     }
<a name="l01093"></a>01093     <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>!=iColumn || <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(pColl-&gt;<a class="code" href="structCollSeq.html#a48d6d5f71d4f8a3ab122903464e8b4a1">zName</a>, zColl) ){
<a name="l01094"></a>01094       <span class="comment">/* Term j of the ORDER BY clause does not match column i of the index */</span>
<a name="l01095"></a>01095       <span class="keywordflow">if</span>( i&lt;nEqCol ){
<a name="l01096"></a>01096         <span class="comment">/* If an index column that is constrained by == fails to match an</span>
<a name="l01097"></a>01097 <span class="comment">        ** ORDER BY term, that is OK.  Just ignore that column of the index</span>
<a name="l01098"></a>01098 <span class="comment">        */</span>
<a name="l01099"></a>01099         <span class="keywordflow">continue</span>;
<a name="l01100"></a>01100       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( i==pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a> ){
<a name="l01101"></a>01101         <span class="comment">/* Index column i is the rowid.  All other terms match. */</span>
<a name="l01102"></a>01102         <span class="keywordflow">break</span>;
<a name="l01103"></a>01103       }<span class="keywordflow">else</span>{
<a name="l01104"></a>01104         <span class="comment">/* If an index column fails to match and is not constrained by ==</span>
<a name="l01105"></a>01105 <span class="comment">        ** then the index cannot satisfy the ORDER BY constraint.</span>
<a name="l01106"></a>01106 <span class="comment">        */</span>
<a name="l01107"></a>01107         <span class="keywordflow">return</span> 0;
<a name="l01108"></a>01108       }
<a name="l01109"></a>01109     }
<a name="l01110"></a>01110     assert( pIdx-&gt;<a class="code" href="structIndex.html#a0a3fc87b53193995f59c9657443e9a99">aSortOrder</a>!=0 );
<a name="l01111"></a>01111     assert( pTerm-&gt;sortOrder==0 || pTerm-&gt;sortOrder==1 );
<a name="l01112"></a>01112     assert( iSortOrder==0 || iSortOrder==1 );
<a name="l01113"></a>01113     termSortOrder = iSortOrder ^ pTerm-&gt;sortOrder;
<a name="l01114"></a>01114     <span class="keywordflow">if</span>( i&gt;nEqCol ){
<a name="l01115"></a>01115       <span class="keywordflow">if</span>( termSortOrder!=sortOrder ){
<a name="l01116"></a>01116         <span class="comment">/* Indices can only be used if all ORDER BY terms past the</span>
<a name="l01117"></a>01117 <span class="comment">        ** equality constraints are all either DESC or ASC. */</span>
<a name="l01118"></a>01118         <span class="keywordflow">return</span> 0;
<a name="l01119"></a>01119       }
<a name="l01120"></a>01120     }<span class="keywordflow">else</span>{
<a name="l01121"></a>01121       sortOrder = termSortOrder;
<a name="l01122"></a>01122     }
<a name="l01123"></a>01123     j++;
<a name="l01124"></a>01124     pTerm++;
<a name="l01125"></a>01125     <span class="keywordflow">if</span>( iColumn&lt;0 &amp;&amp; !<a class="code" href="where_8c.html#ad447600c4b41293c03f230c89407ffcd">referencesOtherTables</a>(pOrderBy, pMaskSet, j, base) ){
<a name="l01126"></a>01126       <span class="comment">/* If the indexed column is the primary key and everything matches</span>
<a name="l01127"></a>01127 <span class="comment">      ** so far and none of the ORDER BY terms to the right reference other</span>
<a name="l01128"></a>01128 <span class="comment">      ** tables in the join, then we are assured that the index can be used </span>
<a name="l01129"></a>01129 <span class="comment">      ** to sort because the primary key is unique and so none of the other</span>
<a name="l01130"></a>01130 <span class="comment">      ** columns will make any difference</span>
<a name="l01131"></a>01131 <span class="comment">      */</span>
<a name="l01132"></a>01132       j = nTerm;
<a name="l01133"></a>01133     }
<a name="l01134"></a>01134   }
<a name="l01135"></a>01135 
<a name="l01136"></a>01136   *pbRev = sortOrder!=0;
<a name="l01137"></a>01137   <span class="keywordflow">if</span>( j&gt;=nTerm ){
<a name="l01138"></a>01138     <span class="comment">/* All terms of the ORDER BY clause are covered by this index so</span>
<a name="l01139"></a>01139 <span class="comment">    ** this index can be used for sorting. */</span>
<a name="l01140"></a>01140     <span class="keywordflow">return</span> 1;
<a name="l01141"></a>01141   }
<a name="l01142"></a>01142   <span class="keywordflow">if</span>( pIdx-&gt;<a class="code" href="structIndex.html#ae8bf87d0414e5c46b86192cfbdd271a7">onError</a>!=<a class="code" href="sqliteInt_8h.html#a203b18293bcbd8c1809ef96bd0663064">OE_None</a> &amp;&amp; i==pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>
<a name="l01143"></a>01143       &amp;&amp; !<a class="code" href="where_8c.html#ad447600c4b41293c03f230c89407ffcd">referencesOtherTables</a>(pOrderBy, pMaskSet, j, base) ){
<a name="l01144"></a>01144     <span class="comment">/* All terms of this index match some prefix of the ORDER BY clause</span>
<a name="l01145"></a>01145 <span class="comment">    ** and the index is UNIQUE and no terms on the tail of the ORDER BY</span>
<a name="l01146"></a>01146 <span class="comment">    ** clause reference other tables in a join.  If this is all true then</span>
<a name="l01147"></a>01147 <span class="comment">    ** the order by clause is superfluous. */</span>
<a name="l01148"></a>01148     <span class="keywordflow">return</span> 1;
<a name="l01149"></a>01149   }
<a name="l01150"></a>01150   <span class="keywordflow">return</span> 0;
<a name="l01151"></a>01151 }
<a name="l01152"></a>01152 
<a name="l01153"></a>01153 <span class="comment">/*</span>
<a name="l01154"></a>01154 <span class="comment">** Check table to see if the ORDER BY clause in pOrderBy can be satisfied</span>
<a name="l01155"></a>01155 <span class="comment">** by sorting in order of ROWID.  Return true if so and set *pbRev to be</span>
<a name="l01156"></a>01156 <span class="comment">** true for reverse ROWID and false for forward ROWID order.</span>
<a name="l01157"></a>01157 <span class="comment">*/</span>
<a name="l01158"></a><a class="code" href="where_8c.html#a496e0c1849e568f228384d42f2144714">01158</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#a496e0c1849e568f228384d42f2144714">sortableByRowid</a>(
<a name="l01159"></a>01159   <span class="keywordtype">int</span> base,               <span class="comment">/* Cursor number for table to be sorted */</span>
<a name="l01160"></a>01160   <a class="code" href="structExprList.html">ExprList</a> *pOrderBy,     <span class="comment">/* The ORDER BY clause */</span>
<a name="l01161"></a>01161   <a class="code" href="structExprMaskSet.html">ExprMaskSet</a> *pMaskSet,  <span class="comment">/* Mapping from tables to bitmaps */</span>
<a name="l01162"></a>01162   <span class="keywordtype">int</span> *pbRev              <span class="comment">/* Set to 1 if ORDER BY is DESC */</span>
<a name="l01163"></a>01163 ){
<a name="l01164"></a>01164   <a class="code" href="structExpr.html">Expr</a> *p;
<a name="l01165"></a>01165 
<a name="l01166"></a>01166   assert( pOrderBy!=0 );
<a name="l01167"></a>01167   assert( pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>&gt;0 );
<a name="l01168"></a>01168   p = pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[0].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l01169"></a>01169   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> &amp;&amp; p-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a>==base &amp;&amp; p-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>==-1
<a name="l01170"></a>01170     &amp;&amp; !<a class="code" href="where_8c.html#ad447600c4b41293c03f230c89407ffcd">referencesOtherTables</a>(pOrderBy, pMaskSet, 1, base) ){
<a name="l01171"></a>01171     *pbRev = pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[0].<a class="code" href="structExprList_1_1ExprList__item.html#af9084dc073f96792c0c7a8a894778881">sortOrder</a>;
<a name="l01172"></a>01172     <span class="keywordflow">return</span> 1;
<a name="l01173"></a>01173   }
<a name="l01174"></a>01174   <span class="keywordflow">return</span> 0;
<a name="l01175"></a>01175 }
<a name="l01176"></a>01176 
<a name="l01177"></a>01177 <span class="comment">/*</span>
<a name="l01178"></a>01178 <span class="comment">** Prepare a crude estimate of the logarithm of the input value.</span>
<a name="l01179"></a>01179 <span class="comment">** The results need not be exact.  This is only used for estimating</span>
<a name="l01180"></a>01180 <span class="comment">** the total cost of performing operations with O(logN) or O(NlogN)</span>
<a name="l01181"></a>01181 <span class="comment">** complexity.  Because N is just a guess, it is no great tragedy if</span>
<a name="l01182"></a>01182 <span class="comment">** logN is a little off.</span>
<a name="l01183"></a>01183 <span class="comment">*/</span>
<a name="l01184"></a><a class="code" href="where_8c.html#aa4287e4538a263b5de0ea252afee1609">01184</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="where_8c.html#aa4287e4538a263b5de0ea252afee1609">estLog</a>(<span class="keywordtype">double</span> N){
<a name="l01185"></a>01185   <span class="keywordtype">double</span> logN = 1;
<a name="l01186"></a>01186   <span class="keywordtype">double</span> x = 10;
<a name="l01187"></a>01187   <span class="keywordflow">while</span>( N&gt;x ){
<a name="l01188"></a>01188     logN += 1;
<a name="l01189"></a>01189     x *= 10;
<a name="l01190"></a>01190   }
<a name="l01191"></a>01191   <span class="keywordflow">return</span> logN;
<a name="l01192"></a>01192 }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194 <span class="comment">/*</span>
<a name="l01195"></a>01195 <span class="comment">** Two routines for printing the content of an sqlite3_index_info</span>
<a name="l01196"></a>01196 <span class="comment">** structure.  Used for testing and debugging only.  If neither</span>
<a name="l01197"></a>01197 <span class="comment">** SQLITE_TEST or SQLITE_DEBUG are defined, then these routines</span>
<a name="l01198"></a>01198 <span class="comment">** are no-ops.</span>
<a name="l01199"></a>01199 <span class="comment">*/</span>
<a name="l01200"></a>01200 <span class="preprocessor">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_DEBUG)</span>
<a name="l01201"></a>01201 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#aa5edc42c29d7010b1fb95f7904d1848d">TRACE_IDX_INPUTS</a>(<a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> *p){
<a name="l01202"></a>01202   <span class="keywordtype">int</span> i;
<a name="l01203"></a>01203   <span class="keywordflow">if</span>( !sqlite3WhereTrace ) <span class="keywordflow">return</span>;
<a name="l01204"></a>01204   <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structsqlite3__index__info.html#ae861993a30ce914a5214eab2579d935a">nConstraint</a>; i++){
<a name="l01205"></a>01205     sqlite3DebugPrintf(<span class="stringliteral">&quot;  constraint[%d]: col=%d termid=%d op=%d usabled=%d\n&quot;</span>,
<a name="l01206"></a>01206        i,
<a name="l01207"></a>01207        p-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint.html#a0f1e207060420058ee2881f2ea368e3a">iColumn</a>,
<a name="l01208"></a>01208        p-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint.html#a4e8368da66f34b7f07b369984b813d1b">iTermOffset</a>,
<a name="l01209"></a>01209        p-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint.html#a362f4ec1f71975cb0ac39a8b5e4b1476">op</a>,
<a name="l01210"></a>01210        p-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint.html#ae16e62caeab743cc68bb22227dacb501">usable</a>);
<a name="l01211"></a>01211   }
<a name="l01212"></a>01212   <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structsqlite3__index__info.html#a3ef850fdc57eddbc8189fe84d0a9044e">nOrderBy</a>; i++){
<a name="l01213"></a>01213     sqlite3DebugPrintf(<span class="stringliteral">&quot;  orderby[%d]: col=%d desc=%d\n&quot;</span>,
<a name="l01214"></a>01214        i,
<a name="l01215"></a>01215        p-&gt;<a class="code" href="structsqlite3__index__info.html#a6823a68979e19d8e332389361e920ef9">aOrderBy</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__orderby.html#a266396085bfda9acef3f13eaa170cd2f">iColumn</a>,
<a name="l01216"></a>01216        p-&gt;<a class="code" href="structsqlite3__index__info.html#a6823a68979e19d8e332389361e920ef9">aOrderBy</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__orderby.html#a0586d1b5d36221af96aeba8cfc56e9c6">desc</a>);
<a name="l01217"></a>01217   }
<a name="l01218"></a>01218 }
<a name="l01219"></a>01219 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#aa1f4c2954ede906003db7008bb295573">TRACE_IDX_OUTPUTS</a>(<a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> *p){
<a name="l01220"></a>01220   <span class="keywordtype">int</span> i;
<a name="l01221"></a>01221   <span class="keywordflow">if</span>( !sqlite3WhereTrace ) <span class="keywordflow">return</span>;
<a name="l01222"></a>01222   <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structsqlite3__index__info.html#ae861993a30ce914a5214eab2579d935a">nConstraint</a>; i++){
<a name="l01223"></a>01223     sqlite3DebugPrintf(<span class="stringliteral">&quot;  usage[%d]: argvIdx=%d omit=%d\n&quot;</span>,
<a name="l01224"></a>01224        i,
<a name="l01225"></a>01225        p-&gt;<a class="code" href="structsqlite3__index__info.html#a79b8a969dd7d582fc2ea3c0fbc5adb56">aConstraintUsage</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint__usage.html#a2cbf680033c2937b3de226e091743a94">argvIndex</a>,
<a name="l01226"></a>01226        p-&gt;<a class="code" href="structsqlite3__index__info.html#a79b8a969dd7d582fc2ea3c0fbc5adb56">aConstraintUsage</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint__usage.html#ad07fa17d30e4fb3abe23ceaf84edf0ef">omit</a>);
<a name="l01227"></a>01227   }
<a name="l01228"></a>01228   sqlite3DebugPrintf(<span class="stringliteral">&quot;  idxNum=%d\n&quot;</span>, p-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a>);
<a name="l01229"></a>01229   sqlite3DebugPrintf(<span class="stringliteral">&quot;  idxStr=%s\n&quot;</span>, p-&gt;<a class="code" href="structsqlite3__index__info.html#a1a9935e997bd6e3cce048534da7506a7">idxStr</a>);
<a name="l01230"></a>01230   sqlite3DebugPrintf(<span class="stringliteral">&quot;  orderByConsumed=%d\n&quot;</span>, p-&gt;<a class="code" href="structsqlite3__index__info.html#a5515d9de0f37f68d7e0930c20a668b29">orderByConsumed</a>);
<a name="l01231"></a>01231   sqlite3DebugPrintf(<span class="stringliteral">&quot;  estimatedCost=%g\n&quot;</span>, p-&gt;<a class="code" href="structsqlite3__index__info.html#aa8b4fe1d2ee38aab57ba5e1da00d7830">estimatedCost</a>);
<a name="l01232"></a>01232 }
<a name="l01233"></a>01233 <span class="preprocessor">#else</span>
<a name="l01234"></a><a class="code" href="where_8c.html#aa5edc42c29d7010b1fb95f7904d1848d">01234</a> <span class="preprocessor"></span><span class="preprocessor">#define TRACE_IDX_INPUTS(A)</span>
<a name="l01235"></a><a class="code" href="where_8c.html#aa1f4c2954ede906003db7008bb295573">01235</a> <span class="preprocessor"></span><span class="preprocessor">#define TRACE_IDX_OUTPUTS(A)</span>
<a name="l01236"></a>01236 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01237"></a>01237 <span class="preprocessor"></span>
<a name="l01238"></a>01238 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l01239"></a>01239 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01240"></a>01240 <span class="comment">** Compute the best index for a virtual table.</span>
<a name="l01241"></a>01241 <span class="comment">**</span>
<a name="l01242"></a>01242 <span class="comment">** The best index is computed by the xBestIndex method of the virtual</span>
<a name="l01243"></a>01243 <span class="comment">** table module.  This routine is really just a wrapper that sets up</span>
<a name="l01244"></a>01244 <span class="comment">** the sqlite3_index_info structure that is used to communicate with</span>
<a name="l01245"></a>01245 <span class="comment">** xBestIndex.</span>
<a name="l01246"></a>01246 <span class="comment">**</span>
<a name="l01247"></a>01247 <span class="comment">** In a join, this routine might be called multiple times for the</span>
<a name="l01248"></a>01248 <span class="comment">** same virtual table.  The sqlite3_index_info structure is created</span>
<a name="l01249"></a>01249 <span class="comment">** and initialized on the first invocation and reused on all subsequent</span>
<a name="l01250"></a>01250 <span class="comment">** invocations.  The sqlite3_index_info structure is also used when</span>
<a name="l01251"></a>01251 <span class="comment">** code is generated to access the virtual table.  The whereInfoDelete() </span>
<a name="l01252"></a>01252 <span class="comment">** routine takes care of freeing the sqlite3_index_info structure after</span>
<a name="l01253"></a>01253 <span class="comment">** everybody has finished with it.</span>
<a name="l01254"></a>01254 <span class="comment">*/</span>
<a name="l01255"></a><a class="code" href="where_8c.html#a7c4fe3545a56e4acb8ab4a4699b56be9">01255</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="where_8c.html#a7c4fe3545a56e4acb8ab4a4699b56be9">bestVirtualIndex</a>(
<a name="l01256"></a>01256   <a class="code" href="structParse.html">Parse</a> *pParse,                 <span class="comment">/* The parsing context */</span>
<a name="l01257"></a>01257   <a class="code" href="structWhereClause.html">WhereClause</a> *pWC,              <span class="comment">/* The WHERE clause */</span>
<a name="l01258"></a>01258   <span class="keyword">struct</span> SrcList_item *pSrc,     <span class="comment">/* The FROM clause term to search */</span>
<a name="l01259"></a>01259   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> notReady,              <span class="comment">/* Mask of cursors that are not available */</span>
<a name="l01260"></a>01260   <a class="code" href="structExprList.html">ExprList</a> *pOrderBy,            <span class="comment">/* The order by clause */</span>
<a name="l01261"></a>01261   <span class="keywordtype">int</span> orderByUsable,             <span class="comment">/* True if we can potential sort */</span>
<a name="l01262"></a>01262   <a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> **ppIdxInfo <span class="comment">/* Index information passed to xBestIndex */</span>
<a name="l01263"></a>01263 ){
<a name="l01264"></a>01264   <a class="code" href="structTable.html">Table</a> *pTab = pSrc-&gt;pTab;
<a name="l01265"></a>01265   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a>;
<a name="l01266"></a>01266   <a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> *pIdxInfo;
<a name="l01267"></a>01267   <span class="keyword">struct </span>sqlite3_index_constraint *pIdxCons;
<a name="l01268"></a>01268   <span class="keyword">struct </span>sqlite3_index_orderby *pIdxOrderBy;
<a name="l01269"></a>01269   <span class="keyword">struct </span>sqlite3_index_constraint_usage *pUsage;
<a name="l01270"></a>01270   <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm;
<a name="l01271"></a>01271   <span class="keywordtype">int</span> i, j;
<a name="l01272"></a>01272   <span class="keywordtype">int</span> nOrderBy;
<a name="l01273"></a>01273   <span class="keywordtype">int</span> rc;
<a name="l01274"></a>01274 
<a name="l01275"></a>01275   <span class="comment">/* If the sqlite3_index_info structure has not been previously</span>
<a name="l01276"></a>01276 <span class="comment">  ** allocated and initialized for this virtual table, then allocate</span>
<a name="l01277"></a>01277 <span class="comment">  ** and initialize it now</span>
<a name="l01278"></a>01278 <span class="comment">  */</span>
<a name="l01279"></a>01279   pIdxInfo = *ppIdxInfo;
<a name="l01280"></a>01280   <span class="keywordflow">if</span>( pIdxInfo==0 ){
<a name="l01281"></a>01281     <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm;
<a name="l01282"></a>01282     <span class="keywordtype">int</span> nTerm;
<a name="l01283"></a>01283     <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;Recomputing index info for %s...\n&quot;</span>, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>));
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     <span class="comment">/* Count the number of possible WHERE clause constraints referring</span>
<a name="l01286"></a>01286 <span class="comment">    ** to this virtual table */</span>
<a name="l01287"></a>01287     <span class="keywordflow">for</span>(i=nTerm=0, pTerm=pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>; i&lt;pWC-&gt;nTerm; i++, pTerm++){
<a name="l01288"></a>01288       <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a> != pSrc-&gt;iCursor ) <span class="keywordflow">continue</span>;
<a name="l01289"></a>01289       assert( (pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>&amp;(pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>-1))==0 );
<a name="l01290"></a>01290       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>==<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a> );
<a name="l01291"></a>01291       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>==<a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a> );
<a name="l01292"></a>01292       <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; (<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a>|<a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a>) ) <span class="keywordflow">continue</span>;
<a name="l01293"></a>01293       nTerm++;
<a name="l01294"></a>01294     }
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     <span class="comment">/* If the ORDER BY clause contains only columns in the current </span>
<a name="l01297"></a>01297 <span class="comment">    ** virtual table then allocate space for the aOrderBy part of</span>
<a name="l01298"></a>01298 <span class="comment">    ** the sqlite3_index_info structure.</span>
<a name="l01299"></a>01299 <span class="comment">    */</span>
<a name="l01300"></a>01300     nOrderBy = 0;
<a name="l01301"></a>01301     <span class="keywordflow">if</span>( pOrderBy ){
<a name="l01302"></a>01302       <span class="keywordflow">for</span>(i=0; i&lt;pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>; i++){
<a name="l01303"></a>01303         <a class="code" href="structExpr.html">Expr</a> *pExpr = pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l01304"></a>01304         <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> || pExpr-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a>!=pSrc-&gt;iCursor ) <span class="keywordflow">break</span>;
<a name="l01305"></a>01305       }
<a name="l01306"></a>01306       <span class="keywordflow">if</span>( i==pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a> ){
<a name="l01307"></a>01307         nOrderBy = pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>;
<a name="l01308"></a>01308       }
<a name="l01309"></a>01309     }
<a name="l01310"></a>01310 
<a name="l01311"></a>01311     <span class="comment">/* Allocate the sqlite3_index_info structure</span>
<a name="l01312"></a>01312 <span class="comment">    */</span>
<a name="l01313"></a>01313     pIdxInfo = <a class="code" href="malloc_8c.html#a9cdef45d3f06c28e71d728e8b15ebc0f">sqlite3DbMallocZero</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>, <span class="keyword">sizeof</span>(*pIdxInfo)
<a name="l01314"></a>01314                              + (<span class="keyword">sizeof</span>(*pIdxCons) + <span class="keyword">sizeof</span>(*pUsage))*nTerm
<a name="l01315"></a>01315                              + <span class="keyword">sizeof</span>(*pIdxOrderBy)*nOrderBy );
<a name="l01316"></a>01316     <span class="keywordflow">if</span>( pIdxInfo==0 ){
<a name="l01317"></a>01317       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;out of memory&quot;</span>);
<a name="l01318"></a>01318       <span class="keywordflow">return</span> 0.0;
<a name="l01319"></a>01319     }
<a name="l01320"></a>01320     *ppIdxInfo = pIdxInfo;
<a name="l01321"></a>01321 
<a name="l01322"></a>01322     <span class="comment">/* Initialize the structure.  The sqlite3_index_info structure contains</span>
<a name="l01323"></a>01323 <span class="comment">    ** many fields that are declared &quot;const&quot; to prevent xBestIndex from</span>
<a name="l01324"></a>01324 <span class="comment">    ** changing them.  We have to do some funky casting in order to</span>
<a name="l01325"></a>01325 <span class="comment">    ** initialize those fields.</span>
<a name="l01326"></a>01326 <span class="comment">    */</span>
<a name="l01327"></a>01327     pIdxCons = (<span class="keyword">struct </span>sqlite3_index_constraint*)&amp;pIdxInfo[1];
<a name="l01328"></a>01328     pIdxOrderBy = (<span class="keyword">struct </span>sqlite3_index_orderby*)&amp;pIdxCons[nTerm];
<a name="l01329"></a>01329     pUsage = (<span class="keyword">struct </span>sqlite3_index_constraint_usage*)&amp;pIdxOrderBy[nOrderBy];
<a name="l01330"></a>01330     *(<span class="keywordtype">int</span>*)&amp;pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#ae861993a30ce914a5214eab2579d935a">nConstraint</a> = nTerm;
<a name="l01331"></a>01331     *(<span class="keywordtype">int</span>*)&amp;pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a3ef850fdc57eddbc8189fe84d0a9044e">nOrderBy</a> = nOrderBy;
<a name="l01332"></a>01332     *(<span class="keyword">struct </span>sqlite3_index_constraint**)&amp;pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a> = pIdxCons;
<a name="l01333"></a>01333     *(<span class="keyword">struct</span> sqlite3_index_orderby**)&amp;pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a6823a68979e19d8e332389361e920ef9">aOrderBy</a> = pIdxOrderBy;
<a name="l01334"></a>01334     *(<span class="keyword">struct </span>sqlite3_index_constraint_usage**)&amp;pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a79b8a969dd7d582fc2ea3c0fbc5adb56">aConstraintUsage</a> =
<a name="l01335"></a>01335                                                                      pUsage;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     <span class="keywordflow">for</span>(i=j=0, pTerm=pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>; i&lt;pWC-&gt;nTerm; i++, pTerm++){
<a name="l01338"></a>01338       <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a> != pSrc-&gt;iCursor ) <span class="keywordflow">continue</span>;
<a name="l01339"></a>01339       assert( (pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>&amp;(pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>-1))==0 );
<a name="l01340"></a>01340       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>==<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a> );
<a name="l01341"></a>01341       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>==<a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a> );
<a name="l01342"></a>01342       <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; (<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a>|<a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a>) ) <span class="keywordflow">continue</span>;
<a name="l01343"></a>01343       pIdxCons[j].iColumn = pTerm-&gt;<a class="code" href="structWhereTerm.html#a48ece896af5482c14c5041fe51a193c2">leftColumn</a>;
<a name="l01344"></a>01344       pIdxCons[j].iTermOffset = i;
<a name="l01345"></a>01345       pIdxCons[j].op = pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a>;
<a name="l01346"></a>01346       <span class="comment">/* The direct assignment in the previous line is possible only because</span>
<a name="l01347"></a>01347 <span class="comment">      ** the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The</span>
<a name="l01348"></a>01348 <span class="comment">      ** following asserts verify this fact. */</span>
<a name="l01349"></a>01349       assert( <a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a>==<a class="code" href="sqlite3_8h.html#a82727c6d3191174cb4e900a70a3434a4">SQLITE_INDEX_CONSTRAINT_EQ</a> );
<a name="l01350"></a>01350       assert( <a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a>==<a class="code" href="sqlite3_8h.html#a11daaa39593ad95c32fb2dfe2440183f">SQLITE_INDEX_CONSTRAINT_LT</a> );
<a name="l01351"></a>01351       assert( <a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>==<a class="code" href="sqlite3_8h.html#a1ff0441c859beb664b043832e9c25bf1">SQLITE_INDEX_CONSTRAINT_LE</a> );
<a name="l01352"></a>01352       assert( <a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a>==<a class="code" href="sqlite3_8h.html#abe6a9340bbfd2e150846c48e6767b2ba">SQLITE_INDEX_CONSTRAINT_GT</a> );
<a name="l01353"></a>01353       assert( <a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>==<a class="code" href="sqlite3_8h.html#a317b481696946b8a3a7d76d32ceeb174">SQLITE_INDEX_CONSTRAINT_GE</a> );
<a name="l01354"></a>01354       assert( <a class="code" href="where_8c.html#a044f3cbfa74e455ad7fa96547d5ada56">WO_MATCH</a>==<a class="code" href="sqlite3_8h.html#a5f5c5144477960f96f6d49bce0598e9a">SQLITE_INDEX_CONSTRAINT_MATCH</a> );
<a name="l01355"></a>01355       assert( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; (<a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a>|<a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a>|<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>|<a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>|<a class="code" href="where_8c.html#a044f3cbfa74e455ad7fa96547d5ada56">WO_MATCH</a>) );
<a name="l01356"></a>01356       j++;
<a name="l01357"></a>01357     }
<a name="l01358"></a>01358     <span class="keywordflow">for</span>(i=0; i&lt;nOrderBy; i++){
<a name="l01359"></a>01359       <a class="code" href="structExpr.html">Expr</a> *pExpr = pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l01360"></a>01360       pIdxOrderBy[i].<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a> = pExpr-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>;
<a name="l01361"></a>01361       pIdxOrderBy[i].desc = pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#af9084dc073f96792c0c7a8a894778881">sortOrder</a>;
<a name="l01362"></a>01362     }
<a name="l01363"></a>01363   }
<a name="l01364"></a>01364 
<a name="l01365"></a>01365   <span class="comment">/* At this point, the sqlite3_index_info structure that pIdxInfo points</span>
<a name="l01366"></a>01366 <span class="comment">  ** to will have been initialized, either during the current invocation or</span>
<a name="l01367"></a>01367 <span class="comment">  ** during some prior invocation.  Now we just have to customize the</span>
<a name="l01368"></a>01368 <span class="comment">  ** details of pIdxInfo for the current invocation and pass it to</span>
<a name="l01369"></a>01369 <span class="comment">  ** xBestIndex.</span>
<a name="l01370"></a>01370 <span class="comment">  */</span>
<a name="l01371"></a>01371 
<a name="l01372"></a>01372   <span class="comment">/* The module name must be defined. Also, by this point there must</span>
<a name="l01373"></a>01373 <span class="comment">  ** be a pointer to an sqlite3_vtab structure. Otherwise</span>
<a name="l01374"></a>01374 <span class="comment">  ** sqlite3ViewGetColumnNames() would have picked up the error. </span>
<a name="l01375"></a>01375 <span class="comment">  */</span>
<a name="l01376"></a>01376   assert( pTab-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a> &amp;&amp; pTab-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>[0] );
<a name="l01377"></a>01377   assert( pVtab );
<a name="l01378"></a>01378 <span class="preprocessor">#if 0</span>
<a name="l01379"></a>01379 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a>==0 ){
<a name="l01380"></a>01380     <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;undefined module %s for table %s&quot;</span>,
<a name="l01381"></a>01381         pTab-&gt;<a class="code" href="structTable.html#af3af6596efa41894bcd3c3c9f9b6781f">azModuleArg</a>[0], pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>);
<a name="l01382"></a>01382     <span class="keywordflow">return</span> 0.0;
<a name="l01383"></a>01383   }
<a name="l01384"></a>01384 <span class="preprocessor">#endif</span>
<a name="l01385"></a>01385 <span class="preprocessor"></span>
<a name="l01386"></a>01386   <span class="comment">/* Set the aConstraint[].usable fields and initialize all </span>
<a name="l01387"></a>01387 <span class="comment">  ** output variables to zero.</span>
<a name="l01388"></a>01388 <span class="comment">  **</span>
<a name="l01389"></a>01389 <span class="comment">  ** aConstraint[].usable is true for constraints where the right-hand</span>
<a name="l01390"></a>01390 <span class="comment">  ** side contains only references to tables to the left of the current</span>
<a name="l01391"></a>01391 <span class="comment">  ** table.  In other words, if the constraint is of the form:</span>
<a name="l01392"></a>01392 <span class="comment">  **</span>
<a name="l01393"></a>01393 <span class="comment">  **           column = expr</span>
<a name="l01394"></a>01394 <span class="comment">  **</span>
<a name="l01395"></a>01395 <span class="comment">  ** and we are evaluating a join, then the constraint on column is </span>
<a name="l01396"></a>01396 <span class="comment">  ** only valid if all tables referenced in expr occur to the left</span>
<a name="l01397"></a>01397 <span class="comment">  ** of the table containing column.</span>
<a name="l01398"></a>01398 <span class="comment">  **</span>
<a name="l01399"></a>01399 <span class="comment">  ** The aConstraints[] array contains entries for all constraints</span>
<a name="l01400"></a>01400 <span class="comment">  ** on the current table.  That way we only have to compute it once</span>
<a name="l01401"></a>01401 <span class="comment">  ** even though we might try to pick the best index multiple times.</span>
<a name="l01402"></a>01402 <span class="comment">  ** For each attempt at picking an index, the order of tables in the</span>
<a name="l01403"></a>01403 <span class="comment">  ** join might be different so we have to recompute the usable flag</span>
<a name="l01404"></a>01404 <span class="comment">  ** each time.</span>
<a name="l01405"></a>01405 <span class="comment">  */</span>
<a name="l01406"></a>01406   pIdxCons = *(<span class="keyword">struct </span>sqlite3_index_constraint**)&amp;pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a>;
<a name="l01407"></a>01407   pUsage = pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a79b8a969dd7d582fc2ea3c0fbc5adb56">aConstraintUsage</a>;
<a name="l01408"></a>01408   <span class="keywordflow">for</span>(i=0; i&lt;pIdxInfo-&gt;nConstraint; i++, pIdxCons++){
<a name="l01409"></a>01409     j = pIdxCons-&gt;iTermOffset;
<a name="l01410"></a>01410     pTerm = &amp;pWC-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[j];
<a name="l01411"></a>01411     pIdxCons-&gt;usable =  (pTerm-&gt;<a class="code" href="structWhereTerm.html#a1274011fa1ef0639284b7944f4570e67">prereqRight</a> &amp; notReady)==0;
<a name="l01412"></a>01412   }
<a name="l01413"></a>01413   memset(pUsage, 0, <span class="keyword">sizeof</span>(pUsage[0])*pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#ae861993a30ce914a5214eab2579d935a">nConstraint</a>);
<a name="l01414"></a>01414   <span class="keywordflow">if</span>( pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a5410066c067c3891cdf165c70cc4d6b1">needToFreeIdxStr</a> ){
<a name="l01415"></a>01415     <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>(pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a1a9935e997bd6e3cce048534da7506a7">idxStr</a>);
<a name="l01416"></a>01416   }
<a name="l01417"></a>01417   pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a1a9935e997bd6e3cce048534da7506a7">idxStr</a> = 0;
<a name="l01418"></a>01418   pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a> = 0;
<a name="l01419"></a>01419   pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a5410066c067c3891cdf165c70cc4d6b1">needToFreeIdxStr</a> = 0;
<a name="l01420"></a>01420   pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a5515d9de0f37f68d7e0930c20a668b29">orderByConsumed</a> = 0;
<a name="l01421"></a>01421   pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#aa8b4fe1d2ee38aab57ba5e1da00d7830">estimatedCost</a> = <a class="code" href="sqliteInt_8h.html#a9e9d52dc56fdad6ba6984d6a6e11ac71">SQLITE_BIG_DBL</a> / 2.0;
<a name="l01422"></a>01422   nOrderBy = pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a3ef850fdc57eddbc8189fe84d0a9044e">nOrderBy</a>;
<a name="l01423"></a>01423   <span class="keywordflow">if</span>( pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a3ef850fdc57eddbc8189fe84d0a9044e">nOrderBy</a> &amp;&amp; !orderByUsable ){
<a name="l01424"></a>01424     *(<span class="keywordtype">int</span>*)&amp;pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a3ef850fdc57eddbc8189fe84d0a9044e">nOrderBy</a> = 0;
<a name="l01425"></a>01425   }
<a name="l01426"></a>01426 
<a name="l01427"></a>01427   (void)<a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>);
<a name="l01428"></a>01428   <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;xBestIndex for %s\n&quot;</span>, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>));
<a name="l01429"></a>01429   <a class="code" href="where_8c.html#aa5edc42c29d7010b1fb95f7904d1848d">TRACE_IDX_INPUTS</a>(pIdxInfo);
<a name="l01430"></a>01430   rc = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>-&gt;<a class="code" href="structsqlite3__module.html#a66577e230ca8de525b30ee6f287eafb1">xBestIndex</a>(pVtab, pIdxInfo);
<a name="l01431"></a>01431   <a class="code" href="where_8c.html#aa1f4c2954ede906003db7008bb295573">TRACE_IDX_OUTPUTS</a>(pIdxInfo);
<a name="l01432"></a>01432   (void)<a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>);
<a name="l01433"></a>01433 
<a name="l01434"></a>01434   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l01435"></a>01435     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a> ){
<a name="l01436"></a>01436       pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l01437"></a>01437     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( !pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> ){
<a name="l01438"></a>01438       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="main_8c.html#a02d1b390ceb669b8e689f27ea7134cad">sqlite3ErrStr</a>(rc));
<a name="l01439"></a>01439     }<span class="keywordflow">else</span>{
<a name="l01440"></a>01440       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;%s&quot;</span>, pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>);
<a name="l01441"></a>01441     }
<a name="l01442"></a>01442   }
<a name="l01443"></a>01443   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>, pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>);
<a name="l01444"></a>01444   pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l01445"></a>01445 
<a name="l01446"></a>01446   <span class="keywordflow">for</span>(i=0; i&lt;pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#ae861993a30ce914a5214eab2579d935a">nConstraint</a>; i++){
<a name="l01447"></a>01447     <span class="keywordflow">if</span>( !pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a>[i].<a class="code" href="structsqlite3__index__info_1_1sqlite3__index__constraint.html#ae16e62caeab743cc68bb22227dacb501">usable</a> &amp;&amp; pUsage[i].argvIndex&gt;0 ){
<a name="l01448"></a>01448       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, 
<a name="l01449"></a>01449           <span class="stringliteral">&quot;table %s: xBestIndex returned an invalid plan&quot;</span>, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>);
<a name="l01450"></a>01450       <span class="keywordflow">return</span> 0.0;
<a name="l01451"></a>01451     }
<a name="l01452"></a>01452   }
<a name="l01453"></a>01453 
<a name="l01454"></a>01454   *(<span class="keywordtype">int</span>*)&amp;pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a3ef850fdc57eddbc8189fe84d0a9044e">nOrderBy</a> = nOrderBy;
<a name="l01455"></a>01455   <span class="keywordflow">return</span> pIdxInfo-&gt;<a class="code" href="structsqlite3__index__info.html#aa8b4fe1d2ee38aab57ba5e1da00d7830">estimatedCost</a>;
<a name="l01456"></a>01456 }
<a name="l01457"></a>01457 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 <span class="comment">/*</span>
<a name="l01460"></a>01460 <span class="comment">** Find the best index for accessing a particular table.  Return a pointer</span>
<a name="l01461"></a>01461 <span class="comment">** to the index, flags that describe how the index should be used, the</span>
<a name="l01462"></a>01462 <span class="comment">** number of equality constraints, and the &quot;cost&quot; for this index.</span>
<a name="l01463"></a>01463 <span class="comment">**</span>
<a name="l01464"></a>01464 <span class="comment">** The lowest cost index wins.  The cost is an estimate of the amount of</span>
<a name="l01465"></a>01465 <span class="comment">** CPU and disk I/O need to process the request using the selected index.</span>
<a name="l01466"></a>01466 <span class="comment">** Factors that influence cost include:</span>
<a name="l01467"></a>01467 <span class="comment">**</span>
<a name="l01468"></a>01468 <span class="comment">**    *  The estimated number of rows that will be retrieved.  (The</span>
<a name="l01469"></a>01469 <span class="comment">**       fewer the better.)</span>
<a name="l01470"></a>01470 <span class="comment">**</span>
<a name="l01471"></a>01471 <span class="comment">**    *  Whether or not sorting must occur.</span>
<a name="l01472"></a>01472 <span class="comment">**</span>
<a name="l01473"></a>01473 <span class="comment">**    *  Whether or not there must be separate lookups in the</span>
<a name="l01474"></a>01474 <span class="comment">**       index and in the main table.</span>
<a name="l01475"></a>01475 <span class="comment">**</span>
<a name="l01476"></a>01476 <span class="comment">** If there was an INDEXED BY clause attached to the table in the SELECT</span>
<a name="l01477"></a>01477 <span class="comment">** statement, then this function only considers strategies using the </span>
<a name="l01478"></a>01478 <span class="comment">** named index. If one cannot be found, then the returned cost is</span>
<a name="l01479"></a>01479 <span class="comment">** SQLITE_BIG_DBL. If a strategy can be found that uses the named index, </span>
<a name="l01480"></a>01480 <span class="comment">** then the cost is calculated in the usual way.</span>
<a name="l01481"></a>01481 <span class="comment">**</span>
<a name="l01482"></a>01482 <span class="comment">** If a NOT INDEXED clause was attached to the table in the SELECT </span>
<a name="l01483"></a>01483 <span class="comment">** statement, then no indexes are considered. However, the selected </span>
<a name="l01484"></a>01484 <span class="comment">** stategy may still take advantage of the tables built-in rowid</span>
<a name="l01485"></a>01485 <span class="comment">** index.</span>
<a name="l01486"></a>01486 <span class="comment">*/</span>
<a name="l01487"></a><a class="code" href="where_8c.html#ac677094c8515920917d4b66722dcbab0">01487</a> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="where_8c.html#ac677094c8515920917d4b66722dcbab0">bestIndex</a>(
<a name="l01488"></a>01488   <a class="code" href="structParse.html">Parse</a> *pParse,              <span class="comment">/* The parsing context */</span>
<a name="l01489"></a>01489   <a class="code" href="structWhereClause.html">WhereClause</a> *pWC,           <span class="comment">/* The WHERE clause */</span>
<a name="l01490"></a>01490   <span class="keyword">struct</span> SrcList_item *pSrc,  <span class="comment">/* The FROM clause term to search */</span>
<a name="l01491"></a>01491   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> notReady,           <span class="comment">/* Mask of cursors that are not available */</span>
<a name="l01492"></a>01492   <a class="code" href="structExprList.html">ExprList</a> *pOrderBy,         <span class="comment">/* The order by clause */</span>
<a name="l01493"></a>01493   <a class="code" href="structIndex.html">Index</a> **ppIndex,            <span class="comment">/* Make *ppIndex point to the best index */</span>
<a name="l01494"></a>01494   <span class="keywordtype">int</span> *pFlags,                <span class="comment">/* Put flags describing this choice in *pFlags */</span>
<a name="l01495"></a>01495   <span class="keywordtype">int</span> *pnEq                   <span class="comment">/* Put the number of == or IN constraints here */</span>
<a name="l01496"></a>01496 ){
<a name="l01497"></a>01497   <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm;
<a name="l01498"></a>01498   <a class="code" href="structIndex.html">Index</a> *bestIdx = 0;         <span class="comment">/* Index that gives the lowest cost */</span>
<a name="l01499"></a>01499   <span class="keywordtype">double</span> lowestCost;          <span class="comment">/* The cost of using bestIdx */</span>
<a name="l01500"></a>01500   <span class="keywordtype">int</span> bestFlags = 0;          <span class="comment">/* Flags associated with bestIdx */</span>
<a name="l01501"></a>01501   <span class="keywordtype">int</span> bestNEq = 0;            <span class="comment">/* Best value for nEq */</span>
<a name="l01502"></a>01502   <span class="keywordtype">int</span> iCur = pSrc-&gt;iCursor;   <span class="comment">/* The cursor of the table to be accessed */</span>
<a name="l01503"></a>01503   <a class="code" href="structIndex.html">Index</a> *pProbe;              <span class="comment">/* An index we are evaluating */</span>
<a name="l01504"></a>01504   <span class="keywordtype">int</span> rev;                    <span class="comment">/* True to scan in reverse order */</span>
<a name="l01505"></a>01505   <span class="keywordtype">int</span> flags;                  <span class="comment">/* Flags associated with pProbe */</span>
<a name="l01506"></a>01506   <span class="keywordtype">int</span> nEq;                    <span class="comment">/* Number of == or IN constraints */</span>
<a name="l01507"></a>01507   <span class="keywordtype">int</span> eqTermMask;             <span class="comment">/* Mask of valid equality operators */</span>
<a name="l01508"></a>01508   <span class="keywordtype">double</span> cost;                <span class="comment">/* Cost of using pProbe */</span>
<a name="l01509"></a>01509 
<a name="l01510"></a>01510   <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;bestIndex: tbl=%s notReady=%llx\n&quot;</span>, pSrc-&gt;pTab-&gt;zName, notReady));
<a name="l01511"></a>01511   lowestCost = <a class="code" href="sqliteInt_8h.html#a9e9d52dc56fdad6ba6984d6a6e11ac71">SQLITE_BIG_DBL</a>;
<a name="l01512"></a>01512   pProbe = pSrc-&gt;pTab-&gt;pIndex;
<a name="l01513"></a>01513   <span class="keywordflow">if</span>( pSrc-&gt;notIndexed ){
<a name="l01514"></a>01514     pProbe = 0;
<a name="l01515"></a>01515   }
<a name="l01516"></a>01516 
<a name="l01517"></a>01517   <span class="comment">/* If the table has no indices and there are no terms in the where</span>
<a name="l01518"></a>01518 <span class="comment">  ** clause that refer to the ROWID, then we will never be able to do</span>
<a name="l01519"></a>01519 <span class="comment">  ** anything other than a full table scan on this table.  We might as</span>
<a name="l01520"></a>01520 <span class="comment">  ** well put it first in the join order.  That way, perhaps it can be</span>
<a name="l01521"></a>01521 <span class="comment">  ** referenced by other tables in the join.</span>
<a name="l01522"></a>01522 <span class="comment">  */</span>
<a name="l01523"></a>01523   <span class="keywordflow">if</span>( pProbe==0 &amp;&amp;
<a name="l01524"></a>01524      <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, -1, 0, <a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a>|<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a>|<a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a>|<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>|<a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>,0)==0 &amp;&amp;
<a name="l01525"></a>01525      (pOrderBy==0 || !<a class="code" href="where_8c.html#a496e0c1849e568f228384d42f2144714">sortableByRowid</a>(iCur, pOrderBy, pWC-&gt;<a class="code" href="structWhereClause.html#a9d38e1e4952bf032ccb08f81af126919">pMaskSet</a>, &amp;rev)) ){
<a name="l01526"></a>01526     *pFlags = 0;
<a name="l01527"></a>01527     *ppIndex = 0;
<a name="l01528"></a>01528     *pnEq = 0;
<a name="l01529"></a>01529     <span class="keywordflow">return</span> 0.0;
<a name="l01530"></a>01530   }
<a name="l01531"></a>01531 
<a name="l01532"></a>01532   <span class="comment">/* Check for a rowid=EXPR or rowid IN (...) constraints. If there was</span>
<a name="l01533"></a>01533 <span class="comment">  ** an INDEXED BY clause attached to this table, skip this step.</span>
<a name="l01534"></a>01534 <span class="comment">  */</span>
<a name="l01535"></a>01535   <span class="keywordflow">if</span>( !pSrc-&gt;pIndex ){
<a name="l01536"></a>01536     pTerm = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, -1, notReady, <a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a>|<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a>, 0);
<a name="l01537"></a>01537     <span class="keywordflow">if</span>( pTerm ){
<a name="l01538"></a>01538       <a class="code" href="structExpr.html">Expr</a> *pExpr;
<a name="l01539"></a>01539       *ppIndex = 0;
<a name="l01540"></a>01540       bestFlags = <a class="code" href="where_8c.html#aa8869a9d16dddbebfe2dc07ff275063e">WHERE_ROWID_EQ</a>;
<a name="l01541"></a>01541       <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; <a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a> ){
<a name="l01542"></a>01542         <span class="comment">/* Rowid== is always the best pick.  Look no further.  Because only</span>
<a name="l01543"></a>01543 <span class="comment">        ** a single row is generated, output is always in sorted order */</span>
<a name="l01544"></a>01544         *pFlags = <a class="code" href="where_8c.html#aa8869a9d16dddbebfe2dc07ff275063e">WHERE_ROWID_EQ</a> | <a class="code" href="where_8c.html#a0e422237e7eec9ee479fc178a89a7c83">WHERE_UNIQUE</a>;
<a name="l01545"></a>01545         *pnEq = 1;
<a name="l01546"></a>01546         <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;... best is rowid\n&quot;</span>));
<a name="l01547"></a>01547         <span class="keywordflow">return</span> 0.0;
<a name="l01548"></a>01548       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( (pExpr = pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>)-&gt;pList!=0 ){
<a name="l01549"></a>01549         <span class="comment">/* Rowid IN (LIST): cost is NlogN where N is the number of list</span>
<a name="l01550"></a>01550 <span class="comment">        ** elements.  */</span>
<a name="l01551"></a>01551         lowestCost = pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>;
<a name="l01552"></a>01552         lowestCost *= <a class="code" href="where_8c.html#aa4287e4538a263b5de0ea252afee1609">estLog</a>(lowestCost);
<a name="l01553"></a>01553       }<span class="keywordflow">else</span>{
<a name="l01554"></a>01554         <span class="comment">/* Rowid IN (SELECT): cost is NlogN where N is the number of rows</span>
<a name="l01555"></a>01555 <span class="comment">        ** in the result of the inner select.  We have no way to estimate</span>
<a name="l01556"></a>01556 <span class="comment">        ** that value so make a wild guess. */</span>
<a name="l01557"></a>01557         lowestCost = 200;
<a name="l01558"></a>01558       }
<a name="l01559"></a>01559       <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;... rowid IN cost: %.9g\n&quot;</span>, lowestCost));
<a name="l01560"></a>01560     }
<a name="l01561"></a>01561   
<a name="l01562"></a>01562     <span class="comment">/* Estimate the cost of a table scan.  If we do not know how many</span>
<a name="l01563"></a>01563 <span class="comment">    ** entries are in the table, use 1 million as a guess.</span>
<a name="l01564"></a>01564 <span class="comment">    */</span>
<a name="l01565"></a>01565     cost = pProbe ? pProbe-&gt;<a class="code" href="structIndex.html#a1c504b4a957f456c088c5114e311dc63">aiRowEst</a>[0] : 1000000;
<a name="l01566"></a>01566     <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;... table scan base cost: %.9g\n&quot;</span>, cost));
<a name="l01567"></a>01567     flags = <a class="code" href="where_8c.html#a44adb93652f7601ac8e7b47d1e6b31d4">WHERE_ROWID_RANGE</a>;
<a name="l01568"></a>01568   
<a name="l01569"></a>01569     <span class="comment">/* Check for constraints on a range of rowids in a table scan.</span>
<a name="l01570"></a>01570 <span class="comment">    */</span>
<a name="l01571"></a>01571     pTerm = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, -1, notReady, <a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a>|<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>|<a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>, 0);
<a name="l01572"></a>01572     <span class="keywordflow">if</span>( pTerm ){
<a name="l01573"></a>01573       <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, -1, notReady, <a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a>|<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>, 0) ){
<a name="l01574"></a>01574         flags |= <a class="code" href="where_8c.html#a235d99551db0e21a521bef747223a2cd">WHERE_TOP_LIMIT</a>;
<a name="l01575"></a>01575         cost /= 3;  <span class="comment">/* Guess that rowid&lt;EXPR eliminates two-thirds or rows */</span>
<a name="l01576"></a>01576       }
<a name="l01577"></a>01577       <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, -1, notReady, <a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>, 0) ){
<a name="l01578"></a>01578         flags |= <a class="code" href="where_8c.html#af6653107415b1dec957976e08d65e528">WHERE_BTM_LIMIT</a>;
<a name="l01579"></a>01579         cost /= 3;  <span class="comment">/* Guess that rowid&gt;EXPR eliminates two-thirds of rows */</span>
<a name="l01580"></a>01580       }
<a name="l01581"></a>01581       <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;... rowid range reduces cost to %.9g\n&quot;</span>, cost));
<a name="l01582"></a>01582     }<span class="keywordflow">else</span>{
<a name="l01583"></a>01583       flags = 0;
<a name="l01584"></a>01584     }
<a name="l01585"></a>01585   
<a name="l01586"></a>01586     <span class="comment">/* If the table scan does not satisfy the ORDER BY clause, increase</span>
<a name="l01587"></a>01587 <span class="comment">    ** the cost by NlogN to cover the expense of sorting. */</span>
<a name="l01588"></a>01588     <span class="keywordflow">if</span>( pOrderBy ){
<a name="l01589"></a>01589       <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#a496e0c1849e568f228384d42f2144714">sortableByRowid</a>(iCur, pOrderBy, pWC-&gt;<a class="code" href="structWhereClause.html#a9d38e1e4952bf032ccb08f81af126919">pMaskSet</a>, &amp;rev) ){
<a name="l01590"></a>01590         flags |= <a class="code" href="where_8c.html#a4caa356cdd5bf6be70e0a2426bfbda2e">WHERE_ORDERBY</a>|<a class="code" href="where_8c.html#a44adb93652f7601ac8e7b47d1e6b31d4">WHERE_ROWID_RANGE</a>;
<a name="l01591"></a>01591         <span class="keywordflow">if</span>( rev ){
<a name="l01592"></a>01592           flags |= <a class="code" href="where_8c.html#a63bbf40b47f87166909e9353514c796e">WHERE_REVERSE</a>;
<a name="l01593"></a>01593         }
<a name="l01594"></a>01594       }<span class="keywordflow">else</span>{
<a name="l01595"></a>01595         cost += cost*<a class="code" href="where_8c.html#aa4287e4538a263b5de0ea252afee1609">estLog</a>(cost);
<a name="l01596"></a>01596         <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;... sorting increases cost to %.9g\n&quot;</span>, cost));
<a name="l01597"></a>01597       }
<a name="l01598"></a>01598     }
<a name="l01599"></a>01599     <span class="keywordflow">if</span>( cost&lt;lowestCost ){
<a name="l01600"></a>01600       lowestCost = cost;
<a name="l01601"></a>01601       bestFlags = flags;
<a name="l01602"></a>01602     }
<a name="l01603"></a>01603   }
<a name="l01604"></a>01604 
<a name="l01605"></a>01605   <span class="comment">/* If the pSrc table is the right table of a LEFT JOIN then we may not</span>
<a name="l01606"></a>01606 <span class="comment">  ** use an index to satisfy IS NULL constraints on that table.  This is</span>
<a name="l01607"></a>01607 <span class="comment">  ** because columns might end up being NULL if the table does not match -</span>
<a name="l01608"></a>01608 <span class="comment">  ** a circumstance which the index cannot help us discover.  Ticket #2177.</span>
<a name="l01609"></a>01609 <span class="comment">  */</span>
<a name="l01610"></a>01610   <span class="keywordflow">if</span>( (pSrc-&gt;jointype &amp; <a class="code" href="sqliteInt_8h.html#ac4edc24e10d5c297818aeb579cb507df">JT_LEFT</a>)!=0 ){
<a name="l01611"></a>01611     eqTermMask = <a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a>|<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a>;
<a name="l01612"></a>01612   }<span class="keywordflow">else</span>{
<a name="l01613"></a>01613     eqTermMask = <a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a>|<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a>|<a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a>;
<a name="l01614"></a>01614   }
<a name="l01615"></a>01615 
<a name="l01616"></a>01616   <span class="comment">/* Look at each index.</span>
<a name="l01617"></a>01617 <span class="comment">  */</span>
<a name="l01618"></a>01618   <span class="keywordflow">if</span>( pSrc-&gt;pIndex ){
<a name="l01619"></a>01619     pProbe = pSrc-&gt;pIndex;
<a name="l01620"></a>01620   }
<a name="l01621"></a>01621   <span class="keywordflow">for</span>(; pProbe; pProbe=(pSrc-&gt;pIndex ? 0 : pProbe-&gt;<a class="code" href="structIndex.html#a115a17d236bd277d59dd5ea030954c3e">pNext</a>)){
<a name="l01622"></a>01622     <span class="keywordtype">int</span> i;                       <span class="comment">/* Loop counter */</span>
<a name="l01623"></a>01623     <span class="keywordtype">double</span> inMultiplier = 1;
<a name="l01624"></a>01624 
<a name="l01625"></a>01625     <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;... index %s:\n&quot;</span>, pProbe-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a>));
<a name="l01626"></a>01626 
<a name="l01627"></a>01627     <span class="comment">/* Count the number of columns in the index that are satisfied</span>
<a name="l01628"></a>01628 <span class="comment">    ** by x=EXPR constraints or x IN (...) constraints.</span>
<a name="l01629"></a>01629 <span class="comment">    */</span>
<a name="l01630"></a>01630     flags = 0;
<a name="l01631"></a>01631     <span class="keywordflow">for</span>(i=0; i&lt;pProbe-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>; i++){
<a name="l01632"></a>01632       <span class="keywordtype">int</span> j = pProbe-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[i];
<a name="l01633"></a>01633       pTerm = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, j, notReady, eqTermMask, pProbe);
<a name="l01634"></a>01634       <span class="keywordflow">if</span>( pTerm==0 ) <span class="keywordflow">break</span>;
<a name="l01635"></a>01635       flags |= <a class="code" href="where_8c.html#ae64de71ae51ba0f8f4e5fd4d54b9b3f8">WHERE_COLUMN_EQ</a>;
<a name="l01636"></a>01636       <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; <a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a> ){
<a name="l01637"></a>01637         <a class="code" href="structExpr.html">Expr</a> *pExpr = pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>;
<a name="l01638"></a>01638         flags |= <a class="code" href="where_8c.html#aa47b246748768d7d65cd3a0d0daede7e">WHERE_COLUMN_IN</a>;
<a name="l01639"></a>01639         <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a54e5186fdf157f8b4ae178919d8ff6b3">pSelect</a>!=0 ){
<a name="l01640"></a>01640           inMultiplier *= 25;
<a name="l01641"></a>01641         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a68d1f09d0baf7bc12a51d34a5c18fcfb">ALWAYS</a>(pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>) ){
<a name="l01642"></a>01642           inMultiplier *= pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a> + 1;
<a name="l01643"></a>01643         }
<a name="l01644"></a>01644       }
<a name="l01645"></a>01645     }
<a name="l01646"></a>01646     cost = pProbe-&gt;<a class="code" href="structIndex.html#a1c504b4a957f456c088c5114e311dc63">aiRowEst</a>[i] * inMultiplier * <a class="code" href="where_8c.html#aa4287e4538a263b5de0ea252afee1609">estLog</a>(inMultiplier);
<a name="l01647"></a>01647     nEq = i;
<a name="l01648"></a>01648     <span class="keywordflow">if</span>( pProbe-&gt;<a class="code" href="structIndex.html#ae8bf87d0414e5c46b86192cfbdd271a7">onError</a>!=<a class="code" href="sqliteInt_8h.html#a203b18293bcbd8c1809ef96bd0663064">OE_None</a> &amp;&amp; (flags &amp; <a class="code" href="where_8c.html#aa47b246748768d7d65cd3a0d0daede7e">WHERE_COLUMN_IN</a>)==0
<a name="l01649"></a>01649          &amp;&amp; nEq==pProbe-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a> ){
<a name="l01650"></a>01650       flags |= <a class="code" href="where_8c.html#a0e422237e7eec9ee479fc178a89a7c83">WHERE_UNIQUE</a>;
<a name="l01651"></a>01651     }
<a name="l01652"></a>01652     <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;...... nEq=%d inMult=%.9g cost=%.9g\n&quot;</span>,nEq,inMultiplier,cost));
<a name="l01653"></a>01653 
<a name="l01654"></a>01654     <span class="comment">/* Look for range constraints</span>
<a name="l01655"></a>01655 <span class="comment">    */</span>
<a name="l01656"></a>01656     <span class="keywordflow">if</span>( nEq&lt;pProbe-&gt;nColumn ){
<a name="l01657"></a>01657       <span class="keywordtype">int</span> j = pProbe-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[nEq];
<a name="l01658"></a>01658       pTerm = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, j, notReady, <a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a>|<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>|<a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>, pProbe);
<a name="l01659"></a>01659       <span class="keywordflow">if</span>( pTerm ){
<a name="l01660"></a>01660         flags |= <a class="code" href="where_8c.html#a474e72ece833680b7b68a9b2ce914126">WHERE_COLUMN_RANGE</a>;
<a name="l01661"></a>01661         <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, j, notReady, <a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a>|<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>, pProbe) ){
<a name="l01662"></a>01662           flags |= <a class="code" href="where_8c.html#a235d99551db0e21a521bef747223a2cd">WHERE_TOP_LIMIT</a>;
<a name="l01663"></a>01663           cost /= 3;
<a name="l01664"></a>01664         }
<a name="l01665"></a>01665         <span class="keywordflow">if</span>( <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, j, notReady, <a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>, pProbe) ){
<a name="l01666"></a>01666           flags |= <a class="code" href="where_8c.html#af6653107415b1dec957976e08d65e528">WHERE_BTM_LIMIT</a>;
<a name="l01667"></a>01667           cost /= 3;
<a name="l01668"></a>01668         }
<a name="l01669"></a>01669         <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;...... range reduces cost to %.9g\n&quot;</span>, cost));
<a name="l01670"></a>01670       }
<a name="l01671"></a>01671     }
<a name="l01672"></a>01672 
<a name="l01673"></a>01673     <span class="comment">/* Add the additional cost of sorting if that is a factor.</span>
<a name="l01674"></a>01674 <span class="comment">    */</span>
<a name="l01675"></a>01675     <span class="keywordflow">if</span>( pOrderBy ){
<a name="l01676"></a>01676       <span class="keywordflow">if</span>( (flags &amp; WHERE_COLUMN_IN)==0 &amp;&amp;
<a name="l01677"></a>01677            <a class="code" href="where_8c.html#a59a1e49f6eb3af7de8aecd971451f98d">isSortingIndex</a>(pParse,pWC-&gt;<a class="code" href="structWhereClause.html#a9d38e1e4952bf032ccb08f81af126919">pMaskSet</a>,pProbe,iCur,pOrderBy,nEq,&amp;rev) ){
<a name="l01678"></a>01678         <span class="keywordflow">if</span>( flags==0 ){
<a name="l01679"></a>01679           flags = <a class="code" href="where_8c.html#a474e72ece833680b7b68a9b2ce914126">WHERE_COLUMN_RANGE</a>;
<a name="l01680"></a>01680         }
<a name="l01681"></a>01681         flags |= <a class="code" href="where_8c.html#a4caa356cdd5bf6be70e0a2426bfbda2e">WHERE_ORDERBY</a>;
<a name="l01682"></a>01682         <span class="keywordflow">if</span>( rev ){
<a name="l01683"></a>01683           flags |= <a class="code" href="where_8c.html#a63bbf40b47f87166909e9353514c796e">WHERE_REVERSE</a>;
<a name="l01684"></a>01684         }
<a name="l01685"></a>01685       }<span class="keywordflow">else</span>{
<a name="l01686"></a>01686         cost += cost*<a class="code" href="where_8c.html#aa4287e4538a263b5de0ea252afee1609">estLog</a>(cost);
<a name="l01687"></a>01687         <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;...... orderby increases cost to %.9g\n&quot;</span>, cost));
<a name="l01688"></a>01688       }
<a name="l01689"></a>01689     }
<a name="l01690"></a>01690 
<a name="l01691"></a>01691     <span class="comment">/* Check to see if we can get away with using just the index without</span>
<a name="l01692"></a>01692 <span class="comment">    ** ever reading the table.  If that is the case, then halve the</span>
<a name="l01693"></a>01693 <span class="comment">    ** cost of this index.</span>
<a name="l01694"></a>01694 <span class="comment">    */</span>
<a name="l01695"></a>01695     <span class="keywordflow">if</span>( flags &amp;&amp; pSrc-&gt;colUsed &lt; (((<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)1)&lt;&lt;(<a class="code" href="where_8c.html#a61ebf73c36e0aa88593c8fdb76891407">BMS</a>-1)) ){
<a name="l01696"></a>01696       <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> m = pSrc-&gt;colUsed;
<a name="l01697"></a>01697       <span class="keywordtype">int</span> j;
<a name="l01698"></a>01698       <span class="keywordflow">for</span>(j=0; j&lt;pProbe-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>; j++){
<a name="l01699"></a>01699         <span class="keywordtype">int</span> x = pProbe-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[j];
<a name="l01700"></a>01700         <span class="keywordflow">if</span>( x&lt;<a class="code" href="where_8c.html#a61ebf73c36e0aa88593c8fdb76891407">BMS</a>-1 ){
<a name="l01701"></a>01701           m &amp;= ~(((<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)1)&lt;&lt;x);
<a name="l01702"></a>01702         }
<a name="l01703"></a>01703       }
<a name="l01704"></a>01704       <span class="keywordflow">if</span>( m==0 ){
<a name="l01705"></a>01705         flags |= <a class="code" href="where_8c.html#a5c7e944406bbba33acde54aa3fcee124">WHERE_IDX_ONLY</a>;
<a name="l01706"></a>01706         cost /= 2;
<a name="l01707"></a>01707         <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;...... idx-only reduces cost to %.9g\n&quot;</span>, cost));
<a name="l01708"></a>01708       }
<a name="l01709"></a>01709     }
<a name="l01710"></a>01710 
<a name="l01711"></a>01711     <span class="comment">/* If this index has achieved the lowest cost so far, then use it.</span>
<a name="l01712"></a>01712 <span class="comment">    */</span>
<a name="l01713"></a>01713     <span class="keywordflow">if</span>( flags &amp;&amp; cost &lt; lowestCost ){
<a name="l01714"></a>01714       bestIdx = pProbe;
<a name="l01715"></a>01715       lowestCost = cost;
<a name="l01716"></a>01716       bestFlags = flags;
<a name="l01717"></a>01717       bestNEq = nEq;
<a name="l01718"></a>01718     }
<a name="l01719"></a>01719   }
<a name="l01720"></a>01720 
<a name="l01721"></a>01721   <span class="comment">/* Report the best result</span>
<a name="l01722"></a>01722 <span class="comment">  */</span>
<a name="l01723"></a>01723   *ppIndex = bestIdx;
<a name="l01724"></a>01724   <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;best index is %s, cost=%.9g, flags=%x, nEq=%d\n&quot;</span>,
<a name="l01725"></a>01725         bestIdx ? bestIdx-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a> : <span class="stringliteral">&quot;(none)&quot;</span>, lowestCost, bestFlags, bestNEq));
<a name="l01726"></a>01726   *pFlags = bestFlags | eqTermMask;
<a name="l01727"></a>01727   *pnEq = bestNEq;
<a name="l01728"></a>01728   <span class="keywordflow">return</span> lowestCost;
<a name="l01729"></a>01729 }
<a name="l01730"></a>01730 
<a name="l01731"></a>01731 
<a name="l01732"></a>01732 <span class="comment">/*</span>
<a name="l01733"></a>01733 <span class="comment">** Disable a term in the WHERE clause.  Except, do not disable the term</span>
<a name="l01734"></a>01734 <span class="comment">** if it controls a LEFT OUTER JOIN and it did not originate in the ON</span>
<a name="l01735"></a>01735 <span class="comment">** or USING clause of that join.</span>
<a name="l01736"></a>01736 <span class="comment">**</span>
<a name="l01737"></a>01737 <span class="comment">** Consider the term t2.z=&apos;ok&apos; in the following queries:</span>
<a name="l01738"></a>01738 <span class="comment">**</span>
<a name="l01739"></a>01739 <span class="comment">**   (1)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z=&apos;ok&apos;</span>
<a name="l01740"></a>01740 <span class="comment">**   (2)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z=&apos;ok&apos;</span>
<a name="l01741"></a>01741 <span class="comment">**   (3)  SELECT * FROM t1, t2 WHERE t1.a=t2.x AND t2.z=&apos;ok&apos;</span>
<a name="l01742"></a>01742 <span class="comment">**</span>
<a name="l01743"></a>01743 <span class="comment">** The t2.z=&apos;ok&apos; is disabled in the in (2) because it originates</span>
<a name="l01744"></a>01744 <span class="comment">** in the ON clause.  The term is disabled in (3) because it is not part</span>
<a name="l01745"></a>01745 <span class="comment">** of a LEFT OUTER JOIN.  In (1), the term is not disabled.</span>
<a name="l01746"></a>01746 <span class="comment">**</span>
<a name="l01747"></a>01747 <span class="comment">** Disabling a term causes that term to not be tested in the inner loop</span>
<a name="l01748"></a>01748 <span class="comment">** of the join.  Disabling is an optimization.  When terms are satisfied</span>
<a name="l01749"></a>01749 <span class="comment">** by indices, we disable them to prevent redundant tests in the inner</span>
<a name="l01750"></a>01750 <span class="comment">** loop.  We would get the correct results if nothing were ever disabled,</span>
<a name="l01751"></a>01751 <span class="comment">** but joins might run a little slower.  The trick is to disable as much</span>
<a name="l01752"></a>01752 <span class="comment">** as we can without disabling too much.  If we disabled in (1), we&apos;d get</span>
<a name="l01753"></a>01753 <span class="comment">** the wrong answer.  See ticket #813.</span>
<a name="l01754"></a>01754 <span class="comment">*/</span>
<a name="l01755"></a><a class="code" href="where_8c.html#a50a51e3dca3d19babeb17d2577889492">01755</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#a50a51e3dca3d19babeb17d2577889492">disableTerm</a>(<a class="code" href="structWhereLevel.html">WhereLevel</a> *pLevel, <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm){
<a name="l01756"></a>01756   <span class="keywordflow">if</span>( pTerm
<a name="l01757"></a>01757       &amp;&amp; <a class="code" href="sqliteInt_8h.html#a68d1f09d0baf7bc12a51d34a5c18fcfb">ALWAYS</a>((pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">TERM_CODED</a>)==0)
<a name="l01758"></a>01758       &amp;&amp; (pLevel-&gt;<a class="code" href="structWhereLevel.html#a600072864f71c568cabcbb6140f6955a">iLeftJoin</a>==0 || <a class="code" href="sqliteInt_8h.html#a70ceb3fd7e20d6b0565b359158c7f1d7">ExprHasProperty</a>(pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>, <a class="code" href="sqliteInt_8h.html#a6bd31d1397219a9745a840e48dd49a53">EP_FromJoin</a>))
<a name="l01759"></a>01759   ){
<a name="l01760"></a>01760     pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> |= <a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">TERM_CODED</a>;
<a name="l01761"></a>01761     <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a>&gt;=0 ){
<a name="l01762"></a>01762       <a class="code" href="structWhereTerm.html">WhereTerm</a> *pOther = &amp;pTerm-&gt;<a class="code" href="structWhereTerm.html#a1fb0a9ede5a12d6d2f7886431b348fb3">pWC</a>-&gt;<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[pTerm-&gt;<a class="code" href="structWhereTerm.html#a4302391abb7fe0a2ff7efb406eb06e75">iParent</a>];
<a name="l01763"></a>01763       <span class="keywordflow">if</span>( (--pOther-&gt;<a class="code" href="structWhereTerm.html#af83cf7bae7760b9b1ca398338a35c32a">nChild</a>)==0 ){
<a name="l01764"></a>01764         <a class="code" href="where_8c.html#a50a51e3dca3d19babeb17d2577889492">disableTerm</a>(pLevel, pOther);
<a name="l01765"></a>01765       }
<a name="l01766"></a>01766     }
<a name="l01767"></a>01767   }
<a name="l01768"></a>01768 }
<a name="l01769"></a>01769 
<a name="l01770"></a>01770 <span class="comment">/*</span>
<a name="l01771"></a>01771 <span class="comment">** Apply the affinities associated with the first n columns of index</span>
<a name="l01772"></a>01772 <span class="comment">** pIdx to the values in the n registers starting at base.</span>
<a name="l01773"></a>01773 <span class="comment">*/</span>
<a name="l01774"></a><a class="code" href="where_8c.html#a035f6bb84d628be6f249071db83b6430">01774</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#a035f6bb84d628be6f249071db83b6430">codeApplyAffinity</a>(<a class="code" href="structParse.html">Parse</a> *pParse, <span class="keywordtype">int</span> base, <span class="keywordtype">int</span> n, <a class="code" href="structIndex.html">Index</a> *pIdx){
<a name="l01775"></a>01775   <span class="keywordflow">if</span>( n&gt;0 ){
<a name="l01776"></a>01776     <a class="code" href="structVdbe.html">Vdbe</a> *v = pParse-&gt;<a class="code" href="structParse.html#a81774053fd5063046f532c07e3daa98b">pVdbe</a>;
<a name="l01777"></a>01777     assert( v!=0 );
<a name="l01778"></a>01778     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a27f4031ee034f306c486c8a02b00ca77">OP_Affinity</a>, base, n);
<a name="l01779"></a>01779     <a class="code" href="insert_8c.html#ad02fc8bcec6054484efe92ff3cd6ab34">sqlite3IndexAffinityStr</a>(v, pIdx);
<a name="l01780"></a>01780     <a class="code" href="expr_8c.html#a34ec8a969b416e209e9dd2d77c674ddf">sqlite3ExprCacheAffinityChange</a>(pParse, base, n);
<a name="l01781"></a>01781   }
<a name="l01782"></a>01782 }
<a name="l01783"></a>01783 
<a name="l01784"></a>01784 
<a name="l01785"></a>01785 <span class="comment">/*</span>
<a name="l01786"></a>01786 <span class="comment">** Generate code for a single equality term of the WHERE clause.  An equality</span>
<a name="l01787"></a>01787 <span class="comment">** term can be either X=expr or X IN (...).   pTerm is the term to be </span>
<a name="l01788"></a>01788 <span class="comment">** coded.</span>
<a name="l01789"></a>01789 <span class="comment">**</span>
<a name="l01790"></a>01790 <span class="comment">** The current value for the constraint is left in register iReg.</span>
<a name="l01791"></a>01791 <span class="comment">**</span>
<a name="l01792"></a>01792 <span class="comment">** For a constraint of the form X=expr, the expression is evaluated and its</span>
<a name="l01793"></a>01793 <span class="comment">** result is left on the stack.  For constraints of the form X IN (...)</span>
<a name="l01794"></a>01794 <span class="comment">** this routine sets up a loop that will iterate over all values of X.</span>
<a name="l01795"></a>01795 <span class="comment">*/</span>
<a name="l01796"></a><a class="code" href="where_8c.html#a7a4ca4f697a0f1accd8dba96ddcba286">01796</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#a7a4ca4f697a0f1accd8dba96ddcba286">codeEqualityTerm</a>(
<a name="l01797"></a>01797   <a class="code" href="structParse.html">Parse</a> *pParse,      <span class="comment">/* The parsing context */</span>
<a name="l01798"></a>01798   <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm,   <span class="comment">/* The term of the WHERE clause to be coded */</span>
<a name="l01799"></a>01799   <a class="code" href="structWhereLevel.html">WhereLevel</a> *pLevel, <span class="comment">/* When level of the FROM clause we are working on */</span>
<a name="l01800"></a>01800   <span class="keywordtype">int</span> iTarget         <span class="comment">/* Attempt to leave results in this register */</span>
<a name="l01801"></a>01801 ){
<a name="l01802"></a>01802   <a class="code" href="structExpr.html">Expr</a> *pX = pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>;
<a name="l01803"></a>01803   <a class="code" href="structVdbe.html">Vdbe</a> *v = pParse-&gt;<a class="code" href="structParse.html#a81774053fd5063046f532c07e3daa98b">pVdbe</a>;
<a name="l01804"></a>01804   <span class="keywordtype">int</span> iReg;                  <span class="comment">/* Register holding results */</span>
<a name="l01805"></a>01805 
<a name="l01806"></a>01806   assert( iTarget&gt;0 );
<a name="l01807"></a>01807   <span class="keywordflow">if</span>( pX-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#a57801ac8a2967e8778d3a94d6a8ba240">TK_EQ</a> ){
<a name="l01808"></a>01808     iReg = <a class="code" href="expr_8c.html#a93c32e44b366b3c3b9e56bda2eecd9db">sqlite3ExprCodeTarget</a>(pParse, pX-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>, iTarget);
<a name="l01809"></a>01809   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pX-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#ae43d2177d750e150adf5cfaa64db421c">TK_ISNULL</a> ){
<a name="l01810"></a>01810     iReg = iTarget;
<a name="l01811"></a>01811     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a9fa8760362f8ea197ca11e99b186206b">OP_Null</a>, 0, iReg);
<a name="l01812"></a>01812 <span class="preprocessor">#ifndef SQLITE_OMIT_SUBQUERY</span>
<a name="l01813"></a>01813 <span class="preprocessor"></span>  }<span class="keywordflow">else</span>{
<a name="l01814"></a>01814     <span class="keywordtype">int</span> eType;
<a name="l01815"></a>01815     <span class="keywordtype">int</span> iTab;
<a name="l01816"></a>01816     <span class="keyword">struct </span>InLoop *pIn;
<a name="l01817"></a>01817 
<a name="l01818"></a>01818     assert( pX-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#a6437312264a013b5bf1539ffe8a65e94">TK_IN</a> );
<a name="l01819"></a>01819     iReg = iTarget;
<a name="l01820"></a>01820     eType = <a class="code" href="expr_8c.html#aa6131595320ca4ba16c4d5ef8157941b">sqlite3FindInIndex</a>(pParse, pX, 0);
<a name="l01821"></a>01821     iTab = pX-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a>;
<a name="l01822"></a>01822     <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>, iTab, 0);
<a name="l01823"></a>01823     <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;%.*s&quot;</span>, pX-&gt;<a class="code" href="structExpr.html#afcaa6aaeff1d91947c7da342e3461284">span</a>.<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a>, pX-&gt;<a class="code" href="structExpr.html#afcaa6aaeff1d91947c7da342e3461284">span</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>));
<a name="l01824"></a>01824     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a276238755297111ab44551dcf4f61392">nIn</a>==0 ){
<a name="l01825"></a>01825       pLevel-&gt;<a class="code" href="structWhereLevel.html#a0d59c7ea0c9f698e45b6ff68336630f5">nxt</a> = <a class="code" href="vdbe_8h.html#a5279e16a2acad1e72ba58ae938d385bd">sqlite3VdbeMakeLabel</a>(v);
<a name="l01826"></a>01826     }
<a name="l01827"></a>01827     pLevel-&gt;<a class="code" href="structWhereLevel.html#a276238755297111ab44551dcf4f61392">nIn</a>++;
<a name="l01828"></a>01828     pLevel-&gt;<a class="code" href="structWhereLevel.html#a2f5661de0daeb57b8df19ffbb705e436">aInLoop</a> = <a class="code" href="malloc_8c.html#ae141b4f66af57a6828c083c6926fa5c0">sqlite3DbReallocOrFree</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>, pLevel-&gt;<a class="code" href="structWhereLevel.html#a2f5661de0daeb57b8df19ffbb705e436">aInLoop</a>,
<a name="l01829"></a>01829                                     <span class="keyword">sizeof</span>(pLevel-&gt;<a class="code" href="structWhereLevel.html#a2f5661de0daeb57b8df19ffbb705e436">aInLoop</a>[0])*pLevel-&gt;<a class="code" href="structWhereLevel.html#a276238755297111ab44551dcf4f61392">nIn</a>);
<a name="l01830"></a>01830     pIn = pLevel-&gt;<a class="code" href="structWhereLevel.html#a2f5661de0daeb57b8df19ffbb705e436">aInLoop</a>;
<a name="l01831"></a>01831     <span class="keywordflow">if</span>( pIn ){
<a name="l01832"></a>01832       pIn += pLevel-&gt;<a class="code" href="structWhereLevel.html#a276238755297111ab44551dcf4f61392">nIn</a> - 1;
<a name="l01833"></a>01833       pIn-&gt;iCur = iTab;
<a name="l01834"></a>01834       <span class="keywordflow">if</span>( eType==<a class="code" href="sqliteInt_8h.html#ab022247bec67ddfa769d864f473de4a3">IN_INDEX_ROWID</a> ){
<a name="l01835"></a>01835         pIn-&gt;topAddr = <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a5a05393545770c35a6071b83679e6be7">OP_Rowid</a>, iTab, iReg);
<a name="l01836"></a>01836       }<span class="keywordflow">else</span>{
<a name="l01837"></a>01837         pIn-&gt;topAddr = <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a>, iTab, 0, iReg);
<a name="l01838"></a>01838       }
<a name="l01839"></a>01839       <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#aa94eede07c1e2c3fcb96239fa368a3d2">OP_IsNull</a>, iReg);
<a name="l01840"></a>01840     }<span class="keywordflow">else</span>{
<a name="l01841"></a>01841       pLevel-&gt;<a class="code" href="structWhereLevel.html#a276238755297111ab44551dcf4f61392">nIn</a> = 0;
<a name="l01842"></a>01842     }
<a name="l01843"></a>01843 <span class="preprocessor">#endif</span>
<a name="l01844"></a>01844 <span class="preprocessor"></span>  }
<a name="l01845"></a>01845   <a class="code" href="where_8c.html#a50a51e3dca3d19babeb17d2577889492">disableTerm</a>(pLevel, pTerm);
<a name="l01846"></a>01846   <span class="keywordflow">return</span> iReg;
<a name="l01847"></a>01847 }
<a name="l01848"></a>01848 
<a name="l01849"></a>01849 <span class="comment">/*</span>
<a name="l01850"></a>01850 <span class="comment">** Generate code that will evaluate all == and IN constraints for an</span>
<a name="l01851"></a>01851 <span class="comment">** index.  The values for all constraints are left on the stack.</span>
<a name="l01852"></a>01852 <span class="comment">**</span>
<a name="l01853"></a>01853 <span class="comment">** For example, consider table t1(a,b,c,d,e,f) with index i1(a,b,c).</span>
<a name="l01854"></a>01854 <span class="comment">** Suppose the WHERE clause is this:  a==5 AND b IN (1,2,3) AND c&gt;5 AND c&lt;10</span>
<a name="l01855"></a>01855 <span class="comment">** The index has as many as three equality constraints, but in this</span>
<a name="l01856"></a>01856 <span class="comment">** example, the third &quot;c&quot; value is an inequality.  So only two </span>
<a name="l01857"></a>01857 <span class="comment">** constraints are coded.  This routine will generate code to evaluate</span>
<a name="l01858"></a>01858 <span class="comment">** a==5 and b IN (1,2,3).  The current values for a and b will be left</span>
<a name="l01859"></a>01859 <span class="comment">** on the stack - a is the deepest and b the shallowest.</span>
<a name="l01860"></a>01860 <span class="comment">**</span>
<a name="l01861"></a>01861 <span class="comment">** In the example above nEq==2.  But this subroutine works for any value</span>
<a name="l01862"></a>01862 <span class="comment">** of nEq including 0.  If nEq==0, this routine is nearly a no-op.</span>
<a name="l01863"></a>01863 <span class="comment">** The only thing it does is allocate the pLevel-&gt;iMem memory cell.</span>
<a name="l01864"></a>01864 <span class="comment">**</span>
<a name="l01865"></a>01865 <span class="comment">** This routine always allocates at least one memory cell and puts</span>
<a name="l01866"></a>01866 <span class="comment">** the address of that memory cell in pLevel-&gt;iMem.  The code that</span>
<a name="l01867"></a>01867 <span class="comment">** calls this routine will use pLevel-&gt;iMem to store the termination</span>
<a name="l01868"></a>01868 <span class="comment">** key value of the loop.  If one or more IN operators appear, then</span>
<a name="l01869"></a>01869 <span class="comment">** this routine allocates an additional nEq memory cells for internal</span>
<a name="l01870"></a>01870 <span class="comment">** use.</span>
<a name="l01871"></a>01871 <span class="comment">*/</span>
<a name="l01872"></a><a class="code" href="where_8c.html#a6dae82b44c22356b9f0873b6c71fee9b">01872</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="where_8c.html#a6dae82b44c22356b9f0873b6c71fee9b">codeAllEqualityTerms</a>(
<a name="l01873"></a>01873   <a class="code" href="structParse.html">Parse</a> *pParse,        <span class="comment">/* Parsing context */</span>
<a name="l01874"></a>01874   <a class="code" href="structWhereLevel.html">WhereLevel</a> *pLevel,   <span class="comment">/* Which nested loop of the FROM we are coding */</span>
<a name="l01875"></a>01875   <a class="code" href="structWhereClause.html">WhereClause</a> *pWC,     <span class="comment">/* The WHERE clause */</span>
<a name="l01876"></a>01876   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> notReady,     <span class="comment">/* Which parts of FROM have not yet been coded */</span>
<a name="l01877"></a>01877   <span class="keywordtype">int</span> nExtraReg         <span class="comment">/* Number of extra registers to allocate */</span>
<a name="l01878"></a>01878 ){
<a name="l01879"></a>01879   <span class="keywordtype">int</span> nEq = pLevel-&gt;<a class="code" href="structWhereLevel.html#ad55e7102154ca32c946809bd94665504">nEq</a>;        <span class="comment">/* The number of == or IN constraints to code */</span>
<a name="l01880"></a>01880   <a class="code" href="structVdbe.html">Vdbe</a> *v = pParse-&gt;<a class="code" href="structParse.html#a81774053fd5063046f532c07e3daa98b">pVdbe</a>;      <span class="comment">/* The virtual machine under construction */</span>
<a name="l01881"></a>01881   <a class="code" href="structIndex.html">Index</a> *pIdx = pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a>;   <span class="comment">/* The index being used for this loop */</span>
<a name="l01882"></a>01882   <span class="keywordtype">int</span> iCur = pLevel-&gt;<a class="code" href="structWhereLevel.html#aa31c27c3304de936a6ce974450c55592">iTabCur</a>;   <span class="comment">/* The cursor of the table */</span>
<a name="l01883"></a>01883   <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm;             <span class="comment">/* A single constraint term */</span>
<a name="l01884"></a>01884   <span class="keywordtype">int</span> j;                        <span class="comment">/* Loop counter */</span>
<a name="l01885"></a>01885   <span class="keywordtype">int</span> regBase;                  <span class="comment">/* Base register */</span>
<a name="l01886"></a>01886 
<a name="l01887"></a>01887   <span class="comment">/* Figure out how many memory cells we will need then allocate them.</span>
<a name="l01888"></a>01888 <span class="comment">  ** We always need at least one used to store the loop terminator</span>
<a name="l01889"></a>01889 <span class="comment">  ** value.  If there are IN operators we&apos;ll need one for each == or</span>
<a name="l01890"></a>01890 <span class="comment">  ** IN constraint.</span>
<a name="l01891"></a>01891 <span class="comment">  */</span>
<a name="l01892"></a>01892   pLevel-&gt;<a class="code" href="structWhereLevel.html#a38f4c52a61c99c91590e65849d720465">iMem</a> = pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a> + 1;
<a name="l01893"></a>01893   regBase = pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a> + 2;
<a name="l01894"></a>01894   pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a> += pLevel-&gt;<a class="code" href="structWhereLevel.html#ad55e7102154ca32c946809bd94665504">nEq</a> + 2 + nExtraReg;
<a name="l01895"></a>01895 
<a name="l01896"></a>01896   <span class="comment">/* Evaluate the equality constraints</span>
<a name="l01897"></a>01897 <span class="comment">  */</span>
<a name="l01898"></a>01898   assert( pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>&gt;=nEq );
<a name="l01899"></a>01899   <span class="keywordflow">for</span>(j=0; j&lt;nEq; j++){
<a name="l01900"></a>01900     <span class="keywordtype">int</span> r1;
<a name="l01901"></a>01901     <span class="keywordtype">int</span> k = pIdx-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[j];
<a name="l01902"></a>01902     pTerm = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(pWC, iCur, k, notReady, pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a>, pIdx);
<a name="l01903"></a>01903     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a43cb5602f3d807a6688b065e5ce0250e">NEVER</a>(pTerm==0) ) <span class="keywordflow">break</span>;
<a name="l01904"></a>01904     assert( (pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">TERM_CODED</a>)==0 );
<a name="l01905"></a>01905     r1 = <a class="code" href="where_8c.html#a7a4ca4f697a0f1accd8dba96ddcba286">codeEqualityTerm</a>(pParse, pTerm, pLevel, regBase+j);
<a name="l01906"></a>01906     <span class="keywordflow">if</span>( r1!=regBase+j ){
<a name="l01907"></a>01907       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#af9e5064dc7159d38276860049da8b3b0">OP_SCopy</a>, r1, regBase+j);
<a name="l01908"></a>01908     }
<a name="l01909"></a>01909     <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; <a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a> );
<a name="l01910"></a>01910     <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; <a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a> );
<a name="l01911"></a>01911     <span class="keywordflow">if</span>( (pTerm-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; (<a class="code" href="where_8c.html#a2c632aef209e4d9c25e6bf7da641c8d4">WO_ISNULL</a>|<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a>))==0 ){
<a name="l01912"></a>01912       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#aa94eede07c1e2c3fcb96239fa368a3d2">OP_IsNull</a>, regBase+j, pLevel-&gt;<a class="code" href="structWhereLevel.html#a808e8fb50b460226d4e366eefc95e710">brk</a>);
<a name="l01913"></a>01913     }
<a name="l01914"></a>01914   }
<a name="l01915"></a>01915   <span class="keywordflow">return</span> regBase;
<a name="l01916"></a>01916 }
<a name="l01917"></a>01917 
<a name="l01918"></a>01918 <span class="preprocessor">#if defined(SQLITE_TEST)</span>
<a name="l01919"></a>01919 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01920"></a>01920 <span class="comment">** The following variable holds a text description of query plan generated</span>
<a name="l01921"></a>01921 <span class="comment">** by the most recent call to sqlite3WhereBegin().  Each call to WhereBegin</span>
<a name="l01922"></a>01922 <span class="comment">** overwrites the previous.  This information is used for testing and</span>
<a name="l01923"></a>01923 <span class="comment">** analysis only.</span>
<a name="l01924"></a>01924 <span class="comment">*/</span>
<a name="l01925"></a>01925 <span class="keywordtype">char</span> sqlite3_query_plan[<a class="code" href="where_8c.html#a61ebf73c36e0aa88593c8fdb76891407">BMS</a>*2*40];  <span class="comment">/* Text of the join */</span>
<a name="l01926"></a>01926 <span class="keyword">static</span> <span class="keywordtype">int</span> nQPlan = 0;              <span class="comment">/* Next free slow in _query_plan[] */</span>
<a name="l01927"></a>01927 
<a name="l01928"></a>01928 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_TEST */</span>
<a name="l01929"></a>01929 
<a name="l01930"></a>01930 
<a name="l01931"></a>01931 <span class="comment">/*</span>
<a name="l01932"></a>01932 <span class="comment">** Free a WhereInfo structure</span>
<a name="l01933"></a>01933 <span class="comment">*/</span>
<a name="l01934"></a><a class="code" href="where_8c.html#a4838f169cd94b3192f9a49558dca6ae0">01934</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="where_8c.html#a4838f169cd94b3192f9a49558dca6ae0">whereInfoFree</a>(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <a class="code" href="structWhereInfo.html">WhereInfo</a> *pWInfo){
<a name="l01935"></a>01935   <span class="keywordflow">if</span>( pWInfo ){
<a name="l01936"></a>01936     <span class="keywordtype">int</span> i;
<a name="l01937"></a>01937     <span class="keywordflow">for</span>(i=0; i&lt;pWInfo-&gt;<a class="code" href="structWhereInfo.html#ab04fa676e481a8df69107201a362c686">nLevel</a>; i++){
<a name="l01938"></a>01938       <a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> *pInfo = pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>[i].<a class="code" href="structWhereLevel.html#a9d8132e8f26189b92e90899094858345">pIdxInfo</a>;
<a name="l01939"></a>01939       <span class="keywordflow">if</span>( pInfo ){
<a name="l01940"></a>01940         assert( pInfo-&gt;<a class="code" href="structsqlite3__index__info.html#a5410066c067c3891cdf165c70cc4d6b1">needToFreeIdxStr</a>==0 );
<a name="l01941"></a>01941         <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pInfo);
<a name="l01942"></a>01942       }
<a name="l01943"></a>01943     }
<a name="l01944"></a>01944     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pWInfo);
<a name="l01945"></a>01945   }
<a name="l01946"></a>01946 }
<a name="l01947"></a>01947 
<a name="l01948"></a>01948 
<a name="l01949"></a>01949 <span class="comment">/*</span>
<a name="l01950"></a>01950 <span class="comment">** Generate the beginning of the loop used for WHERE clause processing.</span>
<a name="l01951"></a>01951 <span class="comment">** The return value is a pointer to an opaque structure that contains</span>
<a name="l01952"></a>01952 <span class="comment">** information needed to terminate the loop.  Later, the calling routine</span>
<a name="l01953"></a>01953 <span class="comment">** should invoke sqlite3WhereEnd() with the return value of this function</span>
<a name="l01954"></a>01954 <span class="comment">** in order to complete the WHERE clause processing.</span>
<a name="l01955"></a>01955 <span class="comment">**</span>
<a name="l01956"></a>01956 <span class="comment">** If an error occurs, this routine returns NULL.</span>
<a name="l01957"></a>01957 <span class="comment">**</span>
<a name="l01958"></a>01958 <span class="comment">** The basic idea is to do a nested loop, one loop for each table in</span>
<a name="l01959"></a>01959 <span class="comment">** the FROM clause of a select.  (INSERT and UPDATE statements are the</span>
<a name="l01960"></a>01960 <span class="comment">** same as a SELECT with only a single table in the FROM clause.)  For</span>
<a name="l01961"></a>01961 <span class="comment">** example, if the SQL is this:</span>
<a name="l01962"></a>01962 <span class="comment">**</span>
<a name="l01963"></a>01963 <span class="comment">**       SELECT * FROM t1, t2, t3 WHERE ...;</span>
<a name="l01964"></a>01964 <span class="comment">**</span>
<a name="l01965"></a>01965 <span class="comment">** Then the code generated is conceptually like the following:</span>
<a name="l01966"></a>01966 <span class="comment">**</span>
<a name="l01967"></a>01967 <span class="comment">**      foreach row1 in t1 do       \    Code generated</span>
<a name="l01968"></a>01968 <span class="comment">**        foreach row2 in t2 do      |-- by sqlite3WhereBegin()</span>
<a name="l01969"></a>01969 <span class="comment">**          foreach row3 in t3 do   /</span>
<a name="l01970"></a>01970 <span class="comment">**            ...</span>
<a name="l01971"></a>01971 <span class="comment">**          end                     \    Code generated</span>
<a name="l01972"></a>01972 <span class="comment">**        end                        |-- by sqlite3WhereEnd()</span>
<a name="l01973"></a>01973 <span class="comment">**      end                         /</span>
<a name="l01974"></a>01974 <span class="comment">**</span>
<a name="l01975"></a>01975 <span class="comment">** Note that the loops might not be nested in the order in which they</span>
<a name="l01976"></a>01976 <span class="comment">** appear in the FROM clause if a different order is better able to make</span>
<a name="l01977"></a>01977 <span class="comment">** use of indices.  Note also that when the IN operator appears in</span>
<a name="l01978"></a>01978 <span class="comment">** the WHERE clause, it might result in additional nested loops for</span>
<a name="l01979"></a>01979 <span class="comment">** scanning through all values on the right-hand side of the IN.</span>
<a name="l01980"></a>01980 <span class="comment">**</span>
<a name="l01981"></a>01981 <span class="comment">** There are Btree cursors associated with each table.  t1 uses cursor</span>
<a name="l01982"></a>01982 <span class="comment">** number pTabList-&gt;a[0].iCursor.  t2 uses the cursor pTabList-&gt;a[1].iCursor.</span>
<a name="l01983"></a>01983 <span class="comment">** And so forth.  This routine generates code to open those VDBE cursors</span>
<a name="l01984"></a>01984 <span class="comment">** and sqlite3WhereEnd() generates the code to close them.</span>
<a name="l01985"></a>01985 <span class="comment">**</span>
<a name="l01986"></a>01986 <span class="comment">** The code that sqlite3WhereBegin() generates leaves the cursors named</span>
<a name="l01987"></a>01987 <span class="comment">** in pTabList pointing at their appropriate entries.  The [...] code</span>
<a name="l01988"></a>01988 <span class="comment">** can use OP_Column and OP_Rowid opcodes on these cursors to extract</span>
<a name="l01989"></a>01989 <span class="comment">** data from the various tables of the loop.</span>
<a name="l01990"></a>01990 <span class="comment">**</span>
<a name="l01991"></a>01991 <span class="comment">** If the WHERE clause is empty, the foreach loops must each scan their</span>
<a name="l01992"></a>01992 <span class="comment">** entire tables.  Thus a three-way join is an O(N^3) operation.  But if</span>
<a name="l01993"></a>01993 <span class="comment">** the tables have indices and there are terms in the WHERE clause that</span>
<a name="l01994"></a>01994 <span class="comment">** refer to those indices, a complete table scan can be avoided and the</span>
<a name="l01995"></a>01995 <span class="comment">** code will run much faster.  Most of the work of this routine is checking</span>
<a name="l01996"></a>01996 <span class="comment">** to see if there are indices that can be used to speed up the loop.</span>
<a name="l01997"></a>01997 <span class="comment">**</span>
<a name="l01998"></a>01998 <span class="comment">** Terms of the WHERE clause are also used to limit which rows actually</span>
<a name="l01999"></a>01999 <span class="comment">** make it to the &quot;...&quot; in the middle of the loop.  After each &quot;foreach&quot;,</span>
<a name="l02000"></a>02000 <span class="comment">** terms of the WHERE clause that use only terms in that loop and outer</span>
<a name="l02001"></a>02001 <span class="comment">** loops are evaluated and if false a jump is made around all subsequent</span>
<a name="l02002"></a>02002 <span class="comment">** inner loops (or around the &quot;...&quot; if the test occurs within the inner-</span>
<a name="l02003"></a>02003 <span class="comment">** most loop)</span>
<a name="l02004"></a>02004 <span class="comment">**</span>
<a name="l02005"></a>02005 <span class="comment">** OUTER JOINS</span>
<a name="l02006"></a>02006 <span class="comment">**</span>
<a name="l02007"></a>02007 <span class="comment">** An outer join of tables t1 and t2 is conceptally coded as follows:</span>
<a name="l02008"></a>02008 <span class="comment">**</span>
<a name="l02009"></a>02009 <span class="comment">**    foreach row1 in t1 do</span>
<a name="l02010"></a>02010 <span class="comment">**      flag = 0</span>
<a name="l02011"></a>02011 <span class="comment">**      foreach row2 in t2 do</span>
<a name="l02012"></a>02012 <span class="comment">**        start:</span>
<a name="l02013"></a>02013 <span class="comment">**          ...</span>
<a name="l02014"></a>02014 <span class="comment">**          flag = 1</span>
<a name="l02015"></a>02015 <span class="comment">**      end</span>
<a name="l02016"></a>02016 <span class="comment">**      if flag==0 then</span>
<a name="l02017"></a>02017 <span class="comment">**        move the row2 cursor to a null row</span>
<a name="l02018"></a>02018 <span class="comment">**        goto start</span>
<a name="l02019"></a>02019 <span class="comment">**      fi</span>
<a name="l02020"></a>02020 <span class="comment">**    end</span>
<a name="l02021"></a>02021 <span class="comment">**</span>
<a name="l02022"></a>02022 <span class="comment">** ORDER BY CLAUSE PROCESSING</span>
<a name="l02023"></a>02023 <span class="comment">**</span>
<a name="l02024"></a>02024 <span class="comment">** *ppOrderBy is a pointer to the ORDER BY clause of a SELECT statement,</span>
<a name="l02025"></a>02025 <span class="comment">** if there is one.  If there is no ORDER BY clause or if this routine</span>
<a name="l02026"></a>02026 <span class="comment">** is called from an UPDATE or DELETE statement, then ppOrderBy is NULL.</span>
<a name="l02027"></a>02027 <span class="comment">**</span>
<a name="l02028"></a>02028 <span class="comment">** If an index can be used so that the natural output order of the table</span>
<a name="l02029"></a>02029 <span class="comment">** scan is correct for the ORDER BY clause, then that index is used and</span>
<a name="l02030"></a>02030 <span class="comment">** *ppOrderBy is set to NULL.  This is an optimization that prevents an</span>
<a name="l02031"></a>02031 <span class="comment">** unnecessary sort of the result set if an index appropriate for the</span>
<a name="l02032"></a>02032 <span class="comment">** ORDER BY clause already exists.</span>
<a name="l02033"></a>02033 <span class="comment">**</span>
<a name="l02034"></a>02034 <span class="comment">** If the where clause loops cannot be arranged to provide the correct</span>
<a name="l02035"></a>02035 <span class="comment">** output order, then the *ppOrderBy is unchanged.</span>
<a name="l02036"></a>02036 <span class="comment">*/</span>
<a name="l02037"></a><a class="code" href="where_8c.html#a1ffe9ca2c9ddae372beb3333320be0d3">02037</a> <a class="code" href="structWhereInfo.html">WhereInfo</a> *<a class="code" href="sqliteInt_8h.html#ac38c22d27f18cabb6583fc4e1de3e088">sqlite3WhereBegin</a>(
<a name="l02038"></a>02038   <a class="code" href="structParse.html">Parse</a> *pParse,        <span class="comment">/* The parser context */</span>
<a name="l02039"></a>02039   <a class="code" href="structSrcList.html">SrcList</a> *pTabList,    <span class="comment">/* A list of all tables to be scanned */</span>
<a name="l02040"></a>02040   <a class="code" href="structExpr.html">Expr</a> *pWhere,         <span class="comment">/* The WHERE clause */</span>
<a name="l02041"></a>02041   <a class="code" href="structExprList.html">ExprList</a> **ppOrderBy, <span class="comment">/* An ORDER BY clause, or NULL */</span>
<a name="l02042"></a>02042   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> wflags             <span class="comment">/* One of the WHERE_* flags defined in sqliteInt.h */</span>
<a name="l02043"></a>02043 ){
<a name="l02044"></a>02044   <span class="keywordtype">int</span> i;                     <span class="comment">/* Loop counter */</span>
<a name="l02045"></a>02045   <a class="code" href="structWhereInfo.html">WhereInfo</a> *pWInfo;         <span class="comment">/* Will become the return value of this function */</span>
<a name="l02046"></a>02046   <a class="code" href="structVdbe.html">Vdbe</a> *v = pParse-&gt;<a class="code" href="structParse.html#a81774053fd5063046f532c07e3daa98b">pVdbe</a>;   <span class="comment">/* The virtual database engine */</span>
<a name="l02047"></a>02047   <span class="keywordtype">int</span> brk, cont = 0;         <span class="comment">/* Addresses used during code generation */</span>
<a name="l02048"></a>02048   <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> notReady;          <span class="comment">/* Cursors that are not yet positioned */</span>
<a name="l02049"></a>02049   <a class="code" href="structWhereTerm.html">WhereTerm</a> *pTerm;          <span class="comment">/* A single term in the WHERE clause */</span>
<a name="l02050"></a>02050   <a class="code" href="structExprMaskSet.html">ExprMaskSet</a> maskSet;       <span class="comment">/* The expression mask set */</span>
<a name="l02051"></a>02051   <a class="code" href="structWhereClause.html">WhereClause</a> wc;            <span class="comment">/* The WHERE clause is divided into these terms */</span>
<a name="l02052"></a>02052   <span class="keyword">struct </span>SrcList_item *pTabItem;  <span class="comment">/* A single entry from pTabList */</span>
<a name="l02053"></a>02053   <a class="code" href="structWhereLevel.html">WhereLevel</a> *pLevel;             <span class="comment">/* A single level in the pWInfo list */</span>
<a name="l02054"></a>02054   <span class="keywordtype">int</span> iFrom;                      <span class="comment">/* First unused FROM clause element */</span>
<a name="l02055"></a>02055   <span class="keywordtype">int</span> andFlags;              <span class="comment">/* AND-ed combination of all wc.a[].flags */</span>
<a name="l02056"></a>02056   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>;               <span class="comment">/* Database connection */</span>
<a name="l02057"></a>02057   <a class="code" href="structExprList.html">ExprList</a> *pOrderBy = 0;
<a name="l02058"></a>02058 
<a name="l02059"></a>02059   <span class="comment">/* The number of tables in the FROM clause is limited by the number of</span>
<a name="l02060"></a>02060 <span class="comment">  ** bits in a Bitmask </span>
<a name="l02061"></a>02061 <span class="comment">  */</span>
<a name="l02062"></a>02062   <span class="keywordflow">if</span>( pTabList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>&gt;<a class="code" href="where_8c.html#a61ebf73c36e0aa88593c8fdb76891407">BMS</a> ){
<a name="l02063"></a>02063     <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;at most %d tables in a join&quot;</span>, <a class="code" href="where_8c.html#a61ebf73c36e0aa88593c8fdb76891407">BMS</a>);
<a name="l02064"></a>02064     <span class="keywordflow">return</span> 0;
<a name="l02065"></a>02065   }
<a name="l02066"></a>02066 
<a name="l02067"></a>02067   <span class="keywordflow">if</span>( ppOrderBy ){
<a name="l02068"></a>02068     pOrderBy = *ppOrderBy;
<a name="l02069"></a>02069   }
<a name="l02070"></a>02070 
<a name="l02071"></a>02071   <span class="comment">/* Split the WHERE clause into separate subexpressions where each</span>
<a name="l02072"></a>02072 <span class="comment">  ** subexpression is separated by an AND operator.</span>
<a name="l02073"></a>02073 <span class="comment">  */</span>
<a name="l02074"></a>02074   <a class="code" href="where_8c.html#a1d379b4d6777b14ba479796030ab4f88">initMaskSet</a>(&amp;maskSet);
<a name="l02075"></a>02075   <a class="code" href="where_8c.html#aa1a7a509852a1a70634cb58355f643bc">whereClauseInit</a>(&amp;wc, pParse, &amp;maskSet);
<a name="l02076"></a>02076   <a class="code" href="expr_8c.html#ad6c04ae907e71b99b0a155e34bce6179">sqlite3ExprCodeConstants</a>(pParse, pWhere);
<a name="l02077"></a>02077   <a class="code" href="where_8c.html#a11081d7feda10bb8c57f960b1a4609ac">whereSplit</a>(&amp;wc, pWhere, <a class="code" href="parse_8h.html#ad216dabb280169cbee05dcec39aa6a08">TK_AND</a>);
<a name="l02078"></a>02078     
<a name="l02079"></a>02079   <span class="comment">/* Allocate and initialize the WhereInfo structure that will become the</span>
<a name="l02080"></a>02080 <span class="comment">  ** return value.</span>
<a name="l02081"></a>02081 <span class="comment">  */</span>
<a name="l02082"></a>02082   db = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l02083"></a>02083   pWInfo = <a class="code" href="malloc_8c.html#a9cdef45d3f06c28e71d728e8b15ebc0f">sqlite3DbMallocZero</a>(db,  
<a name="l02084"></a>02084                       <span class="keyword">sizeof</span>(<a class="code" href="structWhereInfo.html">WhereInfo</a>) + pTabList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>*<span class="keyword">sizeof</span>(<a class="code" href="structWhereLevel.html">WhereLevel</a>));
<a name="l02085"></a>02085   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l02086"></a>02086     <span class="keywordflow">goto</span> whereBeginError;
<a name="l02087"></a>02087   }
<a name="l02088"></a>02088   pWInfo-&gt;<a class="code" href="structWhereInfo.html#ab04fa676e481a8df69107201a362c686">nLevel</a> = pTabList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>;
<a name="l02089"></a>02089   pWInfo-&gt;<a class="code" href="structWhereInfo.html#a26745055cd13360536fb4b074db358f9">pParse</a> = pParse;
<a name="l02090"></a>02090   pWInfo-&gt;<a class="code" href="structWhereInfo.html#a0f43432aeca75640c96a69f6a82aa138">pTabList</a> = pTabList;
<a name="l02091"></a>02091   pWInfo-&gt;<a class="code" href="structWhereInfo.html#a338ac73b84c81db455ad7db56b5e4a06">iBreak</a> = <a class="code" href="vdbe_8h.html#a5279e16a2acad1e72ba58ae938d385bd">sqlite3VdbeMakeLabel</a>(v);
<a name="l02092"></a>02092 
<a name="l02093"></a>02093   <span class="comment">/* Special case: a WHERE clause that is constant.  Evaluate the</span>
<a name="l02094"></a>02094 <span class="comment">  ** expression and either jump over all of the code or fall thru.</span>
<a name="l02095"></a>02095 <span class="comment">  */</span>
<a name="l02096"></a>02096   <span class="keywordflow">if</span>( pWhere &amp;&amp; (pTabList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>==0 || <a class="code" href="expr_8c.html#ac8f20fb7127fd7da66020371786f3f5e">sqlite3ExprIsConstantNotJoin</a>(pWhere)) ){
<a name="l02097"></a>02097     <a class="code" href="expr_8c.html#ac21b74c1bf28cc39d708b8f1375380d9">sqlite3ExprIfFalse</a>(pParse, pWhere, pWInfo-&gt;<a class="code" href="structWhereInfo.html#a338ac73b84c81db455ad7db56b5e4a06">iBreak</a>, <a class="code" href="sqliteInt_8h.html#ae3bc696255d4fc2767f872371662bcd1">SQLITE_JUMPIFNULL</a>);
<a name="l02098"></a>02098     pWhere = 0;
<a name="l02099"></a>02099   }
<a name="l02100"></a>02100 
<a name="l02101"></a>02101   <span class="comment">/* Assign a bit from the bitmask to every term in the FROM clause.</span>
<a name="l02102"></a>02102 <span class="comment">  **</span>
<a name="l02103"></a>02103 <span class="comment">  ** When assigning bitmask values to FROM clause cursors, it must be</span>
<a name="l02104"></a>02104 <span class="comment">  ** the case that if X is the bitmask for the N-th FROM clause term then</span>
<a name="l02105"></a>02105 <span class="comment">  ** the bitmask for all FROM clause terms to the left of the N-th term</span>
<a name="l02106"></a>02106 <span class="comment">  ** is (X-1).   An expression from the ON clause of a LEFT JOIN can use</span>
<a name="l02107"></a>02107 <span class="comment">  ** its Expr.iRightJoinTable value to find the bitmask of the right table</span>
<a name="l02108"></a>02108 <span class="comment">  ** of the join.  Subtracting one from the right table bitmask gives a</span>
<a name="l02109"></a>02109 <span class="comment">  ** bitmask for all tables to the left of the join.  Knowing the bitmask</span>
<a name="l02110"></a>02110 <span class="comment">  ** for all tables to the left of a left join is important.  Ticket #3015.</span>
<a name="l02111"></a>02111 <span class="comment">  */</span>
<a name="l02112"></a>02112   <span class="keywordflow">for</span>(i=0; i&lt;pTabList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>; i++){
<a name="l02113"></a>02113     <a class="code" href="where_8c.html#acd7499fefa31a0ab4cc44d81f0844e4c">createMask</a>(&amp;maskSet, pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[i].<a class="code" href="structSrcList_1_1SrcList__item.html#af2e8aae90bd7a00b814db5a2d31f6607">iCursor</a>);
<a name="l02114"></a>02114   }
<a name="l02115"></a>02115 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l02116"></a>02116 <span class="preprocessor"></span>  {
<a name="l02117"></a>02117     <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> toTheLeft = 0;
<a name="l02118"></a>02118     <span class="keywordflow">for</span>(i=0; i&lt;pTabList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>; i++){
<a name="l02119"></a>02119       <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> m = <a class="code" href="where_8c.html#a330443df7684d9bca657260aea158e0c">getMask</a>(&amp;maskSet, pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[i].<a class="code" href="structSrcList_1_1SrcList__item.html#af2e8aae90bd7a00b814db5a2d31f6607">iCursor</a>);
<a name="l02120"></a>02120       assert( (m-1)==toTheLeft );
<a name="l02121"></a>02121       toTheLeft |= m;
<a name="l02122"></a>02122     }
<a name="l02123"></a>02123   }
<a name="l02124"></a>02124 <span class="preprocessor">#endif</span>
<a name="l02125"></a>02125 <span class="preprocessor"></span>
<a name="l02126"></a>02126   <span class="comment">/* Analyze all of the subexpressions.  Note that exprAnalyze() might</span>
<a name="l02127"></a>02127 <span class="comment">  ** add new virtual terms onto the end of the WHERE clause.  We do not</span>
<a name="l02128"></a>02128 <span class="comment">  ** want to analyze these virtual terms, so start analyzing at the end</span>
<a name="l02129"></a>02129 <span class="comment">  ** and work forward so that the added virtual terms are never processed.</span>
<a name="l02130"></a>02130 <span class="comment">  */</span>
<a name="l02131"></a>02131   <a class="code" href="where_8c.html#a2e7a957af98e240fa68e34d6ff639437">exprAnalyzeAll</a>(pTabList, &amp;wc);
<a name="l02132"></a>02132   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l02133"></a>02133     <span class="keywordflow">goto</span> whereBeginError;
<a name="l02134"></a>02134   }
<a name="l02135"></a>02135 
<a name="l02136"></a>02136   <span class="comment">/* Chose the best index to use for each table in the FROM clause.</span>
<a name="l02137"></a>02137 <span class="comment">  **</span>
<a name="l02138"></a>02138 <span class="comment">  ** This loop fills in the following fields:</span>
<a name="l02139"></a>02139 <span class="comment">  **</span>
<a name="l02140"></a>02140 <span class="comment">  **   pWInfo-&gt;a[].pIdx      The index to use for this level of the loop.</span>
<a name="l02141"></a>02141 <span class="comment">  **   pWInfo-&gt;a[].flags     WHERE_xxx flags associated with pIdx</span>
<a name="l02142"></a>02142 <span class="comment">  **   pWInfo-&gt;a[].nEq       The number of == and IN constraints</span>
<a name="l02143"></a>02143 <span class="comment">  **   pWInfo-&gt;a[].iFrom     Which term of the FROM clause is being coded</span>
<a name="l02144"></a>02144 <span class="comment">  **   pWInfo-&gt;a[].iTabCur   The VDBE cursor for the database table</span>
<a name="l02145"></a>02145 <span class="comment">  **   pWInfo-&gt;a[].iIdxCur   The VDBE cursor for the index</span>
<a name="l02146"></a>02146 <span class="comment">  **</span>
<a name="l02147"></a>02147 <span class="comment">  ** This loop also figures out the nesting order of tables in the FROM</span>
<a name="l02148"></a>02148 <span class="comment">  ** clause.</span>
<a name="l02149"></a>02149 <span class="comment">  */</span>
<a name="l02150"></a>02150   notReady = ~(<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)0;
<a name="l02151"></a>02151   pTabItem = pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>;
<a name="l02152"></a>02152   pLevel = pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>;
<a name="l02153"></a>02153   andFlags = ~0;
<a name="l02154"></a>02154   <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;*** Optimizer Start ***\n&quot;</span>));
<a name="l02155"></a>02155   <span class="keywordflow">for</span>(i=iFrom=0, pLevel=pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>; i&lt;pTabList-&gt;nSrc; i++, pLevel++){
<a name="l02156"></a>02156     <a class="code" href="structIndex.html">Index</a> *pIdx;                <span class="comment">/* Index for FROM table at pTabItem */</span>
<a name="l02157"></a>02157     <span class="keywordtype">int</span> flags;                  <span class="comment">/* Flags asssociated with pIdx */</span>
<a name="l02158"></a>02158     <span class="keywordtype">int</span> nEq;                    <span class="comment">/* Number of == or IN constraints */</span>
<a name="l02159"></a>02159     <span class="keywordtype">double</span> cost;                <span class="comment">/* The cost for pIdx */</span>
<a name="l02160"></a>02160     <span class="keywordtype">int</span> j;                      <span class="comment">/* For looping over FROM tables */</span>
<a name="l02161"></a>02161     <a class="code" href="structIndex.html">Index</a> *pBest = 0;           <span class="comment">/* The best index seen so far */</span>
<a name="l02162"></a>02162     <span class="keywordtype">int</span> bestFlags = 0;          <span class="comment">/* Flags associated with pBest */</span>
<a name="l02163"></a>02163     <span class="keywordtype">int</span> bestNEq = 0;            <span class="comment">/* nEq associated with pBest */</span>
<a name="l02164"></a>02164     <span class="keywordtype">double</span> lowestCost;          <span class="comment">/* Cost of the pBest */</span>
<a name="l02165"></a>02165     <span class="keywordtype">int</span> bestJ = 0;              <span class="comment">/* The value of j */</span>
<a name="l02166"></a>02166     <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> m;                  <span class="comment">/* Bitmask value for j or bestJ */</span>
<a name="l02167"></a>02167     <span class="keywordtype">int</span> once = 0;               <span class="comment">/* True when first table is seen */</span>
<a name="l02168"></a>02168     <a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> *pIndex; <span class="comment">/* Current virtual index */</span>
<a name="l02169"></a>02169 
<a name="l02170"></a>02170     lowestCost = <a class="code" href="sqliteInt_8h.html#a9e9d52dc56fdad6ba6984d6a6e11ac71">SQLITE_BIG_DBL</a>;
<a name="l02171"></a>02171     <span class="keywordflow">for</span>(j=iFrom, pTabItem=&amp;pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[j]; j&lt;pTabList-&gt;nSrc; j++, pTabItem++){
<a name="l02172"></a>02172       <span class="keywordtype">int</span> doNotReorder;  <span class="comment">/* True if this table should not be reordered */</span>
<a name="l02173"></a>02173 
<a name="l02174"></a>02174       doNotReorder =  (pTabItem-&gt;jointype &amp; (<a class="code" href="sqliteInt_8h.html#ac4edc24e10d5c297818aeb579cb507df">JT_LEFT</a>|<a class="code" href="sqliteInt_8h.html#ad2e8bf041b266234a8acbb706031d6c5">JT_CROSS</a>))!=0;
<a name="l02175"></a>02175       <span class="keywordflow">if</span>( once &amp;&amp; doNotReorder ) <span class="keywordflow">break</span>;
<a name="l02176"></a>02176       m = <a class="code" href="where_8c.html#a330443df7684d9bca657260aea158e0c">getMask</a>(&amp;maskSet, pTabItem-&gt;iCursor);
<a name="l02177"></a>02177       <span class="keywordflow">if</span>( (m &amp; notReady)==0 ){
<a name="l02178"></a>02178         <span class="keywordflow">if</span>( j==iFrom ) iFrom++;
<a name="l02179"></a>02179         <span class="keywordflow">continue</span>;
<a name="l02180"></a>02180       }
<a name="l02181"></a>02181       assert( pTabItem-&gt;pTab );
<a name="l02182"></a>02182 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l02183"></a>02183 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a3a32526e289387307e17cfee27f7243e">IsVirtual</a>(pTabItem-&gt;pTab) ){
<a name="l02184"></a>02184         <a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> **ppIdxInfo = &amp;pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>[j].<a class="code" href="structWhereLevel.html#a9d8132e8f26189b92e90899094858345">pIdxInfo</a>;
<a name="l02185"></a>02185         cost = <a class="code" href="where_8c.html#a7c4fe3545a56e4acb8ab4a4699b56be9">bestVirtualIndex</a>(pParse, &amp;wc, pTabItem, notReady,
<a name="l02186"></a>02186                                 ppOrderBy ? *ppOrderBy : 0, i==0,
<a name="l02187"></a>02187                                 ppIdxInfo);
<a name="l02188"></a>02188         flags = <a class="code" href="where_8c.html#af3727628c957ea47b9cc55af600af579">WHERE_VIRTUALTABLE</a>;
<a name="l02189"></a>02189         pIndex = *ppIdxInfo;
<a name="l02190"></a>02190         <span class="keywordflow">if</span>( pIndex &amp;&amp; pIndex-&gt;<a class="code" href="structsqlite3__index__info.html#a5515d9de0f37f68d7e0930c20a668b29">orderByConsumed</a> ){
<a name="l02191"></a>02191           flags = <a class="code" href="where_8c.html#af3727628c957ea47b9cc55af600af579">WHERE_VIRTUALTABLE</a> | <a class="code" href="where_8c.html#a4caa356cdd5bf6be70e0a2426bfbda2e">WHERE_ORDERBY</a>;
<a name="l02192"></a>02192         }
<a name="l02193"></a>02193         pIdx = 0;
<a name="l02194"></a>02194         nEq = 0;
<a name="l02195"></a>02195         <span class="keywordflow">if</span>( (<a class="code" href="sqliteInt_8h.html#a9e9d52dc56fdad6ba6984d6a6e11ac71">SQLITE_BIG_DBL</a>/2.0)&lt;cost ){
<a name="l02196"></a>02196           <span class="comment">/* The cost is not allowed to be larger than SQLITE_BIG_DBL (the</span>
<a name="l02197"></a>02197 <span class="comment">          ** inital value of lowestCost in this loop. If it is, then</span>
<a name="l02198"></a>02198 <span class="comment">          ** the (cost&lt;lowestCost) test below will never be true and</span>
<a name="l02199"></a>02199 <span class="comment">          ** pLevel-&gt;pBestIdx never set.</span>
<a name="l02200"></a>02200 <span class="comment">          */</span> 
<a name="l02201"></a>02201           cost = (<a class="code" href="sqliteInt_8h.html#a9e9d52dc56fdad6ba6984d6a6e11ac71">SQLITE_BIG_DBL</a>/2.0);
<a name="l02202"></a>02202         }
<a name="l02203"></a>02203       }<span class="keywordflow">else</span> 
<a name="l02204"></a>02204 <span class="preprocessor">#endif</span>
<a name="l02205"></a>02205 <span class="preprocessor"></span>      {
<a name="l02206"></a>02206         cost = <a class="code" href="where_8c.html#ac677094c8515920917d4b66722dcbab0">bestIndex</a>(pParse, &amp;wc, pTabItem, notReady,
<a name="l02207"></a>02207                          (i==0 &amp;&amp; ppOrderBy) ? *ppOrderBy : 0,
<a name="l02208"></a>02208                          &amp;pIdx, &amp;flags, &amp;nEq);
<a name="l02209"></a>02209         pIndex = 0;
<a name="l02210"></a>02210       }
<a name="l02211"></a>02211       <span class="keywordflow">if</span>( cost&lt;lowestCost ){
<a name="l02212"></a>02212         once = 1;
<a name="l02213"></a>02213         lowestCost = cost;
<a name="l02214"></a>02214         pBest = pIdx;
<a name="l02215"></a>02215         bestFlags = flags;
<a name="l02216"></a>02216         bestNEq = nEq;
<a name="l02217"></a>02217         bestJ = j;
<a name="l02218"></a>02218         pLevel-&gt;<a class="code" href="structWhereLevel.html#a64b8d6fb04c7d1d43b891f0f04870100">pBestIdx</a> = pIndex;
<a name="l02219"></a>02219       }
<a name="l02220"></a>02220       <span class="keywordflow">if</span>( doNotReorder ) <span class="keywordflow">break</span>;
<a name="l02221"></a>02221     }
<a name="l02222"></a>02222     <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;*** Optimizer selects table %d for loop %d\n&quot;</span>, bestJ,
<a name="l02223"></a>02223            pLevel-pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>));
<a name="l02224"></a>02224     <span class="keywordflow">if</span>( (bestFlags &amp; <a class="code" href="where_8c.html#a4caa356cdd5bf6be70e0a2426bfbda2e">WHERE_ORDERBY</a>)!=0 ){
<a name="l02225"></a>02225       *ppOrderBy = 0;
<a name="l02226"></a>02226     }
<a name="l02227"></a>02227     andFlags &amp;= bestFlags;
<a name="l02228"></a>02228     pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> = bestFlags;
<a name="l02229"></a>02229     pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a> = pBest;
<a name="l02230"></a>02230     pLevel-&gt;<a class="code" href="structWhereLevel.html#ad55e7102154ca32c946809bd94665504">nEq</a> = bestNEq;
<a name="l02231"></a>02231     pLevel-&gt;<a class="code" href="structWhereLevel.html#a2f5661de0daeb57b8df19ffbb705e436">aInLoop</a> = 0;
<a name="l02232"></a>02232     pLevel-&gt;<a class="code" href="structWhereLevel.html#a276238755297111ab44551dcf4f61392">nIn</a> = 0;
<a name="l02233"></a>02233     <span class="keywordflow">if</span>( pBest ){
<a name="l02234"></a>02234       pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a> = pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>++;
<a name="l02235"></a>02235     }<span class="keywordflow">else</span>{
<a name="l02236"></a>02236       pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a> = -1;
<a name="l02237"></a>02237     }
<a name="l02238"></a>02238     notReady &amp;= ~<a class="code" href="where_8c.html#a330443df7684d9bca657260aea158e0c">getMask</a>(&amp;maskSet, pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[bestJ].<a class="code" href="structSrcList_1_1SrcList__item.html#af2e8aae90bd7a00b814db5a2d31f6607">iCursor</a>);
<a name="l02239"></a>02239     pLevel-&gt;<a class="code" href="structWhereLevel.html#a2be02022245f9e1e67aacd7c6d70543f">iFrom</a> = bestJ;
<a name="l02240"></a>02240 
<a name="l02241"></a>02241     <span class="comment">/* Check that if the table scanned by this loop iteration had an</span>
<a name="l02242"></a>02242 <span class="comment">    ** INDEXED BY clause attached to it, that the named index is being</span>
<a name="l02243"></a>02243 <span class="comment">    ** used for the scan. If not, then query compilation has failed.</span>
<a name="l02244"></a>02244 <span class="comment">    ** Return an error.</span>
<a name="l02245"></a>02245 <span class="comment">    */</span>
<a name="l02246"></a>02246     pIdx = pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[bestJ].<a class="code" href="structSrcList_1_1SrcList__item.html#ab4722e97bd4852c8b84e620185955c28">pIndex</a>;
<a name="l02247"></a>02247     assert( !pIdx || !pBest || pIdx==pBest );
<a name="l02248"></a>02248     <span class="keywordflow">if</span>( pIdx &amp;&amp; pBest!=pIdx ){
<a name="l02249"></a>02249       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;cannot use index: %s&quot;</span>, pIdx-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a>);
<a name="l02250"></a>02250       <span class="keywordflow">goto</span> whereBeginError;
<a name="l02251"></a>02251     }
<a name="l02252"></a>02252   }
<a name="l02253"></a>02253   <a class="code" href="where_8c.html#a264203e109dcea2ad86ec889d0a8e102">WHERETRACE</a>((<span class="stringliteral">&quot;*** Optimizer Finished ***\n&quot;</span>));
<a name="l02254"></a>02254 
<a name="l02255"></a>02255   <span class="comment">/* If the total query only selects a single row, then the ORDER BY</span>
<a name="l02256"></a>02256 <span class="comment">  ** clause is irrelevant.</span>
<a name="l02257"></a>02257 <span class="comment">  */</span>
<a name="l02258"></a>02258   <span class="keywordflow">if</span>( (andFlags &amp; <a class="code" href="where_8c.html#a0e422237e7eec9ee479fc178a89a7c83">WHERE_UNIQUE</a>)!=0 &amp;&amp; ppOrderBy ){
<a name="l02259"></a>02259     *ppOrderBy = 0;
<a name="l02260"></a>02260   }
<a name="l02261"></a>02261 
<a name="l02262"></a>02262   <span class="comment">/* If the caller is an UPDATE or DELETE statement that is requesting</span>
<a name="l02263"></a>02263 <span class="comment">  ** to use a one-pass algorithm, determine if this is appropriate.</span>
<a name="l02264"></a>02264 <span class="comment">  ** The one-pass algorithm only works if the WHERE clause constraints</span>
<a name="l02265"></a>02265 <span class="comment">  ** the statement to update a single row.</span>
<a name="l02266"></a>02266 <span class="comment">  */</span>
<a name="l02267"></a>02267   assert( (wflags &amp; <a class="code" href="sqliteInt_8h.html#a63be0f3c4c73caef7fac85f006ba203e">WHERE_ONEPASS_DESIRED</a>)==0 || pWInfo-&gt;<a class="code" href="structWhereInfo.html#ab04fa676e481a8df69107201a362c686">nLevel</a>==1 );
<a name="l02268"></a>02268   <span class="keywordflow">if</span>( (wflags &amp; WHERE_ONEPASS_DESIRED)!=0 &amp;&amp; (andFlags &amp; WHERE_UNIQUE)!=0 ){
<a name="l02269"></a>02269     pWInfo-&gt;<a class="code" href="structWhereInfo.html#a851aa1747f940f6ab58505f9326fe9c7">okOnePass</a> = 1;
<a name="l02270"></a>02270     pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>[0].<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp;= ~<a class="code" href="where_8c.html#a5c7e944406bbba33acde54aa3fcee124">WHERE_IDX_ONLY</a>;
<a name="l02271"></a>02271   }
<a name="l02272"></a>02272 
<a name="l02273"></a>02273   <span class="comment">/* Open all tables in the pTabList and any indices selected for</span>
<a name="l02274"></a>02274 <span class="comment">  ** searching those tables.</span>
<a name="l02275"></a>02275 <span class="comment">  */</span>
<a name="l02276"></a>02276   <a class="code" href="build_8c.html#a51b29407b457575a6d04897e7a19d0b6">sqlite3CodeVerifySchema</a>(pParse, -1); <span class="comment">/* Insert the cookie verifier Goto */</span>
<a name="l02277"></a>02277   <span class="keywordflow">for</span>(i=0, pLevel=pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>; i&lt;pTabList-&gt;nSrc; i++, pLevel++){
<a name="l02278"></a>02278     <a class="code" href="structTable.html">Table</a> *pTab;     <span class="comment">/* Table to open */</span>
<a name="l02279"></a>02279     <a class="code" href="structIndex.html">Index</a> *pIx;      <span class="comment">/* Index used to access pTab (if any) */</span>
<a name="l02280"></a>02280     <span class="keywordtype">int</span> iDb;         <span class="comment">/* Index of database containing table/index */</span>
<a name="l02281"></a>02281     <span class="keywordtype">int</span> iIdxCur = pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a>;
<a name="l02282"></a>02282 
<a name="l02283"></a>02283 <span class="preprocessor">#ifndef SQLITE_OMIT_EXPLAIN</span>
<a name="l02284"></a>02284 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pParse-&gt;<a class="code" href="structParse.html#a41f7ea55f0d6523295a5d958e25a2787">explain</a>==2 ){
<a name="l02285"></a>02285       <span class="keywordtype">char</span> *zMsg;
<a name="l02286"></a>02286       <span class="keyword">struct </span>SrcList_item *pItem = &amp;pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[pLevel-&gt;<a class="code" href="structWhereLevel.html#a2be02022245f9e1e67aacd7c6d70543f">iFrom</a>];
<a name="l02287"></a>02287       zMsg = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db, <span class="stringliteral">&quot;TABLE %s&quot;</span>, pItem-&gt;zName);
<a name="l02288"></a>02288       <span class="keywordflow">if</span>( pItem-&gt;zAlias ){
<a name="l02289"></a>02289         zMsg = <a class="code" href="printf_8c.html#a8c13cea9062e442b7163031ab6429681">sqlite3MAppendf</a>(db, zMsg, <span class="stringliteral">&quot;%s AS %s&quot;</span>, zMsg, pItem-&gt;zAlias);
<a name="l02290"></a>02290       }
<a name="l02291"></a>02291       <span class="keywordflow">if</span>( (pIx = pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a>)!=0 ){
<a name="l02292"></a>02292         zMsg = <a class="code" href="printf_8c.html#a8c13cea9062e442b7163031ab6429681">sqlite3MAppendf</a>(db, zMsg, <span class="stringliteral">&quot;%s WITH INDEX %s&quot;</span>, zMsg, pIx-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a>);
<a name="l02293"></a>02293       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; (<a class="code" href="where_8c.html#aa8869a9d16dddbebfe2dc07ff275063e">WHERE_ROWID_EQ</a>|<a class="code" href="where_8c.html#a44adb93652f7601ac8e7b47d1e6b31d4">WHERE_ROWID_RANGE</a>) ){
<a name="l02294"></a>02294         zMsg = <a class="code" href="printf_8c.html#a8c13cea9062e442b7163031ab6429681">sqlite3MAppendf</a>(db, zMsg, <span class="stringliteral">&quot;%s USING PRIMARY KEY&quot;</span>, zMsg);
<a name="l02295"></a>02295       }
<a name="l02296"></a>02296 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l02297"></a>02297 <span class="preprocessor"></span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a64b8d6fb04c7d1d43b891f0f04870100">pBestIdx</a> ){
<a name="l02298"></a>02298         <a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> *pBestIdx = pLevel-&gt;<a class="code" href="structWhereLevel.html#a64b8d6fb04c7d1d43b891f0f04870100">pBestIdx</a>;
<a name="l02299"></a>02299         zMsg = <a class="code" href="printf_8c.html#a8c13cea9062e442b7163031ab6429681">sqlite3MAppendf</a>(db, zMsg, <span class="stringliteral">&quot;%s VIRTUAL TABLE INDEX %d:%s&quot;</span>, zMsg,
<a name="l02300"></a>02300                     pBestIdx-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a>, pBestIdx-&gt;<a class="code" href="structsqlite3__index__info.html#a1a9935e997bd6e3cce048534da7506a7">idxStr</a>);
<a name="l02301"></a>02301       }
<a name="l02302"></a>02302 <span class="preprocessor">#endif</span>
<a name="l02303"></a>02303 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a4caa356cdd5bf6be70e0a2426bfbda2e">WHERE_ORDERBY</a> ){
<a name="l02304"></a>02304         zMsg = <a class="code" href="printf_8c.html#a8c13cea9062e442b7163031ab6429681">sqlite3MAppendf</a>(db, zMsg, <span class="stringliteral">&quot;%s ORDER BY&quot;</span>, zMsg);
<a name="l02305"></a>02305       }
<a name="l02306"></a>02306       <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a8b5bfbed11785aba4cf5d38d37e9ee5e">OP_Explain</a>, i, pLevel-&gt;<a class="code" href="structWhereLevel.html#a2be02022245f9e1e67aacd7c6d70543f">iFrom</a>, 0, zMsg, <a class="code" href="vdbe_8h.html#ae0cac143cf868ae8ec55be2ea9b13e7c">P4_DYNAMIC</a>);
<a name="l02307"></a>02307     }
<a name="l02308"></a>02308 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_EXPLAIN */</span>
<a name="l02309"></a>02309     pTabItem = &amp;pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[pLevel-&gt;<a class="code" href="structWhereLevel.html#a2be02022245f9e1e67aacd7c6d70543f">iFrom</a>];
<a name="l02310"></a>02310     pTab = pTabItem-&gt;pTab;
<a name="l02311"></a>02311     iDb = <a class="code" href="prepare_8c.html#aecd8922611e561d76d5e9f16655e8a7c">sqlite3SchemaToIndex</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>, pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>);
<a name="l02312"></a>02312     <span class="keywordflow">if</span>( (pTab-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a690bd7ef1267d19627fb376f13b6b4c7">TF_Ephemeral</a>)!=0 || pTab-&gt;<a class="code" href="structTable.html#a39d620182fe2174fc97d04094421fa60">pSelect</a> ) <span class="keywordflow">continue</span>;
<a name="l02313"></a>02313 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l02314"></a>02314 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a64b8d6fb04c7d1d43b891f0f04870100">pBestIdx</a> ){
<a name="l02315"></a>02315       <span class="keywordtype">int</span> iCur = pTabItem-&gt;iCursor;
<a name="l02316"></a>02316       <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a46978f7bad0f7fd6157acf8eddaae12e">OP_VOpen</a>, iCur, 0, 0,
<a name="l02317"></a>02317                         (<span class="keyword">const</span> <span class="keywordtype">char</span>*)pTab-&gt;<a class="code" href="structTable.html#a3afc0189fef01642d5259651592a5a2a">pVtab</a>, <a class="code" href="vdbe_8h.html#a7a5cdd538a2cb9cf421f7e2f14b3947f">P4_VTAB</a>);
<a name="l02318"></a>02318     }<span class="keywordflow">else</span>
<a name="l02319"></a>02319 <span class="preprocessor">#endif</span>
<a name="l02320"></a>02320 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( (pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a5c7e944406bbba33acde54aa3fcee124">WHERE_IDX_ONLY</a>)==0 ){
<a name="l02321"></a>02321       <span class="keywordtype">int</span> op = pWInfo-&gt;<a class="code" href="structWhereInfo.html#a851aa1747f940f6ab58505f9326fe9c7">okOnePass</a> ? <a class="code" href="opcodes_8h.html#a98af8f9fca78ddf04bbc472cf2761f10">OP_OpenWrite</a> : <a class="code" href="opcodes_8h.html#a0c72fbe4989449cdc9a69e1bbb2e91c2">OP_OpenRead</a>;
<a name="l02322"></a>02322       <a class="code" href="delete_8c.html#a45432dea9b811619b910763795b476f3">sqlite3OpenTable</a>(pParse, pTabItem-&gt;iCursor, iDb, pTab, op);
<a name="l02323"></a>02323       <span class="keywordflow">if</span>( !pWInfo-&gt;<a class="code" href="structWhereInfo.html#a851aa1747f940f6ab58505f9326fe9c7">okOnePass</a> &amp;&amp; pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>&lt;(<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)*8) ){
<a name="l02324"></a>02324         <a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a> b = pTabItem-&gt;colUsed;
<a name="l02325"></a>02325         <span class="keywordtype">int</span> n = 0;
<a name="l02326"></a>02326         <span class="keywordflow">for</span>(; b; b=b&gt;&gt;1, n++){}
<a name="l02327"></a>02327         <a class="code" href="vdbe_8h.html#ad80ae0e25107f1e56fad9d6eee8f010d">sqlite3VdbeChangeP2</a>(v, <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v)-2, n);
<a name="l02328"></a>02328         assert( n&lt;=pTab-&gt;nCol );
<a name="l02329"></a>02329       }
<a name="l02330"></a>02330     }<span class="keywordflow">else</span>{
<a name="l02331"></a>02331       <a class="code" href="build_8c.html#aee925cce754840aee3425f2ad3156a78">sqlite3TableLock</a>(pParse, iDb, pTab-&gt;<a class="code" href="structTable.html#aebe1abbfb2fd4b5e5dff8e74a4f3c890">tnum</a>, 0, pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>);
<a name="l02332"></a>02332     }
<a name="l02333"></a>02333     pLevel-&gt;<a class="code" href="structWhereLevel.html#aa31c27c3304de936a6ce974450c55592">iTabCur</a> = pTabItem-&gt;iCursor;
<a name="l02334"></a>02334     <span class="keywordflow">if</span>( (pIx = pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a>)!=0 ){
<a name="l02335"></a>02335       <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKey = <a class="code" href="build_8c.html#aa7138838f73483fbf702e0e295dca2fe">sqlite3IndexKeyinfo</a>(pParse, pIx);
<a name="l02336"></a>02336       assert( pIx-&gt;<a class="code" href="structIndex.html#af14f5ddd57eab2aba63dcb5db2aa92af">pSchema</a>==pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a> );
<a name="l02337"></a>02337       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a573b06e057d808cf609dd66f29e0d998">OP_SetNumColumns</a>, 0, pIx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>+1);
<a name="l02338"></a>02338       <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a0c72fbe4989449cdc9a69e1bbb2e91c2">OP_OpenRead</a>, iIdxCur, pIx-&gt;<a class="code" href="structIndex.html#af895a09c01701021c3e36362c04a1ae6">tnum</a>, iDb,
<a name="l02339"></a>02339                         (<span class="keywordtype">char</span>*)pKey, <a class="code" href="vdbe_8h.html#a5a10f433c58f3ce20eb100fa29025e8d">P4_KEYINFO_HANDOFF</a>);
<a name="l02340"></a>02340       <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;%s&quot;</span>, pIx-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a>));
<a name="l02341"></a>02341     }
<a name="l02342"></a>02342     <a class="code" href="build_8c.html#a51b29407b457575a6d04897e7a19d0b6">sqlite3CodeVerifySchema</a>(pParse, iDb);
<a name="l02343"></a>02343   }
<a name="l02344"></a>02344   pWInfo-&gt;<a class="code" href="structWhereInfo.html#a4edc0a92a162cbe63ac8f52e923fb038">iTop</a> = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l02345"></a>02345 
<a name="l02346"></a>02346   <span class="comment">/* Generate the code to do the search.  Each iteration of the for</span>
<a name="l02347"></a>02347 <span class="comment">  ** loop below generates code for a single nested loop of the VM</span>
<a name="l02348"></a>02348 <span class="comment">  ** program.</span>
<a name="l02349"></a>02349 <span class="comment">  */</span>
<a name="l02350"></a>02350   notReady = ~(<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)0;
<a name="l02351"></a>02351   <span class="keywordflow">for</span>(i=0, pLevel=pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>; i&lt;pTabList-&gt;nSrc; i++, pLevel++){
<a name="l02352"></a>02352     <span class="keywordtype">int</span> j, k;
<a name="l02353"></a>02353     <span class="keywordtype">int</span> iCur = pTabItem-&gt;iCursor;  <span class="comment">/* The VDBE cursor for the table */</span>
<a name="l02354"></a>02354     <a class="code" href="structIndex.html">Index</a> *pIdx;       <span class="comment">/* The index we will be using */</span>
<a name="l02355"></a>02355     <span class="keywordtype">int</span> nxt;           <span class="comment">/* Where to jump to continue with the next IN case */</span>
<a name="l02356"></a>02356     <span class="keywordtype">int</span> iIdxCur;       <span class="comment">/* The VDBE cursor for the index */</span>
<a name="l02357"></a>02357     <span class="keywordtype">int</span> omitTable;     <span class="comment">/* True if we use the index only */</span>
<a name="l02358"></a>02358     <span class="keywordtype">int</span> bRev;          <span class="comment">/* True if we need to scan in reverse order */</span>
<a name="l02359"></a>02359 
<a name="l02360"></a>02360     pTabItem = &amp;pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[pLevel-&gt;<a class="code" href="structWhereLevel.html#a2be02022245f9e1e67aacd7c6d70543f">iFrom</a>];
<a name="l02361"></a>02361     iCur = pTabItem-&gt;<a class="code" href="structSrcList_1_1SrcList__item.html#af2e8aae90bd7a00b814db5a2d31f6607">iCursor</a>;
<a name="l02362"></a>02362     pIdx = pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a>;
<a name="l02363"></a>02363     iIdxCur = pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a>;
<a name="l02364"></a>02364     bRev = (pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a63bbf40b47f87166909e9353514c796e">WHERE_REVERSE</a>)!=0;
<a name="l02365"></a>02365     omitTable = (pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a5c7e944406bbba33acde54aa3fcee124">WHERE_IDX_ONLY</a>)!=0;
<a name="l02366"></a>02366 
<a name="l02367"></a>02367     <span class="comment">/* Create labels for the &quot;break&quot; and &quot;continue&quot; instructions</span>
<a name="l02368"></a>02368 <span class="comment">    ** for the current loop.  Jump to brk to break out of a loop.</span>
<a name="l02369"></a>02369 <span class="comment">    ** Jump to cont to go immediately to the next iteration of the</span>
<a name="l02370"></a>02370 <span class="comment">    ** loop.</span>
<a name="l02371"></a>02371 <span class="comment">    **</span>
<a name="l02372"></a>02372 <span class="comment">    ** When there is an IN operator, we also have a &quot;nxt&quot; label that</span>
<a name="l02373"></a>02373 <span class="comment">    ** means to continue with the next IN value combination.  When</span>
<a name="l02374"></a>02374 <span class="comment">    ** there are no IN operators in the constraints, the &quot;nxt&quot; label</span>
<a name="l02375"></a>02375 <span class="comment">    ** is the same as &quot;brk&quot;.</span>
<a name="l02376"></a>02376 <span class="comment">    */</span>
<a name="l02377"></a>02377     brk = pLevel-&gt;<a class="code" href="structWhereLevel.html#a808e8fb50b460226d4e366eefc95e710">brk</a> = pLevel-&gt;<a class="code" href="structWhereLevel.html#a0d59c7ea0c9f698e45b6ff68336630f5">nxt</a> = <a class="code" href="vdbe_8h.html#a5279e16a2acad1e72ba58ae938d385bd">sqlite3VdbeMakeLabel</a>(v);
<a name="l02378"></a>02378     cont = pLevel-&gt;<a class="code" href="structWhereLevel.html#a6f9de984a7e5a9b731b2eb1bb62fd897">cont</a> = <a class="code" href="vdbe_8h.html#a5279e16a2acad1e72ba58ae938d385bd">sqlite3VdbeMakeLabel</a>(v);
<a name="l02379"></a>02379 
<a name="l02380"></a>02380     <span class="comment">/* If this is the right table of a LEFT OUTER JOIN, allocate and</span>
<a name="l02381"></a>02381 <span class="comment">    ** initialize a memory cell that records if this table matches any</span>
<a name="l02382"></a>02382 <span class="comment">    ** row of the left table of the join.</span>
<a name="l02383"></a>02383 <span class="comment">    */</span>
<a name="l02384"></a>02384     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a2be02022245f9e1e67aacd7c6d70543f">iFrom</a>&gt;0 &amp;&amp; (pTabItem[0].jointype &amp; <a class="code" href="sqliteInt_8h.html#ac4edc24e10d5c297818aeb579cb507df">JT_LEFT</a>)!=0 ){
<a name="l02385"></a>02385       pLevel-&gt;<a class="code" href="structWhereLevel.html#a600072864f71c568cabcbb6140f6955a">iLeftJoin</a> = ++pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>;
<a name="l02386"></a>02386       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, 0, pLevel-&gt;<a class="code" href="structWhereLevel.html#a600072864f71c568cabcbb6140f6955a">iLeftJoin</a>);
<a name="l02387"></a>02387       <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;init LEFT JOIN no-match flag&quot;</span>));
<a name="l02388"></a>02388     }
<a name="l02389"></a>02389 
<a name="l02390"></a>02390 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l02391"></a>02391 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a64b8d6fb04c7d1d43b891f0f04870100">pBestIdx</a> ){
<a name="l02392"></a>02392       <span class="comment">/* Case 0:  The table is a virtual-table.  Use the VFilter and VNext</span>
<a name="l02393"></a>02393 <span class="comment">      **          to access the data.</span>
<a name="l02394"></a>02394 <span class="comment">      */</span>
<a name="l02395"></a>02395       <span class="keywordtype">int</span> j;
<a name="l02396"></a>02396       <span class="keywordtype">int</span> iReg;   <span class="comment">/* P3 Value for OP_VFilter */</span>
<a name="l02397"></a>02397       <a class="code" href="structsqlite3__index__info.html">sqlite3_index_info</a> *pBestIdx = pLevel-&gt;<a class="code" href="structWhereLevel.html#a64b8d6fb04c7d1d43b891f0f04870100">pBestIdx</a>;
<a name="l02398"></a>02398       <span class="keywordtype">int</span> nConstraint = pBestIdx-&gt;<a class="code" href="structsqlite3__index__info.html#ae861993a30ce914a5214eab2579d935a">nConstraint</a>;
<a name="l02399"></a>02399       <span class="keyword">struct </span>sqlite3_index_constraint_usage *aUsage =
<a name="l02400"></a>02400                                                   pBestIdx-&gt;<a class="code" href="structsqlite3__index__info.html#a79b8a969dd7d582fc2ea3c0fbc5adb56">aConstraintUsage</a>;
<a name="l02401"></a>02401       <span class="keyword">const</span> <span class="keyword">struct </span>sqlite3_index_constraint *aConstraint =
<a name="l02402"></a>02402                                                   pBestIdx-&gt;<a class="code" href="structsqlite3__index__info.html#a634aa93834e2b47acf34454746c0f248">aConstraint</a>;
<a name="l02403"></a>02403 
<a name="l02404"></a>02404       iReg = <a class="code" href="expr_8c.html#aa8d79db03e9903a3c056652eea2df234">sqlite3GetTempRange</a>(pParse, nConstraint+2);
<a name="l02405"></a>02405       pParse-&gt;<a class="code" href="structParse.html#adf2e7f1d71c7183949e9340febe0f356">disableColCache</a>++;
<a name="l02406"></a>02406       <span class="keywordflow">for</span>(j=1; j&lt;=nConstraint; j++){
<a name="l02407"></a>02407         <span class="keywordtype">int</span> k;
<a name="l02408"></a>02408         <span class="keywordflow">for</span>(k=0; k&lt;nConstraint; k++){
<a name="l02409"></a>02409           <span class="keywordflow">if</span>( aUsage[k].argvIndex==j ){
<a name="l02410"></a>02410             <span class="keywordtype">int</span> iTerm = aConstraint[k].iTermOffset;
<a name="l02411"></a>02411             assert( pParse-&gt;<a class="code" href="structParse.html#adf2e7f1d71c7183949e9340febe0f356">disableColCache</a> );
<a name="l02412"></a>02412             <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, wc.<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[iTerm].<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>, iReg+j+1);
<a name="l02413"></a>02413             <span class="keywordflow">break</span>;
<a name="l02414"></a>02414           }
<a name="l02415"></a>02415         }
<a name="l02416"></a>02416         <span class="keywordflow">if</span>( k==nConstraint ) <span class="keywordflow">break</span>;
<a name="l02417"></a>02417       }
<a name="l02418"></a>02418       assert( pParse-&gt;<a class="code" href="structParse.html#adf2e7f1d71c7183949e9340febe0f356">disableColCache</a> );
<a name="l02419"></a>02419       pParse-&gt;<a class="code" href="structParse.html#adf2e7f1d71c7183949e9340febe0f356">disableColCache</a>--;
<a name="l02420"></a>02420       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, pBestIdx-&gt;<a class="code" href="structsqlite3__index__info.html#afcee17707a1c147fbd55c23c807fdae3">idxNum</a>, iReg);
<a name="l02421"></a>02421       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, j-1, iReg+1);
<a name="l02422"></a>02422       <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, <a class="code" href="opcodes_8h.html#a8ee396bf68f267316ea560fa54587ed2">OP_VFilter</a>, iCur, brk, iReg, pBestIdx-&gt;<a class="code" href="structsqlite3__index__info.html#a1a9935e997bd6e3cce048534da7506a7">idxStr</a>,
<a name="l02423"></a>02423                         pBestIdx-&gt;<a class="code" href="structsqlite3__index__info.html#a5410066c067c3891cdf165c70cc4d6b1">needToFreeIdxStr</a> ? <a class="code" href="vdbe_8h.html#a92364abf7e21288a31956e5fe2dec7f2">P4_MPRINTF</a> : <a class="code" href="vdbe_8h.html#a016db195c237884a5c6a593a36956297">P4_STATIC</a>);
<a name="l02424"></a>02424       <a class="code" href="expr_8c.html#a6fa2fbefc3cf05be866029e9a5eb6361">sqlite3ReleaseTempRange</a>(pParse, iReg, nConstraint+2);
<a name="l02425"></a>02425       pBestIdx-&gt;<a class="code" href="structsqlite3__index__info.html#a5410066c067c3891cdf165c70cc4d6b1">needToFreeIdxStr</a> = 0;
<a name="l02426"></a>02426       <span class="keywordflow">for</span>(j=0; j&lt;nConstraint; j++){
<a name="l02427"></a>02427         <span class="keywordflow">if</span>( aUsage[j].omit ){
<a name="l02428"></a>02428           <span class="keywordtype">int</span> iTerm = aConstraint[j].iTermOffset;
<a name="l02429"></a>02429           <a class="code" href="where_8c.html#a50a51e3dca3d19babeb17d2577889492">disableTerm</a>(pLevel, &amp;wc.<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>[iTerm]);
<a name="l02430"></a>02430         }
<a name="l02431"></a>02431       }
<a name="l02432"></a>02432       pLevel-&gt;<a class="code" href="structWhereLevel.html#aacd5376163427d16ffd43ff71ee475b3">op</a> = <a class="code" href="opcodes_8h.html#aaa87c642373311ebf2c89a120def52de">OP_VNext</a>;
<a name="l02433"></a>02433       pLevel-&gt;<a class="code" href="structWhereLevel.html#ad544492b3388cb82a4b3674e6c1fdb07">p1</a> = iCur;
<a name="l02434"></a>02434       pLevel-&gt;<a class="code" href="structWhereLevel.html#a9c60432a75f2252764e78128e4dad19b">p2</a> = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l02435"></a>02435     }<span class="keywordflow">else</span>
<a name="l02436"></a>02436 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l02437"></a>02437 
<a name="l02438"></a>02438     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#aa8869a9d16dddbebfe2dc07ff275063e">WHERE_ROWID_EQ</a> ){
<a name="l02439"></a>02439       <span class="comment">/* Case 1:  We can directly reference a single row using an</span>
<a name="l02440"></a>02440 <span class="comment">      **          equality comparison against the ROWID field.  Or</span>
<a name="l02441"></a>02441 <span class="comment">      **          we reference multiple rows using a &quot;rowid IN (...)&quot;</span>
<a name="l02442"></a>02442 <span class="comment">      **          construct.</span>
<a name="l02443"></a>02443 <span class="comment">      */</span>
<a name="l02444"></a>02444       <span class="keywordtype">int</span> r1;
<a name="l02445"></a>02445       <span class="keywordtype">int</span> rtmp = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l02446"></a>02446       pTerm = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(&amp;wc, iCur, -1, notReady, <a class="code" href="where_8c.html#ada8cd0d2f7213c03ceadab0c70ba30fa">WO_EQ</a>|<a class="code" href="where_8c.html#a00d0aae2bdf6ae12427acfcacb605db8">WO_IN</a>, 0);
<a name="l02447"></a>02447       assert( pTerm!=0 );
<a name="l02448"></a>02448       assert( pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>!=0 );
<a name="l02449"></a>02449       assert( pTerm-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a>==iCur );
<a name="l02450"></a>02450       assert( omitTable==0 );
<a name="l02451"></a>02451       r1 = <a class="code" href="where_8c.html#a7a4ca4f697a0f1accd8dba96ddcba286">codeEqualityTerm</a>(pParse, pTerm, pLevel, rtmp);
<a name="l02452"></a>02452       nxt = pLevel-&gt;<a class="code" href="structWhereLevel.html#a0d59c7ea0c9f698e45b6ff68336630f5">nxt</a>;
<a name="l02453"></a>02453       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a580e3f6ffe3e1d44076cdc3ae56f05dc">OP_MustBeInt</a>, r1, nxt);
<a name="l02454"></a>02454       <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a52cd591f2f66a915ef7549c215806357">OP_NotExists</a>, iCur, nxt, r1);
<a name="l02455"></a>02455       <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, rtmp);
<a name="l02456"></a>02456       <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;pk&quot;</span>));
<a name="l02457"></a>02457       pLevel-&gt;<a class="code" href="structWhereLevel.html#aacd5376163427d16ffd43ff71ee475b3">op</a> = <a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a>;
<a name="l02458"></a>02458     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a44adb93652f7601ac8e7b47d1e6b31d4">WHERE_ROWID_RANGE</a> ){
<a name="l02459"></a>02459       <span class="comment">/* Case 2:  We have an inequality comparison against the ROWID field.</span>
<a name="l02460"></a>02460 <span class="comment">      */</span>
<a name="l02461"></a>02461       <span class="keywordtype">int</span> testOp = <a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a>;
<a name="l02462"></a>02462       <span class="keywordtype">int</span> start;
<a name="l02463"></a>02463       <a class="code" href="structWhereTerm.html">WhereTerm</a> *pStart, *pEnd;
<a name="l02464"></a>02464 
<a name="l02465"></a>02465       assert( omitTable==0 );
<a name="l02466"></a>02466       pStart = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(&amp;wc, iCur, -1, notReady, <a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>, 0);
<a name="l02467"></a>02467       pEnd = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(&amp;wc, iCur, -1, notReady, <a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a>|<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>, 0);
<a name="l02468"></a>02468       <span class="keywordflow">if</span>( bRev ){
<a name="l02469"></a>02469         pTerm = pStart;
<a name="l02470"></a>02470         pStart = pEnd;
<a name="l02471"></a>02471         pEnd = pTerm;
<a name="l02472"></a>02472       }
<a name="l02473"></a>02473       <span class="keywordflow">if</span>( pStart ){
<a name="l02474"></a>02474         <a class="code" href="structExpr.html">Expr</a> *pX;
<a name="l02475"></a>02475         <span class="keywordtype">int</span> r1;
<a name="l02476"></a>02476         pX = pStart-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>;
<a name="l02477"></a>02477         assert( pX!=0 );
<a name="l02478"></a>02478         assert( pStart-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a>==iCur );
<a name="l02479"></a>02479 
<a name="l02480"></a>02480         <span class="comment">/* The ForceInt instruction may modify the register that it operates</span>
<a name="l02481"></a>02481 <span class="comment">        ** on. For example it may replace a real value with an integer one,</span>
<a name="l02482"></a>02482 <span class="comment">        ** or if p3 is true it may increment the register value. For this</span>
<a name="l02483"></a>02483 <span class="comment">        ** reason we need to make sure that register r1 is really a newly</span>
<a name="l02484"></a>02484 <span class="comment">        ** allocated temporary register, and not part of the column-cache.</span>
<a name="l02485"></a>02485 <span class="comment">        ** For this reason we cannot use sqlite3ExprCodeTemp() here.</span>
<a name="l02486"></a>02486 <span class="comment">        */</span>
<a name="l02487"></a>02487         r1 = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l02488"></a>02488         <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pX-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>, r1);
<a name="l02489"></a>02489 
<a name="l02490"></a>02490         <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a3b3194df2193c809b9b565003698ab04">OP_ForceInt</a>, r1, brk, 
<a name="l02491"></a>02491                              pX-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#ab2968df89b2ff434e31d618a3ac9c2ff">TK_LE</a> || pX-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a>);
<a name="l02492"></a>02492         <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, bRev ? <a class="code" href="opcodes_8h.html#a3f150ff6af921d6c05dbef4ae6fb0e83">OP_MoveLt</a> : <a class="code" href="opcodes_8h.html#a12380781df416d8ce7e57531bc9265c9">OP_MoveGe</a>, iCur, brk, r1);
<a name="l02493"></a>02493         <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;pk&quot;</span>));
<a name="l02494"></a>02494         <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, r1);
<a name="l02495"></a>02495         <a class="code" href="where_8c.html#a50a51e3dca3d19babeb17d2577889492">disableTerm</a>(pLevel, pStart);
<a name="l02496"></a>02496       }<span class="keywordflow">else</span>{
<a name="l02497"></a>02497         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, bRev ? <a class="code" href="opcodes_8h.html#a82f28b02bb768fdd0d4035a89cf976a7">OP_Last</a> : <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>, iCur, brk);
<a name="l02498"></a>02498       }
<a name="l02499"></a>02499       <span class="keywordflow">if</span>( pEnd ){
<a name="l02500"></a>02500         <a class="code" href="structExpr.html">Expr</a> *pX;
<a name="l02501"></a>02501         pX = pEnd-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>;
<a name="l02502"></a>02502         assert( pX!=0 );
<a name="l02503"></a>02503         assert( pEnd-&gt;<a class="code" href="structWhereTerm.html#a1d3303a1acc8d623cfd3a824a71736bd">leftCursor</a>==iCur );
<a name="l02504"></a>02504         pLevel-&gt;<a class="code" href="structWhereLevel.html#a38f4c52a61c99c91590e65849d720465">iMem</a> = ++pParse-&gt;<a class="code" href="structParse.html#aa66b48b0ababc17403615c899cddec9c">nMem</a>;
<a name="l02505"></a>02505         <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pX-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>, pLevel-&gt;<a class="code" href="structWhereLevel.html#a38f4c52a61c99c91590e65849d720465">iMem</a>);
<a name="l02506"></a>02506         <span class="keywordflow">if</span>( pX-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#a8ae3cd6a51a9c976e55f803363ac40d1">TK_LT</a> || pX-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#a035f542186f94631dd42a67c570a9f0e">TK_GT</a> ){
<a name="l02507"></a>02507           testOp = bRev ? <a class="code" href="opcodes_8h.html#ad70eb5497f2f4799b7d32d244af95fcd">OP_Le</a> : <a class="code" href="opcodes_8h.html#a9b76640baf8827c611aa9b75b57c6cf5">OP_Ge</a>;
<a name="l02508"></a>02508         }<span class="keywordflow">else</span>{
<a name="l02509"></a>02509           testOp = bRev ? <a class="code" href="opcodes_8h.html#a155fbf7f5dbfaf24bddb8edb34ecd951">OP_Lt</a> : <a class="code" href="opcodes_8h.html#aadc39fa262bf974a66edbe9924c68794">OP_Gt</a>;
<a name="l02510"></a>02510         }
<a name="l02511"></a>02511         <a class="code" href="where_8c.html#a50a51e3dca3d19babeb17d2577889492">disableTerm</a>(pLevel, pEnd);
<a name="l02512"></a>02512       }
<a name="l02513"></a>02513       start = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l02514"></a>02514       pLevel-&gt;<a class="code" href="structWhereLevel.html#aacd5376163427d16ffd43ff71ee475b3">op</a> = bRev ? <a class="code" href="opcodes_8h.html#ac0b6604f9f9a15223fa7323d090a5a18">OP_Prev</a> : <a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a>;
<a name="l02515"></a>02515       pLevel-&gt;<a class="code" href="structWhereLevel.html#ad544492b3388cb82a4b3674e6c1fdb07">p1</a> = iCur;
<a name="l02516"></a>02516       pLevel-&gt;<a class="code" href="structWhereLevel.html#a9c60432a75f2252764e78128e4dad19b">p2</a> = start;
<a name="l02517"></a>02517       <span class="keywordflow">if</span>( testOp!=<a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a> ){
<a name="l02518"></a>02518         <span class="keywordtype">int</span> r1 = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l02519"></a>02519         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a5a05393545770c35a6071b83679e6be7">OP_Rowid</a>, iCur, r1);
<a name="l02520"></a>02520         <span class="comment">/* sqlite3VdbeAddOp2(v, OP_SCopy, pLevel-&gt;iMem, 0); */</span>
<a name="l02521"></a>02521         <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, testOp, pLevel-&gt;<a class="code" href="structWhereLevel.html#a38f4c52a61c99c91590e65849d720465">iMem</a>, brk, r1);
<a name="l02522"></a>02522         <a class="code" href="vdbe_8h.html#adb56646cb8d4e3ef524755e857b0f702">sqlite3VdbeChangeP5</a>(v, <a class="code" href="sqliteInt_8h.html#acd7dd66f59f94bbb10d8e9a3f0157c38">SQLITE_AFF_NUMERIC</a> | <a class="code" href="sqliteInt_8h.html#ae3bc696255d4fc2767f872371662bcd1">SQLITE_JUMPIFNULL</a>);
<a name="l02523"></a>02523         <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, r1);
<a name="l02524"></a>02524       }
<a name="l02525"></a>02525     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; (<a class="code" href="where_8c.html#a474e72ece833680b7b68a9b2ce914126">WHERE_COLUMN_RANGE</a>|<a class="code" href="where_8c.html#ae64de71ae51ba0f8f4e5fd4d54b9b3f8">WHERE_COLUMN_EQ</a>) ){
<a name="l02526"></a>02526       <span class="comment">/* Case 3: A scan using an index.</span>
<a name="l02527"></a>02527 <span class="comment">      **</span>
<a name="l02528"></a>02528 <span class="comment">      **         The WHERE clause may contain zero or more equality </span>
<a name="l02529"></a>02529 <span class="comment">      **         terms (&quot;==&quot; or &quot;IN&quot; operators) that refer to the N</span>
<a name="l02530"></a>02530 <span class="comment">      **         left-most columns of the index. It may also contain</span>
<a name="l02531"></a>02531 <span class="comment">      **         inequality constraints (&gt;, &lt;, &gt;= or &lt;=) on the indexed</span>
<a name="l02532"></a>02532 <span class="comment">      **         column that immediately follows the N equalities. Only </span>
<a name="l02533"></a>02533 <span class="comment">      **         the right-most column can be an inequality - the rest must</span>
<a name="l02534"></a>02534 <span class="comment">      **         use the &quot;==&quot; and &quot;IN&quot; operators. For example, if the </span>
<a name="l02535"></a>02535 <span class="comment">      **         index is on (x,y,z), then the following clauses are all </span>
<a name="l02536"></a>02536 <span class="comment">      **         optimized:</span>
<a name="l02537"></a>02537 <span class="comment">      **</span>
<a name="l02538"></a>02538 <span class="comment">      **            x=5</span>
<a name="l02539"></a>02539 <span class="comment">      **            x=5 AND y=10</span>
<a name="l02540"></a>02540 <span class="comment">      **            x=5 AND y&lt;10</span>
<a name="l02541"></a>02541 <span class="comment">      **            x=5 AND y&gt;5 AND y&lt;10</span>
<a name="l02542"></a>02542 <span class="comment">      **            x=5 AND y=5 AND z&lt;=10</span>
<a name="l02543"></a>02543 <span class="comment">      **</span>
<a name="l02544"></a>02544 <span class="comment">      **         The z&lt;10 term of the following cannot be used, only</span>
<a name="l02545"></a>02545 <span class="comment">      **         the x=5 term:</span>
<a name="l02546"></a>02546 <span class="comment">      **</span>
<a name="l02547"></a>02547 <span class="comment">      **            x=5 AND z&lt;10</span>
<a name="l02548"></a>02548 <span class="comment">      **</span>
<a name="l02549"></a>02549 <span class="comment">      **         N may be zero if there are inequality constraints.</span>
<a name="l02550"></a>02550 <span class="comment">      **         If there are no inequality constraints, then N is at</span>
<a name="l02551"></a>02551 <span class="comment">      **         least one.</span>
<a name="l02552"></a>02552 <span class="comment">      **</span>
<a name="l02553"></a>02553 <span class="comment">      **         This case is also used when there are no WHERE clause</span>
<a name="l02554"></a>02554 <span class="comment">      **         constraints but an index is selected anyway, in order</span>
<a name="l02555"></a>02555 <span class="comment">      **         to force the output order to conform to an ORDER BY.</span>
<a name="l02556"></a>02556 <span class="comment">      */</span>  
<a name="l02557"></a>02557       <span class="keywordtype">int</span> aStartOp[] = {
<a name="l02558"></a>02558         0,
<a name="l02559"></a>02559         0,
<a name="l02560"></a>02560         <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>,           <span class="comment">/* 2: (!start_constraints &amp;&amp; startEq &amp;&amp;  !bRev) */</span>
<a name="l02561"></a>02561         <a class="code" href="opcodes_8h.html#a82f28b02bb768fdd0d4035a89cf976a7">OP_Last</a>,             <span class="comment">/* 3: (!start_constraints &amp;&amp; startEq &amp;&amp;   bRev) */</span>
<a name="l02562"></a>02562         <a class="code" href="opcodes_8h.html#a81a079df922cabd4b2d6578fc6a8064a">OP_MoveGt</a>,           <span class="comment">/* 4: (start_constraints  &amp;&amp; !startEq &amp;&amp; !bRev) */</span>
<a name="l02563"></a>02563         <a class="code" href="opcodes_8h.html#a3f150ff6af921d6c05dbef4ae6fb0e83">OP_MoveLt</a>,           <span class="comment">/* 5: (start_constraints  &amp;&amp; !startEq &amp;&amp;  bRev) */</span>
<a name="l02564"></a>02564         <a class="code" href="opcodes_8h.html#a12380781df416d8ce7e57531bc9265c9">OP_MoveGe</a>,           <span class="comment">/* 6: (start_constraints  &amp;&amp;  startEq &amp;&amp; !bRev) */</span>
<a name="l02565"></a>02565         <a class="code" href="opcodes_8h.html#a8f37cd62b49195bfc0a0bc709fa5328d">OP_MoveLe</a>            <span class="comment">/* 7: (start_constraints  &amp;&amp;  startEq &amp;&amp;  bRev) */</span>
<a name="l02566"></a>02566       };
<a name="l02567"></a>02567       <span class="keywordtype">int</span> aEndOp[] = {
<a name="l02568"></a>02568         <a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a>,             <span class="comment">/* 0: (!end_constraints) */</span>
<a name="l02569"></a>02569         <a class="code" href="opcodes_8h.html#aa8d1efdb322995dccc4b70e4126f34f7">OP_IdxGE</a>,            <span class="comment">/* 1: (end_constraints &amp;&amp; !bRev) */</span>
<a name="l02570"></a>02570         <a class="code" href="opcodes_8h.html#ac021e76deac29fea2fa6abcc39bb94a4">OP_IdxLT</a>             <span class="comment">/* 2: (end_constraints &amp;&amp; bRev) */</span>
<a name="l02571"></a>02571       };
<a name="l02572"></a>02572       <span class="keywordtype">int</span> nEq = pLevel-&gt;<a class="code" href="structWhereLevel.html#ad55e7102154ca32c946809bd94665504">nEq</a>;
<a name="l02573"></a>02573       <span class="keywordtype">int</span> isMinQuery = 0;          <span class="comment">/* If this is an optimized SELECT min(x).. */</span>
<a name="l02574"></a>02574       <span class="keywordtype">int</span> regBase;                 <span class="comment">/* Base register holding constraint values */</span>
<a name="l02575"></a>02575       <span class="keywordtype">int</span> r1;                      <span class="comment">/* Temp register */</span>
<a name="l02576"></a>02576       <a class="code" href="structWhereTerm.html">WhereTerm</a> *pRangeStart = 0;  <span class="comment">/* Inequality constraint at range start */</span>
<a name="l02577"></a>02577       <a class="code" href="structWhereTerm.html">WhereTerm</a> *pRangeEnd = 0;    <span class="comment">/* Inequality constraint at range end */</span>
<a name="l02578"></a>02578       <span class="keywordtype">int</span> startEq;                 <span class="comment">/* True if range start uses ==, &gt;= or &lt;= */</span>
<a name="l02579"></a>02579       <span class="keywordtype">int</span> endEq;                   <span class="comment">/* True if range end uses ==, &gt;= or &lt;= */</span>
<a name="l02580"></a>02580       <span class="keywordtype">int</span> start_constraints;       <span class="comment">/* Start of range is constrained */</span>
<a name="l02581"></a>02581       <span class="keywordtype">int</span> k = pIdx-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[nEq]; <span class="comment">/* Column for inequality constraints */</span>
<a name="l02582"></a>02582       <span class="keywordtype">int</span> nConstraint;             <span class="comment">/* Number of constraint terms */</span>
<a name="l02583"></a>02583       <span class="keywordtype">int</span> op;
<a name="l02584"></a>02584 
<a name="l02585"></a>02585       <span class="comment">/* Generate code to evaluate all constraint terms using == or IN</span>
<a name="l02586"></a>02586 <span class="comment">      ** and store the values of those terms in an array of registers</span>
<a name="l02587"></a>02587 <span class="comment">      ** starting at regBase.</span>
<a name="l02588"></a>02588 <span class="comment">      */</span>
<a name="l02589"></a>02589       regBase = <a class="code" href="where_8c.html#a6dae82b44c22356b9f0873b6c71fee9b">codeAllEqualityTerms</a>(pParse, pLevel, &amp;wc, notReady, 2);
<a name="l02590"></a>02590       nxt = pLevel-&gt;<a class="code" href="structWhereLevel.html#a0d59c7ea0c9f698e45b6ff68336630f5">nxt</a>;
<a name="l02591"></a>02591 
<a name="l02592"></a>02592       <span class="comment">/* If this loop satisfies a sort order (pOrderBy) request that </span>
<a name="l02593"></a>02593 <span class="comment">      ** was passed to this function to implement a &quot;SELECT min(x) ...&quot; </span>
<a name="l02594"></a>02594 <span class="comment">      ** query, then the caller will only allow the loop to run for</span>
<a name="l02595"></a>02595 <span class="comment">      ** a single iteration. This means that the first row returned</span>
<a name="l02596"></a>02596 <span class="comment">      ** should not have a NULL value stored in &apos;x&apos;. If column &apos;x&apos; is</span>
<a name="l02597"></a>02597 <span class="comment">      ** the first one after the nEq equality constraints in the index,</span>
<a name="l02598"></a>02598 <span class="comment">      ** this requires some special handling.</span>
<a name="l02599"></a>02599 <span class="comment">      */</span>
<a name="l02600"></a>02600       <span class="keywordflow">if</span>( (wflags&amp;<a class="code" href="sqliteInt_8h.html#a9ec8dbac59be945acd066c5b9b08695b">WHERE_ORDERBY_MIN</a>)!=0
<a name="l02601"></a>02601        &amp;&amp; (pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a>&amp;<a class="code" href="where_8c.html#a4caa356cdd5bf6be70e0a2426bfbda2e">WHERE_ORDERBY</a>)
<a name="l02602"></a>02602        &amp;&amp; (pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>&gt;nEq)
<a name="l02603"></a>02603       ){
<a name="l02604"></a>02604         assert( pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>==1 );
<a name="l02605"></a>02605         assert( pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[0].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>==pIdx-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[nEq] );
<a name="l02606"></a>02606         isMinQuery = 1;
<a name="l02607"></a>02607       }
<a name="l02608"></a>02608 
<a name="l02609"></a>02609       <span class="comment">/* Find any inequality constraint terms for the start and end </span>
<a name="l02610"></a>02610 <span class="comment">      ** of the range. </span>
<a name="l02611"></a>02611 <span class="comment">      */</span>
<a name="l02612"></a>02612       <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a235d99551db0e21a521bef747223a2cd">WHERE_TOP_LIMIT</a> ){
<a name="l02613"></a>02613         pRangeEnd = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(&amp;wc, iCur, k, notReady, (<a class="code" href="where_8c.html#a5e0d116d32566fe6ed20a755fe9e31a1">WO_LT</a>|<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>), pIdx);
<a name="l02614"></a>02614       }
<a name="l02615"></a>02615       <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#af6653107415b1dec957976e08d65e528">WHERE_BTM_LIMIT</a> ){
<a name="l02616"></a>02616         pRangeStart = <a class="code" href="where_8c.html#abd23d1178695dfb36bcd6ad837d22eef">findTerm</a>(&amp;wc, iCur, k, notReady, (<a class="code" href="where_8c.html#a17253dc24c2ff12c2e65c1ecc38cf5cc">WO_GT</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>), pIdx);
<a name="l02617"></a>02617       }
<a name="l02618"></a>02618 
<a name="l02619"></a>02619       <span class="comment">/* If we are doing a reverse order scan on an ascending index, or</span>
<a name="l02620"></a>02620 <span class="comment">      ** a forward order scan on a descending index, interchange the </span>
<a name="l02621"></a>02621 <span class="comment">      ** start and end terms (pRangeStart and pRangeEnd).</span>
<a name="l02622"></a>02622 <span class="comment">      */</span>
<a name="l02623"></a>02623       <span class="keywordflow">if</span>( bRev==(pIdx-&gt;<a class="code" href="structIndex.html#a0a3fc87b53193995f59c9657443e9a99">aSortOrder</a>[nEq]==<a class="code" href="sqliteInt_8h.html#abbcf344697e5298ca06f57fd1e0b8419">SQLITE_SO_ASC</a>) ){
<a name="l02624"></a>02624         <a class="code" href="epoc-btprox_8cpp.html#ac0a175517dd38f43b0dbd572e077a7c2">SWAP</a>(<a class="code" href="structWhereTerm.html">WhereTerm</a> *, pRangeEnd, pRangeStart);
<a name="l02625"></a>02625       }
<a name="l02626"></a>02626 
<a name="l02627"></a>02627       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pRangeStart &amp;&amp; pRangeStart-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; <a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a> );
<a name="l02628"></a>02628       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pRangeStart &amp;&amp; pRangeStart-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; <a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a> );
<a name="l02629"></a>02629       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pRangeEnd &amp;&amp; pRangeEnd-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; <a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a> );
<a name="l02630"></a>02630       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pRangeEnd &amp;&amp; pRangeEnd-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; <a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a> );
<a name="l02631"></a>02631       startEq = !pRangeStart || pRangeStart-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; (<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>);
<a name="l02632"></a>02632       endEq =   !pRangeEnd || pRangeEnd-&gt;<a class="code" href="structWhereTerm.html#af0b4817bee491fa1ee69a87d8ff580c5">eOperator</a> &amp; (<a class="code" href="where_8c.html#a999d5451767194a653cd50072c9f6479">WO_LE</a>|<a class="code" href="where_8c.html#a0147762ee55aecb936ef6dd655c69e8c">WO_GE</a>);
<a name="l02633"></a>02633       start_constraints = pRangeStart || nEq&gt;0;
<a name="l02634"></a>02634 
<a name="l02635"></a>02635       <span class="comment">/* Seek the index cursor to the start of the range. */</span>
<a name="l02636"></a>02636       nConstraint = nEq;
<a name="l02637"></a>02637       <span class="keywordflow">if</span>( pRangeStart ){
<a name="l02638"></a>02638         <span class="keywordtype">int</span> dcc = pParse-&gt;<a class="code" href="structParse.html#adf2e7f1d71c7183949e9340febe0f356">disableColCache</a>;
<a name="l02639"></a>02639         <span class="keywordflow">if</span>( pRangeEnd ){
<a name="l02640"></a>02640           pParse-&gt;<a class="code" href="structParse.html#adf2e7f1d71c7183949e9340febe0f356">disableColCache</a>++;
<a name="l02641"></a>02641         }
<a name="l02642"></a>02642         <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pRangeStart-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>, regBase+nEq);
<a name="l02643"></a>02643         pParse-&gt;<a class="code" href="structParse.html#adf2e7f1d71c7183949e9340febe0f356">disableColCache</a> = dcc;
<a name="l02644"></a>02644         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#aa94eede07c1e2c3fcb96239fa368a3d2">OP_IsNull</a>, regBase+nEq, nxt);
<a name="l02645"></a>02645         nConstraint++;
<a name="l02646"></a>02646       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( isMinQuery ){
<a name="l02647"></a>02647         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a9fa8760362f8ea197ca11e99b186206b">OP_Null</a>, 0, regBase+nEq);
<a name="l02648"></a>02648         nConstraint++;
<a name="l02649"></a>02649         startEq = 0;
<a name="l02650"></a>02650         start_constraints = 1;
<a name="l02651"></a>02651       }
<a name="l02652"></a>02652       <a class="code" href="where_8c.html#a035f6bb84d628be6f249071db83b6430">codeApplyAffinity</a>(pParse, regBase, nConstraint, pIdx);
<a name="l02653"></a>02653       op = aStartOp[(start_constraints&lt;&lt;2) + (startEq&lt;&lt;1) + bRev];
<a name="l02654"></a>02654       assert( op!=0 );
<a name="l02655"></a>02655       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( op==<a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a> );
<a name="l02656"></a>02656       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( op==<a class="code" href="opcodes_8h.html#a82f28b02bb768fdd0d4035a89cf976a7">OP_Last</a> );
<a name="l02657"></a>02657       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( op==<a class="code" href="opcodes_8h.html#a81a079df922cabd4b2d6578fc6a8064a">OP_MoveGt</a> );
<a name="l02658"></a>02658       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( op==<a class="code" href="opcodes_8h.html#a12380781df416d8ce7e57531bc9265c9">OP_MoveGe</a> );
<a name="l02659"></a>02659       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( op==<a class="code" href="opcodes_8h.html#a8f37cd62b49195bfc0a0bc709fa5328d">OP_MoveLe</a> );
<a name="l02660"></a>02660       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( op==<a class="code" href="opcodes_8h.html#a3f150ff6af921d6c05dbef4ae6fb0e83">OP_MoveLt</a> );
<a name="l02661"></a>02661       <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, op, iIdxCur, nxt, regBase, 
<a name="l02662"></a>02662                         <a class="code" href="sqliteInt_8h.html#aa723bebdcf79bbac5b54d6e8c378672a">SQLITE_INT_TO_PTR</a>(nConstraint), <a class="code" href="vdbe_8h.html#a985d1d22c0d0a5ceb7546b09e60d31ef">P4_INT32</a>);
<a name="l02663"></a>02663 
<a name="l02664"></a>02664       <span class="comment">/* Load the value for the inequality constraint at the end of the</span>
<a name="l02665"></a>02665 <span class="comment">      ** range (if any).</span>
<a name="l02666"></a>02666 <span class="comment">      */</span>
<a name="l02667"></a>02667       nConstraint = nEq;
<a name="l02668"></a>02668       <span class="keywordflow">if</span>( pRangeEnd ){
<a name="l02669"></a>02669         <a class="code" href="expr_8c.html#ac47d3dc4764060cd103c8b40aeb0c223">sqlite3ExprCode</a>(pParse, pRangeEnd-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>, regBase+nEq);
<a name="l02670"></a>02670         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#aa94eede07c1e2c3fcb96239fa368a3d2">OP_IsNull</a>, regBase+nEq, nxt);
<a name="l02671"></a>02671         <a class="code" href="where_8c.html#a035f6bb84d628be6f249071db83b6430">codeApplyAffinity</a>(pParse, regBase, nEq+1, pIdx);
<a name="l02672"></a>02672         nConstraint++;
<a name="l02673"></a>02673       }
<a name="l02674"></a>02674 
<a name="l02675"></a>02675       <span class="comment">/* Top of the loop body */</span>
<a name="l02676"></a>02676       pLevel-&gt;<a class="code" href="structWhereLevel.html#a9c60432a75f2252764e78128e4dad19b">p2</a> = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l02677"></a>02677 
<a name="l02678"></a>02678       <span class="comment">/* Check if the index cursor is past the end of the range. */</span>
<a name="l02679"></a>02679       op = aEndOp[(pRangeEnd || nEq) * (1 + bRev)];
<a name="l02680"></a>02680       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( op==<a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a> );
<a name="l02681"></a>02681       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( op==<a class="code" href="opcodes_8h.html#aa8d1efdb322995dccc4b70e4126f34f7">OP_IdxGE</a> );
<a name="l02682"></a>02682       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( op==<a class="code" href="opcodes_8h.html#ac021e76deac29fea2fa6abcc39bb94a4">OP_IdxLT</a> );
<a name="l02683"></a>02683       <a class="code" href="vdbe_8h.html#af86c7c232e63393443a474503d3125bc">sqlite3VdbeAddOp4</a>(v, op, iIdxCur, nxt, regBase,
<a name="l02684"></a>02684                         <a class="code" href="sqliteInt_8h.html#aa723bebdcf79bbac5b54d6e8c378672a">SQLITE_INT_TO_PTR</a>(nConstraint), <a class="code" href="vdbe_8h.html#a985d1d22c0d0a5ceb7546b09e60d31ef">P4_INT32</a>);
<a name="l02685"></a>02685       <a class="code" href="vdbe_8h.html#adb56646cb8d4e3ef524755e857b0f702">sqlite3VdbeChangeP5</a>(v, endEq!=bRev);
<a name="l02686"></a>02686 
<a name="l02687"></a>02687       <span class="comment">/* If there are inequality constraints, check that the value</span>
<a name="l02688"></a>02688 <span class="comment">      ** of the table column that the inequality contrains is not NULL.</span>
<a name="l02689"></a>02689 <span class="comment">      ** If it is, jump to the next iteration of the loop.</span>
<a name="l02690"></a>02690 <span class="comment">      */</span>
<a name="l02691"></a>02691       r1 = <a class="code" href="expr_8c.html#ad054539c0385fbb684b89f302c395b86">sqlite3GetTempReg</a>(pParse);
<a name="l02692"></a>02692       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#af6653107415b1dec957976e08d65e528">WHERE_BTM_LIMIT</a> );
<a name="l02693"></a>02693       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a235d99551db0e21a521bef747223a2cd">WHERE_TOP_LIMIT</a> );
<a name="l02694"></a>02694       <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; (<a class="code" href="where_8c.html#af6653107415b1dec957976e08d65e528">WHERE_BTM_LIMIT</a>|<a class="code" href="where_8c.html#a235d99551db0e21a521bef747223a2cd">WHERE_TOP_LIMIT</a>) ){
<a name="l02695"></a>02695         <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a>, iIdxCur, nEq, r1);
<a name="l02696"></a>02696         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#aa94eede07c1e2c3fcb96239fa368a3d2">OP_IsNull</a>, r1, cont);
<a name="l02697"></a>02697       }
<a name="l02698"></a>02698 
<a name="l02699"></a>02699       <span class="comment">/* Seek the table cursor, if required */</span>
<a name="l02700"></a>02700       <span class="keywordflow">if</span>( !omitTable ){
<a name="l02701"></a>02701         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a372ae42237bb1c3a693f057d84e3aa5b">OP_IdxRowid</a>, iIdxCur, r1);
<a name="l02702"></a>02702         <a class="code" href="vdbe_8h.html#a12143dff6644624fde8068e7ecb75c7a">sqlite3VdbeAddOp3</a>(v, <a class="code" href="opcodes_8h.html#a12380781df416d8ce7e57531bc9265c9">OP_MoveGe</a>, iCur, 0, r1);  <span class="comment">/* Deferred seek */</span>
<a name="l02703"></a>02703       }
<a name="l02704"></a>02704       <a class="code" href="expr_8c.html#afe1c272b1c4c5b6c8cb89835e3539bc3">sqlite3ReleaseTempReg</a>(pParse, r1);
<a name="l02705"></a>02705 
<a name="l02706"></a>02706       <span class="comment">/* Record the instruction used to terminate the loop. Disable </span>
<a name="l02707"></a>02707 <span class="comment">      ** WHERE clause terms made redundant by the index range scan.</span>
<a name="l02708"></a>02708 <span class="comment">      */</span>
<a name="l02709"></a>02709       pLevel-&gt;<a class="code" href="structWhereLevel.html#aacd5376163427d16ffd43ff71ee475b3">op</a> = bRev ? <a class="code" href="opcodes_8h.html#ac0b6604f9f9a15223fa7323d090a5a18">OP_Prev</a> : <a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a>;
<a name="l02710"></a>02710       pLevel-&gt;<a class="code" href="structWhereLevel.html#ad544492b3388cb82a4b3674e6c1fdb07">p1</a> = iIdxCur;
<a name="l02711"></a>02711       <a class="code" href="where_8c.html#a50a51e3dca3d19babeb17d2577889492">disableTerm</a>(pLevel, pRangeStart);
<a name="l02712"></a>02712       <a class="code" href="where_8c.html#a50a51e3dca3d19babeb17d2577889492">disableTerm</a>(pLevel, pRangeEnd);
<a name="l02713"></a>02713     }<span class="keywordflow">else</span>{
<a name="l02714"></a>02714       <span class="comment">/* Case 4:  There is no usable index.  We must do a complete</span>
<a name="l02715"></a>02715 <span class="comment">      **          scan of the entire table.</span>
<a name="l02716"></a>02716 <span class="comment">      */</span>
<a name="l02717"></a>02717       assert( omitTable==0 );
<a name="l02718"></a>02718       assert( bRev==0 );
<a name="l02719"></a>02719       pLevel-&gt;<a class="code" href="structWhereLevel.html#aacd5376163427d16ffd43ff71ee475b3">op</a> = <a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a>;
<a name="l02720"></a>02720       pLevel-&gt;<a class="code" href="structWhereLevel.html#ad544492b3388cb82a4b3674e6c1fdb07">p1</a> = iCur;
<a name="l02721"></a>02721       pLevel-&gt;<a class="code" href="structWhereLevel.html#a9c60432a75f2252764e78128e4dad19b">p2</a> = 1 + <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>, iCur, brk);
<a name="l02722"></a>02722       pLevel-&gt;<a class="code" href="structWhereLevel.html#a5674355442208c20e30df6a08e65559e">p5</a> = <a class="code" href="sqlite3_8h.html#af449097c5bd48942fc2d3710bcaa0cfa">SQLITE_STMTSTATUS_FULLSCAN_STEP</a>;
<a name="l02723"></a>02723     }
<a name="l02724"></a>02724     notReady &amp;= ~<a class="code" href="where_8c.html#a330443df7684d9bca657260aea158e0c">getMask</a>(&amp;maskSet, iCur);
<a name="l02725"></a>02725 
<a name="l02726"></a>02726     <span class="comment">/* Insert code to test every subexpression that can be completely</span>
<a name="l02727"></a>02727 <span class="comment">    ** computed using the current set of tables.</span>
<a name="l02728"></a>02728 <span class="comment">    */</span>
<a name="l02729"></a>02729     k = 0;
<a name="l02730"></a>02730     <span class="keywordflow">for</span>(pTerm=wc.<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>, j=wc.<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>; j&gt;0; j--, pTerm++){
<a name="l02731"></a>02731       <a class="code" href="structExpr.html">Expr</a> *pE;
<a name="l02732"></a>02732       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a> );
<a name="l02733"></a>02733       <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">TERM_CODED</a> );
<a name="l02734"></a>02734       <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; (<a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a>|<a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">TERM_CODED</a>) ) <span class="keywordflow">continue</span>;
<a name="l02735"></a>02735       <span class="keywordflow">if</span>( (pTerm-&gt;<a class="code" href="structWhereTerm.html#a49b700336b005067352366cfc40de07f">prereqAll</a> &amp; notReady)!=0 ) <span class="keywordflow">continue</span>;
<a name="l02736"></a>02736       pE = pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>;
<a name="l02737"></a>02737       assert( pE!=0 );
<a name="l02738"></a>02738       <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a600072864f71c568cabcbb6140f6955a">iLeftJoin</a> &amp;&amp; !<a class="code" href="sqliteInt_8h.html#a70ceb3fd7e20d6b0565b359158c7f1d7">ExprHasProperty</a>(pE, <a class="code" href="sqliteInt_8h.html#a6bd31d1397219a9745a840e48dd49a53">EP_FromJoin</a>) ){
<a name="l02739"></a>02739         <span class="keywordflow">continue</span>;
<a name="l02740"></a>02740       }
<a name="l02741"></a>02741       pParse-&gt;<a class="code" href="structParse.html#adf2e7f1d71c7183949e9340febe0f356">disableColCache</a> += k;
<a name="l02742"></a>02742       <a class="code" href="expr_8c.html#ac21b74c1bf28cc39d708b8f1375380d9">sqlite3ExprIfFalse</a>(pParse, pE, cont, <a class="code" href="sqliteInt_8h.html#ae3bc696255d4fc2767f872371662bcd1">SQLITE_JUMPIFNULL</a>);
<a name="l02743"></a>02743       pParse-&gt;<a class="code" href="structParse.html#adf2e7f1d71c7183949e9340febe0f356">disableColCache</a> -= k;
<a name="l02744"></a>02744       k = 1;
<a name="l02745"></a>02745       pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> |= <a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">TERM_CODED</a>;
<a name="l02746"></a>02746     }
<a name="l02747"></a>02747 
<a name="l02748"></a>02748     <span class="comment">/* For a LEFT OUTER JOIN, generate code that will record the fact that</span>
<a name="l02749"></a>02749 <span class="comment">    ** at least one row of the right table has matched the left table.  </span>
<a name="l02750"></a>02750 <span class="comment">    */</span>
<a name="l02751"></a>02751     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a600072864f71c568cabcbb6140f6955a">iLeftJoin</a> ){
<a name="l02752"></a>02752       pLevel-&gt;<a class="code" href="structWhereLevel.html#a8960310456f9ad473b88e40aff23a8d4">top</a> = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l02753"></a>02753       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>, 1, pLevel-&gt;<a class="code" href="structWhereLevel.html#a600072864f71c568cabcbb6140f6955a">iLeftJoin</a>);
<a name="l02754"></a>02754       <a class="code" href="vdbe_8h.html#aacb89fdebce8fad2d65af6c1159f8742">VdbeComment</a>((v, <span class="stringliteral">&quot;record LEFT JOIN hit&quot;</span>));
<a name="l02755"></a>02755       <a class="code" href="expr_8c.html#ab795cc5e01000014a17845ff726e8bfe">sqlite3ExprClearColumnCache</a>(pParse, pLevel-&gt;<a class="code" href="structWhereLevel.html#aa31c27c3304de936a6ce974450c55592">iTabCur</a>);
<a name="l02756"></a>02756       <a class="code" href="expr_8c.html#ab795cc5e01000014a17845ff726e8bfe">sqlite3ExprClearColumnCache</a>(pParse, pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a>);
<a name="l02757"></a>02757       <span class="keywordflow">for</span>(pTerm=wc.<a class="code" href="structWhereClause.html#a140d726a3e20ac7b6853d539c59add72">a</a>, j=0; j&lt;wc.<a class="code" href="structWhereClause.html#ab84924c3c78af1ab387ab3919c5031c4">nTerm</a>; j++, pTerm++){
<a name="l02758"></a>02758         <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a> );
<a name="l02759"></a>02759         <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; <a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">TERM_CODED</a> );
<a name="l02760"></a>02760         <span class="keywordflow">if</span>( pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> &amp; (<a class="code" href="where_8c.html#a30a502c01ca56dd8e1d82dec415486e2">TERM_VIRTUAL</a>|<a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">TERM_CODED</a>) ) <span class="keywordflow">continue</span>;
<a name="l02761"></a>02761         <span class="keywordflow">if</span>( (pTerm-&gt;<a class="code" href="structWhereTerm.html#a49b700336b005067352366cfc40de07f">prereqAll</a> &amp; notReady)!=0 ) <span class="keywordflow">continue</span>;
<a name="l02762"></a>02762         assert( pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a> );
<a name="l02763"></a>02763         <a class="code" href="expr_8c.html#ac21b74c1bf28cc39d708b8f1375380d9">sqlite3ExprIfFalse</a>(pParse, pTerm-&gt;<a class="code" href="structWhereTerm.html#af5ec32fe3a2e4623c900cb91aa86bc9d">pExpr</a>, cont, <a class="code" href="sqliteInt_8h.html#ae3bc696255d4fc2767f872371662bcd1">SQLITE_JUMPIFNULL</a>);
<a name="l02764"></a>02764         pTerm-&gt;<a class="code" href="structWhereTerm.html#aa6fb66acde421e40cf65535929f2b716">flags</a> |= <a class="code" href="where_8c.html#a564a8820a15652a2f021520c6cef5924">TERM_CODED</a>;
<a name="l02765"></a>02765       }
<a name="l02766"></a>02766     }
<a name="l02767"></a>02767   }
<a name="l02768"></a>02768 
<a name="l02769"></a>02769 <span class="preprocessor">#ifdef SQLITE_TEST  </span><span class="comment">/* For testing and debugging use only */</span>
<a name="l02770"></a>02770   <span class="comment">/* Record in the query plan information about the current table</span>
<a name="l02771"></a>02771 <span class="comment">  ** and the index used to access it (if any).  If the table itself</span>
<a name="l02772"></a>02772 <span class="comment">  ** is not used, its name is just &apos;{}&apos;.  If no index is used</span>
<a name="l02773"></a>02773 <span class="comment">  ** the index is listed as &quot;{}&quot;.  If the primary key is used the</span>
<a name="l02774"></a>02774 <span class="comment">  ** index name is &apos;*&apos;.</span>
<a name="l02775"></a>02775 <span class="comment">  */</span>
<a name="l02776"></a>02776   <span class="keywordflow">for</span>(i=0; i&lt;pTabList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>; i++){
<a name="l02777"></a>02777     <span class="keywordtype">char</span> *z;
<a name="l02778"></a>02778     <span class="keywordtype">int</span> n;
<a name="l02779"></a>02779     pLevel = &amp;pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>[i];
<a name="l02780"></a>02780     pTabItem = &amp;pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[pLevel-&gt;<a class="code" href="structWhereLevel.html#a2be02022245f9e1e67aacd7c6d70543f">iFrom</a>];
<a name="l02781"></a>02781     z = pTabItem-&gt;<a class="code" href="structSrcList_1_1SrcList__item.html#a461ef8d80828ed8dd4409b9244ae2919">zAlias</a>;
<a name="l02782"></a>02782     <span class="keywordflow">if</span>( z==0 ) z = pTabItem-&gt;pTab-&gt;zName;
<a name="l02783"></a>02783     n = strlen(z);
<a name="l02784"></a>02784     <span class="keywordflow">if</span>( n+nQPlan &lt; <span class="keyword">sizeof</span>(sqlite3_query_plan)-10 ){
<a name="l02785"></a>02785       <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a5c7e944406bbba33acde54aa3fcee124">WHERE_IDX_ONLY</a> ){
<a name="l02786"></a>02786         memcpy(&amp;sqlite3_query_plan[nQPlan], <span class="stringliteral">&quot;{}&quot;</span>, 2);
<a name="l02787"></a>02787         nQPlan += 2;
<a name="l02788"></a>02788       }<span class="keywordflow">else</span>{
<a name="l02789"></a>02789         memcpy(&amp;sqlite3_query_plan[nQPlan], z, n);
<a name="l02790"></a>02790         nQPlan += n;
<a name="l02791"></a>02791       }
<a name="l02792"></a>02792       sqlite3_query_plan[nQPlan++] = <span class="charliteral">&apos; &apos;</span>;
<a name="l02793"></a>02793     }
<a name="l02794"></a>02794     <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#aa8869a9d16dddbebfe2dc07ff275063e">WHERE_ROWID_EQ</a> );
<a name="l02795"></a>02795     <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a44adb93652f7601ac8e7b47d1e6b31d4">WHERE_ROWID_RANGE</a> );
<a name="l02796"></a>02796     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; (<a class="code" href="where_8c.html#aa8869a9d16dddbebfe2dc07ff275063e">WHERE_ROWID_EQ</a>|<a class="code" href="where_8c.html#a44adb93652f7601ac8e7b47d1e6b31d4">WHERE_ROWID_RANGE</a>) ){
<a name="l02797"></a>02797       memcpy(&amp;sqlite3_query_plan[nQPlan], <span class="stringliteral">&quot;* &quot;</span>, 2);
<a name="l02798"></a>02798       nQPlan += 2;
<a name="l02799"></a>02799     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a>==0 ){
<a name="l02800"></a>02800       memcpy(&amp;sqlite3_query_plan[nQPlan], <span class="stringliteral">&quot;{} &quot;</span>, 3);
<a name="l02801"></a>02801       nQPlan += 3;
<a name="l02802"></a>02802     }<span class="keywordflow">else</span>{
<a name="l02803"></a>02803       n = strlen(pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a>-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a>);
<a name="l02804"></a>02804       <span class="keywordflow">if</span>( n+nQPlan &lt; <span class="keyword">sizeof</span>(sqlite3_query_plan)-2 ){
<a name="l02805"></a>02805         memcpy(&amp;sqlite3_query_plan[nQPlan], pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a>-&gt;<a class="code" href="structIndex.html#a8848cddf6e09f22e3b794ec019082ced">zName</a>, n);
<a name="l02806"></a>02806         nQPlan += n;
<a name="l02807"></a>02807         sqlite3_query_plan[nQPlan++] = <span class="charliteral">&apos; &apos;</span>;
<a name="l02808"></a>02808       }
<a name="l02809"></a>02809     }
<a name="l02810"></a>02810   }
<a name="l02811"></a>02811   <span class="keywordflow">while</span>( nQPlan&gt;0 &amp;&amp; sqlite3_query_plan[nQPlan-1]==<span class="charliteral">&apos; &apos;</span> ){
<a name="l02812"></a>02812     sqlite3_query_plan[--nQPlan] = 0;
<a name="l02813"></a>02813   }
<a name="l02814"></a>02814   sqlite3_query_plan[nQPlan] = 0;
<a name="l02815"></a>02815   nQPlan = 0;
<a name="l02816"></a>02816 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_TEST // Testing and debugging use only */</span>
<a name="l02817"></a>02817 
<a name="l02818"></a>02818   <span class="comment">/* Record the continuation address in the WhereInfo structure.  Then</span>
<a name="l02819"></a>02819 <span class="comment">  ** clean up and return.</span>
<a name="l02820"></a>02820 <span class="comment">  */</span>
<a name="l02821"></a>02821   pWInfo-&gt;<a class="code" href="structWhereInfo.html#a5b8eb73a6a5bba7ef126b9de13ee8537">iContinue</a> = cont;
<a name="l02822"></a>02822   <a class="code" href="where_8c.html#adb29ca8d094e2324f7fc20962502d8c9">whereClauseClear</a>(&amp;wc);
<a name="l02823"></a>02823   <span class="keywordflow">return</span> pWInfo;
<a name="l02824"></a>02824 
<a name="l02825"></a>02825   <span class="comment">/* Jump here if malloc fails */</span>
<a name="l02826"></a>02826 whereBeginError:
<a name="l02827"></a>02827   <a class="code" href="where_8c.html#adb29ca8d094e2324f7fc20962502d8c9">whereClauseClear</a>(&amp;wc);
<a name="l02828"></a>02828   <a class="code" href="where_8c.html#a4838f169cd94b3192f9a49558dca6ae0">whereInfoFree</a>(db, pWInfo);
<a name="l02829"></a>02829   <span class="keywordflow">return</span> 0;
<a name="l02830"></a>02830 }
<a name="l02831"></a>02831 
<a name="l02832"></a>02832 <span class="comment">/*</span>
<a name="l02833"></a>02833 <span class="comment">** Generate the end of the WHERE loop.  See comments on </span>
<a name="l02834"></a>02834 <span class="comment">** sqlite3WhereBegin() for additional information.</span>
<a name="l02835"></a>02835 <span class="comment">*/</span>
<a name="l02836"></a><a class="code" href="where_8c.html#ab7497539f066dfbc5278f819176c1670">02836</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#ad37330a32667067fb71acc8dfeae0d41">sqlite3WhereEnd</a>(<a class="code" href="structWhereInfo.html">WhereInfo</a> *pWInfo){
<a name="l02837"></a>02837   <a class="code" href="structParse.html">Parse</a> *pParse = pWInfo-&gt;<a class="code" href="structWhereInfo.html#a26745055cd13360536fb4b074db358f9">pParse</a>;
<a name="l02838"></a>02838   <a class="code" href="structVdbe.html">Vdbe</a> *v = pParse-&gt;<a class="code" href="structParse.html#a81774053fd5063046f532c07e3daa98b">pVdbe</a>;
<a name="l02839"></a>02839   <span class="keywordtype">int</span> i;
<a name="l02840"></a>02840   <a class="code" href="structWhereLevel.html">WhereLevel</a> *pLevel;
<a name="l02841"></a>02841   <a class="code" href="structSrcList.html">SrcList</a> *pTabList = pWInfo-&gt;<a class="code" href="structWhereInfo.html#a0f43432aeca75640c96a69f6a82aa138">pTabList</a>;
<a name="l02842"></a>02842   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l02843"></a>02843 
<a name="l02844"></a>02844   <span class="comment">/* Generate loop termination code.</span>
<a name="l02845"></a>02845 <span class="comment">  */</span>
<a name="l02846"></a>02846   <a class="code" href="expr_8c.html#ab795cc5e01000014a17845ff726e8bfe">sqlite3ExprClearColumnCache</a>(pParse, -1);
<a name="l02847"></a>02847   <span class="keywordflow">for</span>(i=pTabList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>-1; i&gt;=0; i--){
<a name="l02848"></a>02848     pLevel = &amp;pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>[i];
<a name="l02849"></a>02849     <a class="code" href="vdbe_8h.html#aea27581f782aaa7e14ae22a3c061f483">sqlite3VdbeResolveLabel</a>(v, pLevel-&gt;<a class="code" href="structWhereLevel.html#a6f9de984a7e5a9b731b2eb1bb62fd897">cont</a>);
<a name="l02850"></a>02850     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#aacd5376163427d16ffd43ff71ee475b3">op</a>!=<a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a> ){
<a name="l02851"></a>02851       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, pLevel-&gt;<a class="code" href="structWhereLevel.html#aacd5376163427d16ffd43ff71ee475b3">op</a>, pLevel-&gt;<a class="code" href="structWhereLevel.html#ad544492b3388cb82a4b3674e6c1fdb07">p1</a>, pLevel-&gt;<a class="code" href="structWhereLevel.html#a9c60432a75f2252764e78128e4dad19b">p2</a>);
<a name="l02852"></a>02852       <a class="code" href="vdbe_8h.html#adb56646cb8d4e3ef524755e857b0f702">sqlite3VdbeChangeP5</a>(v, pLevel-&gt;<a class="code" href="structWhereLevel.html#a5674355442208c20e30df6a08e65559e">p5</a>);
<a name="l02853"></a>02853     }
<a name="l02854"></a>02854     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a276238755297111ab44551dcf4f61392">nIn</a> ){
<a name="l02855"></a>02855       <span class="keyword">struct </span>InLoop *pIn;
<a name="l02856"></a>02856       <span class="keywordtype">int</span> j;
<a name="l02857"></a>02857       <a class="code" href="vdbe_8h.html#aea27581f782aaa7e14ae22a3c061f483">sqlite3VdbeResolveLabel</a>(v, pLevel-&gt;<a class="code" href="structWhereLevel.html#a0d59c7ea0c9f698e45b6ff68336630f5">nxt</a>);
<a name="l02858"></a>02858       <span class="keywordflow">for</span>(j=pLevel-&gt;<a class="code" href="structWhereLevel.html#a276238755297111ab44551dcf4f61392">nIn</a>, pIn=&amp;pLevel-&gt;<a class="code" href="structWhereLevel.html#a2f5661de0daeb57b8df19ffbb705e436">aInLoop</a>[j-1]; j&gt;0; j--, pIn--){
<a name="l02859"></a>02859         <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, pIn-&gt;topAddr+1);
<a name="l02860"></a>02860         <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a>, pIn-&gt;iCur, pIn-&gt;topAddr);
<a name="l02861"></a>02861         <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, pIn-&gt;topAddr-1);
<a name="l02862"></a>02862       }
<a name="l02863"></a>02863       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pLevel-&gt;<a class="code" href="structWhereLevel.html#a2f5661de0daeb57b8df19ffbb705e436">aInLoop</a>);
<a name="l02864"></a>02864     }
<a name="l02865"></a>02865     <a class="code" href="vdbe_8h.html#aea27581f782aaa7e14ae22a3c061f483">sqlite3VdbeResolveLabel</a>(v, pLevel-&gt;<a class="code" href="structWhereLevel.html#a808e8fb50b460226d4e366eefc95e710">brk</a>);
<a name="l02866"></a>02866     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a600072864f71c568cabcbb6140f6955a">iLeftJoin</a> ){
<a name="l02867"></a>02867       <span class="keywordtype">int</span> addr;
<a name="l02868"></a>02868       addr = <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#ac568254599af4699a2e12fc88dbc69f9">OP_IfPos</a>, pLevel-&gt;<a class="code" href="structWhereLevel.html#a600072864f71c568cabcbb6140f6955a">iLeftJoin</a>);
<a name="l02869"></a>02869       <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a8436c9b66cd27597a1ddd5c5b05d4baf">OP_NullRow</a>, pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[i].<a class="code" href="structSrcList_1_1SrcList__item.html#af2e8aae90bd7a00b814db5a2d31f6607">iCursor</a>);
<a name="l02870"></a>02870       <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a>&gt;=0 ){
<a name="l02871"></a>02871         <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a8436c9b66cd27597a1ddd5c5b05d4baf">OP_NullRow</a>, pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a>);
<a name="l02872"></a>02872       }
<a name="l02873"></a>02873       <a class="code" href="vdbe_8h.html#a7d56bb85b080a9461610763a4f83ef33">sqlite3VdbeAddOp2</a>(v, <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>, 0, pLevel-&gt;<a class="code" href="structWhereLevel.html#a8960310456f9ad473b88e40aff23a8d4">top</a>);
<a name="l02874"></a>02874       <a class="code" href="vdbe_8h.html#a24089b5911246ef4efd52da2ad723e5c">sqlite3VdbeJumpHere</a>(v, addr);
<a name="l02875"></a>02875     }
<a name="l02876"></a>02876   }
<a name="l02877"></a>02877 
<a name="l02878"></a>02878   <span class="comment">/* The &quot;break&quot; point is here, just past the end of the outer loop.</span>
<a name="l02879"></a>02879 <span class="comment">  ** Set it.</span>
<a name="l02880"></a>02880 <span class="comment">  */</span>
<a name="l02881"></a>02881   <a class="code" href="vdbe_8h.html#aea27581f782aaa7e14ae22a3c061f483">sqlite3VdbeResolveLabel</a>(v, pWInfo-&gt;<a class="code" href="structWhereInfo.html#a338ac73b84c81db455ad7db56b5e4a06">iBreak</a>);
<a name="l02882"></a>02882 
<a name="l02883"></a>02883   <span class="comment">/* Close all of the cursors that were opened by sqlite3WhereBegin.</span>
<a name="l02884"></a>02884 <span class="comment">  */</span>
<a name="l02885"></a>02885   <span class="keywordflow">for</span>(i=0, pLevel=pWInfo-&gt;<a class="code" href="structWhereInfo.html#a427337160cbeaf64b23a8241fb10dbf9">a</a>; i&lt;pTabList-&gt;nSrc; i++, pLevel++){
<a name="l02886"></a>02886     <span class="keyword">struct </span>SrcList_item *pTabItem = &amp;pTabList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[pLevel-&gt;<a class="code" href="structWhereLevel.html#a2be02022245f9e1e67aacd7c6d70543f">iFrom</a>];
<a name="l02887"></a>02887     <a class="code" href="structTable.html">Table</a> *pTab = pTabItem-&gt;<a class="code" href="structSrcList_1_1SrcList__item.html#a8779b2d10d0e25af78ad90e57f9cd4f6">pTab</a>;
<a name="l02888"></a>02888     assert( pTab!=0 );
<a name="l02889"></a>02889     <span class="keywordflow">if</span>( (pTab-&gt;<a class="code" href="structTable.html#ab0aeb112ae7e1b81e2a18bc493f7992c">tabFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a690bd7ef1267d19627fb376f13b6b4c7">TF_Ephemeral</a>)!=0 || pTab-&gt;<a class="code" href="structTable.html#a39d620182fe2174fc97d04094421fa60">pSelect</a> ) <span class="keywordflow">continue</span>;
<a name="l02890"></a>02890     <span class="keywordflow">if</span>( !pWInfo-&gt;<a class="code" href="structWhereInfo.html#a851aa1747f940f6ab58505f9326fe9c7">okOnePass</a> &amp;&amp; (pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a5c7e944406bbba33acde54aa3fcee124">WHERE_IDX_ONLY</a>)==0 ){
<a name="l02891"></a>02891       <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, pTabItem-&gt;iCursor);
<a name="l02892"></a>02892     }
<a name="l02893"></a>02893     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a>!=0 ){
<a name="l02894"></a>02894       <a class="code" href="vdbe_8h.html#a422e10ccdbc193c2da411dc717afd913">sqlite3VdbeAddOp1</a>(v, <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>, pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a>);
<a name="l02895"></a>02895     }
<a name="l02896"></a>02896 
<a name="l02897"></a>02897     <span class="comment">/* If this scan uses an index, make code substitutions to read data</span>
<a name="l02898"></a>02898 <span class="comment">    ** from the index in preference to the table. Sometimes, this means</span>
<a name="l02899"></a>02899 <span class="comment">    ** the table need never be read from. This is a performance boost,</span>
<a name="l02900"></a>02900 <span class="comment">    ** as the vdbe level waits until the table is read before actually</span>
<a name="l02901"></a>02901 <span class="comment">    ** seeking the table cursor to the record corresponding to the current</span>
<a name="l02902"></a>02902 <span class="comment">    ** position in the index.</span>
<a name="l02903"></a>02903 <span class="comment">    ** </span>
<a name="l02904"></a>02904 <span class="comment">    ** Calls to the code generator in between sqlite3WhereBegin and</span>
<a name="l02905"></a>02905 <span class="comment">    ** sqlite3WhereEnd will have created code that references the table</span>
<a name="l02906"></a>02906 <span class="comment">    ** directly.  This loop scans all that code looking for opcodes</span>
<a name="l02907"></a>02907 <span class="comment">    ** that reference the table and converts them into opcodes that</span>
<a name="l02908"></a>02908 <span class="comment">    ** reference the index.</span>
<a name="l02909"></a>02909 <span class="comment">    */</span>
<a name="l02910"></a>02910     <span class="keywordflow">if</span>( pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a> ){
<a name="l02911"></a>02911       <span class="keywordtype">int</span> k, j, last;
<a name="l02912"></a>02912       <a class="code" href="structVdbeOp.html">VdbeOp</a> *pOp;
<a name="l02913"></a>02913       <a class="code" href="structIndex.html">Index</a> *pIdx = pLevel-&gt;<a class="code" href="structWhereLevel.html#a343b88412a928f6b824ed61873ff61e5">pIdx</a>;
<a name="l02914"></a>02914       <span class="keywordtype">int</span> useIndexOnly = pLevel-&gt;<a class="code" href="structWhereLevel.html#a6374ab92f58eac84e0f59906f2f36f5f">flags</a> &amp; <a class="code" href="where_8c.html#a5c7e944406bbba33acde54aa3fcee124">WHERE_IDX_ONLY</a>;
<a name="l02915"></a>02915 
<a name="l02916"></a>02916       assert( pIdx!=0 );
<a name="l02917"></a>02917       pOp = <a class="code" href="vdbe_8h.html#a1badd052381dc9cd17422bcc7e09db43">sqlite3VdbeGetOp</a>(v, pWInfo-&gt;<a class="code" href="structWhereInfo.html#a4edc0a92a162cbe63ac8f52e923fb038">iTop</a>);
<a name="l02918"></a>02918       last = <a class="code" href="vdbe_8h.html#a8a73fb57fa0a5e758ade8c531907e466">sqlite3VdbeCurrentAddr</a>(v);
<a name="l02919"></a>02919       <span class="keywordflow">for</span>(k=pWInfo-&gt;<a class="code" href="structWhereInfo.html#a4edc0a92a162cbe63ac8f52e923fb038">iTop</a>; k&lt;last; k++, pOp++){
<a name="l02920"></a>02920         <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>!=pLevel-&gt;<a class="code" href="structWhereLevel.html#aa31c27c3304de936a6ce974450c55592">iTabCur</a> ) <span class="keywordflow">continue</span>;
<a name="l02921"></a>02921         <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a> ){
<a name="l02922"></a>02922           <span class="keywordflow">for</span>(j=0; j&lt;pIdx-&gt;<a class="code" href="structIndex.html#ac583449830c285a52d1fd10b8c890162">nColumn</a>; j++){
<a name="l02923"></a>02923             <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>==pIdx-&gt;<a class="code" href="structIndex.html#acbb125339b02ca6819dd2e382de2d639">aiColumn</a>[j] ){
<a name="l02924"></a>02924               pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> = j;
<a name="l02925"></a>02925               pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> = pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a>;
<a name="l02926"></a>02926               <span class="keywordflow">break</span>;
<a name="l02927"></a>02927             }
<a name="l02928"></a>02928           }
<a name="l02929"></a>02929           assert(!useIndexOnly || j&lt;pIdx-&gt;nColumn);
<a name="l02930"></a>02930         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a5a05393545770c35a6071b83679e6be7">OP_Rowid</a> ){
<a name="l02931"></a>02931           pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> = pLevel-&gt;<a class="code" href="structWhereLevel.html#a0733f34c7987c721351ab0001d4b1dd9">iIdxCur</a>;
<a name="l02932"></a>02932           pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> = <a class="code" href="opcodes_8h.html#a372ae42237bb1c3a693f057d84e3aa5b">OP_IdxRowid</a>;
<a name="l02933"></a>02933         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a8436c9b66cd27597a1ddd5c5b05d4baf">OP_NullRow</a> &amp;&amp; useIndexOnly ){
<a name="l02934"></a>02934           pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> = <a class="code" href="opcodes_8h.html#a386505cfdd62821f982f5383305d78d2">OP_Noop</a>;
<a name="l02935"></a>02935         }
<a name="l02936"></a>02936       }
<a name="l02937"></a>02937     }
<a name="l02938"></a>02938   }
<a name="l02939"></a>02939 
<a name="l02940"></a>02940   <span class="comment">/* Final cleanup</span>
<a name="l02941"></a>02941 <span class="comment">  */</span>
<a name="l02942"></a>02942   <a class="code" href="where_8c.html#a4838f169cd94b3192f9a49558dca6ae0">whereInfoFree</a>(db, pWInfo);
<a name="l02943"></a>02943   <span class="keywordflow">return</span>;
<a name="l02944"></a>02944 }
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:57 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
