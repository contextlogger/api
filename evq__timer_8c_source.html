<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: evq_timer.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_bf2b3bdb1651bc5322e1494d35fecc4b.html">shared</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_0c37473320d0f0bf464654b3047150fd.html">common</a>
  </div>
</div>
<div class="contents">
<h1>evq_timer.c</h1><a href="evq__timer_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &quot;<a class="code" href="evq__timer_8h.html">common/evq_timer.h</a>&quot;</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &quot;<a class="code" href="logging_8h.html">common/logging.h</a>&quot;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;<a class="code" href="assertions_8h.html">common/assertions.h</a>&quot;</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;asm-generic/errno.h&gt;</span> <span class="comment">// ETIMEDOUT</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="comment">// We will have the event framework make this callback when it is time to process an event.</span>
<a name="l00011"></a><a class="code" href="evq__timer_8c.html#ad3c58b9d3dfc92c6a7e82fea6e3e1739">00011</a> <span class="keyword">static</span> <a class="code" href="evq__event_8h.html#a5a16010b63b7fc8efe6dcccec6bad442">MAYBE_ERROR_RTYPE</a> <a class="code" href="evq__timer_8c.html#ad3c58b9d3dfc92c6a7e82fea6e3e1739">event_cb</a>(<a class="code" href="struct__Event.html">Event</a>* event <a class="code" href="evq__event_8h.html#a33c485b1c23471c07c345fdfcacf8c13">MAYBE_ERROR_PARAM</a>)
<a name="l00012"></a>00012 {
<a name="l00013"></a>00013   <a class="code" href="structTimer.html">Timer</a>* timer = (<a class="code" href="structTimer.html">Timer</a>*)event;
<a name="l00014"></a>00014   <a class="code" href="evq__event_8h.html#a23fd9f6f1a7305e024ae8a8a42086aea">MAYBE_ERROR_INVOKE</a>((*timer-&gt;<a class="code" href="structTimer.html#abd00c0de5571d594beed927f11af0ebc">callback</a>), 0, timer-&gt;<a class="code" href="structTimer.html#ab63f401004cd126319cab7354f5beb53">user_data</a>);
<a name="l00015"></a>00015   <a class="code" href="evq__event_8h.html#a07e84f7e6386f2faa03c22a5da1f6a23">MAYBE_ERROR_RETURN</a>;
<a name="l00016"></a>00016 }
<a name="l00017"></a>00017 
<a name="l00018"></a><a class="code" href="evq__timer_8c.html#ab76df023fd9715f5e1004853f0067287">00018</a> <span class="keyword">static</span> <span class="keywordtype">void</span>* <a class="code" href="evq__timer_8c.html#ab76df023fd9715f5e1004853f0067287">worker_task</a>(<span class="keywordtype">void</span>* arg)
<a name="l00019"></a>00019 {
<a name="l00020"></a>00020   <span class="keywordtype">int</span> <a class="code" href="lundump_8c.html#a6776ffdd5e2abf4119b1d45731e9e668">error</a>;
<a name="l00021"></a>00021   <a class="code" href="structTimer.html">Timer</a>* timer = (<a class="code" href="structTimer.html">Timer</a>*)arg;
<a name="l00022"></a>00022   pthread_mutex_lock(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>);
<a name="l00023"></a>00023   <span class="keywordflow">while</span> (timer-&gt;<a class="code" href="structTimer.html#a9f729b56f68b1cd7d4e604d6877f88bd">running</a>) {
<a name="l00024"></a>00024     <span class="keywordflow">if</span> (timer-&gt;<a class="code" href="structTimer.html#aa05a88159da74e709d2e73907dba23cd">active</a>) {
<a name="l00025"></a>00025       <span class="comment">// Wait for a signal with a timer.</span>
<a name="l00026"></a>00026       <span class="comment">//logt(&quot;doing timed wait&quot;);</span>
<a name="l00027"></a>00027       <span class="comment">// See asm-generic/errno.h and asm-generic/errno-base.h for the</span>
<a name="l00028"></a>00028       <span class="comment">// relevant error codes.</span>
<a name="l00029"></a>00029       error = pthread_cond_timedwait(&amp;timer-&gt;<a class="code" href="structTimer.html#a7693034c916caddb387ff27eac2eeb8f">cond</a>, &amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>, timer-&gt;<a class="code" href="structTimer.html#a4fc41b3b1f9b12fb86932443a1e2fb04">time</a>);
<a name="l00030"></a>00030       <span class="comment">//logf(&quot;error is %d&quot;, error);</span>
<a name="l00031"></a>00031       <span class="keywordflow">if</span> (timer-&gt;<a class="code" href="structTimer.html#aa05a88159da74e709d2e73907dba23cd">active</a>) {
<a name="l00032"></a>00032   <span class="keywordflow">if</span> (error == ETIMEDOUT) {
<a name="l00033"></a>00033     timer-&gt;<a class="code" href="structTimer.html#aa05a88159da74e709d2e73907dba23cd">active</a> = 0;
<a name="l00034"></a>00034     <a class="code" href="evq__event_8c.html#ab74b73a80e20a631d9277162c33036ed">event_put</a>(timer-&gt;<a class="code" href="structTimer.html#a11438a848dbc55970be91c35d5a78403">queue</a>, (<a class="code" href="struct__Event.html">Event</a>*)timer);
<a name="l00035"></a>00035   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error) {
<a name="l00036"></a>00036     logf(<span class="stringliteral">&quot;pthread_cond_timedwait error %d&quot;</span>, error);
<a name="l00037"></a>00037     assert(0 &amp;&amp; <span class="stringliteral">&quot;pthread_cond_timedwait invalid args?&quot;</span>);
<a name="l00038"></a>00038   }
<a name="l00039"></a>00039       }
<a name="l00040"></a>00040     } <span class="keywordflow">else</span> {
<a name="l00041"></a>00041       <span class="comment">// Wait for a signal without a timer.</span>
<a name="l00042"></a>00042       pthread_cond_wait(&amp;timer-&gt;<a class="code" href="structTimer.html#a7693034c916caddb387ff27eac2eeb8f">cond</a>, &amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>); <span class="comment">// no error code</span>
<a name="l00043"></a>00043     }
<a name="l00044"></a>00044   }
<a name="l00045"></a>00045   pthread_mutex_unlock(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>);
<a name="l00046"></a>00046   <span class="keywordflow">return</span> ((<span class="keywordtype">void</span>*)0);
<a name="l00047"></a>00047 }
<a name="l00048"></a>00048 
<a name="l00049"></a><a class="code" href="evq__timer_8h.html#ab863d9b38439a08079390ab6f7f9fa6d">00049</a> <span class="keywordtype">void</span> <a class="code" href="evq__timer_8c.html#ab863d9b38439a08079390ab6f7f9fa6d">timer_init</a>(<a class="code" href="structQueue.html">EventQueue</a>* queue, <a class="code" href="structTimer.html">Timer</a>* timer)
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051   timer-&gt;<a class="code" href="structTimer.html#a11438a848dbc55970be91c35d5a78403">queue</a> = queue;
<a name="l00052"></a>00052   timer-&gt;<a class="code" href="structTimer.html#aa05a88159da74e709d2e73907dba23cd">active</a> = 0;
<a name="l00053"></a>00053   timer-&gt;<a class="code" href="structTimer.html#a9f729b56f68b1cd7d4e604d6877f88bd">running</a> = 1;
<a name="l00054"></a>00054   timer-&gt;<a class="code" href="structTimer.html#aac831b73ab61ff085700d9d086cfac1f">event</a>.<a class="code" href="struct__Event.html#a7e639a6c342745d7889f91db4d2f6686">callback</a> = &amp;<a class="code" href="evq__timer_8c.html#ad3c58b9d3dfc92c6a7e82fea6e3e1739">event_cb</a>;
<a name="l00055"></a>00055   pthread_mutex_init(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>, NULL);
<a name="l00056"></a>00056   pthread_cond_init(&amp;timer-&gt;<a class="code" href="structTimer.html#a7693034c916caddb387ff27eac2eeb8f">cond</a>, NULL);
<a name="l00057"></a>00057   pthread_create(&amp;timer-&gt;<a class="code" href="structTimer.html#a680d510446a242964bd021d3b83fa088">worker</a>, NULL, &amp;<a class="code" href="evq__timer_8c.html#ab76df023fd9715f5e1004853f0067287">worker_task</a>, timer);
<a name="l00058"></a>00058 }
<a name="l00059"></a>00059 
<a name="l00060"></a><a class="code" href="evq__timer_8h.html#a42047c46a32d6c4d2d622515460ec8bd">00060</a> <span class="keywordtype">void</span> <a class="code" href="evq__timer_8c.html#a42047c46a32d6c4d2d622515460ec8bd">timer_at</a>(<a class="code" href="structTimer.html">Timer</a>* timer, <span class="keyword">struct</span> timespec* time, <a class="code" href="evq__timer_8h.html#a8de423df324af7cf771a7f6a8e95c609">TimerCallback</a>* <a class="code" href="shell_8c.html#a0c6dc6c47e267588f0ae3cb5c3b4692a">callback</a>, <span class="keywordtype">void</span>* user_data)
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062   pthread_mutex_lock(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>);
<a name="l00063"></a>00063   assert(!timer-&gt;<a class="code" href="structTimer.html#aa05a88159da74e709d2e73907dba23cd">active</a> &amp;&amp; <span class="stringliteral">&quot;timer already active&quot;</span>);
<a name="l00064"></a>00064   timer-&gt;<a class="code" href="structTimer.html#a4fc41b3b1f9b12fb86932443a1e2fb04">time</a> = time;
<a name="l00065"></a>00065   timer-&gt;<a class="code" href="structTimer.html#abd00c0de5571d594beed927f11af0ebc">callback</a> = callback;
<a name="l00066"></a>00066   timer-&gt;<a class="code" href="structTimer.html#ab63f401004cd126319cab7354f5beb53">user_data</a> = user_data;
<a name="l00067"></a>00067   timer-&gt;<a class="code" href="structTimer.html#aa05a88159da74e709d2e73907dba23cd">active</a> = 1;
<a name="l00068"></a>00068   pthread_cond_signal(&amp;timer-&gt;<a class="code" href="structTimer.html#a7693034c916caddb387ff27eac2eeb8f">cond</a>);
<a name="l00069"></a>00069   pthread_mutex_unlock(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>);
<a name="l00070"></a>00070 }
<a name="l00071"></a>00071 
<a name="l00072"></a><a class="code" href="evq__timer_8h.html#a9e1387e84876981ae132ae75686ccbac">00072</a> <span class="keywordtype">void</span> <a class="code" href="evq__timer_8c.html#a9e1387e84876981ae132ae75686ccbac">timer_cancel</a>(<a class="code" href="structTimer.html">Timer</a>* timer)
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074   pthread_mutex_lock(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>);
<a name="l00075"></a>00075   <span class="keywordflow">if</span> (timer-&gt;<a class="code" href="structTimer.html#aa05a88159da74e709d2e73907dba23cd">active</a>) {
<a name="l00076"></a>00076     timer-&gt;<a class="code" href="structTimer.html#aa05a88159da74e709d2e73907dba23cd">active</a> = 0;
<a name="l00077"></a>00077     pthread_cond_signal(&amp;timer-&gt;<a class="code" href="structTimer.html#a7693034c916caddb387ff27eac2eeb8f">cond</a>);
<a name="l00078"></a>00078   } <span class="keywordflow">else</span> {
<a name="l00079"></a>00079     <a class="code" href="evq__event_8c.html#ad8d71c30f256c5aff6d6106708cab664">event_remove</a>(timer-&gt;<a class="code" href="structTimer.html#a11438a848dbc55970be91c35d5a78403">queue</a>, (<a class="code" href="struct__Event.html">Event</a>*)timer);
<a name="l00080"></a>00080   }
<a name="l00081"></a>00081   pthread_mutex_unlock(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>);
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a><a class="code" href="evq__timer_8h.html#a12d7235ecfef38a532027fa66eb53643">00084</a> <span class="keywordtype">void</span> <a class="code" href="evq__timer_8c.html#a12d7235ecfef38a532027fa66eb53643">timer_close</a>(<a class="code" href="structTimer.html">Timer</a>* timer)
<a name="l00085"></a>00085 {
<a name="l00086"></a>00086   <a class="code" href="evq__timer_8c.html#a9e1387e84876981ae132ae75686ccbac">timer_cancel</a>(timer);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   pthread_mutex_lock(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>);
<a name="l00089"></a>00089   timer-&gt;<a class="code" href="structTimer.html#a9f729b56f68b1cd7d4e604d6877f88bd">running</a> = 0;
<a name="l00090"></a>00090   pthread_cond_signal(&amp;timer-&gt;<a class="code" href="structTimer.html#a7693034c916caddb387ff27eac2eeb8f">cond</a>);
<a name="l00091"></a>00091   pthread_mutex_unlock(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="keywordtype">void</span>* exitValue;
<a name="l00094"></a>00094   pthread_join(timer-&gt;<a class="code" href="structTimer.html#a680d510446a242964bd021d3b83fa088">worker</a>, &amp;exitValue);
<a name="l00095"></a>00095   printf(<span class="stringliteral">&quot;timer worker exited with %d\n&quot;</span>, (<span class="keywordtype">int</span>)exitValue);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097   <span class="comment">// Destroying these is perfectly safe now that the worker thread has stopped running. Other than the owner thread no other thread should any longer be accessing this object, and even the owner should not after calling timer_close.</span>
<a name="l00098"></a>00098   pthread_cond_destroy(&amp;timer-&gt;<a class="code" href="structTimer.html#a7693034c916caddb387ff27eac2eeb8f">cond</a>);
<a name="l00099"></a>00099   pthread_mutex_destroy(&amp;timer-&gt;<a class="code" href="structTimer.html#ae88f2eb8a491bc6ff88d65a6553fe2ce">mutex</a>);
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="comment">// This ensures that once this call returns, the owning thread will not be processing any events relating to this timer.</span>
<a name="l00102"></a>00102   <a class="code" href="evq__event_8c.html#ad8d71c30f256c5aff6d6106708cab664">event_remove</a>(timer-&gt;<a class="code" href="structTimer.html#a11438a848dbc55970be91c35d5a78403">queue</a>, (<a class="code" href="struct__Event.html">Event</a>*)timer);
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 <span class="comment"></span>
<a name="l00105"></a>00105 <span class="comment">/**</span>
<a name="l00106"></a>00106 <span class="comment"></span>
<a name="l00107"></a>00107 <span class="comment">evq_timer.c</span>
<a name="l00108"></a>00108 <span class="comment"></span>
<a name="l00109"></a>00109 <span class="comment">Copyright 2009 Helsinki Institute for Information Technology (HIIT)</span>
<a name="l00110"></a>00110 <span class="comment">and the authors. All rights reserved.</span>
<a name="l00111"></a>00111 <span class="comment"></span>
<a name="l00112"></a>00112 <span class="comment">Authors: Tero Hasu &lt;tero.hasu@hut.fi&gt;</span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">Permission is hereby granted, free of charge, to any person</span>
<a name="l00115"></a>00115 <span class="comment">obtaining a copy of this software and associated documentation files</span>
<a name="l00116"></a>00116 <span class="comment">(the &quot;Software&quot;), to deal in the Software without restriction,</span>
<a name="l00117"></a>00117 <span class="comment">including without limitation the rights to use, copy, modify, merge,</span>
<a name="l00118"></a>00118 <span class="comment">publish, distribute, sublicense, and/or sell copies of the Software,</span>
<a name="l00119"></a>00119 <span class="comment">and to permit persons to whom the Software is furnished to do so,</span>
<a name="l00120"></a>00120 <span class="comment">subject to the following conditions:</span>
<a name="l00121"></a>00121 <span class="comment"></span>
<a name="l00122"></a>00122 <span class="comment">The above copyright notice and this permission notice shall be</span>
<a name="l00123"></a>00123 <span class="comment">included in all copies or substantial portions of the Software.</span>
<a name="l00124"></a>00124 <span class="comment"></span>
<a name="l00125"></a>00125 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<a name="l00126"></a>00126 <span class="comment">EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<a name="l00127"></a>00127 <span class="comment">MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<a name="l00128"></a>00128 <span class="comment">NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<a name="l00129"></a>00129 <span class="comment">BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<a name="l00130"></a>00130 <span class="comment">ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<a name="l00131"></a>00131 <span class="comment">CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<a name="l00132"></a>00132 <span class="comment">SOFTWARE.</span>
<a name="l00133"></a>00133 <span class="comment"></span>
<a name="l00134"></a>00134 <span class="comment"> **/</span>
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:52 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
