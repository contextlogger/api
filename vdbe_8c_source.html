<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: vdbe.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>vdbe.c</h1><a href="vdbe_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">** 2001 September 15</span>
<a name="l00003"></a>00003 <span class="comment">**</span>
<a name="l00004"></a>00004 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00005"></a>00005 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00006"></a>00006 <span class="comment">**</span>
<a name="l00007"></a>00007 <span class="comment">**    May you do good and not evil.</span>
<a name="l00008"></a>00008 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00009"></a>00009 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">*************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment">** The code in this file implements execution method of the </span>
<a name="l00013"></a>00013 <span class="comment">** Virtual Database Engine (VDBE).  A separate file (&quot;vdbeaux.c&quot;)</span>
<a name="l00014"></a>00014 <span class="comment">** handles housekeeping details such as creating and deleting</span>
<a name="l00015"></a>00015 <span class="comment">** VDBE instances.  This file is solely interested in executing</span>
<a name="l00016"></a>00016 <span class="comment">** the VDBE program.</span>
<a name="l00017"></a>00017 <span class="comment">**</span>
<a name="l00018"></a>00018 <span class="comment">** In the external interface, an &quot;sqlite3_stmt*&quot; is an opaque pointer</span>
<a name="l00019"></a>00019 <span class="comment">** to a VDBE.</span>
<a name="l00020"></a>00020 <span class="comment">**</span>
<a name="l00021"></a>00021 <span class="comment">** The SQL parser generates a program which is then executed by</span>
<a name="l00022"></a>00022 <span class="comment">** the VDBE to do the work of the SQL statement.  VDBE programs are </span>
<a name="l00023"></a>00023 <span class="comment">** similar in form to assembly language.  The program consists of</span>
<a name="l00024"></a>00024 <span class="comment">** a linear sequence of operations.  Each operation has an opcode </span>
<a name="l00025"></a>00025 <span class="comment">** and 5 operands.  Operands P1, P2, and P3 are integers.  Operand P4 </span>
<a name="l00026"></a>00026 <span class="comment">** is a null-terminated string.  Operand P5 is an unsigned character.</span>
<a name="l00027"></a>00027 <span class="comment">** Few opcodes use all 5 operands.</span>
<a name="l00028"></a>00028 <span class="comment">**</span>
<a name="l00029"></a>00029 <span class="comment">** Computation results are stored on a set of registers numbered beginning</span>
<a name="l00030"></a>00030 <span class="comment">** with 1 and going up to Vdbe.nMem.  Each register can store</span>
<a name="l00031"></a>00031 <span class="comment">** either an integer, a null-terminated string, a floating point</span>
<a name="l00032"></a>00032 <span class="comment">** number, or the SQL &quot;NULL&quot; value.  An implicit conversion from one</span>
<a name="l00033"></a>00033 <span class="comment">** type to the other occurs as necessary.</span>
<a name="l00034"></a>00034 <span class="comment">** </span>
<a name="l00035"></a>00035 <span class="comment">** Most of the code in this file is taken up by the sqlite3VdbeExec()</span>
<a name="l00036"></a>00036 <span class="comment">** function which does the work of interpreting a VDBE program.</span>
<a name="l00037"></a>00037 <span class="comment">** But other routines are also provided to help in building up</span>
<a name="l00038"></a>00038 <span class="comment">** a program instruction by instruction.</span>
<a name="l00039"></a>00039 <span class="comment">**</span>
<a name="l00040"></a>00040 <span class="comment">** Various scripts scan this source file in order to generate HTML</span>
<a name="l00041"></a>00041 <span class="comment">** documentation, headers files, or other derived files.  The formatting</span>
<a name="l00042"></a>00042 <span class="comment">** of the code in this file is, therefore, important.  See other comments</span>
<a name="l00043"></a>00043 <span class="comment">** in this file for details.  If in doubt, do not deviate from existing</span>
<a name="l00044"></a>00044 <span class="comment">** commenting and indentation practices when changing or adding code.</span>
<a name="l00045"></a>00045 <span class="comment">**</span>
<a name="l00046"></a>00046 <span class="comment">** $Id: vdbe.c,v 1.786 2008/11/05 16:37:35 drh Exp $</span>
<a name="l00047"></a>00047 <span class="comment">*/</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="sqliteInt_8h.html">sqliteInt.h</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="vdbeInt_8h.html">vdbeInt.h</a>&quot;</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">/*</span>
<a name="l00053"></a>00053 <span class="comment">** The following global variable is incremented every time a cursor</span>
<a name="l00054"></a>00054 <span class="comment">** moves, either by the OP_MoveXX, OP_Next, or OP_Prev opcodes.  The test</span>
<a name="l00055"></a>00055 <span class="comment">** procedures use this information to make sure that indices are</span>
<a name="l00056"></a>00056 <span class="comment">** working correctly.  This variable has no function other than to</span>
<a name="l00057"></a>00057 <span class="comment">** help verify the correct operation of the library.</span>
<a name="l00058"></a>00058 <span class="comment">*/</span>
<a name="l00059"></a>00059 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="keywordtype">int</span> sqlite3_search_count = 0;
<a name="l00061"></a>00061 <span class="preprocessor">#endif</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="comment">/*</span>
<a name="l00064"></a>00064 <span class="comment">** When this global variable is positive, it gets decremented once before</span>
<a name="l00065"></a>00065 <span class="comment">** each instruction in the VDBE.  When reaches zero, the u1.isInterrupted</span>
<a name="l00066"></a>00066 <span class="comment">** field of the sqlite3 structure is set in order to simulate and interrupt.</span>
<a name="l00067"></a>00067 <span class="comment">**</span>
<a name="l00068"></a>00068 <span class="comment">** This facility is used for testing purposes only.  It does not function</span>
<a name="l00069"></a>00069 <span class="comment">** in an ordinary build.</span>
<a name="l00070"></a>00070 <span class="comment">*/</span>
<a name="l00071"></a>00071 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="keywordtype">int</span> sqlite3_interrupt_count = 0;
<a name="l00073"></a>00073 <span class="preprocessor">#endif</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="comment">/*</span>
<a name="l00076"></a>00076 <span class="comment">** The next global variable is incremented each type the OP_Sort opcode</span>
<a name="l00077"></a>00077 <span class="comment">** is executed.  The test procedures use this information to make sure that</span>
<a name="l00078"></a>00078 <span class="comment">** sorting is occurring or not occurring at appropriate times.   This variable</span>
<a name="l00079"></a>00079 <span class="comment">** has no function other than to help verify the correct operation of the</span>
<a name="l00080"></a>00080 <span class="comment">** library.</span>
<a name="l00081"></a>00081 <span class="comment">*/</span>
<a name="l00082"></a>00082 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="keywordtype">int</span> sqlite3_sort_count = 0;
<a name="l00084"></a>00084 <span class="preprocessor">#endif</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span>
<a name="l00086"></a>00086 <span class="comment">/*</span>
<a name="l00087"></a>00087 <span class="comment">** The next global variable records the size of the largest MEM_Blob</span>
<a name="l00088"></a>00088 <span class="comment">** or MEM_Str that has been used by a VDBE opcode.  The test procedures</span>
<a name="l00089"></a>00089 <span class="comment">** use this information to make sure that the zero-blob functionality</span>
<a name="l00090"></a>00090 <span class="comment">** is working correctly.   This variable has no function other than to</span>
<a name="l00091"></a>00091 <span class="comment">** help verify the correct operation of the library.</span>
<a name="l00092"></a>00092 <span class="comment">*/</span>
<a name="l00093"></a>00093 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="keywordtype">int</span> sqlite3_max_blobsize = 0;
<a name="l00095"></a>00095 <span class="keyword">static</span> <span class="keywordtype">void</span> updateMaxBlobsize(<a class="code" href="structMem.html">Mem</a> *p){
<a name="l00096"></a>00096   <span class="keywordflow">if</span>( (p-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; (<a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a>|<a class="code" href="vdbeInt_8h.html#a4def40a3702fc50cd2f3a5820e1a4f68">MEM_Blob</a>))!=0 &amp;&amp; p-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>&gt;sqlite3_max_blobsize ){
<a name="l00097"></a>00097     sqlite3_max_blobsize = p-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>;
<a name="l00098"></a>00098   }
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 <span class="preprocessor">#endif</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>
<a name="l00102"></a>00102 <span class="comment">/*</span>
<a name="l00103"></a>00103 <span class="comment">** Test a register to see if it exceeds the current maximum blob size.</span>
<a name="l00104"></a>00104 <span class="comment">** If it does, record the new maximum blob size.</span>
<a name="l00105"></a>00105 <span class="comment">*/</span>
<a name="l00106"></a>00106 <span class="preprocessor">#if defined(SQLITE_TEST) &amp;&amp; !defined(SQLITE_OMIT_BUILTIN_TEST)</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor"># define UPDATE_MAX_BLOBSIZE(P)  updateMaxBlobsize(P)</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00109"></a><a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">00109</a> <span class="preprocessor"></span><span class="preprocessor"># define UPDATE_MAX_BLOBSIZE(P)</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span>
<a name="l00112"></a>00112 <span class="comment">/*</span>
<a name="l00113"></a>00113 <span class="comment">** Convert the given register into a string if it isn&apos;t one</span>
<a name="l00114"></a>00114 <span class="comment">** already. Return non-zero if a malloc() fails.</span>
<a name="l00115"></a>00115 <span class="comment">*/</span>
<a name="l00116"></a><a class="code" href="vdbe_8c.html#a9aa45b1a0b74041d343d26d5bff08377">00116</a> <span class="preprocessor">#define Stringify(P, enc) \</span>
<a name="l00117"></a>00117 <span class="preprocessor">   if(((P)-&gt;flags&amp;(MEM_Str|MEM_Blob))==0 &amp;&amp; sqlite3VdbeMemStringify(P,enc)) \</span>
<a name="l00118"></a>00118 <span class="preprocessor">     { goto no_mem; }</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>
<a name="l00120"></a>00120 <span class="comment">/*</span>
<a name="l00121"></a>00121 <span class="comment">** An ephemeral string value (signified by the MEM_Ephem flag) contains</span>
<a name="l00122"></a>00122 <span class="comment">** a pointer to a dynamically allocated string where some other entity</span>
<a name="l00123"></a>00123 <span class="comment">** is responsible for deallocating that string.  Because the register</span>
<a name="l00124"></a>00124 <span class="comment">** does not control the string, it might be deleted without the register</span>
<a name="l00125"></a>00125 <span class="comment">** knowing it.</span>
<a name="l00126"></a>00126 <span class="comment">**</span>
<a name="l00127"></a>00127 <span class="comment">** This routine converts an ephemeral string into a dynamically allocated</span>
<a name="l00128"></a>00128 <span class="comment">** string that the register itself controls.  In other words, it</span>
<a name="l00129"></a>00129 <span class="comment">** converts an MEM_Ephem string into an MEM_Dyn string.</span>
<a name="l00130"></a>00130 <span class="comment">*/</span>
<a name="l00131"></a><a class="code" href="vdbe_8c.html#a3ad1ce209d3f21b491cd09bb096ffd48">00131</a> <span class="preprocessor">#define Deephemeralize(P) \</span>
<a name="l00132"></a>00132 <span class="preprocessor">   if( ((P)-&gt;flags&amp;MEM_Ephem)!=0 \</span>
<a name="l00133"></a>00133 <span class="preprocessor">       &amp;&amp; sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;}</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span>
<a name="l00135"></a>00135 <span class="comment">/*</span>
<a name="l00136"></a>00136 <span class="comment">** Call sqlite3VdbeMemExpandBlob() on the supplied value (type Mem*)</span>
<a name="l00137"></a>00137 <span class="comment">** P if required.</span>
<a name="l00138"></a>00138 <span class="comment">*/</span>
<a name="l00139"></a><a class="code" href="vdbe_8c.html#a69b8bf9ca78e4cf90c8553b34e2ad336">00139</a> <span class="preprocessor">#define ExpandBlob(P) (((P)-&gt;flags&amp;MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>
<a name="l00141"></a>00141 <span class="comment">/*</span>
<a name="l00142"></a>00142 <span class="comment">** Argument pMem points at a register that will be passed to a</span>
<a name="l00143"></a>00143 <span class="comment">** user-defined function or returned to the user as the result of a query.</span>
<a name="l00144"></a>00144 <span class="comment">** The second argument, &apos;db_enc&apos; is the text encoding used by the vdbe for</span>
<a name="l00145"></a>00145 <span class="comment">** register variables.  This routine sets the pMem-&gt;enc and pMem-&gt;type</span>
<a name="l00146"></a>00146 <span class="comment">** variables used by the sqlite3_value_*() routines.</span>
<a name="l00147"></a>00147 <span class="comment">*/</span>
<a name="l00148"></a><a class="code" href="vdbe_8c.html#a5bd05ac6e7d78cc6314d4d02b0e32793">00148</a> <span class="preprocessor">#define storeTypeInfo(A,B) _storeTypeInfo(A)</span>
<a name="l00149"></a><a class="code" href="vdbe_8c.html#ae959026c1a2fff6481dabd0bbad143e7">00149</a> <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbe_8c.html#ae959026c1a2fff6481dabd0bbad143e7">_storeTypeInfo</a>(<a class="code" href="structMem.html">Mem</a> *pMem){
<a name="l00150"></a>00150   <span class="keywordtype">int</span> flags = pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>;
<a name="l00151"></a>00151   <span class="keywordflow">if</span>( flags &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l00152"></a>00152     pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#afd180931f2d06d6c245791d187da5802">SQLITE_NULL</a>;
<a name="l00153"></a>00153   }
<a name="l00154"></a>00154   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flags &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> ){
<a name="l00155"></a>00155     pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#a7453d71905f10fa330940428f8abe21c">SQLITE_INTEGER</a>;
<a name="l00156"></a>00156   }
<a name="l00157"></a>00157   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flags &amp; <a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a> ){
<a name="l00158"></a>00158     pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#a0f415018bddf6542e69792aee0357984">SQLITE_FLOAT</a>;
<a name="l00159"></a>00159   }
<a name="l00160"></a>00160   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( flags &amp; <a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a> ){
<a name="l00161"></a>00161     pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#accfdca5d473931c3959bbdf4fc5c2ead">SQLITE_TEXT</a>;
<a name="l00162"></a>00162   }<span class="keywordflow">else</span>{
<a name="l00163"></a>00163     pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a> = <a class="code" href="sqlite3_8h.html#a26c29a137b2a35bbde7048e5e48b794a">SQLITE_BLOB</a>;
<a name="l00164"></a>00164   }
<a name="l00165"></a>00165 }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="comment">/*</span>
<a name="l00168"></a>00168 <span class="comment">** Properties of opcodes.  The OPFLG_INITIALIZER macro is</span>
<a name="l00169"></a>00169 <span class="comment">** created by mkopcodeh.awk during compilation.  Data is obtained</span>
<a name="l00170"></a>00170 <span class="comment">** from the comments following the &quot;case OP_xxxx:&quot; statements in</span>
<a name="l00171"></a>00171 <span class="comment">** this file.  </span>
<a name="l00172"></a>00172 <span class="comment">*/</span>
<a name="l00173"></a><a class="code" href="vdbe_8c.html#a197b1e5fad916e73fab63eda598a87dd">00173</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="vdbe_8c.html#a197b1e5fad916e73fab63eda598a87dd">opcodeProperty</a>[] = <a class="code" href="opcodes_8h.html#ac2e081e7d20be7c31016d1a20e938670">OPFLG_INITIALIZER</a>;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">/*</span>
<a name="l00176"></a>00176 <span class="comment">** Return true if an opcode has any of the OPFLG_xxx properties</span>
<a name="l00177"></a>00177 <span class="comment">** specified by mask.</span>
<a name="l00178"></a>00178 <span class="comment">*/</span>
<a name="l00179"></a><a class="code" href="vdbeInt_8h.html#a112201f32b1da48d5cdb820adc133ad8">00179</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8c.html#a87b4d0450221c137df3f4952a2162865">sqlite3VdbeOpcodeHasProperty</a>(<span class="keywordtype">int</span> opcode, <span class="keywordtype">int</span> mask){
<a name="l00180"></a>00180   assert( opcode&gt;0 &amp;&amp; opcode&lt;<span class="keyword">sizeof</span>(opcodeProperty) );
<a name="l00181"></a>00181   <span class="keywordflow">return</span> (opcodeProperty[opcode]&amp;mask)!=0;
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="comment">/*</span>
<a name="l00185"></a>00185 <span class="comment">** Allocate VdbeCursor number iCur.  Return a pointer to it.  Return NULL</span>
<a name="l00186"></a>00186 <span class="comment">** if we run out of memory.</span>
<a name="l00187"></a>00187 <span class="comment">*/</span>
<a name="l00188"></a><a class="code" href="vdbe_8c.html#a5e6a4a459c5d72f8cc5478bea910dfdf">00188</a> <span class="keyword">static</span> <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *<a class="code" href="vdbe_8c.html#a5e6a4a459c5d72f8cc5478bea910dfdf">allocateCursor</a>(
<a name="l00189"></a>00189   <a class="code" href="structVdbe.html">Vdbe</a> *p,              <span class="comment">/* The virtual machine */</span>
<a name="l00190"></a>00190   <span class="keywordtype">int</span> iCur,             <span class="comment">/* Index of the new VdbeCursor */</span>
<a name="l00191"></a>00191   <a class="code" href="structVdbeOp.html">Op</a> *pOp,              <span class="comment">/* */</span>
<a name="l00192"></a>00192   <span class="keywordtype">int</span> iDb,              <span class="comment">/* */</span>
<a name="l00193"></a>00193   <span class="keywordtype">int</span> isBtreeCursor     <span class="comment">/* */</span>
<a name="l00194"></a>00194 ){
<a name="l00195"></a>00195   <span class="comment">/* Find the memory cell that will be used to store the blob of memory</span>
<a name="l00196"></a>00196 <span class="comment">  ** required for this VdbeCursor structure. It is convenient to use a </span>
<a name="l00197"></a>00197 <span class="comment">  ** vdbe memory cell to manage the memory allocation required for a</span>
<a name="l00198"></a>00198 <span class="comment">  ** VdbeCursor structure for the following reasons:</span>
<a name="l00199"></a>00199 <span class="comment">  **</span>
<a name="l00200"></a>00200 <span class="comment">  **   * Sometimes cursor numbers are used for a couple of different</span>
<a name="l00201"></a>00201 <span class="comment">  **     purposes in a vdbe program. The different uses might require</span>
<a name="l00202"></a>00202 <span class="comment">  **     different sized allocations. Memory cells provide growable</span>
<a name="l00203"></a>00203 <span class="comment">  **     allocations.</span>
<a name="l00204"></a>00204 <span class="comment">  **</span>
<a name="l00205"></a>00205 <span class="comment">  **   * When using ENABLE_MEMORY_MANAGEMENT, memory cell buffers can</span>
<a name="l00206"></a>00206 <span class="comment">  **     be freed lazily via the sqlite3_release_memory() API. This</span>
<a name="l00207"></a>00207 <span class="comment">  **     minimizes the number of malloc calls made by the system.</span>
<a name="l00208"></a>00208 <span class="comment">  **</span>
<a name="l00209"></a>00209 <span class="comment">  ** Memory cells for cursors are allocated at the top of the address</span>
<a name="l00210"></a>00210 <span class="comment">  ** space. Memory cell (p-&gt;nMem) corresponds to cursor 0. Space for</span>
<a name="l00211"></a>00211 <span class="comment">  ** cursor 1 is managed by memory cell (p-&gt;nMem-1), etc.</span>
<a name="l00212"></a>00212 <span class="comment">  */</span>
<a name="l00213"></a>00213   <a class="code" href="structMem.html">Mem</a> *pMem = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a>-iCur];
<a name="l00214"></a>00214 
<a name="l00215"></a>00215   <span class="keywordtype">int</span> nByte;
<a name="l00216"></a>00216   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCx = 0;
<a name="l00217"></a>00217   <span class="comment">/* If the opcode of pOp is OP_SetNumColumns, then pOp-&gt;p2 contains</span>
<a name="l00218"></a>00218 <span class="comment">  ** the number of fields in the records contained in the table or</span>
<a name="l00219"></a>00219 <span class="comment">  ** index being opened. Use this to reserve space for the </span>
<a name="l00220"></a>00220 <span class="comment">  ** VdbeCursor.aType[] array.</span>
<a name="l00221"></a>00221 <span class="comment">  */</span>
<a name="l00222"></a>00222   <span class="keywordtype">int</span> nField = 0;
<a name="l00223"></a>00223   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a573b06e057d808cf609dd66f29e0d998">OP_SetNumColumns</a> || pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a2c9ec21e951d5ecf39b32e118d57a262">OP_OpenEphemeral</a> ){
<a name="l00224"></a>00224     nField = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l00225"></a>00225   }
<a name="l00226"></a>00226   nByte = 
<a name="l00227"></a>00227       <span class="keyword">sizeof</span>(<a class="code" href="structVdbeCursor.html">VdbeCursor</a>) + 
<a name="l00228"></a>00228       (isBtreeCursor?<a class="code" href="btree_8c.html#a96338636fbb297e190ebbe528d065cbe">sqlite3BtreeCursorSize</a>():0) + 
<a name="l00229"></a>00229       2*nField*<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a>);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   assert( iCur&lt;p-&gt;nCursor );
<a name="l00232"></a>00232   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[iCur] ){
<a name="l00233"></a>00233     <a class="code" href="vdbeaux_8c.html#a6db711e5d25afe0e6b41bb62b5d45ee6">sqlite3VdbeFreeCursor</a>(p, p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[iCur]);
<a name="l00234"></a>00234     p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[iCur] = 0;
<a name="l00235"></a>00235   }
<a name="l00236"></a>00236   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==<a class="code" href="vdbeInt_8h.html#ac934bc728baa7b73867a62722c30d311">sqlite3VdbeMemGrow</a>(pMem, nByte, 0) ){
<a name="l00237"></a>00237     p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[iCur] = pCx = (<a class="code" href="structVdbeCursor.html">VdbeCursor</a>*)pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>;
<a name="l00238"></a>00238     memset(pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, 0, nByte);
<a name="l00239"></a>00239     pCx-&gt;<a class="code" href="structVdbeCursor.html#a1215b7b0d1bbd882d6bfb8b118712d89">iDb</a> = iDb;
<a name="l00240"></a>00240     pCx-&gt;<a class="code" href="structVdbeCursor.html#aa115a60e335e738945127141303eaedb">nField</a> = nField;
<a name="l00241"></a>00241     <span class="keywordflow">if</span>( nField ){
<a name="l00242"></a>00242       pCx-&gt;<a class="code" href="structVdbeCursor.html#a6992d2bf9eb8480985aec47dae58f1ab">aType</a> = (<a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> *)&amp;pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[<span class="keyword">sizeof</span>(<a class="code" href="structVdbeCursor.html">VdbeCursor</a>)];
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244     <span class="keywordflow">if</span>( isBtreeCursor ){
<a name="l00245"></a>00245       pCx-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a> = (<a class="code" href="structBtCursor.html">BtCursor</a>*)
<a name="l00246"></a>00246           &amp;pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[<span class="keyword">sizeof</span>(<a class="code" href="structVdbeCursor.html">VdbeCursor</a>)+2*nField*<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a>)];
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248   }
<a name="l00249"></a>00249   <span class="keywordflow">return</span> pCx;
<a name="l00250"></a>00250 }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="comment">/*</span>
<a name="l00253"></a>00253 <span class="comment">** Try to convert a value into a numeric representation if we can</span>
<a name="l00254"></a>00254 <span class="comment">** do so without loss of information.  In other words, if the string</span>
<a name="l00255"></a>00255 <span class="comment">** looks like a number, convert it into a number.  If it does not</span>
<a name="l00256"></a>00256 <span class="comment">** look like a number, leave it alone.</span>
<a name="l00257"></a>00257 <span class="comment">*/</span>
<a name="l00258"></a><a class="code" href="vdbe_8c.html#a746d87f60796d3903aa4b8e7ce123ada">00258</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbe_8c.html#a746d87f60796d3903aa4b8e7ce123ada">applyNumericAffinity</a>(<a class="code" href="structMem.html">Mem</a> *pRec){
<a name="l00259"></a>00259   <span class="keywordflow">if</span>( (pRec-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; (<a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>|<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>))==0 ){
<a name="l00260"></a>00260     <span class="keywordtype">int</span> realnum;
<a name="l00261"></a>00261     <a class="code" href="vdbeInt_8h.html#ad2fc78228cee77b674db3eed601ef0bd">sqlite3VdbeMemNulTerminate</a>(pRec);
<a name="l00262"></a>00262     <span class="keywordflow">if</span>( (pRec-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a>)
<a name="l00263"></a>00263          &amp;&amp; <a class="code" href="sqliteInt_8h.html#ab7937a8daf7159354d0ea24679605924">sqlite3IsNumber</a>(pRec-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, &amp;realnum, pRec-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a>) ){
<a name="l00264"></a>00264       <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> value;
<a name="l00265"></a>00265       <a class="code" href="vdbeInt_8h.html#a94f53f04621df5bca68190710998b086">sqlite3VdbeChangeEncoding</a>(pRec, <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>);
<a name="l00266"></a>00266       <span class="keywordflow">if</span>( !realnum &amp;&amp; <a class="code" href="sqliteInt_8h.html#ad1b21ea73071f002b389388afb02b09f">sqlite3Atoi64</a>(pRec-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, &amp;value) ){
<a name="l00267"></a>00267         pRec-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = value;
<a name="l00268"></a>00268         <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pRec, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l00269"></a>00269       }<span class="keywordflow">else</span>{
<a name="l00270"></a>00270         <a class="code" href="vdbeInt_8h.html#aee9a6411cb0a7b31e361aea01ee97e51">sqlite3VdbeMemRealify</a>(pRec);
<a name="l00271"></a>00271       }
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273   }
<a name="l00274"></a>00274 }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="comment">/*</span>
<a name="l00277"></a>00277 <span class="comment">** Processing is determine by the affinity parameter:</span>
<a name="l00278"></a>00278 <span class="comment">**</span>
<a name="l00279"></a>00279 <span class="comment">** SQLITE_AFF_INTEGER:</span>
<a name="l00280"></a>00280 <span class="comment">** SQLITE_AFF_REAL:</span>
<a name="l00281"></a>00281 <span class="comment">** SQLITE_AFF_NUMERIC:</span>
<a name="l00282"></a>00282 <span class="comment">**    Try to convert pRec to an integer representation or a </span>
<a name="l00283"></a>00283 <span class="comment">**    floating-point representation if an integer representation</span>
<a name="l00284"></a>00284 <span class="comment">**    is not possible.  Note that the integer representation is</span>
<a name="l00285"></a>00285 <span class="comment">**    always preferred, even if the affinity is REAL, because</span>
<a name="l00286"></a>00286 <span class="comment">**    an integer representation is more space efficient on disk.</span>
<a name="l00287"></a>00287 <span class="comment">**</span>
<a name="l00288"></a>00288 <span class="comment">** SQLITE_AFF_TEXT:</span>
<a name="l00289"></a>00289 <span class="comment">**    Convert pRec to a text representation.</span>
<a name="l00290"></a>00290 <span class="comment">**</span>
<a name="l00291"></a>00291 <span class="comment">** SQLITE_AFF_NONE:</span>
<a name="l00292"></a>00292 <span class="comment">**    No-op.  pRec is unchanged.</span>
<a name="l00293"></a>00293 <span class="comment">*/</span>
<a name="l00294"></a><a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">00294</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>(
<a name="l00295"></a>00295   <a class="code" href="structMem.html">Mem</a> *pRec,          <span class="comment">/* The value to apply affinity to */</span>
<a name="l00296"></a>00296   <span class="keywordtype">char</span> affinity,      <span class="comment">/* The affinity to be applied */</span>
<a name="l00297"></a>00297   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> enc              <span class="comment">/* Use this text encoding */</span>
<a name="l00298"></a>00298 ){
<a name="l00299"></a>00299   <span class="keywordflow">if</span>( affinity==<a class="code" href="sqliteInt_8h.html#a14eb26c096ab7ac7cccd4a4d08b6a84e">SQLITE_AFF_TEXT</a> ){
<a name="l00300"></a>00300     <span class="comment">/* Only attempt the conversion to TEXT if there is an integer or real</span>
<a name="l00301"></a>00301 <span class="comment">    ** representation (blob and NULL do not get converted) but no string</span>
<a name="l00302"></a>00302 <span class="comment">    ** representation.</span>
<a name="l00303"></a>00303 <span class="comment">    */</span>
<a name="l00304"></a>00304     <span class="keywordflow">if</span>( 0==(pRec-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a>) &amp;&amp; (pRec-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;(<a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>|<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>)) ){
<a name="l00305"></a>00305       <a class="code" href="vdbeInt_8h.html#aba611e1c01384469f5067b3c6295c6fb">sqlite3VdbeMemStringify</a>(pRec, enc);
<a name="l00306"></a>00306     }
<a name="l00307"></a>00307     pRec-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp;= ~(<a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>|<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l00308"></a>00308   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( affinity!=<a class="code" href="sqliteInt_8h.html#a1173a38e4836a42c0a7992df894a0972">SQLITE_AFF_NONE</a> ){
<a name="l00309"></a>00309     assert( affinity==<a class="code" href="sqliteInt_8h.html#a45e5dc1cc144e55d53389ac9d1066924">SQLITE_AFF_INTEGER</a> || affinity==<a class="code" href="sqliteInt_8h.html#a134b5c5d792faf2f63dcc35ca872539b">SQLITE_AFF_REAL</a>
<a name="l00310"></a>00310              || affinity==<a class="code" href="sqliteInt_8h.html#acd7dd66f59f94bbb10d8e9a3f0157c38">SQLITE_AFF_NUMERIC</a> );
<a name="l00311"></a>00311     <a class="code" href="vdbe_8c.html#a746d87f60796d3903aa4b8e7ce123ada">applyNumericAffinity</a>(pRec);
<a name="l00312"></a>00312     <span class="keywordflow">if</span>( pRec-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a> ){
<a name="l00313"></a>00313       <a class="code" href="vdbeInt_8h.html#afb8c115e74d571571def7ff0d9fa70c5">sqlite3VdbeIntegerAffinity</a>(pRec);
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315   }
<a name="l00316"></a>00316 }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 <span class="comment">/*</span>
<a name="l00319"></a>00319 <span class="comment">** Try to convert the type of a function argument or a result column</span>
<a name="l00320"></a>00320 <span class="comment">** into a numeric representation.  Use either INTEGER or REAL whichever</span>
<a name="l00321"></a>00321 <span class="comment">** is appropriate.  But only do the conversion if it is possible without</span>
<a name="l00322"></a>00322 <span class="comment">** loss of information and return the revised type of the argument.</span>
<a name="l00323"></a>00323 <span class="comment">**</span>
<a name="l00324"></a>00324 <span class="comment">** This is an EXPERIMENTAL api and is subject to change or removal.</span>
<a name="l00325"></a>00325 <span class="comment">*/</span>
<a name="l00326"></a><a class="code" href="vdbe_8c.html#a2c2f20240cc2cb652c3ba10492c24c00">00326</a> <span class="keywordtype">int</span> <a class="code" href="sqlite3_8h.html#a188720dd3783aa9dd216ffd4057af06e">sqlite3_value_numeric_type</a>(<a class="code" href="structMem.html">sqlite3_value</a> *pVal){
<a name="l00327"></a>00327   <a class="code" href="structMem.html">Mem</a> *pMem = (<a class="code" href="structMem.html">Mem</a>*)pVal;
<a name="l00328"></a>00328   <a class="code" href="vdbe_8c.html#a746d87f60796d3903aa4b8e7ce123ada">applyNumericAffinity</a>(pMem);
<a name="l00329"></a>00329   <a class="code" href="vdbe_8c.html#a5bd05ac6e7d78cc6314d4d02b0e32793">storeTypeInfo</a>(pMem, 0);
<a name="l00330"></a>00330   <span class="keywordflow">return</span> pMem-&gt;<a class="code" href="structMem.html#a6756879ca1e5fa71b12db25f981b7e87">type</a>;
<a name="l00331"></a>00331 }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 <span class="comment">/*</span>
<a name="l00334"></a>00334 <span class="comment">** Exported version of applyAffinity(). This one works on sqlite3_value*, </span>
<a name="l00335"></a>00335 <span class="comment">** not the internal Mem* type.</span>
<a name="l00336"></a>00336 <span class="comment">*/</span>
<a name="l00337"></a><a class="code" href="vdbe_8c.html#a017c42e21c8c768d9dacba76e8b6c867">00337</a> <span class="keywordtype">void</span> <a class="code" href="sqliteInt_8h.html#aabfecd06ed956cceb98da55950ac44cb">sqlite3ValueApplyAffinity</a>(
<a name="l00338"></a>00338   <a class="code" href="structMem.html">sqlite3_value</a> *pVal, 
<a name="l00339"></a>00339   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> affinity, 
<a name="l00340"></a>00340   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> enc
<a name="l00341"></a>00341 ){
<a name="l00342"></a>00342   <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>((<a class="code" href="structMem.html">Mem</a> *)pVal, affinity, enc);
<a name="l00343"></a>00343 }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00346"></a>00346 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00347"></a>00347 <span class="comment">** Write a nice string representation of the contents of cell pMem</span>
<a name="l00348"></a>00348 <span class="comment">** into buffer zBuf, length nBuf.</span>
<a name="l00349"></a>00349 <span class="comment">*/</span>
<a name="l00350"></a>00350 <span class="keywordtype">void</span> sqlite3VdbeMemPrettyPrint(<a class="code" href="structMem.html">Mem</a> *pMem, <span class="keywordtype">char</span> *zBuf){
<a name="l00351"></a>00351   <span class="keywordtype">char</span> *zCsr = zBuf;
<a name="l00352"></a>00352   <span class="keywordtype">int</span> <a class="code" href="libluasqlite3_8c.html#ae16fcc70ad2cbf55b1906507bcb6fa33">f</a> = pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> encnames[] = {<span class="stringliteral">&quot;(X)&quot;</span>, <span class="stringliteral">&quot;(8)&quot;</span>, <span class="stringliteral">&quot;(16LE)&quot;</span>, <span class="stringliteral">&quot;(16BE)&quot;</span>};
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   <span class="keywordflow">if</span>( f&amp;<a class="code" href="vdbeInt_8h.html#a4def40a3702fc50cd2f3a5820e1a4f68">MEM_Blob</a> ){
<a name="l00357"></a>00357     <span class="keywordtype">int</span> i;
<a name="l00358"></a>00358     <span class="keywordtype">char</span> c;
<a name="l00359"></a>00359     <span class="keywordflow">if</span>( f &amp; <a class="code" href="vdbeInt_8h.html#ae9774193fee66e1494092aa77697eb61">MEM_Dyn</a> ){
<a name="l00360"></a>00360       c = <span class="charliteral">&apos;z&apos;</span>;
<a name="l00361"></a>00361       assert( (f &amp; (<a class="code" href="vdbeInt_8h.html#a4f3ef3e28665fca360d6d0945ac4c02f">MEM_Static</a>|<a class="code" href="vdbeInt_8h.html#a38c45feb5b1c4fd9e789aaafcf7e47cd">MEM_Ephem</a>))==0 );
<a name="l00362"></a>00362     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( f &amp; <a class="code" href="vdbeInt_8h.html#a4f3ef3e28665fca360d6d0945ac4c02f">MEM_Static</a> ){
<a name="l00363"></a>00363       c = <span class="charliteral">&apos;t&apos;</span>;
<a name="l00364"></a>00364       assert( (f &amp; (MEM_Dyn|<a class="code" href="vdbeInt_8h.html#a38c45feb5b1c4fd9e789aaafcf7e47cd">MEM_Ephem</a>))==0 );
<a name="l00365"></a>00365     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( f &amp; <a class="code" href="vdbeInt_8h.html#a38c45feb5b1c4fd9e789aaafcf7e47cd">MEM_Ephem</a> ){
<a name="l00366"></a>00366       c = <span class="charliteral">&apos;e&apos;</span>;
<a name="l00367"></a>00367       assert( (f &amp; (MEM_Static|MEM_Dyn))==0 );
<a name="l00368"></a>00368     }<span class="keywordflow">else</span>{
<a name="l00369"></a>00369       c = <span class="charliteral">&apos;s&apos;</span>;
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(100, zCsr, <span class="stringliteral">&quot;%c&quot;</span>, c);
<a name="l00373"></a>00373     zCsr += strlen(zCsr);
<a name="l00374"></a>00374     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(100, zCsr, <span class="stringliteral">&quot;%d[&quot;</span>, pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>);
<a name="l00375"></a>00375     zCsr += strlen(zCsr);
<a name="l00376"></a>00376     <span class="keywordflow">for</span>(i=0; i&lt;16 &amp;&amp; i&lt;pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>; i++){
<a name="l00377"></a>00377       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(100, zCsr, <span class="stringliteral">&quot;%02X&quot;</span>, ((<span class="keywordtype">int</span>)pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[i] &amp; 0xFF));
<a name="l00378"></a>00378       zCsr += strlen(zCsr);
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380     <span class="keywordflow">for</span>(i=0; i&lt;16 &amp;&amp; i&lt;pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>; i++){
<a name="l00381"></a>00381       <span class="keywordtype">char</span> z = pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[i];
<a name="l00382"></a>00382       <span class="keywordflow">if</span>( z&lt;32 || z&gt;126 ) *zCsr++ = <span class="charliteral">&apos;.&apos;</span>;
<a name="l00383"></a>00383       <span class="keywordflow">else</span> *zCsr++ = z;
<a name="l00384"></a>00384     }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(100, zCsr, <span class="stringliteral">&quot;]%s&quot;</span>, encnames[pMem-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a>]);
<a name="l00387"></a>00387     zCsr += strlen(zCsr);
<a name="l00388"></a>00388     <span class="keywordflow">if</span>( f &amp; <a class="code" href="vdbeInt_8h.html#a9433e8fe887266736d2e795fe0b71fd3">MEM_Zero</a> ){
<a name="l00389"></a>00389       <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(100, zCsr,<span class="stringliteral">&quot;+%lldz&quot;</span>,pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>);
<a name="l00390"></a>00390       zCsr += strlen(zCsr);
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392     *zCsr = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00393"></a>00393   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( f &amp; <a class="code" href="vdbeInt_8h.html#aa82916da07ec18d50128bda85cbe6ab0">MEM_Str</a> ){
<a name="l00394"></a>00394     <span class="keywordtype">int</span> j, k;
<a name="l00395"></a>00395     zBuf[0] = <span class="charliteral">&apos; &apos;</span>;
<a name="l00396"></a>00396     <span class="keywordflow">if</span>( f &amp; MEM_Dyn ){
<a name="l00397"></a>00397       zBuf[1] = <span class="charliteral">&apos;z&apos;</span>;
<a name="l00398"></a>00398       assert( (f &amp; (MEM_Static|MEM_Ephem))==0 );
<a name="l00399"></a>00399     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( f &amp; MEM_Static ){
<a name="l00400"></a>00400       zBuf[1] = <span class="charliteral">&apos;t&apos;</span>;
<a name="l00401"></a>00401       assert( (f &amp; (MEM_Dyn|MEM_Ephem))==0 );
<a name="l00402"></a>00402     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( f &amp; MEM_Ephem ){
<a name="l00403"></a>00403       zBuf[1] = <span class="charliteral">&apos;e&apos;</span>;
<a name="l00404"></a>00404       assert( (f &amp; (MEM_Static|MEM_Dyn))==0 );
<a name="l00405"></a>00405     }<span class="keywordflow">else</span>{
<a name="l00406"></a>00406       zBuf[1] = <span class="charliteral">&apos;s&apos;</span>;
<a name="l00407"></a>00407     }
<a name="l00408"></a>00408     k = 2;
<a name="l00409"></a>00409     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(100, &amp;zBuf[k], <span class="stringliteral">&quot;%d&quot;</span>, pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>);
<a name="l00410"></a>00410     k += strlen(&amp;zBuf[k]);
<a name="l00411"></a>00411     zBuf[k++] = <span class="charliteral">&apos;[&apos;</span>;
<a name="l00412"></a>00412     <span class="keywordflow">for</span>(j=0; j&lt;15 &amp;&amp; j&lt;pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>; j++){
<a name="l00413"></a>00413       <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> c = pMem-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[j];
<a name="l00414"></a>00414       <span class="keywordflow">if</span>( c&gt;=0x20 &amp;&amp; c&lt;0x7f ){
<a name="l00415"></a>00415         zBuf[k++] = c;
<a name="l00416"></a>00416       }<span class="keywordflow">else</span>{
<a name="l00417"></a>00417         zBuf[k++] = <span class="charliteral">&apos;.&apos;</span>;
<a name="l00418"></a>00418       }
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420     zBuf[k++] = <span class="charliteral">&apos;]&apos;</span>;
<a name="l00421"></a>00421     <a class="code" href="printf_8c.html#aa62e83e27ab0a63e15f9f844c17c595f">sqlite3_snprintf</a>(100,&amp;zBuf[k], encnames[pMem-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a>]);
<a name="l00422"></a>00422     k += strlen(&amp;zBuf[k]);
<a name="l00423"></a>00423     zBuf[k++] = 0;
<a name="l00424"></a>00424   }
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 <span class="preprocessor">#endif</span>
<a name="l00427"></a>00427 <span class="preprocessor"></span>
<a name="l00428"></a>00428 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00429"></a>00429 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00430"></a>00430 <span class="comment">** Print the value of a register for tracing purposes:</span>
<a name="l00431"></a>00431 <span class="comment">*/</span>
<a name="l00432"></a>00432 <span class="keyword">static</span> <span class="keywordtype">void</span> memTracePrint(FILE *out, <a class="code" href="structMem.html">Mem</a> *p){
<a name="l00433"></a>00433   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l00434"></a>00434     fprintf(out, <span class="stringliteral">&quot; NULL&quot;</span>);
<a name="l00435"></a>00435   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( (p-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; (<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>|MEM_Str))==(<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>|MEM_Str) ){
<a name="l00436"></a>00436     fprintf(out, <span class="stringliteral">&quot; si:%lld&quot;</span>, p-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>);
<a name="l00437"></a>00437   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> ){
<a name="l00438"></a>00438     fprintf(out, <span class="stringliteral">&quot; i:%lld&quot;</span>, p-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>);
<a name="l00439"></a>00439   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a> ){
<a name="l00440"></a>00440     fprintf(out, <span class="stringliteral">&quot; r:%g&quot;</span>, p-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>);
<a name="l00441"></a>00441   }<span class="keywordflow">else</span>{
<a name="l00442"></a>00442     <span class="keywordtype">char</span> zBuf[200];
<a name="l00443"></a>00443     sqlite3VdbeMemPrettyPrint(p, zBuf);
<a name="l00444"></a>00444     fprintf(out, <span class="stringliteral">&quot; &quot;</span>);
<a name="l00445"></a>00445     fprintf(out, <span class="stringliteral">&quot;%s&quot;</span>, zBuf);
<a name="l00446"></a>00446   }
<a name="l00447"></a>00447 }
<a name="l00448"></a>00448 <span class="keyword">static</span> <span class="keywordtype">void</span> registerTrace(FILE *out, <span class="keywordtype">int</span> iReg, <a class="code" href="structMem.html">Mem</a> *p){
<a name="l00449"></a>00449   fprintf(out, <span class="stringliteral">&quot;REG[%d] = &quot;</span>, iReg);
<a name="l00450"></a>00450   memTracePrint(out, p);
<a name="l00451"></a>00451   fprintf(out, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 <span class="preprocessor">#endif</span>
<a name="l00454"></a>00454 <span class="preprocessor"></span>
<a name="l00455"></a>00455 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span><span class="preprocessor">#  define REGISTER_TRACE(R,M) if(p-&gt;trace)registerTrace(p-&gt;trace,R,M)</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00458"></a><a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">00458</a> <span class="preprocessor"></span><span class="preprocessor">#  define REGISTER_TRACE(R,M)</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 <span class="preprocessor">#ifdef VDBE_PROFILE</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>
<a name="l00464"></a>00464 <span class="comment">/* </span>
<a name="l00465"></a>00465 <span class="comment">** hwtime.h contains inline assembler code for implementing </span>
<a name="l00466"></a>00466 <span class="comment">** high-performance timing routines.</span>
<a name="l00467"></a>00467 <span class="comment">*/</span>
<a name="l00468"></a>00468 <span class="preprocessor">#include &quot;<a class="code" href="hwtime_8h.html">hwtime.h</a>&quot;</span>
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 <span class="preprocessor">#endif</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span>
<a name="l00472"></a>00472 <span class="comment">/*</span>
<a name="l00473"></a>00473 <span class="comment">** The CHECK_FOR_INTERRUPT macro defined here looks to see if the</span>
<a name="l00474"></a>00474 <span class="comment">** sqlite3_interrupt() routine has been called.  If it has been, then</span>
<a name="l00475"></a>00475 <span class="comment">** processing of the VDBE program is interrupted.</span>
<a name="l00476"></a>00476 <span class="comment">**</span>
<a name="l00477"></a>00477 <span class="comment">** This macro added to every instruction that does a jump in order to</span>
<a name="l00478"></a>00478 <span class="comment">** implement a loop.  This test used to be on every single instruction,</span>
<a name="l00479"></a>00479 <span class="comment">** but that meant we more testing that we needed.  By only testing the</span>
<a name="l00480"></a>00480 <span class="comment">** flag on jump instructions, we get a (small) speed improvement.</span>
<a name="l00481"></a>00481 <span class="comment">*/</span>
<a name="l00482"></a><a class="code" href="vdbe_8c.html#ac7ee506756b15c8b7da860830e1393af">00482</a> <span class="preprocessor">#define CHECK_FOR_INTERRUPT \</span>
<a name="l00483"></a>00483 <span class="preprocessor">   if( db-&gt;u1.isInterrupted ) goto abort_due_to_interrupt;</span>
<a name="l00484"></a>00484 <span class="preprocessor"></span>
<a name="l00485"></a>00485 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00486"></a>00486 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> fileExists(<a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *zFile){
<a name="l00487"></a>00487   <span class="keywordtype">int</span> res = 0;
<a name="l00488"></a>00488   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00489"></a>00489 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span>  <span class="comment">/* If we are currently testing IO errors, then do not call OsAccess() to</span>
<a name="l00491"></a>00491 <span class="comment">  ** test for the presence of zFile. This is because any IO error that</span>
<a name="l00492"></a>00492 <span class="comment">  ** occurs here will not be reported, causing the test to fail.</span>
<a name="l00493"></a>00493 <span class="comment">  */</span>
<a name="l00494"></a>00494   <span class="keyword">extern</span> <span class="keywordtype">int</span> sqlite3_io_error_pending;
<a name="l00495"></a>00495   <span class="keywordflow">if</span>( sqlite3_io_error_pending&lt;=0 )
<a name="l00496"></a>00496 <span class="preprocessor">#endif</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span>    rc = <a class="code" href="os_8c.html#a0cae4a47231c187a56c7b1aa98708b6a">sqlite3OsAccess</a>(db-&gt;<a class="code" href="structsqlite3.html#a8ad0bcb473e4cb492165739acff918cd">pVfs</a>, zFile, <a class="code" href="sqlite3_8h.html#a8451f266ab642f03f344209484dc3b61">SQLITE_ACCESS_EXISTS</a>, &amp;res);
<a name="l00498"></a>00498   <span class="keywordflow">return</span> (res &amp;&amp; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>);
<a name="l00499"></a>00499 }
<a name="l00500"></a>00500 <span class="preprocessor">#endif</span>
<a name="l00501"></a>00501 <span class="preprocessor"></span>
<a name="l00502"></a>00502 <span class="comment">/*</span>
<a name="l00503"></a>00503 <span class="comment">** Execute as much of a VDBE program as we can then return.</span>
<a name="l00504"></a>00504 <span class="comment">**</span>
<a name="l00505"></a>00505 <span class="comment">** sqlite3VdbeMakeReady() must be called before this routine in order to</span>
<a name="l00506"></a>00506 <span class="comment">** close the program with a final OP_Halt and to set up the callbacks</span>
<a name="l00507"></a>00507 <span class="comment">** and the error message pointer.</span>
<a name="l00508"></a>00508 <span class="comment">**</span>
<a name="l00509"></a>00509 <span class="comment">** Whenever a row or result data is available, this routine will either</span>
<a name="l00510"></a>00510 <span class="comment">** invoke the result callback (if there is one) or return with</span>
<a name="l00511"></a>00511 <span class="comment">** SQLITE_ROW.</span>
<a name="l00512"></a>00512 <span class="comment">**</span>
<a name="l00513"></a>00513 <span class="comment">** If an attempt is made to open a locked database, then this routine</span>
<a name="l00514"></a>00514 <span class="comment">** will either invoke the busy callback (if there is one) or it will</span>
<a name="l00515"></a>00515 <span class="comment">** return SQLITE_BUSY.</span>
<a name="l00516"></a>00516 <span class="comment">**</span>
<a name="l00517"></a>00517 <span class="comment">** If an error occurs, an error message is written to memory obtained</span>
<a name="l00518"></a>00518 <span class="comment">** from sqlite3_malloc() and p-&gt;zErrMsg is made to point to that memory.</span>
<a name="l00519"></a>00519 <span class="comment">** The error code is stored in p-&gt;rc and this routine returns SQLITE_ERROR.</span>
<a name="l00520"></a>00520 <span class="comment">**</span>
<a name="l00521"></a>00521 <span class="comment">** If the callback ever returns non-zero, then the program exits</span>
<a name="l00522"></a>00522 <span class="comment">** immediately.  There will be no error message but the p-&gt;rc field is</span>
<a name="l00523"></a>00523 <span class="comment">** set to SQLITE_ABORT and this routine will return SQLITE_ERROR.</span>
<a name="l00524"></a>00524 <span class="comment">**</span>
<a name="l00525"></a>00525 <span class="comment">** A memory allocation error causes p-&gt;rc to be set to SQLITE_NOMEM and this</span>
<a name="l00526"></a>00526 <span class="comment">** routine to return SQLITE_ERROR.</span>
<a name="l00527"></a>00527 <span class="comment">**</span>
<a name="l00528"></a>00528 <span class="comment">** Other fatal errors return SQLITE_ERROR.</span>
<a name="l00529"></a>00529 <span class="comment">**</span>
<a name="l00530"></a>00530 <span class="comment">** After this routine has finished, sqlite3VdbeFinalize() should be</span>
<a name="l00531"></a>00531 <span class="comment">** used to clean up the mess that was left behind.</span>
<a name="l00532"></a>00532 <span class="comment">*/</span>
<a name="l00533"></a><a class="code" href="vdbeInt_8h.html#a848eaa835b988992835c5bed8f161f45">00533</a> <span class="keywordtype">int</span> <a class="code" href="vdbe_8c.html#a2c2a1aedf2ae4831cca418069fe93108">sqlite3VdbeExec</a>(
<a name="l00534"></a>00534   <a class="code" href="structVdbe.html">Vdbe</a> *p                    <span class="comment">/* The VDBE */</span>
<a name="l00535"></a>00535 ){
<a name="l00536"></a>00536   <span class="keywordtype">int</span> pc;                    <span class="comment">/* The program counter */</span>
<a name="l00537"></a>00537   <a class="code" href="structVdbeOp.html">Op</a> *pOp;                   <span class="comment">/* Current operation */</span>
<a name="l00538"></a>00538   <span class="keywordtype">int</span> rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;        <span class="comment">/* Value to return */</span>
<a name="l00539"></a>00539   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>;       <span class="comment">/* The database */</span>
<a name="l00540"></a>00540   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> encoding = <a class="code" href="sqliteInt_8h.html#a8d01c7bc7577fdd8cae2d7f9e13ae88d">ENC</a>(db);     <span class="comment">/* The database encoding */</span>
<a name="l00541"></a>00541   <a class="code" href="structMem.html">Mem</a> *pIn1, *pIn2, *pIn3;   <span class="comment">/* Input operands */</span>
<a name="l00542"></a>00542   <a class="code" href="structMem.html">Mem</a> *pOut;                 <span class="comment">/* Output operand */</span>
<a name="l00543"></a>00543   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> opProperty;
<a name="l00544"></a>00544   <span class="keywordtype">int</span> iCompare = 0;          <span class="comment">/* Result of last OP_Compare operation */</span>
<a name="l00545"></a>00545   <span class="keywordtype">int</span> *aPermute = 0;         <span class="comment">/* Permuation of columns for OP_Compare */</span>
<a name="l00546"></a>00546 <span class="preprocessor">#ifdef VDBE_PROFILE</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span>  <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> start;                 <span class="comment">/* CPU clock count at start of opcode */</span>
<a name="l00548"></a>00548   <span class="keywordtype">int</span> origPc;                <span class="comment">/* Program counter at start of opcode */</span>
<a name="l00549"></a>00549 <span class="preprocessor">#endif</span>
<a name="l00550"></a>00550 <span class="preprocessor"></span><span class="preprocessor">#ifndef SQLITE_OMIT_PROGRESS_CALLBACK</span>
<a name="l00551"></a>00551 <span class="preprocessor"></span>  <span class="keywordtype">int</span> nProgressOps = 0;      <span class="comment">/* Opcodes executed since progress callback. */</span>
<a name="l00552"></a>00552 <span class="preprocessor">#endif</span>
<a name="l00553"></a>00553 <span class="preprocessor"></span>  <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> aTempRec[16]; <span class="comment">/* Space to hold a transient UnpackedRecord */</span>
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 
<a name="l00556"></a>00556   assert( p-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#af3737d82d7edf97fffb59baf1592a528">VDBE_MAGIC_RUN</a> );  <span class="comment">/* sqlite3_step() verifies this */</span>
<a name="l00557"></a>00557   assert( db-&gt;<a class="code" href="structsqlite3.html#a6d9069c555657020c5dd1532d8e9c3f9">magic</a>==<a class="code" href="sqliteInt_8h.html#ad024aa586d9bf98f26fccca95f21b265">SQLITE_MAGIC_BUSY</a> );
<a name="l00558"></a>00558   <a class="code" href="btree_8h.html#abf94f61173691e5a98c08e89bb905d3a">sqlite3BtreeMutexArrayEnter</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#aeeff59f076cad0b73997113e4e29bd76">aMutex</a>);
<a name="l00559"></a>00559   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a> ){
<a name="l00560"></a>00560     <span class="comment">/* This happens if a malloc() inside a call to sqlite3_column_text() or</span>
<a name="l00561"></a>00561 <span class="comment">    ** sqlite3_column_text16() failed.  */</span>
<a name="l00562"></a>00562     <span class="keywordflow">goto</span> no_mem;
<a name="l00563"></a>00563   }
<a name="l00564"></a>00564   assert( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> || p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a> );
<a name="l00565"></a>00565   p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l00566"></a>00566   assert( p-&gt;<a class="code" href="structVdbe.html#aa1bbd3dcd803eb59dc73e681b6a585ed">explain</a>==0 );
<a name="l00567"></a>00567   p-&gt;<a class="code" href="structVdbe.html#a0dec47b8d8c481df2b73d5bbf9cdde11">pResultSet</a> = 0;
<a name="l00568"></a>00568   db-&gt;<a class="code" href="structsqlite3.html#a5f50915803efe2ad40dc1a5e31763671">busyHandler</a>.<a class="code" href="structBusyHandler.html#aac4531c677ed5ae9e4757ca1b02c568b">nBusy</a> = 0;
<a name="l00569"></a>00569   <a class="code" href="vdbe_8c.html#ac7ee506756b15c8b7da860830e1393af">CHECK_FOR_INTERRUPT</a>;
<a name="l00570"></a>00570   <a class="code" href="sqliteInt_8h.html#abf1afd97609bace214ec9b39ed71e03c">sqlite3VdbeIOTraceSql</a>(p);
<a name="l00571"></a>00571 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00572"></a>00572 <span class="preprocessor"></span>  <a class="code" href="fault_8c.html#abd9e16e72d950da81603ebdf72ed4d5c">sqlite3BeginBenignMalloc</a>();
<a name="l00573"></a>00573   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a>==0 
<a name="l00574"></a>00574    &amp;&amp; ((p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#adc5c973db132ec0d59dd1ddc0d517d7b">SQLITE_VdbeListing</a>) || fileExists(db, <span class="stringliteral">&quot;vdbe_explain&quot;</span>))
<a name="l00575"></a>00575   ){
<a name="l00576"></a>00576     <span class="keywordtype">int</span> i;
<a name="l00577"></a>00577     printf(<span class="stringliteral">&quot;VDBE Program Listing:\n&quot;</span>);
<a name="l00578"></a>00578     sqlite3VdbePrintSql(p);
<a name="l00579"></a>00579     <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a>; i++){
<a name="l00580"></a>00580       sqlite3VdbePrintOp(stdout, i, &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[i]);
<a name="l00581"></a>00581     }
<a name="l00582"></a>00582   }
<a name="l00583"></a>00583   <span class="keywordflow">if</span>( fileExists(db, <span class="stringliteral">&quot;vdbe_trace&quot;</span>) ){
<a name="l00584"></a>00584     p-&gt;trace = stdout;
<a name="l00585"></a>00585   }
<a name="l00586"></a>00586   <a class="code" href="fault_8c.html#ab9784f82977599f15fc02ea3ce1a770a">sqlite3EndBenignMalloc</a>();
<a name="l00587"></a>00587 <span class="preprocessor">#endif</span>
<a name="l00588"></a>00588 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(pc=p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a>; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>; pc++){
<a name="l00589"></a>00589     assert( pc&gt;=0 &amp;&amp; pc&lt;p-&gt;nOp );
<a name="l00590"></a>00590     <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ) <span class="keywordflow">goto</span> no_mem;
<a name="l00591"></a>00591 <span class="preprocessor">#ifdef VDBE_PROFILE</span>
<a name="l00592"></a>00592 <span class="preprocessor"></span>    origPc = pc;
<a name="l00593"></a>00593     start = <a class="code" href="hwtime_8h.html#ae0de71b2be73b39d4e3aae0ecf872ef2">sqlite3Hwtime</a>();
<a name="l00594"></a>00594 <span class="preprocessor">#endif</span>
<a name="l00595"></a>00595 <span class="preprocessor"></span>    pOp = &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[pc];
<a name="l00596"></a>00596 
<a name="l00597"></a>00597     <span class="comment">/* Only allow tracing if SQLITE_DEBUG is defined.</span>
<a name="l00598"></a>00598 <span class="comment">    */</span>
<a name="l00599"></a>00599 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( p-&gt;trace ){
<a name="l00601"></a>00601       <span class="keywordflow">if</span>( pc==0 ){
<a name="l00602"></a>00602         printf(<span class="stringliteral">&quot;VDBE Execution Trace:\n&quot;</span>);
<a name="l00603"></a>00603         sqlite3VdbePrintSql(p);
<a name="l00604"></a>00604       }
<a name="l00605"></a>00605       sqlite3VdbePrintOp(p-&gt;trace, pc, pOp);
<a name="l00606"></a>00606     }
<a name="l00607"></a>00607     <span class="keywordflow">if</span>( p-&gt;trace==0 &amp;&amp; pc==0 ){
<a name="l00608"></a>00608       <a class="code" href="fault_8c.html#abd9e16e72d950da81603ebdf72ed4d5c">sqlite3BeginBenignMalloc</a>();
<a name="l00609"></a>00609       <span class="keywordflow">if</span>( fileExists(db, <span class="stringliteral">&quot;vdbe_sqltrace&quot;</span>) ){
<a name="l00610"></a>00610         sqlite3VdbePrintSql(p);
<a name="l00611"></a>00611       }
<a name="l00612"></a>00612       <a class="code" href="fault_8c.html#ab9784f82977599f15fc02ea3ce1a770a">sqlite3EndBenignMalloc</a>();
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614 <span class="preprocessor">#endif</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span>      
<a name="l00616"></a>00616 
<a name="l00617"></a>00617     <span class="comment">/* Check to see if we need to simulate an interrupt.  This only happens</span>
<a name="l00618"></a>00618 <span class="comment">    ** if we have a special test build.</span>
<a name="l00619"></a>00619 <span class="comment">    */</span>
<a name="l00620"></a>00620 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( sqlite3_interrupt_count&gt;0 ){
<a name="l00622"></a>00622       sqlite3_interrupt_count--;
<a name="l00623"></a>00623       <span class="keywordflow">if</span>( sqlite3_interrupt_count==0 ){
<a name="l00624"></a>00624         <a class="code" href="main_8c.html#a6105f4c9687e243ce3d1706b34100c5f">sqlite3_interrupt</a>(db);
<a name="l00625"></a>00625       }
<a name="l00626"></a>00626     }
<a name="l00627"></a>00627 <span class="preprocessor">#endif</span>
<a name="l00628"></a>00628 <span class="preprocessor"></span>
<a name="l00629"></a>00629 <span class="preprocessor">#ifndef SQLITE_OMIT_PROGRESS_CALLBACK</span>
<a name="l00630"></a>00630 <span class="preprocessor"></span>    <span class="comment">/* Call the progress callback if it is configured and the required number</span>
<a name="l00631"></a>00631 <span class="comment">    ** of VDBE ops have been executed (either since this invocation of</span>
<a name="l00632"></a>00632 <span class="comment">    ** sqlite3VdbeExec() or since last time the progress callback was called).</span>
<a name="l00633"></a>00633 <span class="comment">    ** If the progress callback returns non-zero, exit the virtual machine with</span>
<a name="l00634"></a>00634 <span class="comment">    ** a return code SQLITE_ABORT.</span>
<a name="l00635"></a>00635 <span class="comment">    */</span>
<a name="l00636"></a>00636     <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#aa691b02e7878f45a7c2b59a70e9c5ef3">xProgress</a> ){
<a name="l00637"></a>00637       <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#af124e2c511fea75ead3b1f180ce63447">nProgressOps</a>==nProgressOps ){
<a name="l00638"></a>00638         <span class="keywordtype">int</span> prc;
<a name="l00639"></a>00639         <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l00640"></a>00640         prc =db-&gt;<a class="code" href="structsqlite3.html#aa691b02e7878f45a7c2b59a70e9c5ef3">xProgress</a>(db-&gt;<a class="code" href="structsqlite3.html#a1731a4d0a73f57415d35ef2a2997971b">pProgressArg</a>);
<a name="l00641"></a>00641         <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l00642"></a>00642         <span class="keywordflow">if</span>( prc!=0 ){
<a name="l00643"></a>00643           rc = <a class="code" href="sqlite3_8h.html#a03c9b25faf07d0e47ce7a1b1e46b2adc">SQLITE_INTERRUPT</a>;
<a name="l00644"></a>00644           <span class="keywordflow">goto</span> vdbe_error_halt;
<a name="l00645"></a>00645         }
<a name="l00646"></a>00646         nProgressOps = 0;
<a name="l00647"></a>00647       }
<a name="l00648"></a>00648       nProgressOps++;
<a name="l00649"></a>00649     }
<a name="l00650"></a>00650 <span class="preprocessor">#endif</span>
<a name="l00651"></a>00651 <span class="preprocessor"></span>
<a name="l00652"></a>00652     <span class="comment">/* Do common setup processing for any opcode that is marked</span>
<a name="l00653"></a>00653 <span class="comment">    ** with the &quot;out2-prerelease&quot; tag.  Such opcodes have a single</span>
<a name="l00654"></a>00654 <span class="comment">    ** output which is specified by the P2 parameter.  The P2 register</span>
<a name="l00655"></a>00655 <span class="comment">    ** is initialized to a NULL.</span>
<a name="l00656"></a>00656 <span class="comment">    */</span>
<a name="l00657"></a>00657     opProperty = opcodeProperty[pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>];
<a name="l00658"></a>00658     <span class="keywordflow">if</span>( (opProperty &amp; <a class="code" href="opcodes_8h.html#ad4ab7b001d9da0643ec213a10c5946ea">OPFLG_OUT2_PRERELEASE</a>)!=0 ){
<a name="l00659"></a>00659       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 );
<a name="l00660"></a>00660       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l00661"></a>00661       pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l00662"></a>00662       <a class="code" href="vdbeInt_8h.html#ac41fe3900e1fc0c17e00402551b6c8a3">sqlite3VdbeMemReleaseExternal</a>(pOut);
<a name="l00663"></a>00663       pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;
<a name="l00664"></a>00664     }<span class="keywordflow">else</span>
<a name="l00665"></a>00665  
<a name="l00666"></a>00666     <span class="comment">/* Do common setup for opcodes marked with one of the following</span>
<a name="l00667"></a>00667 <span class="comment">    ** combinations of properties.</span>
<a name="l00668"></a>00668 <span class="comment">    **</span>
<a name="l00669"></a>00669 <span class="comment">    **           in1</span>
<a name="l00670"></a>00670 <span class="comment">    **           in1 in2</span>
<a name="l00671"></a>00671 <span class="comment">    **           in1 in2 out3</span>
<a name="l00672"></a>00672 <span class="comment">    **           in1 in3</span>
<a name="l00673"></a>00673 <span class="comment">    **</span>
<a name="l00674"></a>00674 <span class="comment">    ** Variables pIn1, pIn2, and pIn3 are made to point to appropriate</span>
<a name="l00675"></a>00675 <span class="comment">    ** registers for inputs.  Variable pOut points to the output register.</span>
<a name="l00676"></a>00676 <span class="comment">    */</span>
<a name="l00677"></a>00677     <span class="keywordflow">if</span>( (opProperty &amp; <a class="code" href="opcodes_8h.html#a60fd7c4877febcc4529df59c2c634414">OPFLG_IN1</a>)!=0 ){
<a name="l00678"></a>00678       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;0 );
<a name="l00679"></a>00679       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l00680"></a>00680       pIn1 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l00681"></a>00681       <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pIn1);
<a name="l00682"></a>00682       <span class="keywordflow">if</span>( (opProperty &amp; <a class="code" href="opcodes_8h.html#aa0eac93f3b0baed54c1baf7b6156a417">OPFLG_IN2</a>)!=0 ){
<a name="l00683"></a>00683         assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 );
<a name="l00684"></a>00684         assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l00685"></a>00685         pIn2 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l00686"></a>00686         <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pIn2);
<a name="l00687"></a>00687         <span class="keywordflow">if</span>( (opProperty &amp; <a class="code" href="opcodes_8h.html#a3f5aec92398056b314c0b759de82ab52">OPFLG_OUT3</a>)!=0 ){
<a name="l00688"></a>00688           assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 );
<a name="l00689"></a>00689           assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l00690"></a>00690           pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l00691"></a>00691         }
<a name="l00692"></a>00692       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( (opProperty &amp; <a class="code" href="opcodes_8h.html#a763223598212ecd6d5ce292efde19bf9">OPFLG_IN3</a>)!=0 ){
<a name="l00693"></a>00693         assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 );
<a name="l00694"></a>00694         assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l00695"></a>00695         pIn3 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l00696"></a>00696         <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pIn3);
<a name="l00697"></a>00697       }
<a name="l00698"></a>00698     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( (opProperty &amp; <a class="code" href="opcodes_8h.html#aa0eac93f3b0baed54c1baf7b6156a417">OPFLG_IN2</a>)!=0 ){
<a name="l00699"></a>00699       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 );
<a name="l00700"></a>00700       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l00701"></a>00701       pIn2 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l00702"></a>00702       <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pIn2);
<a name="l00703"></a>00703     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( (opProperty &amp; <a class="code" href="opcodes_8h.html#a763223598212ecd6d5ce292efde19bf9">OPFLG_IN3</a>)!=0 ){
<a name="l00704"></a>00704       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 );
<a name="l00705"></a>00705       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l00706"></a>00706       pIn3 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l00707"></a>00707       <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pIn3);
<a name="l00708"></a>00708     }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710     <span class="keywordflow">switch</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> ){
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <span class="comment">/*****************************************************************************</span>
<a name="l00713"></a>00713 <span class="comment">** What follows is a massive switch statement where each case implements a</span>
<a name="l00714"></a>00714 <span class="comment">** separate instruction in the virtual machine.  If we follow the usual</span>
<a name="l00715"></a>00715 <span class="comment">** indentation conventions, each case should be indented by 6 spaces.  But</span>
<a name="l00716"></a>00716 <span class="comment">** that is a lot of wasted space on the left margin.  So the code within</span>
<a name="l00717"></a>00717 <span class="comment">** the switch statement will break with convention and be flush-left. Another</span>
<a name="l00718"></a>00718 <span class="comment">** big comment (similar to this one) will mark the point in the code where</span>
<a name="l00719"></a>00719 <span class="comment">** we transition back to normal indentation.</span>
<a name="l00720"></a>00720 <span class="comment">**</span>
<a name="l00721"></a>00721 <span class="comment">** The formatting of each case is important.  The makefile for SQLite</span>
<a name="l00722"></a>00722 <span class="comment">** generates two C files &quot;opcodes.h&quot; and &quot;opcodes.c&quot; by scanning this</span>
<a name="l00723"></a>00723 <span class="comment">** file looking for lines that begin with &quot;case OP_&quot;.  The opcodes.h files</span>
<a name="l00724"></a>00724 <span class="comment">** will be filled with #defines that give unique integer values to each</span>
<a name="l00725"></a>00725 <span class="comment">** opcode and the opcodes.c file is filled with an array of strings where</span>
<a name="l00726"></a>00726 <span class="comment">** each string is the symbolic name for the corresponding opcode.  If the</span>
<a name="l00727"></a>00727 <span class="comment">** case statement is followed by a comment of the form &quot;/# same as ... #/&quot;</span>
<a name="l00728"></a>00728 <span class="comment">** that comment is used to determine the particular value of the opcode.</span>
<a name="l00729"></a>00729 <span class="comment">**</span>
<a name="l00730"></a>00730 <span class="comment">** Other keywords in the comment that follows each case are used to</span>
<a name="l00731"></a>00731 <span class="comment">** construct the OPFLG_INITIALIZER value that initializes opcodeProperty[].</span>
<a name="l00732"></a>00732 <span class="comment">** Keywords include: in1, in2, in3, out2_prerelease, out2, out3.  See</span>
<a name="l00733"></a>00733 <span class="comment">** the mkopcodeh.awk script for additional information.</span>
<a name="l00734"></a>00734 <span class="comment">**</span>
<a name="l00735"></a>00735 <span class="comment">** Documentation about VDBE opcodes is generated by scanning this file</span>
<a name="l00736"></a>00736 <span class="comment">** for lines of that contain &quot;Opcode:&quot;.  That line and all subsequent</span>
<a name="l00737"></a>00737 <span class="comment">** comment lines are used in the generation of the opcode.html documentation</span>
<a name="l00738"></a>00738 <span class="comment">** file.</span>
<a name="l00739"></a>00739 <span class="comment">**</span>
<a name="l00740"></a>00740 <span class="comment">** SUMMARY:</span>
<a name="l00741"></a>00741 <span class="comment">**</span>
<a name="l00742"></a>00742 <span class="comment">**     Formatting is important to scripts that scan this file.</span>
<a name="l00743"></a>00743 <span class="comment">**     Do not deviate from the formatting style currently in use.</span>
<a name="l00744"></a>00744 <span class="comment">**</span>
<a name="l00745"></a>00745 <span class="comment">*****************************************************************************/</span>
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="comment">/* Opcode:  Goto * P2 * * *</span>
<a name="l00748"></a>00748 <span class="comment">**</span>
<a name="l00749"></a>00749 <span class="comment">** An unconditional jump to address P2.</span>
<a name="l00750"></a>00750 <span class="comment">** The next instruction executed will be </span>
<a name="l00751"></a>00751 <span class="comment">** the one at index P2 from the beginning of</span>
<a name="l00752"></a>00752 <span class="comment">** the program.</span>
<a name="l00753"></a>00753 <span class="comment">*/</span>
<a name="l00754"></a>00754 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ab620ab13af4a418a93982d89219be92b">OP_Goto</a>: {             <span class="comment">/* jump */</span>
<a name="l00755"></a>00755   <a class="code" href="vdbe_8c.html#ac7ee506756b15c8b7da860830e1393af">CHECK_FOR_INTERRUPT</a>;
<a name="l00756"></a>00756   pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l00757"></a>00757   <span class="keywordflow">break</span>;
<a name="l00758"></a>00758 }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760 <span class="comment">/* Opcode:  Gosub P1 P2 * * *</span>
<a name="l00761"></a>00761 <span class="comment">**</span>
<a name="l00762"></a>00762 <span class="comment">** Write the current address onto register P1</span>
<a name="l00763"></a>00763 <span class="comment">** and then jump to address P2.</span>
<a name="l00764"></a>00764 <span class="comment">*/</span>
<a name="l00765"></a>00765 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3a514c62873e2e1c9ee2e68824782886">OP_Gosub</a>: {            <span class="comment">/* jump */</span>
<a name="l00766"></a>00766   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;0 );
<a name="l00767"></a>00767   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l00768"></a>00768   pIn1 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l00769"></a>00769   assert( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; MEM_Dyn)==0 );
<a name="l00770"></a>00770   pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l00771"></a>00771   pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = pc;
<a name="l00772"></a>00772   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pIn1);
<a name="l00773"></a>00773   pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l00774"></a>00774   <span class="keywordflow">break</span>;
<a name="l00775"></a>00775 }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="comment">/* Opcode:  Return P1 * * * *</span>
<a name="l00778"></a>00778 <span class="comment">**</span>
<a name="l00779"></a>00779 <span class="comment">** Jump to the next instruction after the address in register P1.</span>
<a name="l00780"></a>00780 <span class="comment">*/</span>
<a name="l00781"></a>00781 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a91411834ed8d4f75e9e26968b8e9db85">OP_Return</a>: {           <span class="comment">/* in1 */</span>
<a name="l00782"></a>00782   assert( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l00783"></a>00783   pc = pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l00784"></a>00784   <span class="keywordflow">break</span>;
<a name="l00785"></a>00785 }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="comment">/* Opcode:  Yield P1 * * * *</span>
<a name="l00788"></a>00788 <span class="comment">**</span>
<a name="l00789"></a>00789 <span class="comment">** Swap the program counter with the value in register P1.</span>
<a name="l00790"></a>00790 <span class="comment">*/</span>
<a name="l00791"></a>00791 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a7ebd9b3f2515a2a3787fcb78265ec036">OP_Yield</a>: {
<a name="l00792"></a>00792   <span class="keywordtype">int</span> pcDest;
<a name="l00793"></a>00793   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;0 );
<a name="l00794"></a>00794   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l00795"></a>00795   pIn1 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l00796"></a>00796   assert( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; MEM_Dyn)==0 );
<a name="l00797"></a>00797   pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l00798"></a>00798   pcDest = pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l00799"></a>00799   pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = pc;
<a name="l00800"></a>00800   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pIn1);
<a name="l00801"></a>00801   pc = pcDest;
<a name="l00802"></a>00802   <span class="keywordflow">break</span>;
<a name="l00803"></a>00803 }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <span class="comment">/* Opcode:  Halt P1 P2 * P4 *</span>
<a name="l00807"></a>00807 <span class="comment">**</span>
<a name="l00808"></a>00808 <span class="comment">** Exit immediately.  All open cursors, Fifos, etc are closed</span>
<a name="l00809"></a>00809 <span class="comment">** automatically.</span>
<a name="l00810"></a>00810 <span class="comment">**</span>
<a name="l00811"></a>00811 <span class="comment">** P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),</span>
<a name="l00812"></a>00812 <span class="comment">** or sqlite3_finalize().  For a normal halt, this should be SQLITE_OK (0).</span>
<a name="l00813"></a>00813 <span class="comment">** For errors, it can be some other value.  If P1!=0 then P2 will determine</span>
<a name="l00814"></a>00814 <span class="comment">** whether or not to rollback the current transaction.  Do not rollback</span>
<a name="l00815"></a>00815 <span class="comment">** if P2==OE_Fail. Do the rollback if P2==OE_Rollback.  If P2==OE_Abort,</span>
<a name="l00816"></a>00816 <span class="comment">** then back out all changes that have occurred during this execution of the</span>
<a name="l00817"></a>00817 <span class="comment">** VDBE, but do not rollback the transaction. </span>
<a name="l00818"></a>00818 <span class="comment">**</span>
<a name="l00819"></a>00819 <span class="comment">** If P4 is not null then it is an error message string.</span>
<a name="l00820"></a>00820 <span class="comment">**</span>
<a name="l00821"></a>00821 <span class="comment">** There is an implied &quot;Halt 0 0 0&quot; instruction inserted at the very end of</span>
<a name="l00822"></a>00822 <span class="comment">** every program.  So a jump past the last instruction of the program</span>
<a name="l00823"></a>00823 <span class="comment">** is the same as executing Halt.</span>
<a name="l00824"></a>00824 <span class="comment">*/</span>
<a name="l00825"></a>00825 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#af1020441d30e76aa4d065ac2ec56c23d">OP_Halt</a>: {
<a name="l00826"></a>00826   p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l00827"></a>00827   p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a> = pc;
<a name="l00828"></a>00828   p-&gt;<a class="code" href="structVdbe.html#accafc9e9bac961a2e34daa1190cc228a">errorAction</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l00829"></a>00829   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a> ){
<a name="l00830"></a>00830     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;%s&quot;</span>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l00831"></a>00831   }
<a name="l00832"></a>00832   rc = <a class="code" href="vdbeaux_8c.html#af186927cd7de8e0c35b3d3fdb584c3ab">sqlite3VdbeHalt</a>(p);
<a name="l00833"></a>00833   assert( rc==<a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a> || rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> );
<a name="l00834"></a>00834   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a> ){
<a name="l00835"></a>00835     p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l00836"></a>00836   }<span class="keywordflow">else</span>{
<a name="l00837"></a>00837     rc = p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> ? <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a> : <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>;
<a name="l00838"></a>00838   }
<a name="l00839"></a>00839   <span class="keywordflow">goto</span> vdbe_return;
<a name="l00840"></a>00840 }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 <span class="comment">/* Opcode: Integer P1 P2 * * *</span>
<a name="l00843"></a>00843 <span class="comment">**</span>
<a name="l00844"></a>00844 <span class="comment">** The 32-bit integer value P1 is written into register P2.</span>
<a name="l00845"></a>00845 <span class="comment">*/</span>
<a name="l00846"></a>00846 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a8f70956ac71f1638e10484e8eeecf1df">OP_Integer</a>: {         <span class="comment">/* out2-prerelease */</span>
<a name="l00847"></a>00847   pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l00848"></a>00848   pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l00849"></a>00849   <span class="keywordflow">break</span>;
<a name="l00850"></a>00850 }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852 <span class="comment">/* Opcode: Int64 * P2 * P4 *</span>
<a name="l00853"></a>00853 <span class="comment">**</span>
<a name="l00854"></a>00854 <span class="comment">** P4 is a pointer to a 64-bit integer value.</span>
<a name="l00855"></a>00855 <span class="comment">** Write that value into register P2.</span>
<a name="l00856"></a>00856 <span class="comment">*/</span>
<a name="l00857"></a>00857 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a2a532571ef41da79903a0a349ddbe90f">OP_Int64</a>: {           <span class="comment">/* out2-prerelease */</span>
<a name="l00858"></a>00858   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aca64f9003a7490b02e08d790a7680fc3">pI64</a>!=0 );
<a name="l00859"></a>00859   pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l00860"></a>00860   pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = *pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aca64f9003a7490b02e08d790a7680fc3">pI64</a>;
<a name="l00861"></a>00861   <span class="keywordflow">break</span>;
<a name="l00862"></a>00862 }
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 <span class="comment">/* Opcode: Real * P2 * P4 *</span>
<a name="l00865"></a>00865 <span class="comment">**</span>
<a name="l00866"></a>00866 <span class="comment">** P4 is a pointer to a 64-bit floating point value.</span>
<a name="l00867"></a>00867 <span class="comment">** Write that value into register P2.</span>
<a name="l00868"></a>00868 <span class="comment">*/</span>
<a name="l00869"></a>00869 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#af3d4504e1556b24e6ac051e9f89b1ed4">OP_Real</a>: {            <span class="comment">/* same as TK_FLOAT, out2-prerelease */</span>
<a name="l00870"></a>00870   pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>;
<a name="l00871"></a>00871   assert( !<a class="code" href="sqliteInt_8h.html#a82c2a680007adffbdf6e95315b02477d">sqlite3IsNaN</a>(*pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a627ba5846cb35734a01493acd010a9a0">pReal</a>) );
<a name="l00872"></a>00872   pOut-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a> = *pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a627ba5846cb35734a01493acd010a9a0">pReal</a>;
<a name="l00873"></a>00873   <span class="keywordflow">break</span>;
<a name="l00874"></a>00874 }
<a name="l00875"></a>00875 
<a name="l00876"></a>00876 <span class="comment">/* Opcode: String8 * P2 * P4 *</span>
<a name="l00877"></a>00877 <span class="comment">**</span>
<a name="l00878"></a>00878 <span class="comment">** P4 points to a nul terminated UTF-8 string. This opcode is transformed </span>
<a name="l00879"></a>00879 <span class="comment">** into an OP_String before it is executed for the first time.</span>
<a name="l00880"></a>00880 <span class="comment">*/</span>
<a name="l00881"></a>00881 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a0ab67291a4b5d78f4f5b359b9c3d33e3">OP_String8</a>: {         <span class="comment">/* same as TK_STRING, out2-prerelease */</span>
<a name="l00882"></a>00882   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>!=0 );
<a name="l00883"></a>00883   pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> = <a class="code" href="opcodes_8h.html#a53558a93378fb60f25c54934011df9e9">OP_String</a>;
<a name="l00884"></a>00884   pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> = strlen(pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 <span class="preprocessor">#ifndef SQLITE_OMIT_UTF16</span>
<a name="l00887"></a>00887 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( encoding!=<a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a> ){
<a name="l00888"></a>00888     <a class="code" href="vdbeInt_8h.html#aba781c78989d5481ac168c09108c0ba8">sqlite3VdbeMemSetStr</a>(pOut, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>, -1, <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>, <a class="code" href="sqlite3_8h.html#a98b49797a7a15e2a570532fc2b5537c8">SQLITE_STATIC</a>);
<a name="l00889"></a>00889     <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=<a class="code" href="vdbeInt_8h.html#a94f53f04621df5bca68190710998b086">sqlite3VdbeChangeEncoding</a>(pOut, encoding) ) <span class="keywordflow">goto</span> no_mem;
<a name="l00890"></a>00890     <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>!=<a class="code" href="vdbeInt_8h.html#af70fb4d14fad367fa2b959e3777c4a69">sqlite3VdbeMemMakeWriteable</a>(pOut) ) <span class="keywordflow">goto</span> no_mem;
<a name="l00891"></a>00891     pOut-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l00892"></a>00892     pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> |= MEM_Static;
<a name="l00893"></a>00893     pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp;= ~MEM_Dyn;
<a name="l00894"></a>00894     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#ae0cac143cf868ae8ec55be2ea9b13e7c">P4_DYNAMIC</a> ){
<a name="l00895"></a>00895       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l00896"></a>00896     }
<a name="l00897"></a>00897     pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = <a class="code" href="vdbe_8h.html#ae0cac143cf868ae8ec55be2ea9b13e7c">P4_DYNAMIC</a>;
<a name="l00898"></a>00898     pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a> = pOut-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>;
<a name="l00899"></a>00899     pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> = pOut-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>;
<a name="l00900"></a>00900     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;db-&gt;<a class="code" href="structsqlite3.html#ad8acf663e1619905094c9dfe4125157b">aLimit</a>[<a class="code" href="sqlite3_8h.html#aeba56345f14b7febdafaaa4bc3949245">SQLITE_LIMIT_LENGTH</a>] ){
<a name="l00901"></a>00901       <span class="keywordflow">goto</span> too_big;
<a name="l00902"></a>00902     }
<a name="l00903"></a>00903     <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pOut);
<a name="l00904"></a>00904     <span class="keywordflow">break</span>;
<a name="l00905"></a>00905   }
<a name="l00906"></a>00906 <span class="preprocessor">#endif</span>
<a name="l00907"></a>00907 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;db-&gt;<a class="code" href="structsqlite3.html#ad8acf663e1619905094c9dfe4125157b">aLimit</a>[<a class="code" href="sqlite3_8h.html#aeba56345f14b7febdafaaa4bc3949245">SQLITE_LIMIT_LENGTH</a>] ){
<a name="l00908"></a>00908     <span class="keywordflow">goto</span> too_big;
<a name="l00909"></a>00909   }
<a name="l00910"></a>00910   <span class="comment">/* Fall through to the next case, OP_String */</span>
<a name="l00911"></a>00911 }
<a name="l00912"></a>00912   
<a name="l00913"></a>00913 <span class="comment">/* Opcode: String P1 P2 * P4 *</span>
<a name="l00914"></a>00914 <span class="comment">**</span>
<a name="l00915"></a>00915 <span class="comment">** The string value P4 of length P1 (bytes) is stored in register P2.</span>
<a name="l00916"></a>00916 <span class="comment">*/</span>
<a name="l00917"></a>00917 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a53558a93378fb60f25c54934011df9e9">OP_String</a>: {          <span class="comment">/* out2-prerelease */</span>
<a name="l00918"></a>00918   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>!=0 );
<a name="l00919"></a>00919   pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = MEM_Str|MEM_Static|<a class="code" href="vdbeInt_8h.html#a07b1add4713bc55a88ecb0085c846ab7">MEM_Term</a>;
<a name="l00920"></a>00920   pOut-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>;
<a name="l00921"></a>00921   pOut-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l00922"></a>00922   pOut-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = encoding;
<a name="l00923"></a>00923   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pOut);
<a name="l00924"></a>00924   <span class="keywordflow">break</span>;
<a name="l00925"></a>00925 }
<a name="l00926"></a>00926 
<a name="l00927"></a>00927 <span class="comment">/* Opcode: Null * P2 * * *</span>
<a name="l00928"></a>00928 <span class="comment">**</span>
<a name="l00929"></a>00929 <span class="comment">** Write a NULL into register P2.</span>
<a name="l00930"></a>00930 <span class="comment">*/</span>
<a name="l00931"></a>00931 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a9fa8760362f8ea197ca11e99b186206b">OP_Null</a>: {           <span class="comment">/* out2-prerelease */</span>
<a name="l00932"></a>00932   <span class="keywordflow">break</span>;
<a name="l00933"></a>00933 }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935 
<a name="l00936"></a>00936 <span class="preprocessor">#ifndef SQLITE_OMIT_BLOB_LITERAL</span>
<a name="l00937"></a>00937 <span class="preprocessor"></span><span class="comment">/* Opcode: Blob P1 P2 * P4</span>
<a name="l00938"></a>00938 <span class="comment">**</span>
<a name="l00939"></a>00939 <span class="comment">** P4 points to a blob of data P1 bytes long.  Store this</span>
<a name="l00940"></a>00940 <span class="comment">** blob in register P2. This instruction is not coded directly</span>
<a name="l00941"></a>00941 <span class="comment">** by the compiler. Instead, the compiler layer specifies</span>
<a name="l00942"></a>00942 <span class="comment">** an OP_HexBlob opcode, with the hex string representation of</span>
<a name="l00943"></a>00943 <span class="comment">** the blob as P4. This opcode is transformed to an OP_Blob</span>
<a name="l00944"></a>00944 <span class="comment">** the first time it is executed.</span>
<a name="l00945"></a>00945 <span class="comment">*/</span>
<a name="l00946"></a>00946 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a7e0f5fa11738ec2896447b0a1df15dc2">OP_Blob</a>: {                <span class="comment">/* out2-prerelease */</span>
<a name="l00947"></a>00947   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> &lt;= <a class="code" href="sqliteLimit_8h.html#a7b098125363ac8171d012422a0203940">SQLITE_MAX_LENGTH</a> );
<a name="l00948"></a>00948   <a class="code" href="vdbeInt_8h.html#aba781c78989d5481ac168c09108c0ba8">sqlite3VdbeMemSetStr</a>(pOut, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, 0, 0);
<a name="l00949"></a>00949   pOut-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = encoding;
<a name="l00950"></a>00950   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pOut);
<a name="l00951"></a>00951   <span class="keywordflow">break</span>;
<a name="l00952"></a>00952 }
<a name="l00953"></a>00953 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_BLOB_LITERAL */</span>
<a name="l00954"></a>00954 
<a name="l00955"></a>00955 <span class="comment">/* Opcode: Variable P1 P2 * * *</span>
<a name="l00956"></a>00956 <span class="comment">**</span>
<a name="l00957"></a>00957 <span class="comment">** The value of variable P1 is written into register P2. A variable is</span>
<a name="l00958"></a>00958 <span class="comment">** an unknown in the original SQL string as handed to sqlite3_compile().</span>
<a name="l00959"></a>00959 <span class="comment">** Any occurrence of the &apos;?&apos; character in the original SQL is considered</span>
<a name="l00960"></a>00960 <span class="comment">** a variable.  Variables in the SQL string are number from left to</span>
<a name="l00961"></a>00961 <span class="comment">** right beginning with 1.  The values of variables are set using the</span>
<a name="l00962"></a>00962 <span class="comment">** sqlite3_bind() API.</span>
<a name="l00963"></a>00963 <span class="comment">*/</span>
<a name="l00964"></a>00964 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a2ebfabd08425c365befd3c0eca08634b">OP_Variable</a>: {           <span class="comment">/* out2-prerelease */</span>
<a name="l00965"></a>00965   <span class="keywordtype">int</span> j = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> - 1;
<a name="l00966"></a>00966   <a class="code" href="structMem.html">Mem</a> *pVar;
<a name="l00967"></a>00967   assert( j&gt;=0 &amp;&amp; j&lt;p-&gt;nVar );
<a name="l00968"></a>00968 
<a name="l00969"></a>00969   pVar = &amp;p-&gt;<a class="code" href="structVdbe.html#a8877b72591926e3597fa93e22f84b99c">aVar</a>[j];
<a name="l00970"></a>00970   <span class="keywordflow">if</span>( <a class="code" href="vdbeInt_8h.html#ad54b97fcfa33086c7313ef1754d65362">sqlite3VdbeMemTooBig</a>(pVar) ){
<a name="l00971"></a>00971     <span class="keywordflow">goto</span> too_big;
<a name="l00972"></a>00972   }
<a name="l00973"></a>00973   <a class="code" href="vdbeInt_8h.html#a3009da1d59046acf76835bcb353f9fca">sqlite3VdbeMemShallowCopy</a>(pOut, &amp;p-&gt;<a class="code" href="structVdbe.html#a8877b72591926e3597fa93e22f84b99c">aVar</a>[j], MEM_Static);
<a name="l00974"></a>00974   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pOut);
<a name="l00975"></a>00975   <span class="keywordflow">break</span>;
<a name="l00976"></a>00976 }
<a name="l00977"></a>00977 
<a name="l00978"></a>00978 <span class="comment">/* Opcode: Move P1 P2 P3 * *</span>
<a name="l00979"></a>00979 <span class="comment">**</span>
<a name="l00980"></a>00980 <span class="comment">** Move the values in register P1..P1+P3-1 over into</span>
<a name="l00981"></a>00981 <span class="comment">** registers P2..P2+P3-1.  Registers P1..P1+P1-1 are</span>
<a name="l00982"></a>00982 <span class="comment">** left holding a NULL.  It is an error for register ranges</span>
<a name="l00983"></a>00983 <span class="comment">** P1..P1+P3-1 and P2..P2+P3-1 to overlap.</span>
<a name="l00984"></a>00984 <span class="comment">*/</span>
<a name="l00985"></a>00985 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a7e6df7e65a685a85d6cd33a945d3bbe4">OP_Move</a>: {
<a name="l00986"></a>00986   <span class="keywordtype">char</span> *zMalloc;
<a name="l00987"></a>00987   <span class="keywordtype">int</span> n = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;
<a name="l00988"></a>00988   <span class="keywordtype">int</span> p1 = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l00989"></a>00989   <span class="keywordtype">int</span> p2 = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l00990"></a>00990   assert( n&gt;0 );
<a name="l00991"></a>00991   assert( p1&gt;0 );
<a name="l00992"></a>00992   assert( p1+n&lt;p-&gt;nMem );
<a name="l00993"></a>00993   pIn1 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[p1];
<a name="l00994"></a>00994   assert( p2&gt;0 );
<a name="l00995"></a>00995   assert( p2+n&lt;p-&gt;nMem );
<a name="l00996"></a>00996   pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[p2];
<a name="l00997"></a>00997   assert( p1+n&lt;=p2 || p2+n&lt;=p1 );
<a name="l00998"></a>00998   <span class="keywordflow">while</span>( n-- ){
<a name="l00999"></a>00999     zMalloc = pOut-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a>;
<a name="l01000"></a>01000     pOut-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l01001"></a>01001     <a class="code" href="vdbeInt_8h.html#ac6decc64fa0cfb686d6e548953d7705a">sqlite3VdbeMemMove</a>(pOut, pIn1);
<a name="l01002"></a>01002     pIn1-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = zMalloc;
<a name="l01003"></a>01003     <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(p2++, pOut);
<a name="l01004"></a>01004     pIn1++;
<a name="l01005"></a>01005     pOut++;
<a name="l01006"></a>01006   }
<a name="l01007"></a>01007   <span class="keywordflow">break</span>;
<a name="l01008"></a>01008 }
<a name="l01009"></a>01009 
<a name="l01010"></a>01010 <span class="comment">/* Opcode: Copy P1 P2 * * *</span>
<a name="l01011"></a>01011 <span class="comment">**</span>
<a name="l01012"></a>01012 <span class="comment">** Make a copy of register P1 into register P2.</span>
<a name="l01013"></a>01013 <span class="comment">**</span>
<a name="l01014"></a>01014 <span class="comment">** This instruction makes a deep copy of the value.  A duplicate</span>
<a name="l01015"></a>01015 <span class="comment">** is made of any string or blob constant.  See also OP_SCopy.</span>
<a name="l01016"></a>01016 <span class="comment">*/</span>
<a name="l01017"></a>01017 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a199cca2bd475929d963d79d27a75af82">OP_Copy</a>: {
<a name="l01018"></a>01018   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;0 );
<a name="l01019"></a>01019   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l01020"></a>01020   pIn1 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l01021"></a>01021   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 );
<a name="l01022"></a>01022   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l01023"></a>01023   pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l01024"></a>01024   assert( pOut!=pIn1 );
<a name="l01025"></a>01025   <a class="code" href="vdbeInt_8h.html#a3009da1d59046acf76835bcb353f9fca">sqlite3VdbeMemShallowCopy</a>(pOut, pIn1, MEM_Ephem);
<a name="l01026"></a>01026   <a class="code" href="vdbe_8c.html#a3ad1ce209d3f21b491cd09bb096ffd48">Deephemeralize</a>(pOut);
<a name="l01027"></a>01027   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pOut);
<a name="l01028"></a>01028   <span class="keywordflow">break</span>;
<a name="l01029"></a>01029 }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 <span class="comment">/* Opcode: SCopy P1 P2 * * *</span>
<a name="l01032"></a>01032 <span class="comment">**</span>
<a name="l01033"></a>01033 <span class="comment">** Make a shallow copy of register P1 into register P2.</span>
<a name="l01034"></a>01034 <span class="comment">**</span>
<a name="l01035"></a>01035 <span class="comment">** This instruction makes a shallow copy of the value.  If the value</span>
<a name="l01036"></a>01036 <span class="comment">** is a string or blob, then the copy is only a pointer to the</span>
<a name="l01037"></a>01037 <span class="comment">** original and hence if the original changes so will the copy.</span>
<a name="l01038"></a>01038 <span class="comment">** Worse, if the original is deallocated, the copy becomes invalid.</span>
<a name="l01039"></a>01039 <span class="comment">** Thus the program must guarantee that the original will not change</span>
<a name="l01040"></a>01040 <span class="comment">** during the lifetime of the copy.  Use OP_Copy to make a complete</span>
<a name="l01041"></a>01041 <span class="comment">** copy.</span>
<a name="l01042"></a>01042 <span class="comment">*/</span>
<a name="l01043"></a>01043 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#af9e5064dc7159d38276860049da8b3b0">OP_SCopy</a>: {
<a name="l01044"></a>01044   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;0 );
<a name="l01045"></a>01045   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l01046"></a>01046   pIn1 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l01047"></a>01047   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pIn1);
<a name="l01048"></a>01048   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 );
<a name="l01049"></a>01049   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l01050"></a>01050   pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l01051"></a>01051   assert( pOut!=pIn1 );
<a name="l01052"></a>01052   <a class="code" href="vdbeInt_8h.html#a3009da1d59046acf76835bcb353f9fca">sqlite3VdbeMemShallowCopy</a>(pOut, pIn1, MEM_Ephem);
<a name="l01053"></a>01053   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pOut);
<a name="l01054"></a>01054   <span class="keywordflow">break</span>;
<a name="l01055"></a>01055 }
<a name="l01056"></a>01056 
<a name="l01057"></a>01057 <span class="comment">/* Opcode: ResultRow P1 P2 * * *</span>
<a name="l01058"></a>01058 <span class="comment">**</span>
<a name="l01059"></a>01059 <span class="comment">** The registers P1 through P1+P2-1 contain a single row of</span>
<a name="l01060"></a>01060 <span class="comment">** results. This opcode causes the sqlite3_step() call to terminate</span>
<a name="l01061"></a>01061 <span class="comment">** with an SQLITE_ROW return code and it sets up the sqlite3_stmt</span>
<a name="l01062"></a>01062 <span class="comment">** structure to provide access to the top P1 values as the result</span>
<a name="l01063"></a>01063 <span class="comment">** row.</span>
<a name="l01064"></a>01064 <span class="comment">*/</span>
<a name="l01065"></a>01065 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a4a151d57c367806cd9e8a75f4865fd1b">OP_ResultRow</a>: {
<a name="l01066"></a>01066   <a class="code" href="structMem.html">Mem</a> *pMem;
<a name="l01067"></a>01067   <span class="keywordtype">int</span> i;
<a name="l01068"></a>01068   assert( p-&gt;<a class="code" href="structVdbe.html#ae4aebc61bfb17f7dc2099c4143900e83">nResColumn</a>==pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> );
<a name="l01069"></a>01069   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;0 );
<a name="l01070"></a>01070   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>+pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l01071"></a>01071 
<a name="l01072"></a>01072   <span class="comment">/* Invalidate all ephemeral cursor row caches */</span>
<a name="l01073"></a>01073   p-&gt;<a class="code" href="structVdbe.html#ad3eb9132373a6b791c69251f94949744">cacheCtr</a> = (p-&gt;<a class="code" href="structVdbe.html#ad3eb9132373a6b791c69251f94949744">cacheCtr</a> + 2)|1;
<a name="l01074"></a>01074 
<a name="l01075"></a>01075   <span class="comment">/* Make sure the results of the current row are \000 terminated</span>
<a name="l01076"></a>01076 <span class="comment">  ** and have an assigned type.  The results are de-ephemeralized as</span>
<a name="l01077"></a>01077 <span class="comment">  ** as side effect.</span>
<a name="l01078"></a>01078 <span class="comment">  */</span>
<a name="l01079"></a>01079   pMem = p-&gt;<a class="code" href="structVdbe.html#a0dec47b8d8c481df2b73d5bbf9cdde11">pResultSet</a> = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l01080"></a>01080   <span class="keywordflow">for</span>(i=0; i&lt;pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>; i++){
<a name="l01081"></a>01081     <a class="code" href="vdbeInt_8h.html#ad2fc78228cee77b674db3eed601ef0bd">sqlite3VdbeMemNulTerminate</a>(&amp;pMem[i]);
<a name="l01082"></a>01082     <a class="code" href="vdbe_8c.html#a5bd05ac6e7d78cc6314d4d02b0e32793">storeTypeInfo</a>(&amp;pMem[i], encoding);
<a name="l01083"></a>01083     <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>+i, &amp;pMem[i]);
<a name="l01084"></a>01084   }
<a name="l01085"></a>01085   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ) <span class="keywordflow">goto</span> no_mem;
<a name="l01086"></a>01086 
<a name="l01087"></a>01087   <span class="comment">/* Return SQLITE_ROW</span>
<a name="l01088"></a>01088 <span class="comment">  */</span>
<a name="l01089"></a>01089   p-&gt;<a class="code" href="structVdbe.html#a89d6a5b65bb4bbde03f83af4a457eb8a">nCallback</a>++;
<a name="l01090"></a>01090   p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a> = pc + 1;
<a name="l01091"></a>01091   rc = <a class="code" href="sqlite3_8h.html#a624365823d0b11a99ccb49e9bb5f8fcf">SQLITE_ROW</a>;
<a name="l01092"></a>01092   <span class="keywordflow">goto</span> vdbe_return;
<a name="l01093"></a>01093 }
<a name="l01094"></a>01094 
<a name="l01095"></a>01095 <span class="comment">/* Opcode: Concat P1 P2 P3 * *</span>
<a name="l01096"></a>01096 <span class="comment">**</span>
<a name="l01097"></a>01097 <span class="comment">** Add the text in register P1 onto the end of the text in</span>
<a name="l01098"></a>01098 <span class="comment">** register P2 and store the result in register P3.</span>
<a name="l01099"></a>01099 <span class="comment">** If either the P1 or P2 text are NULL then store NULL in P3.</span>
<a name="l01100"></a>01100 <span class="comment">**</span>
<a name="l01101"></a>01101 <span class="comment">**   P3 = P2 || P1</span>
<a name="l01102"></a>01102 <span class="comment">**</span>
<a name="l01103"></a>01103 <span class="comment">** It is illegal for P1 and P3 to be the same register. Sometimes,</span>
<a name="l01104"></a>01104 <span class="comment">** if P3 is the same register as P2, the implementation is able</span>
<a name="l01105"></a>01105 <span class="comment">** to avoid a memcpy().</span>
<a name="l01106"></a>01106 <span class="comment">*/</span>
<a name="l01107"></a>01107 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a75340ebf44b7417a93bb9b87a2ebfe2f">OP_Concat</a>: {           <span class="comment">/* same as TK_CONCAT, in1, in2, out3 */</span>
<a name="l01108"></a>01108   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> nByte;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110   assert( pIn1!=pOut );
<a name="l01111"></a>01111   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> | pIn2-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>) &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l01112"></a>01112     <a class="code" href="vdbeInt_8h.html#a312cd58d3f6b7a2d9c73579685b20c02">sqlite3VdbeMemSetNull</a>(pOut);
<a name="l01113"></a>01113     <span class="keywordflow">break</span>;
<a name="l01114"></a>01114   }
<a name="l01115"></a>01115   <a class="code" href="vdbe_8c.html#a69b8bf9ca78e4cf90c8553b34e2ad336">ExpandBlob</a>(pIn1);
<a name="l01116"></a>01116   <a class="code" href="vdbe_8c.html#a9aa45b1a0b74041d343d26d5bff08377">Stringify</a>(pIn1, encoding);
<a name="l01117"></a>01117   <a class="code" href="vdbe_8c.html#a69b8bf9ca78e4cf90c8553b34e2ad336">ExpandBlob</a>(pIn2);
<a name="l01118"></a>01118   <a class="code" href="vdbe_8c.html#a9aa45b1a0b74041d343d26d5bff08377">Stringify</a>(pIn2, encoding);
<a name="l01119"></a>01119   nByte = pIn1-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> + pIn2-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>;
<a name="l01120"></a>01120   <span class="keywordflow">if</span>( nByte&gt;db-&gt;<a class="code" href="structsqlite3.html#ad8acf663e1619905094c9dfe4125157b">aLimit</a>[<a class="code" href="sqlite3_8h.html#aeba56345f14b7febdafaaa4bc3949245">SQLITE_LIMIT_LENGTH</a>] ){
<a name="l01121"></a>01121     <span class="keywordflow">goto</span> too_big;
<a name="l01122"></a>01122   }
<a name="l01123"></a>01123   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, MEM_Str);
<a name="l01124"></a>01124   <span class="keywordflow">if</span>( <a class="code" href="vdbeInt_8h.html#ac934bc728baa7b73867a62722c30d311">sqlite3VdbeMemGrow</a>(pOut, nByte+2, pOut==pIn2) ){
<a name="l01125"></a>01125     <span class="keywordflow">goto</span> no_mem;
<a name="l01126"></a>01126   }
<a name="l01127"></a>01127   <span class="keywordflow">if</span>( pOut!=pIn2 ){
<a name="l01128"></a>01128     memcpy(pOut-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, pIn2-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, pIn2-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>);
<a name="l01129"></a>01129   }
<a name="l01130"></a>01130   memcpy(&amp;pOut-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[pIn2-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>], pIn1-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, pIn1-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>);
<a name="l01131"></a>01131   pOut-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[nByte] = 0;
<a name="l01132"></a>01132   pOut-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>[nByte+1] = 0;
<a name="l01133"></a>01133   pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> |= <a class="code" href="vdbeInt_8h.html#a07b1add4713bc55a88ecb0085c846ab7">MEM_Term</a>;
<a name="l01134"></a>01134   pOut-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = nByte;
<a name="l01135"></a>01135   pOut-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = encoding;
<a name="l01136"></a>01136   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pOut);
<a name="l01137"></a>01137   <span class="keywordflow">break</span>;
<a name="l01138"></a>01138 }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140 <span class="comment">/* Opcode: Add P1 P2 P3 * *</span>
<a name="l01141"></a>01141 <span class="comment">**</span>
<a name="l01142"></a>01142 <span class="comment">** Add the value in register P1 to the value in register P2</span>
<a name="l01143"></a>01143 <span class="comment">** and store the result in register P3.</span>
<a name="l01144"></a>01144 <span class="comment">** If either input is NULL, the result is NULL.</span>
<a name="l01145"></a>01145 <span class="comment">*/</span>
<a name="l01146"></a>01146 <span class="comment">/* Opcode: Multiply P1 P2 P3 * *</span>
<a name="l01147"></a>01147 <span class="comment">**</span>
<a name="l01148"></a>01148 <span class="comment">**</span>
<a name="l01149"></a>01149 <span class="comment">** Multiply the value in register P1 by the value in register P2</span>
<a name="l01150"></a>01150 <span class="comment">** and store the result in register P3.</span>
<a name="l01151"></a>01151 <span class="comment">** If either input is NULL, the result is NULL.</span>
<a name="l01152"></a>01152 <span class="comment">*/</span>
<a name="l01153"></a>01153 <span class="comment">/* Opcode: Subtract P1 P2 P3 * *</span>
<a name="l01154"></a>01154 <span class="comment">**</span>
<a name="l01155"></a>01155 <span class="comment">** Subtract the value in register P1 from the value in register P2</span>
<a name="l01156"></a>01156 <span class="comment">** and store the result in register P3.</span>
<a name="l01157"></a>01157 <span class="comment">** If either input is NULL, the result is NULL.</span>
<a name="l01158"></a>01158 <span class="comment">*/</span>
<a name="l01159"></a>01159 <span class="comment">/* Opcode: Divide P1 P2 P3 * *</span>
<a name="l01160"></a>01160 <span class="comment">**</span>
<a name="l01161"></a>01161 <span class="comment">** Divide the value in register P1 by the value in register P2</span>
<a name="l01162"></a>01162 <span class="comment">** and store the result in register P3.  If the value in register P2</span>
<a name="l01163"></a>01163 <span class="comment">** is zero, then the result is NULL.</span>
<a name="l01164"></a>01164 <span class="comment">** If either input is NULL, the result is NULL.</span>
<a name="l01165"></a>01165 <span class="comment">*/</span>
<a name="l01166"></a>01166 <span class="comment">/* Opcode: Remainder P1 P2 P3 * *</span>
<a name="l01167"></a>01167 <span class="comment">**</span>
<a name="l01168"></a>01168 <span class="comment">** Compute the remainder after integer division of the value in</span>
<a name="l01169"></a>01169 <span class="comment">** register P1 by the value in register P2 and store the result in P3. </span>
<a name="l01170"></a>01170 <span class="comment">** If the value in register P2 is zero the result is NULL.</span>
<a name="l01171"></a>01171 <span class="comment">** If either operand is NULL, the result is NULL.</span>
<a name="l01172"></a>01172 <span class="comment">*/</span>
<a name="l01173"></a>01173 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aeb890546012c8823566b3f36871d7dc6">OP_Add</a>:                   <span class="comment">/* same as TK_PLUS, in1, in2, out3 */</span>
<a name="l01174"></a>01174 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a5d537ab19c5cbd19c24fd8f480cb6677">OP_Subtract</a>:              <span class="comment">/* same as TK_MINUS, in1, in2, out3 */</span>
<a name="l01175"></a>01175 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3a12937a365f2e33ddca749b1095d48f">OP_Multiply</a>:              <span class="comment">/* same as TK_STAR, in1, in2, out3 */</span>
<a name="l01176"></a>01176 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a4117d2ce898c25dd2d2a9f00c8197590">OP_Divide</a>:                <span class="comment">/* same as TK_SLASH, in1, in2, out3 */</span>
<a name="l01177"></a>01177 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ae6fc4ca92f0033731afb0f22290654df">OP_Remainder</a>: {           <span class="comment">/* same as TK_REM, in1, in2, out3 */</span>
<a name="l01178"></a>01178   <span class="keywordtype">int</span> flags;
<a name="l01179"></a>01179   <a class="code" href="vdbe_8c.html#a746d87f60796d3903aa4b8e7ce123ada">applyNumericAffinity</a>(pIn1);
<a name="l01180"></a>01180   <a class="code" href="vdbe_8c.html#a746d87f60796d3903aa4b8e7ce123ada">applyNumericAffinity</a>(pIn2);
<a name="l01181"></a>01181   flags = pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> | pIn2-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>;
<a name="l01182"></a>01182   <span class="keywordflow">if</span>( (flags &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>)!=0 ) <span class="keywordflow">goto</span> arithmetic_result_is_null;
<a name="l01183"></a>01183   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; pIn2-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>)==<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> ){
<a name="l01184"></a>01184     <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> a, b;
<a name="l01185"></a>01185     a = pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l01186"></a>01186     b = pIn2-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l01187"></a>01187     <span class="keywordflow">switch</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> ){
<a name="l01188"></a>01188       <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aeb890546012c8823566b3f36871d7dc6">OP_Add</a>:         b += a;       <span class="keywordflow">break</span>;
<a name="l01189"></a>01189       <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a5d537ab19c5cbd19c24fd8f480cb6677">OP_Subtract</a>:    b -= a;       <span class="keywordflow">break</span>;
<a name="l01190"></a>01190       <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3a12937a365f2e33ddca749b1095d48f">OP_Multiply</a>:    b *= a;       <span class="keywordflow">break</span>;
<a name="l01191"></a>01191       <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a4117d2ce898c25dd2d2a9f00c8197590">OP_Divide</a>: {
<a name="l01192"></a>01192         <span class="keywordflow">if</span>( a==0 ) <span class="keywordflow">goto</span> arithmetic_result_is_null;
<a name="l01193"></a>01193         <span class="comment">/* Dividing the largest possible negative 64-bit integer (1&lt;&lt;63) by </span>
<a name="l01194"></a>01194 <span class="comment">        ** -1 returns an integer too large to store in a 64-bit data-type. On</span>
<a name="l01195"></a>01195 <span class="comment">        ** some architectures, the value overflows to (1&lt;&lt;63). On others,</span>
<a name="l01196"></a>01196 <span class="comment">        ** a SIGFPE is issued. The following statement normalizes this</span>
<a name="l01197"></a>01197 <span class="comment">        ** behavior so that all architectures behave as if integer </span>
<a name="l01198"></a>01198 <span class="comment">        ** overflow occurred.</span>
<a name="l01199"></a>01199 <span class="comment">        */</span>
<a name="l01200"></a>01200         <span class="keywordflow">if</span>( a==-1 &amp;&amp; b==<a class="code" href="sqliteInt_8h.html#a7acdd4a04ca937094ccd720717a4bc0a">SMALLEST_INT64</a> ) a = 1;
<a name="l01201"></a>01201         b /= a;
<a name="l01202"></a>01202         <span class="keywordflow">break</span>;
<a name="l01203"></a>01203       }
<a name="l01204"></a>01204       <span class="keywordflow">default</span>: {
<a name="l01205"></a>01205         <span class="keywordflow">if</span>( a==0 ) <span class="keywordflow">goto</span> arithmetic_result_is_null;
<a name="l01206"></a>01206         <span class="keywordflow">if</span>( a==-1 ) a = 1;
<a name="l01207"></a>01207         b %= a;
<a name="l01208"></a>01208         <span class="keywordflow">break</span>;
<a name="l01209"></a>01209       }
<a name="l01210"></a>01210     }
<a name="l01211"></a>01211     pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = b;
<a name="l01212"></a>01212     <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l01213"></a>01213   }<span class="keywordflow">else</span>{
<a name="l01214"></a>01214     <span class="keywordtype">double</span> a, b;
<a name="l01215"></a>01215     a = <a class="code" href="vdbeInt_8h.html#a2c297a2c56fc7d55a18b5def3d2dd270">sqlite3VdbeRealValue</a>(pIn1);
<a name="l01216"></a>01216     b = <a class="code" href="vdbeInt_8h.html#a2c297a2c56fc7d55a18b5def3d2dd270">sqlite3VdbeRealValue</a>(pIn2);
<a name="l01217"></a>01217     <span class="keywordflow">switch</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> ){
<a name="l01218"></a>01218       <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aeb890546012c8823566b3f36871d7dc6">OP_Add</a>:         b += a;       <span class="keywordflow">break</span>;
<a name="l01219"></a>01219       <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a5d537ab19c5cbd19c24fd8f480cb6677">OP_Subtract</a>:    b -= a;       <span class="keywordflow">break</span>;
<a name="l01220"></a>01220       <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3a12937a365f2e33ddca749b1095d48f">OP_Multiply</a>:    b *= a;       <span class="keywordflow">break</span>;
<a name="l01221"></a>01221       <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a4117d2ce898c25dd2d2a9f00c8197590">OP_Divide</a>: {
<a name="l01222"></a>01222         <span class="keywordflow">if</span>( a==0.0 ) <span class="keywordflow">goto</span> arithmetic_result_is_null;
<a name="l01223"></a>01223         b /= a;
<a name="l01224"></a>01224         <span class="keywordflow">break</span>;
<a name="l01225"></a>01225       }
<a name="l01226"></a>01226       <span class="keywordflow">default</span>: {
<a name="l01227"></a>01227         <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> ia = (<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)a;
<a name="l01228"></a>01228         <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> ib = (<a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a>)b;
<a name="l01229"></a>01229         <span class="keywordflow">if</span>( ia==0 ) <span class="keywordflow">goto</span> arithmetic_result_is_null;
<a name="l01230"></a>01230         <span class="keywordflow">if</span>( ia==-1 ) ia = 1;
<a name="l01231"></a>01231         b = ib % ia;
<a name="l01232"></a>01232         <span class="keywordflow">break</span>;
<a name="l01233"></a>01233       }
<a name="l01234"></a>01234     }
<a name="l01235"></a>01235     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a82c2a680007adffbdf6e95315b02477d">sqlite3IsNaN</a>(b) ){
<a name="l01236"></a>01236       <span class="keywordflow">goto</span> arithmetic_result_is_null;
<a name="l01237"></a>01237     }
<a name="l01238"></a>01238     pOut-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a> = b;
<a name="l01239"></a>01239     <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>);
<a name="l01240"></a>01240     <span class="keywordflow">if</span>( (flags &amp; <a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>)==0 ){
<a name="l01241"></a>01241       <a class="code" href="vdbeInt_8h.html#afb8c115e74d571571def7ff0d9fa70c5">sqlite3VdbeIntegerAffinity</a>(pOut);
<a name="l01242"></a>01242     }
<a name="l01243"></a>01243   }
<a name="l01244"></a>01244   <span class="keywordflow">break</span>;
<a name="l01245"></a>01245 
<a name="l01246"></a>01246 arithmetic_result_is_null:
<a name="l01247"></a>01247   <a class="code" href="vdbeInt_8h.html#a312cd58d3f6b7a2d9c73579685b20c02">sqlite3VdbeMemSetNull</a>(pOut);
<a name="l01248"></a>01248   <span class="keywordflow">break</span>;
<a name="l01249"></a>01249 }
<a name="l01250"></a>01250 
<a name="l01251"></a>01251 <span class="comment">/* Opcode: CollSeq * * P4</span>
<a name="l01252"></a>01252 <span class="comment">**</span>
<a name="l01253"></a>01253 <span class="comment">** P4 is a pointer to a CollSeq struct. If the next call to a user function</span>
<a name="l01254"></a>01254 <span class="comment">** or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will</span>
<a name="l01255"></a>01255 <span class="comment">** be returned. This is used by the built-in min(), max() and nullif()</span>
<a name="l01256"></a>01256 <span class="comment">** functions.</span>
<a name="l01257"></a>01257 <span class="comment">**</span>
<a name="l01258"></a>01258 <span class="comment">** The interface used by the implementation of the aforementioned functions</span>
<a name="l01259"></a>01259 <span class="comment">** to retrieve the collation sequence set by this opcode is not available</span>
<a name="l01260"></a>01260 <span class="comment">** publicly, only to user functions defined in func.c.</span>
<a name="l01261"></a>01261 <span class="comment">*/</span>
<a name="l01262"></a>01262 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a389d9861bd3309094d8496cf44592380">OP_CollSeq</a>: {
<a name="l01263"></a>01263   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a75b33b0e5ede33c0da0a513e3ff9cdb8">P4_COLLSEQ</a> );
<a name="l01264"></a>01264   <span class="keywordflow">break</span>;
<a name="l01265"></a>01265 }
<a name="l01266"></a>01266 
<a name="l01267"></a>01267 <span class="comment">/* Opcode: Function P1 P2 P3 P4 P5</span>
<a name="l01268"></a>01268 <span class="comment">**</span>
<a name="l01269"></a>01269 <span class="comment">** Invoke a user function (P4 is a pointer to a Function structure that</span>
<a name="l01270"></a>01270 <span class="comment">** defines the function) with P5 arguments taken from register P2 and</span>
<a name="l01271"></a>01271 <span class="comment">** successors.  The result of the function is stored in register P3.</span>
<a name="l01272"></a>01272 <span class="comment">** Register P3 must not be one of the function inputs.</span>
<a name="l01273"></a>01273 <span class="comment">**</span>
<a name="l01274"></a>01274 <span class="comment">** P1 is a 32-bit bitmask indicating whether or not each argument to the </span>
<a name="l01275"></a>01275 <span class="comment">** function was determined to be constant at compile time. If the first</span>
<a name="l01276"></a>01276 <span class="comment">** argument was constant then bit 0 of P1 is set. This is used to determine</span>
<a name="l01277"></a>01277 <span class="comment">** whether meta data associated with a user function argument using the</span>
<a name="l01278"></a>01278 <span class="comment">** sqlite3_set_auxdata() API may be safely retained until the next</span>
<a name="l01279"></a>01279 <span class="comment">** invocation of this opcode.</span>
<a name="l01280"></a>01280 <span class="comment">**</span>
<a name="l01281"></a>01281 <span class="comment">** See also: AggStep and AggFinal</span>
<a name="l01282"></a>01282 <span class="comment">*/</span>
<a name="l01283"></a>01283 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a4b273a1a59a2d7e22996e32c3ab632c9">OP_Function</a>: {
<a name="l01284"></a>01284   <span class="keywordtype">int</span> i;
<a name="l01285"></a>01285   <a class="code" href="structMem.html">Mem</a> *pArg;
<a name="l01286"></a>01286   <a class="code" href="structsqlite3__context.html">sqlite3_context</a> ctx;
<a name="l01287"></a>01287   <a class="code" href="structMem.html">sqlite3_value</a> **apVal;
<a name="l01288"></a>01288   <span class="keywordtype">int</span> n = pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290   apVal = p-&gt;<a class="code" href="structVdbe.html#a74fd4612c55ac2fde475096a4d2605b5">apArg</a>;
<a name="l01291"></a>01291   assert( apVal || n==0 );
<a name="l01292"></a>01292 
<a name="l01293"></a>01293   assert( n==0 || (pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>+n&lt;=p-&gt;nMem) );
<a name="l01294"></a>01294   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> || pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;=pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>+n );
<a name="l01295"></a>01295   pArg = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l01296"></a>01296   <span class="keywordflow">for</span>(i=0; i&lt;n; i++, pArg++){
<a name="l01297"></a>01297     apVal[i] = pArg;
<a name="l01298"></a>01298     <a class="code" href="vdbe_8c.html#a5bd05ac6e7d78cc6314d4d02b0e32793">storeTypeInfo</a>(pArg, encoding);
<a name="l01299"></a>01299     <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pArg);
<a name="l01300"></a>01300   }
<a name="l01301"></a>01301 
<a name="l01302"></a>01302   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a57b87da56c7edb102ed8d0525f9ab54e">P4_FUNCDEF</a> || pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a711e7b05e9760d62cdb148164846fcbc">P4_VDBEFUNC</a> );
<a name="l01303"></a>01303   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a57b87da56c7edb102ed8d0525f9ab54e">P4_FUNCDEF</a> ){
<a name="l01304"></a>01304     ctx.<a class="code" href="structsqlite3__context.html#af4215c87be2c0cb10868f623a552a2aa">pFunc</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a041e9019dd14f775e7dc639e35127d39">pFunc</a>;
<a name="l01305"></a>01305     ctx.<a class="code" href="structsqlite3__context.html#af35405f4f62cfc0b81bb2eb6c82b2363">pVdbeFunc</a> = 0;
<a name="l01306"></a>01306   }<span class="keywordflow">else</span>{
<a name="l01307"></a>01307     ctx.<a class="code" href="structsqlite3__context.html#af35405f4f62cfc0b81bb2eb6c82b2363">pVdbeFunc</a> = (<a class="code" href="structVdbeFunc.html">VdbeFunc</a>*)pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a4091014dd0f37dfb31fb6e75f42f06ec">pVdbeFunc</a>;
<a name="l01308"></a>01308     ctx.<a class="code" href="structsqlite3__context.html#af4215c87be2c0cb10868f623a552a2aa">pFunc</a> = ctx.<a class="code" href="structsqlite3__context.html#af35405f4f62cfc0b81bb2eb6c82b2363">pVdbeFunc</a>-&gt;<a class="code" href="structVdbeFunc.html#a73cbc96029bec2f37c7e2a79052a2f65">pFunc</a>;
<a name="l01309"></a>01309   }
<a name="l01310"></a>01310 
<a name="l01311"></a>01311   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l01312"></a>01312   pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l01313"></a>01313   ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>.<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;
<a name="l01314"></a>01314   ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>.<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = db;
<a name="l01315"></a>01315   ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>.<a class="code" href="structMem.html#a081ea2f86933d68a8940785b62f638ef">xDel</a> = 0;
<a name="l01316"></a>01316   ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l01317"></a>01317 
<a name="l01318"></a>01318   <span class="comment">/* The output cell may already have a buffer allocated. Move</span>
<a name="l01319"></a>01319 <span class="comment">  ** the pointer to ctx.s so in case the user-function can use</span>
<a name="l01320"></a>01320 <span class="comment">  ** the already allocated buffer instead of allocating a new one.</span>
<a name="l01321"></a>01321 <span class="comment">  */</span>
<a name="l01322"></a>01322   <a class="code" href="vdbeInt_8h.html#ac6decc64fa0cfb686d6e548953d7705a">sqlite3VdbeMemMove</a>(&amp;ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>, pOut);
<a name="l01323"></a>01323   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(&amp;ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>, <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>);
<a name="l01324"></a>01324 
<a name="l01325"></a>01325   ctx.<a class="code" href="structsqlite3__context.html#ae4351b8da8c6d2676074612c1b8d4af5">isError</a> = 0;
<a name="l01326"></a>01326   <span class="keywordflow">if</span>( ctx.<a class="code" href="structsqlite3__context.html#af4215c87be2c0cb10868f623a552a2aa">pFunc</a>-&gt;<a class="code" href="structFuncDef.html#aed4dc88e58b7582668bcaf425c4d053f">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#ad57f921244a73d0689df7276b0a5a7d5">SQLITE_FUNC_NEEDCOLL</a> ){
<a name="l01327"></a>01327     assert( pOp&gt;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a> );
<a name="l01328"></a>01328     assert( pOp[-1].p4type==<a class="code" href="vdbe_8h.html#a75b33b0e5ede33c0da0a513e3ff9cdb8">P4_COLLSEQ</a> );
<a name="l01329"></a>01329     assert( pOp[-1].opcode==<a class="code" href="opcodes_8h.html#a389d9861bd3309094d8496cf44592380">OP_CollSeq</a> );
<a name="l01330"></a>01330     ctx.<a class="code" href="structsqlite3__context.html#a4e4b12fb65814515fdb967559693f816">pColl</a> = pOp[-1].<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aaf1833fde93e43f42bac11511a0e9910">pColl</a>;
<a name="l01331"></a>01331   }
<a name="l01332"></a>01332   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l01333"></a>01333   (*ctx.<a class="code" href="structsqlite3__context.html#af4215c87be2c0cb10868f623a552a2aa">pFunc</a>-&gt;<a class="code" href="structFuncDef.html#a1cfd07fdfe22ff504ea7f36c0752c1da">xFunc</a>)(&amp;ctx, n, apVal);
<a name="l01334"></a>01334   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ){
<a name="l01335"></a>01335     <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(&amp;ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>);
<a name="l01336"></a>01336     <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l01337"></a>01337   }
<a name="l01338"></a>01338   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l01339"></a>01339     <span class="comment">/* Even though a malloc() has failed, the implementation of the</span>
<a name="l01340"></a>01340 <span class="comment">    ** user function may have called an sqlite3_result_XXX() function</span>
<a name="l01341"></a>01341 <span class="comment">    ** to return a value. The following call releases any resources</span>
<a name="l01342"></a>01342 <span class="comment">    ** associated with such a value.</span>
<a name="l01343"></a>01343 <span class="comment">    **</span>
<a name="l01344"></a>01344 <span class="comment">    ** Note: Maybe MemRelease() should be called if sqlite3SafetyOn()</span>
<a name="l01345"></a>01345 <span class="comment">    ** fails also (the if(...) statement above). But if people are</span>
<a name="l01346"></a>01346 <span class="comment">    ** misusing sqlite, they have bigger problems than a leaked value.</span>
<a name="l01347"></a>01347 <span class="comment">    */</span>
<a name="l01348"></a>01348     <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(&amp;ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>);
<a name="l01349"></a>01349     <span class="keywordflow">goto</span> no_mem;
<a name="l01350"></a>01350   }
<a name="l01351"></a>01351 
<a name="l01352"></a>01352   <span class="comment">/* If any auxiliary data functions have been called by this user function,</span>
<a name="l01353"></a>01353 <span class="comment">  ** immediately call the destructor for any non-static values.</span>
<a name="l01354"></a>01354 <span class="comment">  */</span>
<a name="l01355"></a>01355   <span class="keywordflow">if</span>( ctx.<a class="code" href="structsqlite3__context.html#af35405f4f62cfc0b81bb2eb6c82b2363">pVdbeFunc</a> ){
<a name="l01356"></a>01356     <a class="code" href="vdbeaux_8c.html#a39bd3906d852580ad020e9261f9d6eba">sqlite3VdbeDeleteAuxData</a>(ctx.<a class="code" href="structsqlite3__context.html#af35405f4f62cfc0b81bb2eb6c82b2363">pVdbeFunc</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>);
<a name="l01357"></a>01357     pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a4091014dd0f37dfb31fb6e75f42f06ec">pVdbeFunc</a> = ctx.<a class="code" href="structsqlite3__context.html#af35405f4f62cfc0b81bb2eb6c82b2363">pVdbeFunc</a>;
<a name="l01358"></a>01358     pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a> = <a class="code" href="vdbe_8h.html#a711e7b05e9760d62cdb148164846fcbc">P4_VDBEFUNC</a>;
<a name="l01359"></a>01359   }
<a name="l01360"></a>01360 
<a name="l01361"></a>01361   <span class="comment">/* If the function returned an error, throw an exception */</span>
<a name="l01362"></a>01362   <span class="keywordflow">if</span>( ctx.<a class="code" href="structsqlite3__context.html#ae4351b8da8c6d2676074612c1b8d4af5">isError</a> ){
<a name="l01363"></a>01363     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(&amp;ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>));
<a name="l01364"></a>01364     rc = ctx.<a class="code" href="structsqlite3__context.html#ae4351b8da8c6d2676074612c1b8d4af5">isError</a>;
<a name="l01365"></a>01365   }
<a name="l01366"></a>01366 
<a name="l01367"></a>01367   <span class="comment">/* Copy the result of the function into register P3 */</span>
<a name="l01368"></a>01368   <a class="code" href="vdbeInt_8h.html#a94f53f04621df5bca68190710998b086">sqlite3VdbeChangeEncoding</a>(&amp;ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>, encoding);
<a name="l01369"></a>01369   <a class="code" href="vdbeInt_8h.html#ac6decc64fa0cfb686d6e548953d7705a">sqlite3VdbeMemMove</a>(pOut, &amp;ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>);
<a name="l01370"></a>01370   <span class="keywordflow">if</span>( <a class="code" href="vdbeInt_8h.html#ad54b97fcfa33086c7313ef1754d65362">sqlite3VdbeMemTooBig</a>(pOut) ){
<a name="l01371"></a>01371     <span class="keywordflow">goto</span> too_big;
<a name="l01372"></a>01372   }
<a name="l01373"></a>01373   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pOut);
<a name="l01374"></a>01374   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pOut);
<a name="l01375"></a>01375   <span class="keywordflow">break</span>;
<a name="l01376"></a>01376 }
<a name="l01377"></a>01377 
<a name="l01378"></a>01378 <span class="comment">/* Opcode: BitAnd P1 P2 P3 * *</span>
<a name="l01379"></a>01379 <span class="comment">**</span>
<a name="l01380"></a>01380 <span class="comment">** Take the bit-wise AND of the values in register P1 and P2 and</span>
<a name="l01381"></a>01381 <span class="comment">** store the result in register P3.</span>
<a name="l01382"></a>01382 <span class="comment">** If either input is NULL, the result is NULL.</span>
<a name="l01383"></a>01383 <span class="comment">*/</span>
<a name="l01384"></a>01384 <span class="comment">/* Opcode: BitOr P1 P2 P3 * *</span>
<a name="l01385"></a>01385 <span class="comment">**</span>
<a name="l01386"></a>01386 <span class="comment">** Take the bit-wise OR of the values in register P1 and P2 and</span>
<a name="l01387"></a>01387 <span class="comment">** store the result in register P3.</span>
<a name="l01388"></a>01388 <span class="comment">** If either input is NULL, the result is NULL.</span>
<a name="l01389"></a>01389 <span class="comment">*/</span>
<a name="l01390"></a>01390 <span class="comment">/* Opcode: ShiftLeft P1 P2 P3 * *</span>
<a name="l01391"></a>01391 <span class="comment">**</span>
<a name="l01392"></a>01392 <span class="comment">** Shift the integer value in register P2 to the left by the</span>
<a name="l01393"></a>01393 <span class="comment">** number of bits specified by the integer in regiser P1.</span>
<a name="l01394"></a>01394 <span class="comment">** Store the result in register P3.</span>
<a name="l01395"></a>01395 <span class="comment">** If either input is NULL, the result is NULL.</span>
<a name="l01396"></a>01396 <span class="comment">*/</span>
<a name="l01397"></a>01397 <span class="comment">/* Opcode: ShiftRight P1 P2 P3 * *</span>
<a name="l01398"></a>01398 <span class="comment">**</span>
<a name="l01399"></a>01399 <span class="comment">** Shift the integer value in register P2 to the right by the</span>
<a name="l01400"></a>01400 <span class="comment">** number of bits specified by the integer in register P1.</span>
<a name="l01401"></a>01401 <span class="comment">** Store the result in register P3.</span>
<a name="l01402"></a>01402 <span class="comment">** If either input is NULL, the result is NULL.</span>
<a name="l01403"></a>01403 <span class="comment">*/</span>
<a name="l01404"></a>01404 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a808516f71594d09d23f0c6b62e3e809e">OP_BitAnd</a>:                 <span class="comment">/* same as TK_BITAND, in1, in2, out3 */</span>
<a name="l01405"></a>01405 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a48774df4fd87711b89569d9f4fa736b2">OP_BitOr</a>:                  <span class="comment">/* same as TK_BITOR, in1, in2, out3 */</span>
<a name="l01406"></a>01406 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ac3f7ad69f441da6a856f679456612daf">OP_ShiftLeft</a>:              <span class="comment">/* same as TK_LSHIFT, in1, in2, out3 */</span>
<a name="l01407"></a>01407 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aaf9e788da13f1d49af0cb0924804d3fd">OP_ShiftRight</a>: {           <span class="comment">/* same as TK_RSHIFT, in1, in2, out3 */</span>
<a name="l01408"></a>01408   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> a, b;
<a name="l01409"></a>01409 
<a name="l01410"></a>01410   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> | pIn2-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>) &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l01411"></a>01411     <a class="code" href="vdbeInt_8h.html#a312cd58d3f6b7a2d9c73579685b20c02">sqlite3VdbeMemSetNull</a>(pOut);
<a name="l01412"></a>01412     <span class="keywordflow">break</span>;
<a name="l01413"></a>01413   }
<a name="l01414"></a>01414   a = <a class="code" href="vdbeInt_8h.html#af740891f040ec074e1a140d71c1cacba">sqlite3VdbeIntValue</a>(pIn2);
<a name="l01415"></a>01415   b = <a class="code" href="vdbeInt_8h.html#af740891f040ec074e1a140d71c1cacba">sqlite3VdbeIntValue</a>(pIn1);
<a name="l01416"></a>01416   <span class="keywordflow">switch</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> ){
<a name="l01417"></a>01417     <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a808516f71594d09d23f0c6b62e3e809e">OP_BitAnd</a>:      a &amp;= b;     <span class="keywordflow">break</span>;
<a name="l01418"></a>01418     <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a48774df4fd87711b89569d9f4fa736b2">OP_BitOr</a>:       a |= b;     <span class="keywordflow">break</span>;
<a name="l01419"></a>01419     <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ac3f7ad69f441da6a856f679456612daf">OP_ShiftLeft</a>:   a &lt;&lt;= b;    <span class="keywordflow">break</span>;
<a name="l01420"></a>01420     <span class="keywordflow">default</span>:  assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#aaf9e788da13f1d49af0cb0924804d3fd">OP_ShiftRight</a> );
<a name="l01421"></a>01421                          a &gt;&gt;= b;    <span class="keywordflow">break</span>;
<a name="l01422"></a>01422   }
<a name="l01423"></a>01423   pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = a;
<a name="l01424"></a>01424   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l01425"></a>01425   <span class="keywordflow">break</span>;
<a name="l01426"></a>01426 }
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 <span class="comment">/* Opcode: AddImm  P1 P2 * * *</span>
<a name="l01429"></a>01429 <span class="comment">** </span>
<a name="l01430"></a>01430 <span class="comment">** Add the constant P2 to the value in register P1.</span>
<a name="l01431"></a>01431 <span class="comment">** The result is always an integer.</span>
<a name="l01432"></a>01432 <span class="comment">**</span>
<a name="l01433"></a>01433 <span class="comment">** To force any register to be an integer, just add 0.</span>
<a name="l01434"></a>01434 <span class="comment">*/</span>
<a name="l01435"></a>01435 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a7714cbc92ac65a80b5b1b7513f17d9b0">OP_AddImm</a>: {            <span class="comment">/* in1 */</span>
<a name="l01436"></a>01436   <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pIn1);
<a name="l01437"></a>01437   pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> += pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l01438"></a>01438   <span class="keywordflow">break</span>;
<a name="l01439"></a>01439 }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441 <span class="comment">/* Opcode: ForceInt P1 P2 P3 * *</span>
<a name="l01442"></a>01442 <span class="comment">**</span>
<a name="l01443"></a>01443 <span class="comment">** Convert value in register P1 into an integer.  If the value </span>
<a name="l01444"></a>01444 <span class="comment">** in P1 is not numeric (meaning that is is a NULL or a string that</span>
<a name="l01445"></a>01445 <span class="comment">** does not look like an integer or floating point number) then</span>
<a name="l01446"></a>01446 <span class="comment">** jump to P2.  If the value in P1 is numeric then</span>
<a name="l01447"></a>01447 <span class="comment">** convert it into the least integer that is greater than or equal to its</span>
<a name="l01448"></a>01448 <span class="comment">** current value if P3==0, or to the least integer that is strictly</span>
<a name="l01449"></a>01449 <span class="comment">** greater than its current value if P3==1.</span>
<a name="l01450"></a>01450 <span class="comment">*/</span>
<a name="l01451"></a>01451 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3b3194df2193c809b9b565003698ab04">OP_ForceInt</a>: {            <span class="comment">/* jump, in1 */</span>
<a name="l01452"></a>01452   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> v;
<a name="l01453"></a>01453   <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>(pIn1, <a class="code" href="sqliteInt_8h.html#acd7dd66f59f94bbb10d8e9a3f0157c38">SQLITE_AFF_NUMERIC</a>, encoding);
<a name="l01454"></a>01454   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; (<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>|<a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>))==0 ){
<a name="l01455"></a>01455     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l01456"></a>01456     <span class="keywordflow">break</span>;
<a name="l01457"></a>01457   }
<a name="l01458"></a>01458   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> ){
<a name="l01459"></a>01459     v = pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> + (pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>!=0);
<a name="l01460"></a>01460   }<span class="keywordflow">else</span>{
<a name="l01461"></a>01461     assert( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a> );
<a name="l01462"></a>01462     v = (<a class="code" href="sqlite3_8h.html#a0a4d3e6c1ad46f90e746b920ab6ca0d2">sqlite3_int64</a>)pIn1-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>;
<a name="l01463"></a>01463     <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>&gt;(<span class="keywordtype">double</span>)v ) v++;
<a name="l01464"></a>01464     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a> &amp;&amp; pIn1-&gt;<a class="code" href="structMem.html#a89ce926e95eb6d3f75344fd6525229da">r</a>==(<span class="keywordtype">double</span>)v ) v++;
<a name="l01465"></a>01465   }
<a name="l01466"></a>01466   pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = v;
<a name="l01467"></a>01467   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pIn1, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l01468"></a>01468   <span class="keywordflow">break</span>;
<a name="l01469"></a>01469 }
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="comment">/* Opcode: MustBeInt P1 P2 * * *</span>
<a name="l01472"></a>01472 <span class="comment">** </span>
<a name="l01473"></a>01473 <span class="comment">** Force the value in register P1 to be an integer.  If the value</span>
<a name="l01474"></a>01474 <span class="comment">** in P1 is not an integer and cannot be converted into an integer</span>
<a name="l01475"></a>01475 <span class="comment">** without data loss, then jump immediately to P2, or if P2==0</span>
<a name="l01476"></a>01476 <span class="comment">** raise an SQLITE_MISMATCH exception.</span>
<a name="l01477"></a>01477 <span class="comment">*/</span>
<a name="l01478"></a>01478 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a580e3f6ffe3e1d44076cdc3ae56f05dc">OP_MustBeInt</a>: {            <span class="comment">/* jump, in1 */</span>
<a name="l01479"></a>01479   <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>(pIn1, <a class="code" href="sqliteInt_8h.html#acd7dd66f59f94bbb10d8e9a3f0157c38">SQLITE_AFF_NUMERIC</a>, encoding);
<a name="l01480"></a>01480   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>)==0 ){
<a name="l01481"></a>01481     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>==0 ){
<a name="l01482"></a>01482       rc = <a class="code" href="sqlite3_8h.html#a788bd19e9f21649acfb6307801c6474f">SQLITE_MISMATCH</a>;
<a name="l01483"></a>01483       <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l01484"></a>01484     }<span class="keywordflow">else</span>{
<a name="l01485"></a>01485       pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487   }<span class="keywordflow">else</span>{
<a name="l01488"></a>01488     <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pIn1, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l01489"></a>01489   }
<a name="l01490"></a>01490   <span class="keywordflow">break</span>;
<a name="l01491"></a>01491 }
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 <span class="comment">/* Opcode: RealAffinity P1 * * * *</span>
<a name="l01494"></a>01494 <span class="comment">**</span>
<a name="l01495"></a>01495 <span class="comment">** If register P1 holds an integer convert it to a real value.</span>
<a name="l01496"></a>01496 <span class="comment">**</span>
<a name="l01497"></a>01497 <span class="comment">** This opcode is used when extracting information from a column that</span>
<a name="l01498"></a>01498 <span class="comment">** has REAL affinity.  Such column values may still be stored as</span>
<a name="l01499"></a>01499 <span class="comment">** integers, for space efficiency, but after extraction we want them</span>
<a name="l01500"></a>01500 <span class="comment">** to have only a real value.</span>
<a name="l01501"></a>01501 <span class="comment">*/</span>
<a name="l01502"></a>01502 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a7711b8825fbf0f8cbc3a137ff30846f7">OP_RealAffinity</a>: {                  <span class="comment">/* in1 */</span>
<a name="l01503"></a>01503   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> ){
<a name="l01504"></a>01504     <a class="code" href="vdbeInt_8h.html#aee9a6411cb0a7b31e361aea01ee97e51">sqlite3VdbeMemRealify</a>(pIn1);
<a name="l01505"></a>01505   }
<a name="l01506"></a>01506   <span class="keywordflow">break</span>;
<a name="l01507"></a>01507 }
<a name="l01508"></a>01508 
<a name="l01509"></a>01509 <span class="preprocessor">#ifndef SQLITE_OMIT_CAST</span>
<a name="l01510"></a>01510 <span class="preprocessor"></span><span class="comment">/* Opcode: ToText P1 * * * *</span>
<a name="l01511"></a>01511 <span class="comment">**</span>
<a name="l01512"></a>01512 <span class="comment">** Force the value in register P1 to be text.</span>
<a name="l01513"></a>01513 <span class="comment">** If the value is numeric, convert it to a string using the</span>
<a name="l01514"></a>01514 <span class="comment">** equivalent of printf().  Blob values are unchanged and</span>
<a name="l01515"></a>01515 <span class="comment">** are afterwards simply interpreted as text.</span>
<a name="l01516"></a>01516 <span class="comment">**</span>
<a name="l01517"></a>01517 <span class="comment">** A NULL value is not changed by this routine.  It remains NULL.</span>
<a name="l01518"></a>01518 <span class="comment">*/</span>
<a name="l01519"></a>01519 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a2d9b684e13eeb8928b71b77eaf3b80cc">OP_ToText</a>: {                  <span class="comment">/* same as TK_TO_TEXT, in1 */</span>
<a name="l01520"></a>01520   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ) <span class="keywordflow">break</span>;
<a name="l01521"></a>01521   assert( MEM_Str==(MEM_Blob&gt;&gt;3) );
<a name="l01522"></a>01522   pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> |= (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;MEM_Blob)&gt;&gt;3;
<a name="l01523"></a>01523   <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>(pIn1, <a class="code" href="sqliteInt_8h.html#a14eb26c096ab7ac7cccd4a4d08b6a84e">SQLITE_AFF_TEXT</a>, encoding);
<a name="l01524"></a>01524   rc = <a class="code" href="vdbe_8c.html#a69b8bf9ca78e4cf90c8553b34e2ad336">ExpandBlob</a>(pIn1);
<a name="l01525"></a>01525   assert( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; MEM_Str || db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> );
<a name="l01526"></a>01526   pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp;= ~(<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>|<a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>|MEM_Blob);
<a name="l01527"></a>01527   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pIn1);
<a name="l01528"></a>01528   <span class="keywordflow">break</span>;
<a name="l01529"></a>01529 }
<a name="l01530"></a>01530 
<a name="l01531"></a>01531 <span class="comment">/* Opcode: ToBlob P1 * * * *</span>
<a name="l01532"></a>01532 <span class="comment">**</span>
<a name="l01533"></a>01533 <span class="comment">** Force the value in register P1 to be a BLOB.</span>
<a name="l01534"></a>01534 <span class="comment">** If the value is numeric, convert it to a string first.</span>
<a name="l01535"></a>01535 <span class="comment">** Strings are simply reinterpreted as blobs with no change</span>
<a name="l01536"></a>01536 <span class="comment">** to the underlying data.</span>
<a name="l01537"></a>01537 <span class="comment">**</span>
<a name="l01538"></a>01538 <span class="comment">** A NULL value is not changed by this routine.  It remains NULL.</span>
<a name="l01539"></a>01539 <span class="comment">*/</span>
<a name="l01540"></a>01540 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#af5c88f06a60127e13d5b0eb5efabfa13">OP_ToBlob</a>: {                  <span class="comment">/* same as TK_TO_BLOB, in1 */</span>
<a name="l01541"></a>01541   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ) <span class="keywordflow">break</span>;
<a name="l01542"></a>01542   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; MEM_Blob)==0 ){
<a name="l01543"></a>01543     <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>(pIn1, <a class="code" href="sqliteInt_8h.html#a14eb26c096ab7ac7cccd4a4d08b6a84e">SQLITE_AFF_TEXT</a>, encoding);
<a name="l01544"></a>01544     assert( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; MEM_Str || db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> );
<a name="l01545"></a>01545   }
<a name="l01546"></a>01546   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pIn1, MEM_Blob);
<a name="l01547"></a>01547   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pIn1);
<a name="l01548"></a>01548   <span class="keywordflow">break</span>;
<a name="l01549"></a>01549 }
<a name="l01550"></a>01550 
<a name="l01551"></a>01551 <span class="comment">/* Opcode: ToNumeric P1 * * * *</span>
<a name="l01552"></a>01552 <span class="comment">**</span>
<a name="l01553"></a>01553 <span class="comment">** Force the value in register P1 to be numeric (either an</span>
<a name="l01554"></a>01554 <span class="comment">** integer or a floating-point number.)</span>
<a name="l01555"></a>01555 <span class="comment">** If the value is text or blob, try to convert it to an using the</span>
<a name="l01556"></a>01556 <span class="comment">** equivalent of atoi() or atof() and store 0 if no such conversion </span>
<a name="l01557"></a>01557 <span class="comment">** is possible.</span>
<a name="l01558"></a>01558 <span class="comment">**</span>
<a name="l01559"></a>01559 <span class="comment">** A NULL value is not changed by this routine.  It remains NULL.</span>
<a name="l01560"></a>01560 <span class="comment">*/</span>
<a name="l01561"></a>01561 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#af38aa0b665e70b7bcb63d9b3105bcff0">OP_ToNumeric</a>: {                  <span class="comment">/* same as TK_TO_NUMERIC, in1 */</span>
<a name="l01562"></a>01562   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; (<a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>|<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>|<a class="code" href="vdbeInt_8h.html#a2775e87c0325fa8546a8f68311905908">MEM_Real</a>))==0 ){
<a name="l01563"></a>01563     <a class="code" href="vdbeInt_8h.html#a84bf8e1853429ef19a83dd5d85627568">sqlite3VdbeMemNumerify</a>(pIn1);
<a name="l01564"></a>01564   }
<a name="l01565"></a>01565   <span class="keywordflow">break</span>;
<a name="l01566"></a>01566 }
<a name="l01567"></a>01567 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_CAST */</span>
<a name="l01568"></a>01568 
<a name="l01569"></a>01569 <span class="comment">/* Opcode: ToInt P1 * * * *</span>
<a name="l01570"></a>01570 <span class="comment">**</span>
<a name="l01571"></a>01571 <span class="comment">** Force the value in register P1 be an integer.  If</span>
<a name="l01572"></a>01572 <span class="comment">** The value is currently a real number, drop its fractional part.</span>
<a name="l01573"></a>01573 <span class="comment">** If the value is text or blob, try to convert it to an integer using the</span>
<a name="l01574"></a>01574 <span class="comment">** equivalent of atoi() and store 0 if no such conversion is possible.</span>
<a name="l01575"></a>01575 <span class="comment">**</span>
<a name="l01576"></a>01576 <span class="comment">** A NULL value is not changed by this routine.  It remains NULL.</span>
<a name="l01577"></a>01577 <span class="comment">*/</span>
<a name="l01578"></a>01578 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a61859a1edd9a562a91cb64c2ac94dc16">OP_ToInt</a>: {                  <span class="comment">/* same as TK_TO_INT, in1 */</span>
<a name="l01579"></a>01579   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>)==0 ){
<a name="l01580"></a>01580     <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pIn1);
<a name="l01581"></a>01581   }
<a name="l01582"></a>01582   <span class="keywordflow">break</span>;
<a name="l01583"></a>01583 }
<a name="l01584"></a>01584 
<a name="l01585"></a>01585 <span class="preprocessor">#ifndef SQLITE_OMIT_CAST</span>
<a name="l01586"></a>01586 <span class="preprocessor"></span><span class="comment">/* Opcode: ToReal P1 * * * *</span>
<a name="l01587"></a>01587 <span class="comment">**</span>
<a name="l01588"></a>01588 <span class="comment">** Force the value in register P1 to be a floating point number.</span>
<a name="l01589"></a>01589 <span class="comment">** If The value is currently an integer, convert it.</span>
<a name="l01590"></a>01590 <span class="comment">** If the value is text or blob, try to convert it to an integer using the</span>
<a name="l01591"></a>01591 <span class="comment">** equivalent of atoi() and store 0.0 if no such conversion is possible.</span>
<a name="l01592"></a>01592 <span class="comment">**</span>
<a name="l01593"></a>01593 <span class="comment">** A NULL value is not changed by this routine.  It remains NULL.</span>
<a name="l01594"></a>01594 <span class="comment">*/</span>
<a name="l01595"></a>01595 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ab544a00fcc2d8aa28a7e0e55742a4c1a">OP_ToReal</a>: {                  <span class="comment">/* same as TK_TO_REAL, in1 */</span>
<a name="l01596"></a>01596   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>)==0 ){
<a name="l01597"></a>01597     <a class="code" href="vdbeInt_8h.html#aee9a6411cb0a7b31e361aea01ee97e51">sqlite3VdbeMemRealify</a>(pIn1);
<a name="l01598"></a>01598   }
<a name="l01599"></a>01599   <span class="keywordflow">break</span>;
<a name="l01600"></a>01600 }
<a name="l01601"></a>01601 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_CAST */</span>
<a name="l01602"></a>01602 
<a name="l01603"></a>01603 <span class="comment">/* Opcode: Lt P1 P2 P3 P4 P5</span>
<a name="l01604"></a>01604 <span class="comment">**</span>
<a name="l01605"></a>01605 <span class="comment">** Compare the values in register P1 and P3.  If reg(P3)&lt;reg(P1) then</span>
<a name="l01606"></a>01606 <span class="comment">** jump to address P2.  </span>
<a name="l01607"></a>01607 <span class="comment">**</span>
<a name="l01608"></a>01608 <span class="comment">** If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or</span>
<a name="l01609"></a>01609 <span class="comment">** reg(P3) is NULL then take the jump.  If the SQLITE_JUMPIFNULL </span>
<a name="l01610"></a>01610 <span class="comment">** bit is clear then fall thru if either operand is NULL.</span>
<a name="l01611"></a>01611 <span class="comment">**</span>
<a name="l01612"></a>01612 <span class="comment">** The SQLITE_AFF_MASK portion of P5 must be an affinity character -</span>
<a name="l01613"></a>01613 <span class="comment">** SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made </span>
<a name="l01614"></a>01614 <span class="comment">** to coerce both inputs according to this affinity before the</span>
<a name="l01615"></a>01615 <span class="comment">** comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric</span>
<a name="l01616"></a>01616 <span class="comment">** affinity is used. Note that the affinity conversions are stored</span>
<a name="l01617"></a>01617 <span class="comment">** back into the input registers P1 and P3.  So this opcode can cause</span>
<a name="l01618"></a>01618 <span class="comment">** persistent changes to registers P1 and P3.</span>
<a name="l01619"></a>01619 <span class="comment">**</span>
<a name="l01620"></a>01620 <span class="comment">** Once any conversions have taken place, and neither value is NULL, </span>
<a name="l01621"></a>01621 <span class="comment">** the values are compared. If both values are blobs then memcmp() is</span>
<a name="l01622"></a>01622 <span class="comment">** used to determine the results of the comparison.  If both values</span>
<a name="l01623"></a>01623 <span class="comment">** are text, then the appropriate collating function specified in</span>
<a name="l01624"></a>01624 <span class="comment">** P4 is  used to do the comparison.  If P4 is not specified then</span>
<a name="l01625"></a>01625 <span class="comment">** memcmp() is used to compare text string.  If both values are</span>
<a name="l01626"></a>01626 <span class="comment">** numeric, then a numeric comparison is used. If the two values</span>
<a name="l01627"></a>01627 <span class="comment">** are of different types, then numbers are considered less than</span>
<a name="l01628"></a>01628 <span class="comment">** strings and strings are considered less than blobs.</span>
<a name="l01629"></a>01629 <span class="comment">**</span>
<a name="l01630"></a>01630 <span class="comment">** If the SQLITE_STOREP2 bit of P5 is set, then do not jump.  Instead,</span>
<a name="l01631"></a>01631 <span class="comment">** store a boolean result (either 0, or 1, or NULL) in register P2.</span>
<a name="l01632"></a>01632 <span class="comment">*/</span>
<a name="l01633"></a>01633 <span class="comment">/* Opcode: Ne P1 P2 P3 P4 P5</span>
<a name="l01634"></a>01634 <span class="comment">**</span>
<a name="l01635"></a>01635 <span class="comment">** This works just like the Lt opcode except that the jump is taken if</span>
<a name="l01636"></a>01636 <span class="comment">** the operands in registers P1 and P3 are not equal.  See the Lt opcode for</span>
<a name="l01637"></a>01637 <span class="comment">** additional information.</span>
<a name="l01638"></a>01638 <span class="comment">*/</span>
<a name="l01639"></a>01639 <span class="comment">/* Opcode: Eq P1 P2 P3 P4 P5</span>
<a name="l01640"></a>01640 <span class="comment">**</span>
<a name="l01641"></a>01641 <span class="comment">** This works just like the Lt opcode except that the jump is taken if</span>
<a name="l01642"></a>01642 <span class="comment">** the operands in registers P1 and P3 are equal.</span>
<a name="l01643"></a>01643 <span class="comment">** See the Lt opcode for additional information.</span>
<a name="l01644"></a>01644 <span class="comment">*/</span>
<a name="l01645"></a>01645 <span class="comment">/* Opcode: Le P1 P2 P3 P4 P5</span>
<a name="l01646"></a>01646 <span class="comment">**</span>
<a name="l01647"></a>01647 <span class="comment">** This works just like the Lt opcode except that the jump is taken if</span>
<a name="l01648"></a>01648 <span class="comment">** the content of register P3 is less than or equal to the content of</span>
<a name="l01649"></a>01649 <span class="comment">** register P1.  See the Lt opcode for additional information.</span>
<a name="l01650"></a>01650 <span class="comment">*/</span>
<a name="l01651"></a>01651 <span class="comment">/* Opcode: Gt P1 P2 P3 P4 P5</span>
<a name="l01652"></a>01652 <span class="comment">**</span>
<a name="l01653"></a>01653 <span class="comment">** This works just like the Lt opcode except that the jump is taken if</span>
<a name="l01654"></a>01654 <span class="comment">** the content of register P3 is greater than the content of</span>
<a name="l01655"></a>01655 <span class="comment">** register P1.  See the Lt opcode for additional information.</span>
<a name="l01656"></a>01656 <span class="comment">*/</span>
<a name="l01657"></a>01657 <span class="comment">/* Opcode: Ge P1 P2 P3 P4 P5</span>
<a name="l01658"></a>01658 <span class="comment">**</span>
<a name="l01659"></a>01659 <span class="comment">** This works just like the Lt opcode except that the jump is taken if</span>
<a name="l01660"></a>01660 <span class="comment">** the content of register P3 is greater than or equal to the content of</span>
<a name="l01661"></a>01661 <span class="comment">** register P1.  See the Lt opcode for additional information.</span>
<a name="l01662"></a>01662 <span class="comment">*/</span>
<a name="l01663"></a>01663 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#acf73fed9b37e6b94d3fdc05156314674">OP_Eq</a>:               <span class="comment">/* same as TK_EQ, jump, in1, in3 */</span>
<a name="l01664"></a>01664 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a72f505669c4d1c712c51c3eaff262b57">OP_Ne</a>:               <span class="comment">/* same as TK_NE, jump, in1, in3 */</span>
<a name="l01665"></a>01665 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a155fbf7f5dbfaf24bddb8edb34ecd951">OP_Lt</a>:               <span class="comment">/* same as TK_LT, jump, in1, in3 */</span>
<a name="l01666"></a>01666 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ad70eb5497f2f4799b7d32d244af95fcd">OP_Le</a>:               <span class="comment">/* same as TK_LE, jump, in1, in3 */</span>
<a name="l01667"></a>01667 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aadc39fa262bf974a66edbe9924c68794">OP_Gt</a>:               <span class="comment">/* same as TK_GT, jump, in1, in3 */</span>
<a name="l01668"></a>01668 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a9b76640baf8827c611aa9b75b57c6cf5">OP_Ge</a>: {             <span class="comment">/* same as TK_GE, jump, in1, in3 */</span>
<a name="l01669"></a>01669   <span class="keywordtype">int</span> flags;
<a name="l01670"></a>01670   <span class="keywordtype">int</span> res;
<a name="l01671"></a>01671   <span class="keywordtype">char</span> affinity;
<a name="l01672"></a>01672 
<a name="l01673"></a>01673   flags = pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>|pIn3-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>;
<a name="l01674"></a>01674 
<a name="l01675"></a>01675   <span class="keywordflow">if</span>( flags&amp;<a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l01676"></a>01676     <span class="comment">/* If either operand is NULL then the result is always NULL.</span>
<a name="l01677"></a>01677 <span class="comment">    ** The jump is taken if the SQLITE_JUMPIFNULL bit is set.</span>
<a name="l01678"></a>01678 <span class="comment">    */</span>
<a name="l01679"></a>01679     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> &amp; <a class="code" href="sqliteInt_8h.html#a566dfaf84a2e1f0d74c8c6559e76943c">SQLITE_STOREP2</a> ){
<a name="l01680"></a>01680       pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l01681"></a>01681       <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, MEM_Null);
<a name="l01682"></a>01682       <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pOut);
<a name="l01683"></a>01683     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> &amp; <a class="code" href="sqliteInt_8h.html#ae3bc696255d4fc2767f872371662bcd1">SQLITE_JUMPIFNULL</a> ){
<a name="l01684"></a>01684       pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>-1;
<a name="l01685"></a>01685     }
<a name="l01686"></a>01686     <span class="keywordflow">break</span>;
<a name="l01687"></a>01687   }
<a name="l01688"></a>01688 
<a name="l01689"></a>01689   affinity = pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> &amp; <a class="code" href="sqliteInt_8h.html#a0656efb72a4cd58851eaf7c71b8d2277">SQLITE_AFF_MASK</a>;
<a name="l01690"></a>01690   <span class="keywordflow">if</span>( affinity ){
<a name="l01691"></a>01691     <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>(pIn1, affinity, encoding);
<a name="l01692"></a>01692     <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>(pIn3, affinity, encoding);
<a name="l01693"></a>01693   }
<a name="l01694"></a>01694 
<a name="l01695"></a>01695   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a75b33b0e5ede33c0da0a513e3ff9cdb8">P4_COLLSEQ</a> || pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aaf1833fde93e43f42bac11511a0e9910">pColl</a>==0 );
<a name="l01696"></a>01696   <a class="code" href="vdbe_8c.html#a69b8bf9ca78e4cf90c8553b34e2ad336">ExpandBlob</a>(pIn1);
<a name="l01697"></a>01697   <a class="code" href="vdbe_8c.html#a69b8bf9ca78e4cf90c8553b34e2ad336">ExpandBlob</a>(pIn3);
<a name="l01698"></a>01698   res = <a class="code" href="vdbeInt_8h.html#aec697f0479b721b582dcab0baf2dd031">sqlite3MemCompare</a>(pIn3, pIn1, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aaf1833fde93e43f42bac11511a0e9910">pColl</a>);
<a name="l01699"></a>01699   <span class="keywordflow">switch</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a> ){
<a name="l01700"></a>01700     <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#acf73fed9b37e6b94d3fdc05156314674">OP_Eq</a>:    res = res==0;     <span class="keywordflow">break</span>;
<a name="l01701"></a>01701     <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a72f505669c4d1c712c51c3eaff262b57">OP_Ne</a>:    res = res!=0;     <span class="keywordflow">break</span>;
<a name="l01702"></a>01702     <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a155fbf7f5dbfaf24bddb8edb34ecd951">OP_Lt</a>:    res = res&lt;0;      <span class="keywordflow">break</span>;
<a name="l01703"></a>01703     <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ad70eb5497f2f4799b7d32d244af95fcd">OP_Le</a>:    res = res&lt;=0;     <span class="keywordflow">break</span>;
<a name="l01704"></a>01704     <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aadc39fa262bf974a66edbe9924c68794">OP_Gt</a>:    res = res&gt;0;      <span class="keywordflow">break</span>;
<a name="l01705"></a>01705     <span class="keywordflow">default</span>:       res = res&gt;=0;     <span class="keywordflow">break</span>;
<a name="l01706"></a>01706   }
<a name="l01707"></a>01707 
<a name="l01708"></a>01708   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> &amp; <a class="code" href="sqliteInt_8h.html#a566dfaf84a2e1f0d74c8c6559e76943c">SQLITE_STOREP2</a> ){
<a name="l01709"></a>01709     pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l01710"></a>01710     <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l01711"></a>01711     pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = res;
<a name="l01712"></a>01712     <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pOut);
<a name="l01713"></a>01713   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( res ){
<a name="l01714"></a>01714     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>-1;
<a name="l01715"></a>01715   }
<a name="l01716"></a>01716   <span class="keywordflow">break</span>;
<a name="l01717"></a>01717 }
<a name="l01718"></a>01718 
<a name="l01719"></a>01719 <span class="comment">/* Opcode: Permutation * * * P4 *</span>
<a name="l01720"></a>01720 <span class="comment">**</span>
<a name="l01721"></a>01721 <span class="comment">** Set the permuation used by the OP_Compare operator to be the array</span>
<a name="l01722"></a>01722 <span class="comment">** of integers in P4.</span>
<a name="l01723"></a>01723 <span class="comment">**</span>
<a name="l01724"></a>01724 <span class="comment">** The permutation is only valid until the next OP_Permutation, OP_Compare,</span>
<a name="l01725"></a>01725 <span class="comment">** OP_Halt, or OP_ResultRow.  Typically the OP_Permutation should occur</span>
<a name="l01726"></a>01726 <span class="comment">** immediately prior to the OP_Compare.</span>
<a name="l01727"></a>01727 <span class="comment">*/</span>
<a name="l01728"></a>01728 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a5f89cc344c2087752fc09b981107351b">OP_Permutation</a>: {
<a name="l01729"></a>01729   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a6049b6360b78fd6f690f090640e9544b">P4_INTARRAY</a> );
<a name="l01730"></a>01730   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#ad04f10290bdb4d5f6378df4b5b4022d5">ai</a> );
<a name="l01731"></a>01731   aPermute = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#ad04f10290bdb4d5f6378df4b5b4022d5">ai</a>;
<a name="l01732"></a>01732   <span class="keywordflow">break</span>;
<a name="l01733"></a>01733 }
<a name="l01734"></a>01734 
<a name="l01735"></a>01735 <span class="comment">/* Opcode: Compare P1 P2 P3 P4 *</span>
<a name="l01736"></a>01736 <span class="comment">**</span>
<a name="l01737"></a>01737 <span class="comment">** Compare to vectors of registers in reg(P1)..reg(P1+P3-1) (all this</span>
<a name="l01738"></a>01738 <span class="comment">** one &quot;A&quot;) and in reg(P2)..reg(P2+P3-1) (&quot;B&quot;).  Save the result of</span>
<a name="l01739"></a>01739 <span class="comment">** the comparison for use by the next OP_Jump instruct.</span>
<a name="l01740"></a>01740 <span class="comment">**</span>
<a name="l01741"></a>01741 <span class="comment">** P4 is a KeyInfo structure that defines collating sequences and sort</span>
<a name="l01742"></a>01742 <span class="comment">** orders for the comparison.  The permutation applies to registers</span>
<a name="l01743"></a>01743 <span class="comment">** only.  The KeyInfo elements are used sequentially.</span>
<a name="l01744"></a>01744 <span class="comment">**</span>
<a name="l01745"></a>01745 <span class="comment">** The comparison is a sort comparison, so NULLs compare equal,</span>
<a name="l01746"></a>01746 <span class="comment">** NULLs are less than numbers, numbers are less than strings,</span>
<a name="l01747"></a>01747 <span class="comment">** and strings are less than blobs.</span>
<a name="l01748"></a>01748 <span class="comment">*/</span>
<a name="l01749"></a>01749 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3614e5fc061a223dfc501a140553141d">OP_Compare</a>: {
<a name="l01750"></a>01750   <span class="keywordtype">int</span> n = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;
<a name="l01751"></a>01751   <span class="keywordtype">int</span> i, p1, p2;
<a name="l01752"></a>01752   <span class="keyword">const</span> <a class="code" href="structKeyInfo.html">KeyInfo</a> *pKeyInfo = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a531b315fc943dd3990adb10e687ba737">pKeyInfo</a>;
<a name="l01753"></a>01753   assert( n&gt;0 );
<a name="l01754"></a>01754   assert( pKeyInfo!=0 );
<a name="l01755"></a>01755   p1 = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l01756"></a>01756   assert( p1&gt;0 &amp;&amp; p1+n-1&lt;p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l01757"></a>01757   p2 = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l01758"></a>01758   assert( p2&gt;0 &amp;&amp; p2+n-1&lt;p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l01759"></a>01759   <span class="keywordflow">for</span>(i=0; i&lt;n; i++){
<a name="l01760"></a>01760     <span class="keywordtype">int</span> idx = aPermute ? aPermute[i] : i;
<a name="l01761"></a>01761     <a class="code" href="structCollSeq.html">CollSeq</a> *pColl;    <span class="comment">/* Collating sequence to use on this term */</span>
<a name="l01762"></a>01762     <span class="keywordtype">int</span> bRev;          <span class="comment">/* True for DESCENDING sort order */</span>
<a name="l01763"></a>01763     <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(p1+idx, &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[p1+idx]);
<a name="l01764"></a>01764     <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(p2+idx, &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[p2+idx]);
<a name="l01765"></a>01765     assert( i&lt;pKeyInfo-&gt;nField );
<a name="l01766"></a>01766     pColl = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ad43aa024fca5a065e75d8e24b231adcb">aColl</a>[i];
<a name="l01767"></a>01767     bRev = pKeyInfo-&gt;<a class="code" href="structKeyInfo.html#ac5fe4bd0172a1f11f41f678528a7b21e">aSortOrder</a>[i];
<a name="l01768"></a>01768     iCompare = <a class="code" href="vdbeInt_8h.html#aec697f0479b721b582dcab0baf2dd031">sqlite3MemCompare</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[p1+idx], &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[p2+idx], pColl);
<a name="l01769"></a>01769     <span class="keywordflow">if</span>( iCompare ){
<a name="l01770"></a>01770       <span class="keywordflow">if</span>( bRev ) iCompare = -iCompare;
<a name="l01771"></a>01771       <span class="keywordflow">break</span>;
<a name="l01772"></a>01772     }
<a name="l01773"></a>01773   }
<a name="l01774"></a>01774   aPermute = 0;
<a name="l01775"></a>01775   <span class="keywordflow">break</span>;
<a name="l01776"></a>01776 }
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 <span class="comment">/* Opcode: Jump P1 P2 P3 * *</span>
<a name="l01779"></a>01779 <span class="comment">**</span>
<a name="l01780"></a>01780 <span class="comment">** Jump to the instruction at address P1, P2, or P3 depending on whether</span>
<a name="l01781"></a>01781 <span class="comment">** in the most recent OP_Compare instruction the P1 vector was less than</span>
<a name="l01782"></a>01782 <span class="comment">** equal to, or greater than the P2 vector, respectively.</span>
<a name="l01783"></a>01783 <span class="comment">*/</span>
<a name="l01784"></a>01784 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ae666bfaba9ee0a77af194f998d89ea75">OP_Jump</a>: {             <span class="comment">/* jump */</span>
<a name="l01785"></a>01785   <span class="keywordflow">if</span>( iCompare&lt;0 ){
<a name="l01786"></a>01786     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> - 1;
<a name="l01787"></a>01787   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( iCompare==0 ){
<a name="l01788"></a>01788     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l01789"></a>01789   }<span class="keywordflow">else</span>{
<a name="l01790"></a>01790     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a> - 1;
<a name="l01791"></a>01791   }
<a name="l01792"></a>01792   <span class="keywordflow">break</span>;
<a name="l01793"></a>01793 }
<a name="l01794"></a>01794 
<a name="l01795"></a>01795 <span class="comment">/* Opcode: And P1 P2 P3 * *</span>
<a name="l01796"></a>01796 <span class="comment">**</span>
<a name="l01797"></a>01797 <span class="comment">** Take the logical AND of the values in registers P1 and P2 and</span>
<a name="l01798"></a>01798 <span class="comment">** write the result into register P3.</span>
<a name="l01799"></a>01799 <span class="comment">**</span>
<a name="l01800"></a>01800 <span class="comment">** If either P1 or P2 is 0 (false) then the result is 0 even if</span>
<a name="l01801"></a>01801 <span class="comment">** the other input is NULL.  A NULL and true or two NULLs give</span>
<a name="l01802"></a>01802 <span class="comment">** a NULL output.</span>
<a name="l01803"></a>01803 <span class="comment">*/</span>
<a name="l01804"></a>01804 <span class="comment">/* Opcode: Or P1 P2 P3 * *</span>
<a name="l01805"></a>01805 <span class="comment">**</span>
<a name="l01806"></a>01806 <span class="comment">** Take the logical OR of the values in register P1 and P2 and</span>
<a name="l01807"></a>01807 <span class="comment">** store the answer in register P3.</span>
<a name="l01808"></a>01808 <span class="comment">**</span>
<a name="l01809"></a>01809 <span class="comment">** If either P1 or P2 is nonzero (true) then the result is 1 (true)</span>
<a name="l01810"></a>01810 <span class="comment">** even if the other input is NULL.  A NULL and false or two NULLs</span>
<a name="l01811"></a>01811 <span class="comment">** give a NULL output.</span>
<a name="l01812"></a>01812 <span class="comment">*/</span>
<a name="l01813"></a>01813 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ab379966a1411dab39cc1892adf60020a">OP_And</a>:              <span class="comment">/* same as TK_AND, in1, in2, out3 */</span>
<a name="l01814"></a>01814 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#add71cab87a29aaf9a6ef32a3fa99685e">OP_Or</a>: {             <span class="comment">/* same as TK_OR, in1, in2, out3 */</span>
<a name="l01815"></a>01815   <span class="keywordtype">int</span> v1, v2;    <span class="comment">/* 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */</span>
<a name="l01816"></a>01816 
<a name="l01817"></a>01817   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l01818"></a>01818     v1 = 2;
<a name="l01819"></a>01819   }<span class="keywordflow">else</span>{
<a name="l01820"></a>01820     v1 = <a class="code" href="vdbeInt_8h.html#af740891f040ec074e1a140d71c1cacba">sqlite3VdbeIntValue</a>(pIn1)!=0;
<a name="l01821"></a>01821   }
<a name="l01822"></a>01822   <span class="keywordflow">if</span>( pIn2-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l01823"></a>01823     v2 = 2;
<a name="l01824"></a>01824   }<span class="keywordflow">else</span>{
<a name="l01825"></a>01825     v2 = <a class="code" href="vdbeInt_8h.html#af740891f040ec074e1a140d71c1cacba">sqlite3VdbeIntValue</a>(pIn2)!=0;
<a name="l01826"></a>01826   }
<a name="l01827"></a>01827   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#ab379966a1411dab39cc1892adf60020a">OP_And</a> ){
<a name="l01828"></a>01828     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> and_logic[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 };
<a name="l01829"></a>01829     v1 = and_logic[v1*3+v2];
<a name="l01830"></a>01830   }<span class="keywordflow">else</span>{
<a name="l01831"></a>01831     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> or_logic[] = { 0, 1, 2, 1, 1, 1, 2, 1, 2 };
<a name="l01832"></a>01832     v1 = or_logic[v1*3+v2];
<a name="l01833"></a>01833   }
<a name="l01834"></a>01834   <span class="keywordflow">if</span>( v1==2 ){
<a name="l01835"></a>01835     <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>);
<a name="l01836"></a>01836   }<span class="keywordflow">else</span>{
<a name="l01837"></a>01837     pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = v1;
<a name="l01838"></a>01838     <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l01839"></a>01839   }
<a name="l01840"></a>01840   <span class="keywordflow">break</span>;
<a name="l01841"></a>01841 }
<a name="l01842"></a>01842 
<a name="l01843"></a>01843 <span class="comment">/* Opcode: Not P1 * * * *</span>
<a name="l01844"></a>01844 <span class="comment">**</span>
<a name="l01845"></a>01845 <span class="comment">** Interpret the value in register P1 as a boolean value.  Replace it</span>
<a name="l01846"></a>01846 <span class="comment">** with its complement.  If the value in register P1 is NULL its value</span>
<a name="l01847"></a>01847 <span class="comment">** is unchanged.</span>
<a name="l01848"></a>01848 <span class="comment">*/</span>
<a name="l01849"></a>01849 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a721f5350755626d3a55189eb7647809e">OP_Not</a>: {                <span class="comment">/* same as TK_NOT, in1 */</span>
<a name="l01850"></a>01850   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ) <span class="keywordflow">break</span>;  <span class="comment">/* Do nothing to NULLs */</span>
<a name="l01851"></a>01851   <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pIn1);
<a name="l01852"></a>01852   pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = !pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l01853"></a>01853   assert( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l01854"></a>01854   <span class="keywordflow">break</span>;
<a name="l01855"></a>01855 }
<a name="l01856"></a>01856 
<a name="l01857"></a>01857 <span class="comment">/* Opcode: BitNot P1 * * * *</span>
<a name="l01858"></a>01858 <span class="comment">**</span>
<a name="l01859"></a>01859 <span class="comment">** Interpret the content of register P1 as an integer.  Replace it</span>
<a name="l01860"></a>01860 <span class="comment">** with its ones-complement.  If the value is originally NULL, leave</span>
<a name="l01861"></a>01861 <span class="comment">** it unchanged.</span>
<a name="l01862"></a>01862 <span class="comment">*/</span>
<a name="l01863"></a>01863 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aeae389b7c43fdc158c4676c193037fa0">OP_BitNot</a>: {             <span class="comment">/* same as TK_BITNOT, in1 */</span>
<a name="l01864"></a>01864   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ) <span class="keywordflow">break</span>;  <span class="comment">/* Do nothing to NULLs */</span>
<a name="l01865"></a>01865   <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pIn1);
<a name="l01866"></a>01866   pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = ~pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l01867"></a>01867   assert( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l01868"></a>01868   <span class="keywordflow">break</span>;
<a name="l01869"></a>01869 }
<a name="l01870"></a>01870 
<a name="l01871"></a>01871 <span class="comment">/* Opcode: If P1 P2 P3 * *</span>
<a name="l01872"></a>01872 <span class="comment">**</span>
<a name="l01873"></a>01873 <span class="comment">** Jump to P2 if the value in register P1 is true.  The value is</span>
<a name="l01874"></a>01874 <span class="comment">** is considered true if it is numeric and non-zero.  If the value</span>
<a name="l01875"></a>01875 <span class="comment">** in P1 is NULL then take the jump if P3 is true.</span>
<a name="l01876"></a>01876 <span class="comment">*/</span>
<a name="l01877"></a>01877 <span class="comment">/* Opcode: IfNot P1 P2 P3 * *</span>
<a name="l01878"></a>01878 <span class="comment">**</span>
<a name="l01879"></a>01879 <span class="comment">** Jump to P2 if the value in register P1 is False.  The value is</span>
<a name="l01880"></a>01880 <span class="comment">** is considered true if it has a numeric value of zero.  If the value</span>
<a name="l01881"></a>01881 <span class="comment">** in P1 is NULL then take the jump if P3 is true.</span>
<a name="l01882"></a>01882 <span class="comment">*/</span>
<a name="l01883"></a>01883 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ac2b8b882b701cfbad6bfca4ac6db76bc">OP_If</a>:                 <span class="comment">/* jump, in1 */</span>
<a name="l01884"></a>01884 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a0a9e48b3f9e90716ecab8041c7c0e8ac">OP_IfNot</a>: {            <span class="comment">/* jump, in1 */</span>
<a name="l01885"></a>01885   <span class="keywordtype">int</span> c;
<a name="l01886"></a>01886   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l01887"></a>01887     c = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;
<a name="l01888"></a>01888   }<span class="keywordflow">else</span>{
<a name="l01889"></a>01889 <span class="preprocessor">#ifdef SQLITE_OMIT_FLOATING_POINT</span>
<a name="l01890"></a>01890 <span class="preprocessor"></span>    c = <a class="code" href="vdbeInt_8h.html#af740891f040ec074e1a140d71c1cacba">sqlite3VdbeIntValue</a>(pIn1);
<a name="l01891"></a>01891 <span class="preprocessor">#else</span>
<a name="l01892"></a>01892 <span class="preprocessor"></span>    c = <a class="code" href="vdbeInt_8h.html#a2c297a2c56fc7d55a18b5def3d2dd270">sqlite3VdbeRealValue</a>(pIn1)!=0.0;
<a name="l01893"></a>01893 <span class="preprocessor">#endif</span>
<a name="l01894"></a>01894 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a0a9e48b3f9e90716ecab8041c7c0e8ac">OP_IfNot</a> ) c = !c;
<a name="l01895"></a>01895   }
<a name="l01896"></a>01896   <span class="keywordflow">if</span>( c ){
<a name="l01897"></a>01897     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>-1;
<a name="l01898"></a>01898   }
<a name="l01899"></a>01899   <span class="keywordflow">break</span>;
<a name="l01900"></a>01900 }
<a name="l01901"></a>01901 
<a name="l01902"></a>01902 <span class="comment">/* Opcode: IsNull P1 P2 P3 * *</span>
<a name="l01903"></a>01903 <span class="comment">**</span>
<a name="l01904"></a>01904 <span class="comment">** Jump to P2 if the value in register P1 is NULL.  If P3 is greater</span>
<a name="l01905"></a>01905 <span class="comment">** than zero, then check all values reg(P1), reg(P1+1), </span>
<a name="l01906"></a>01906 <span class="comment">** reg(P1+2), ..., reg(P1+P3-1).</span>
<a name="l01907"></a>01907 <span class="comment">*/</span>
<a name="l01908"></a>01908 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aa94eede07c1e2c3fcb96239fa368a3d2">OP_IsNull</a>: {            <span class="comment">/* same as TK_ISNULL, jump, in1 */</span>
<a name="l01909"></a>01909   <span class="keywordtype">int</span> n = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;
<a name="l01910"></a>01910   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>==0 || pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;0 );
<a name="l01911"></a>01911   <span class="keywordflow">do</span>{
<a name="l01912"></a>01912     <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>)!=0 ){
<a name="l01913"></a>01913       pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l01914"></a>01914       <span class="keywordflow">break</span>;
<a name="l01915"></a>01915     }
<a name="l01916"></a>01916     pIn1++;
<a name="l01917"></a>01917   }<span class="keywordflow">while</span>( --n &gt; 0 );
<a name="l01918"></a>01918   <span class="keywordflow">break</span>;
<a name="l01919"></a>01919 }
<a name="l01920"></a>01920 
<a name="l01921"></a>01921 <span class="comment">/* Opcode: NotNull P1 P2 * * *</span>
<a name="l01922"></a>01922 <span class="comment">**</span>
<a name="l01923"></a>01923 <span class="comment">** Jump to P2 if the value in register P1 is not NULL.  </span>
<a name="l01924"></a>01924 <span class="comment">*/</span>
<a name="l01925"></a>01925 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a2c2d69757c7bf41ae12092a80b04c088">OP_NotNull</a>: {            <span class="comment">/* same as TK_NOTNULL, jump, in1 */</span>
<a name="l01926"></a>01926   <span class="keywordflow">if</span>( (pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>)==0 ){
<a name="l01927"></a>01927     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l01928"></a>01928   }
<a name="l01929"></a>01929   <span class="keywordflow">break</span>;
<a name="l01930"></a>01930 }
<a name="l01931"></a>01931 
<a name="l01932"></a>01932 <span class="comment">/* Opcode: SetNumColumns * P2 * * *</span>
<a name="l01933"></a>01933 <span class="comment">**</span>
<a name="l01934"></a>01934 <span class="comment">** This opcode sets the number of columns for the cursor opened by the</span>
<a name="l01935"></a>01935 <span class="comment">** following instruction to P2.</span>
<a name="l01936"></a>01936 <span class="comment">**</span>
<a name="l01937"></a>01937 <span class="comment">** An OP_SetNumColumns is only useful if it occurs immediately before </span>
<a name="l01938"></a>01938 <span class="comment">** one of the following opcodes:</span>
<a name="l01939"></a>01939 <span class="comment">**</span>
<a name="l01940"></a>01940 <span class="comment">**     OpenRead</span>
<a name="l01941"></a>01941 <span class="comment">**     OpenWrite</span>
<a name="l01942"></a>01942 <span class="comment">**     OpenPseudo</span>
<a name="l01943"></a>01943 <span class="comment">**</span>
<a name="l01944"></a>01944 <span class="comment">** If the OP_Column opcode is to be executed on a cursor, then</span>
<a name="l01945"></a>01945 <span class="comment">** this opcode must be present immediately before the opcode that</span>
<a name="l01946"></a>01946 <span class="comment">** opens the cursor.</span>
<a name="l01947"></a>01947 <span class="comment">*/</span>
<a name="l01948"></a>01948 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a573b06e057d808cf609dd66f29e0d998">OP_SetNumColumns</a>: {
<a name="l01949"></a>01949   <span class="keywordflow">break</span>;
<a name="l01950"></a>01950 }
<a name="l01951"></a>01951 
<a name="l01952"></a>01952 <span class="comment">/* Opcode: Column P1 P2 P3 P4 *</span>
<a name="l01953"></a>01953 <span class="comment">**</span>
<a name="l01954"></a>01954 <span class="comment">** Interpret the data that cursor P1 points to as a structure built using</span>
<a name="l01955"></a>01955 <span class="comment">** the MakeRecord instruction.  (See the MakeRecord opcode for additional</span>
<a name="l01956"></a>01956 <span class="comment">** information about the format of the data.)  Extract the P2-th column</span>
<a name="l01957"></a>01957 <span class="comment">** from this record.  If there are less that (P2+1) </span>
<a name="l01958"></a>01958 <span class="comment">** values in the record, extract a NULL.</span>
<a name="l01959"></a>01959 <span class="comment">**</span>
<a name="l01960"></a>01960 <span class="comment">** The value extracted is stored in register P3.</span>
<a name="l01961"></a>01961 <span class="comment">**</span>
<a name="l01962"></a>01962 <span class="comment">** If the column contains fewer than P2 fields, then extract a NULL.  Or,</span>
<a name="l01963"></a>01963 <span class="comment">** if the P4 argument is a P4_MEM use the value of the P4 argument as</span>
<a name="l01964"></a>01964 <span class="comment">** the result.</span>
<a name="l01965"></a>01965 <span class="comment">*/</span>
<a name="l01966"></a>01966 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a38d4675eacb229ecb7fbf9062c880773">OP_Column</a>: {
<a name="l01967"></a>01967   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> payloadSize;   <span class="comment">/* Number of bytes in the record */</span>
<a name="l01968"></a>01968   <span class="keywordtype">int</span> p1 = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;  <span class="comment">/* P1 value of the opcode */</span>
<a name="l01969"></a>01969   <span class="keywordtype">int</span> p2 = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;  <span class="comment">/* column number to retrieve */</span>
<a name="l01970"></a>01970   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC = 0;<span class="comment">/* The VDBE cursor */</span>
<a name="l01971"></a>01971   <span class="keywordtype">char</span> *zRec;        <span class="comment">/* Pointer to complete record-data */</span>
<a name="l01972"></a>01972   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;   <span class="comment">/* The BTree cursor */</span>
<a name="l01973"></a>01973   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> *aType;        <span class="comment">/* aType[i] holds the numeric type of the i-th column */</span>
<a name="l01974"></a>01974   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> *aOffset;      <span class="comment">/* aOffset[i] is offset to start of data for i-th column */</span>
<a name="l01975"></a>01975   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> nField;        <span class="comment">/* number of fields in the record */</span>
<a name="l01976"></a>01976   <span class="keywordtype">int</span> len;           <span class="comment">/* The length of the serialized data for the column */</span>
<a name="l01977"></a>01977   <span class="keywordtype">int</span> i;             <span class="comment">/* Loop counter */</span>
<a name="l01978"></a>01978   <span class="keywordtype">char</span> *zData;       <span class="comment">/* Part of the record being decoded */</span>
<a name="l01979"></a>01979   <a class="code" href="structMem.html">Mem</a> *pDest;        <span class="comment">/* Where to write the extracted value */</span>
<a name="l01980"></a>01980   <a class="code" href="structMem.html">Mem</a> sMem;          <span class="comment">/* For storing the record being decoded */</span>
<a name="l01981"></a>01981 
<a name="l01982"></a>01982   sMem.<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = 0;
<a name="l01983"></a>01983   sMem.<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = 0;
<a name="l01984"></a>01984   sMem.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l01985"></a>01985   assert( p1&lt;p-&gt;nCursor );
<a name="l01986"></a>01986   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l01987"></a>01987   pDest = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l01988"></a>01988   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pDest, <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>);
<a name="l01989"></a>01989 
<a name="l01990"></a>01990   <span class="comment">/* This block sets the variable payloadSize to be the total number of</span>
<a name="l01991"></a>01991 <span class="comment">  ** bytes in the record.</span>
<a name="l01992"></a>01992 <span class="comment">  **</span>
<a name="l01993"></a>01993 <span class="comment">  ** zRec is set to be the complete text of the record if it is available.</span>
<a name="l01994"></a>01994 <span class="comment">  ** The complete record text is always available for pseudo-tables</span>
<a name="l01995"></a>01995 <span class="comment">  ** If the record is stored in a cursor, the complete record text</span>
<a name="l01996"></a>01996 <span class="comment">  ** might be available in the  pC-&gt;aRow cache.  Or it might not be.</span>
<a name="l01997"></a>01997 <span class="comment">  ** If the data is unavailable,  zRec is set to NULL.</span>
<a name="l01998"></a>01998 <span class="comment">  **</span>
<a name="l01999"></a>01999 <span class="comment">  ** We also compute the number of columns in the record.  For cursors,</span>
<a name="l02000"></a>02000 <span class="comment">  ** the number of columns is stored in the VdbeCursor.nField element.</span>
<a name="l02001"></a>02001 <span class="comment">  */</span>
<a name="l02002"></a>02002   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[p1];
<a name="l02003"></a>02003   assert( pC!=0 );
<a name="l02004"></a>02004 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l02005"></a>02005 <span class="preprocessor"></span>  assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>==0 );
<a name="l02006"></a>02006 <span class="preprocessor">#endif</span>
<a name="l02007"></a>02007 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>!=0 ){
<a name="l02008"></a>02008     <span class="comment">/* The record is stored in a B-Tree */</span>
<a name="l02009"></a>02009     rc = <a class="code" href="vdbeaux_8c.html#a0e6c6ab44bba69b7b9d4e5b8c461dfe2">sqlite3VdbeCursorMoveto</a>(pC);
<a name="l02010"></a>02010     <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l02011"></a>02011     zRec = 0;
<a name="l02012"></a>02012     pCrsr = pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>;
<a name="l02013"></a>02013     <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> ){
<a name="l02014"></a>02014       payloadSize = 0;
<a name="l02015"></a>02015     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a>==p-&gt;<a class="code" href="structVdbe.html#ad3eb9132373a6b791c69251f94949744">cacheCtr</a> ){
<a name="l02016"></a>02016       payloadSize = pC-&gt;<a class="code" href="structVdbeCursor.html#a5c1fa124d7f27a30e14ef0f455955cab">payloadSize</a>;
<a name="l02017"></a>02017       zRec = (<span class="keywordtype">char</span>*)pC-&gt;<a class="code" href="structVdbeCursor.html#a6bd10979ffb5d4828967eea1d6e0d2c8">aRow</a>;
<a name="l02018"></a>02018     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> ){
<a name="l02019"></a>02019       <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> payloadSize64;
<a name="l02020"></a>02020       <a class="code" href="btree_8c.html#a2d5023d925e7eade74a33a94fbbc45e0">sqlite3BtreeKeySize</a>(pCrsr, &amp;payloadSize64);
<a name="l02021"></a>02021       payloadSize = payloadSize64;
<a name="l02022"></a>02022     }<span class="keywordflow">else</span>{
<a name="l02023"></a>02023       <a class="code" href="btree_8c.html#a8c49974ebd7131c7789e3bdb7fd41c96">sqlite3BtreeDataSize</a>(pCrsr, &amp;payloadSize);
<a name="l02024"></a>02024     }
<a name="l02025"></a>02025     nField = pC-&gt;<a class="code" href="structVdbeCursor.html#aa115a60e335e738945127141303eaedb">nField</a>;
<a name="l02026"></a>02026   }<span class="keywordflow">else</span>{
<a name="l02027"></a>02027     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a762de613989f39beaf12a05af896300a">pseudoTable</a> );
<a name="l02028"></a>02028     <span class="comment">/* The record is the sole entry of a pseudo-table */</span>
<a name="l02029"></a>02029     payloadSize = pC-&gt;<a class="code" href="structVdbeCursor.html#ae321ce63d59409703a48a48d82d24830">nData</a>;
<a name="l02030"></a>02030     zRec = pC-&gt;<a class="code" href="structVdbeCursor.html#a24a939339569b64ed386652955df6be7">pData</a>;
<a name="l02031"></a>02031     pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l02032"></a>02032     assert( payloadSize==0 || zRec!=0 );
<a name="l02033"></a>02033     nField = pC-&gt;<a class="code" href="structVdbeCursor.html#aa115a60e335e738945127141303eaedb">nField</a>;
<a name="l02034"></a>02034     pCrsr = 0;
<a name="l02035"></a>02035   }
<a name="l02036"></a>02036 
<a name="l02037"></a>02037   <span class="comment">/* If payloadSize is 0, then just store a NULL */</span>
<a name="l02038"></a>02038   <span class="keywordflow">if</span>( payloadSize==0 ){
<a name="l02039"></a>02039     assert( pDest-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> );
<a name="l02040"></a>02040     <span class="keywordflow">goto</span> op_column_out;
<a name="l02041"></a>02041   }
<a name="l02042"></a>02042   <span class="keywordflow">if</span>( payloadSize&gt;db-&gt;<a class="code" href="structsqlite3.html#ad8acf663e1619905094c9dfe4125157b">aLimit</a>[<a class="code" href="sqlite3_8h.html#aeba56345f14b7febdafaaa4bc3949245">SQLITE_LIMIT_LENGTH</a>] ){
<a name="l02043"></a>02043     <span class="keywordflow">goto</span> too_big;
<a name="l02044"></a>02044   }
<a name="l02045"></a>02045 
<a name="l02046"></a>02046   assert( p2&lt;nField );
<a name="l02047"></a>02047 
<a name="l02048"></a>02048   <span class="comment">/* Read and parse the table header.  Store the results of the parse</span>
<a name="l02049"></a>02049 <span class="comment">  ** into the record header cache fields of the cursor.</span>
<a name="l02050"></a>02050 <span class="comment">  */</span>
<a name="l02051"></a>02051   aType = pC-&gt;<a class="code" href="structVdbeCursor.html#a6992d2bf9eb8480985aec47dae58f1ab">aType</a>;
<a name="l02052"></a>02052   <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a>==p-&gt;<a class="code" href="structVdbe.html#ad3eb9132373a6b791c69251f94949744">cacheCtr</a> ){
<a name="l02053"></a>02053     aOffset = pC-&gt;<a class="code" href="structVdbeCursor.html#a17431e67b341282aeb6c026cd01ec1e9">aOffset</a>;
<a name="l02054"></a>02054   }<span class="keywordflow">else</span>{
<a name="l02055"></a>02055     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *zIdx;        <span class="comment">/* Index into header */</span>
<a name="l02056"></a>02056     <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *zEndHdr;     <span class="comment">/* Pointer to first byte after the header */</span>
<a name="l02057"></a>02057     <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> offset;      <span class="comment">/* Offset into the data */</span>
<a name="l02058"></a>02058     <span class="keywordtype">int</span> szHdrSz;     <span class="comment">/* Size of the header size field at start of record */</span>
<a name="l02059"></a>02059     <span class="keywordtype">int</span> avail;       <span class="comment">/* Number of bytes of available data */</span>
<a name="l02060"></a>02060 
<a name="l02061"></a>02061     assert(aType);
<a name="l02062"></a>02062     pC-&gt;<a class="code" href="structVdbeCursor.html#a17431e67b341282aeb6c026cd01ec1e9">aOffset</a> = aOffset = &amp;aType[nField];
<a name="l02063"></a>02063     pC-&gt;<a class="code" href="structVdbeCursor.html#a5c1fa124d7f27a30e14ef0f455955cab">payloadSize</a> = payloadSize;
<a name="l02064"></a>02064     pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = p-&gt;<a class="code" href="structVdbe.html#ad3eb9132373a6b791c69251f94949744">cacheCtr</a>;
<a name="l02065"></a>02065 
<a name="l02066"></a>02066     <span class="comment">/* Figure out how many bytes are in the header */</span>
<a name="l02067"></a>02067     <span class="keywordflow">if</span>( zRec ){
<a name="l02068"></a>02068       zData = zRec;
<a name="l02069"></a>02069     }<span class="keywordflow">else</span>{
<a name="l02070"></a>02070       <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> ){
<a name="l02071"></a>02071         zData = (<span class="keywordtype">char</span>*)<a class="code" href="btree_8c.html#a00fd4652b07c4c9b9e8f0b508bc506b9">sqlite3BtreeKeyFetch</a>(pCrsr, &amp;avail);
<a name="l02072"></a>02072       }<span class="keywordflow">else</span>{
<a name="l02073"></a>02073         zData = (<span class="keywordtype">char</span>*)<a class="code" href="btree_8c.html#a151a21a039480e05578c458269d94f89">sqlite3BtreeDataFetch</a>(pCrsr, &amp;avail);
<a name="l02074"></a>02074       }
<a name="l02075"></a>02075       <span class="comment">/* If KeyFetch()/DataFetch() managed to get the entire payload,</span>
<a name="l02076"></a>02076 <span class="comment">      ** save the payload in the pC-&gt;aRow cache.  That will save us from</span>
<a name="l02077"></a>02077 <span class="comment">      ** having to make additional calls to fetch the content portion of</span>
<a name="l02078"></a>02078 <span class="comment">      ** the record.</span>
<a name="l02079"></a>02079 <span class="comment">      */</span>
<a name="l02080"></a>02080       <span class="keywordflow">if</span>( avail&gt;=payloadSize ){
<a name="l02081"></a>02081         zRec = zData;
<a name="l02082"></a>02082         pC-&gt;<a class="code" href="structVdbeCursor.html#a6bd10979ffb5d4828967eea1d6e0d2c8">aRow</a> = (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)zData;
<a name="l02083"></a>02083       }<span class="keywordflow">else</span>{
<a name="l02084"></a>02084         pC-&gt;<a class="code" href="structVdbeCursor.html#a6bd10979ffb5d4828967eea1d6e0d2c8">aRow</a> = 0;
<a name="l02085"></a>02085       }
<a name="l02086"></a>02086     }
<a name="l02087"></a>02087     <span class="comment">/* The following assert is true in all cases accept when</span>
<a name="l02088"></a>02088 <span class="comment">    ** the database file has been corrupted externally.</span>
<a name="l02089"></a>02089 <span class="comment">    **    assert( zRec!=0 || avail&gt;=payloadSize || avail&gt;=9 ); */</span>
<a name="l02090"></a>02090     szHdrSz = <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>((<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)zData, offset);
<a name="l02091"></a>02091 
<a name="l02092"></a>02092     <span class="comment">/* The KeyFetch() or DataFetch() above are fast and will get the entire</span>
<a name="l02093"></a>02093 <span class="comment">    ** record header in most cases.  But they will fail to get the complete</span>
<a name="l02094"></a>02094 <span class="comment">    ** record header if the record header does not fit on a single page</span>
<a name="l02095"></a>02095 <span class="comment">    ** in the B-Tree.  When that happens, use sqlite3VdbeMemFromBtree() to</span>
<a name="l02096"></a>02096 <span class="comment">    ** acquire the complete header text.</span>
<a name="l02097"></a>02097 <span class="comment">    */</span>
<a name="l02098"></a>02098     <span class="keywordflow">if</span>( !zRec &amp;&amp; avail&lt;offset ){
<a name="l02099"></a>02099       sMem.<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = 0;
<a name="l02100"></a>02100       sMem.<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = 0;
<a name="l02101"></a>02101       rc = <a class="code" href="vdbeInt_8h.html#a923c9ff0b25fe7535097420b26712ee1">sqlite3VdbeMemFromBtree</a>(pCrsr, 0, offset, pC-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a>, &amp;sMem);
<a name="l02102"></a>02102       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02103"></a>02103         <span class="keywordflow">goto</span> op_column_out;
<a name="l02104"></a>02104       }
<a name="l02105"></a>02105       zData = sMem.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>;
<a name="l02106"></a>02106     }
<a name="l02107"></a>02107     zEndHdr = (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *)&amp;zData[offset];
<a name="l02108"></a>02108     zIdx = (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *)&amp;zData[szHdrSz];
<a name="l02109"></a>02109 
<a name="l02110"></a>02110     <span class="comment">/* Scan the header and use it to fill in the aType[] and aOffset[]</span>
<a name="l02111"></a>02111 <span class="comment">    ** arrays.  aType[i] will contain the type integer for the i-th</span>
<a name="l02112"></a>02112 <span class="comment">    ** column and aOffset[i] will contain the offset from the beginning</span>
<a name="l02113"></a>02113 <span class="comment">    ** of the record to the start of the data for the i-th column</span>
<a name="l02114"></a>02114 <span class="comment">    */</span>
<a name="l02115"></a>02115     <span class="keywordflow">for</span>(i=0; i&lt;nField; i++){
<a name="l02116"></a>02116       <span class="keywordflow">if</span>( zIdx&lt;zEndHdr ){
<a name="l02117"></a>02117         aOffset[i] = offset;
<a name="l02118"></a>02118         zIdx += <a class="code" href="sqliteInt_8h.html#a20c8e1bb19173aadc361de2e7487bf3b">getVarint32</a>(zIdx, aType[i]);
<a name="l02119"></a>02119         offset += <a class="code" href="vdbeaux_8c.html#a002b233ebea0d972e5bc2964f5fe5de6">sqlite3VdbeSerialTypeLen</a>(aType[i]);
<a name="l02120"></a>02120       }<span class="keywordflow">else</span>{
<a name="l02121"></a>02121         <span class="comment">/* If i is less that nField, then there are less fields in this</span>
<a name="l02122"></a>02122 <span class="comment">        ** record than SetNumColumns indicated there are columns in the</span>
<a name="l02123"></a>02123 <span class="comment">        ** table. Set the offset for any extra columns not present in</span>
<a name="l02124"></a>02124 <span class="comment">        ** the record to 0. This tells code below to store a NULL</span>
<a name="l02125"></a>02125 <span class="comment">        ** instead of deserializing a value from the record.</span>
<a name="l02126"></a>02126 <span class="comment">        */</span>
<a name="l02127"></a>02127         aOffset[i] = 0;
<a name="l02128"></a>02128       }
<a name="l02129"></a>02129     }
<a name="l02130"></a>02130     <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(&amp;sMem);
<a name="l02131"></a>02131     sMem.<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;
<a name="l02132"></a>02132 
<a name="l02133"></a>02133     <span class="comment">/* If we have read more header data than was contained in the header,</span>
<a name="l02134"></a>02134 <span class="comment">    ** or if the end of the last field appears to be past the end of the</span>
<a name="l02135"></a>02135 <span class="comment">    ** record, or if the end of the last field appears to be before the end</span>
<a name="l02136"></a>02136 <span class="comment">    ** of the record (when all fields present), then we must be dealing </span>
<a name="l02137"></a>02137 <span class="comment">    ** with a corrupt database.</span>
<a name="l02138"></a>02138 <span class="comment">    */</span>
<a name="l02139"></a>02139     <span class="keywordflow">if</span>( zIdx&gt;zEndHdr || offset&gt;payloadSize 
<a name="l02140"></a>02140      || (zIdx==zEndHdr &amp;&amp; offset!=payloadSize) ){
<a name="l02141"></a>02141       rc = <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l02142"></a>02142       <span class="keywordflow">goto</span> op_column_out;
<a name="l02143"></a>02143     }
<a name="l02144"></a>02144   }
<a name="l02145"></a>02145 
<a name="l02146"></a>02146   <span class="comment">/* Get the column information. If aOffset[p2] is non-zero, then </span>
<a name="l02147"></a>02147 <span class="comment">  ** deserialize the value from the record. If aOffset[p2] is zero,</span>
<a name="l02148"></a>02148 <span class="comment">  ** then there are not enough fields in the record to satisfy the</span>
<a name="l02149"></a>02149 <span class="comment">  ** request.  In this case, set the value NULL or to P4 if P4 is</span>
<a name="l02150"></a>02150 <span class="comment">  ** a pointer to a Mem object.</span>
<a name="l02151"></a>02151 <span class="comment">  */</span>
<a name="l02152"></a>02152   <span class="keywordflow">if</span>( aOffset[p2] ){
<a name="l02153"></a>02153     assert( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> );
<a name="l02154"></a>02154     <span class="keywordflow">if</span>( zRec ){
<a name="l02155"></a>02155       <a class="code" href="vdbeInt_8h.html#ac41fe3900e1fc0c17e00402551b6c8a3">sqlite3VdbeMemReleaseExternal</a>(pDest);
<a name="l02156"></a>02156       <a class="code" href="vdbeaux_8c.html#ac46e144d389f7ef81075005a4b5c41ef">sqlite3VdbeSerialGet</a>((<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *)&amp;zRec[aOffset[p2]], aType[p2], pDest);
<a name="l02157"></a>02157     }<span class="keywordflow">else</span>{
<a name="l02158"></a>02158       len = <a class="code" href="vdbeaux_8c.html#a002b233ebea0d972e5bc2964f5fe5de6">sqlite3VdbeSerialTypeLen</a>(aType[p2]);
<a name="l02159"></a>02159       <a class="code" href="vdbeInt_8h.html#ac6decc64fa0cfb686d6e548953d7705a">sqlite3VdbeMemMove</a>(&amp;sMem, pDest);
<a name="l02160"></a>02160       rc = <a class="code" href="vdbeInt_8h.html#a923c9ff0b25fe7535097420b26712ee1">sqlite3VdbeMemFromBtree</a>(pCrsr, aOffset[p2], len, pC-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a>, &amp;sMem);
<a name="l02161"></a>02161       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02162"></a>02162         <span class="keywordflow">goto</span> op_column_out;
<a name="l02163"></a>02163       }
<a name="l02164"></a>02164       zData = sMem.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>;
<a name="l02165"></a>02165       <a class="code" href="vdbeaux_8c.html#ac46e144d389f7ef81075005a4b5c41ef">sqlite3VdbeSerialGet</a>((<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a>*)zData, aType[p2], pDest);
<a name="l02166"></a>02166     }
<a name="l02167"></a>02167     pDest-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = encoding;
<a name="l02168"></a>02168   }<span class="keywordflow">else</span>{
<a name="l02169"></a>02169     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#af6c6e3475005335f2646434d48af6ffa">P4_MEM</a> ){
<a name="l02170"></a>02170       <a class="code" href="vdbeInt_8h.html#a3009da1d59046acf76835bcb353f9fca">sqlite3VdbeMemShallowCopy</a>(pDest, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#ae4fe6fe3da8afb8d946df3676d766bb7">pMem</a>, MEM_Static);
<a name="l02171"></a>02171     }<span class="keywordflow">else</span>{
<a name="l02172"></a>02172       assert( pDest-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> );
<a name="l02173"></a>02173     }
<a name="l02174"></a>02174   }
<a name="l02175"></a>02175 
<a name="l02176"></a>02176   <span class="comment">/* If we dynamically allocated space to hold the data (in the</span>
<a name="l02177"></a>02177 <span class="comment">  ** sqlite3VdbeMemFromBtree() call above) then transfer control of that</span>
<a name="l02178"></a>02178 <span class="comment">  ** dynamically allocated space over to the pDest structure.</span>
<a name="l02179"></a>02179 <span class="comment">  ** This prevents a memory copy.</span>
<a name="l02180"></a>02180 <span class="comment">  */</span>
<a name="l02181"></a>02181   <span class="keywordflow">if</span>( sMem.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> ){
<a name="l02182"></a>02182     assert( sMem.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>==sMem.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> );
<a name="l02183"></a>02183     assert( !(pDest-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; MEM_Dyn) );
<a name="l02184"></a>02184     assert( !(pDest-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; (MEM_Blob|MEM_Str)) || pDest-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>==sMem.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> );
<a name="l02185"></a>02185     pDest-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp;= ~(MEM_Ephem|MEM_Static);
<a name="l02186"></a>02186     pDest-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> |= <a class="code" href="vdbeInt_8h.html#a07b1add4713bc55a88ecb0085c846ab7">MEM_Term</a>;
<a name="l02187"></a>02187     pDest-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> = sMem.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>;
<a name="l02188"></a>02188     pDest-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = sMem.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a>;
<a name="l02189"></a>02189   }
<a name="l02190"></a>02190 
<a name="l02191"></a>02191   rc = <a class="code" href="vdbeInt_8h.html#af70fb4d14fad367fa2b959e3777c4a69">sqlite3VdbeMemMakeWriteable</a>(pDest);
<a name="l02192"></a>02192 
<a name="l02193"></a>02193 op_column_out:
<a name="l02194"></a>02194   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pDest);
<a name="l02195"></a>02195   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pDest);
<a name="l02196"></a>02196   <span class="keywordflow">break</span>;
<a name="l02197"></a>02197 }
<a name="l02198"></a>02198 
<a name="l02199"></a>02199 <span class="comment">/* Opcode: Affinity P1 P2 * P4 *</span>
<a name="l02200"></a>02200 <span class="comment">**</span>
<a name="l02201"></a>02201 <span class="comment">** Apply affinities to a range of P2 registers starting with P1.</span>
<a name="l02202"></a>02202 <span class="comment">**</span>
<a name="l02203"></a>02203 <span class="comment">** P4 is a string that is P2 characters long. The nth character of the</span>
<a name="l02204"></a>02204 <span class="comment">** string indicates the column affinity that should be used for the nth</span>
<a name="l02205"></a>02205 <span class="comment">** memory cell in the range.</span>
<a name="l02206"></a>02206 <span class="comment">*/</span>
<a name="l02207"></a>02207 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a27f4031ee034f306c486c8a02b00ca77">OP_Affinity</a>: {
<a name="l02208"></a>02208   <span class="keywordtype">char</span> *zAffinity = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>;
<a name="l02209"></a>02209   <a class="code" href="structMem.html">Mem</a> *pData0 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l02210"></a>02210   <a class="code" href="structMem.html">Mem</a> *pLast = &amp;pData0[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>-1];
<a name="l02211"></a>02211   <a class="code" href="structMem.html">Mem</a> *pRec;
<a name="l02212"></a>02212 
<a name="l02213"></a>02213   <span class="keywordflow">for</span>(pRec=pData0; pRec&lt;=pLast; pRec++){
<a name="l02214"></a>02214     <a class="code" href="vdbe_8c.html#a69b8bf9ca78e4cf90c8553b34e2ad336">ExpandBlob</a>(pRec);
<a name="l02215"></a>02215     <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>(pRec, zAffinity[pRec-pData0], encoding);
<a name="l02216"></a>02216   }
<a name="l02217"></a>02217   <span class="keywordflow">break</span>;
<a name="l02218"></a>02218 }
<a name="l02219"></a>02219 
<a name="l02220"></a>02220 <span class="comment">/* Opcode: MakeRecord P1 P2 P3 P4 *</span>
<a name="l02221"></a>02221 <span class="comment">**</span>
<a name="l02222"></a>02222 <span class="comment">** Convert P2 registers beginning with P1 into a single entry</span>
<a name="l02223"></a>02223 <span class="comment">** suitable for use as a data record in a database table or as a key</span>
<a name="l02224"></a>02224 <span class="comment">** in an index.  The details of the format are irrelevant as long as</span>
<a name="l02225"></a>02225 <span class="comment">** the OP_Column opcode can decode the record later.</span>
<a name="l02226"></a>02226 <span class="comment">** Refer to source code comments for the details of the record</span>
<a name="l02227"></a>02227 <span class="comment">** format.</span>
<a name="l02228"></a>02228 <span class="comment">**</span>
<a name="l02229"></a>02229 <span class="comment">** P4 may be a string that is P2 characters long.  The nth character of the</span>
<a name="l02230"></a>02230 <span class="comment">** string indicates the column affinity that should be used for the nth</span>
<a name="l02231"></a>02231 <span class="comment">** field of the index key.</span>
<a name="l02232"></a>02232 <span class="comment">**</span>
<a name="l02233"></a>02233 <span class="comment">** The mapping from character to affinity is given by the SQLITE_AFF_</span>
<a name="l02234"></a>02234 <span class="comment">** macros defined in sqliteInt.h.</span>
<a name="l02235"></a>02235 <span class="comment">**</span>
<a name="l02236"></a>02236 <span class="comment">** If P4 is NULL then all index fields have the affinity NONE.</span>
<a name="l02237"></a>02237 <span class="comment">*/</span>
<a name="l02238"></a>02238 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aaa8701055972e3d38e2f9801708cd9fc">OP_MakeRecord</a>: {
<a name="l02239"></a>02239   <span class="comment">/* Assuming the record contains N fields, the record format looks</span>
<a name="l02240"></a>02240 <span class="comment">  ** like this:</span>
<a name="l02241"></a>02241 <span class="comment">  **</span>
<a name="l02242"></a>02242 <span class="comment">  ** ------------------------------------------------------------------------</span>
<a name="l02243"></a>02243 <span class="comment">  ** | hdr-size | type 0 | type 1 | ... | type N-1 | data0 | ... | data N-1 | </span>
<a name="l02244"></a>02244 <span class="comment">  ** ------------------------------------------------------------------------</span>
<a name="l02245"></a>02245 <span class="comment">  **</span>
<a name="l02246"></a>02246 <span class="comment">  ** Data(0) is taken from register P1.  Data(1) comes from register P1+1</span>
<a name="l02247"></a>02247 <span class="comment">  ** and so froth.</span>
<a name="l02248"></a>02248 <span class="comment">  **</span>
<a name="l02249"></a>02249 <span class="comment">  ** Each type field is a varint representing the serial type of the </span>
<a name="l02250"></a>02250 <span class="comment">  ** corresponding data element (see sqlite3VdbeSerialType()). The</span>
<a name="l02251"></a>02251 <span class="comment">  ** hdr-size field is also a varint which is the offset from the beginning</span>
<a name="l02252"></a>02252 <span class="comment">  ** of the record to data0.</span>
<a name="l02253"></a>02253 <span class="comment">  */</span>
<a name="l02254"></a>02254   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *zNewRecord;        <span class="comment">/* A buffer to hold the data for the new record */</span>
<a name="l02255"></a>02255   <a class="code" href="structMem.html">Mem</a> *pRec;             <span class="comment">/* The new record */</span>
<a name="l02256"></a>02256   <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> nData = 0;         <span class="comment">/* Number of bytes of data space */</span>
<a name="l02257"></a>02257   <span class="keywordtype">int</span> nHdr = 0;          <span class="comment">/* Number of bytes of header space */</span>
<a name="l02258"></a>02258   <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> nByte = 0;         <span class="comment">/* Data space required for this record */</span>
<a name="l02259"></a>02259   <span class="keywordtype">int</span> nZero = 0;         <span class="comment">/* Number of zero bytes at the end of the record */</span>
<a name="l02260"></a>02260   <span class="keywordtype">int</span> nVarint;           <span class="comment">/* Number of bytes in a varint */</span>
<a name="l02261"></a>02261   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> serial_type;       <span class="comment">/* Type field */</span>
<a name="l02262"></a>02262   <a class="code" href="structMem.html">Mem</a> *pData0;           <span class="comment">/* First field to be combined into the record */</span>
<a name="l02263"></a>02263   <a class="code" href="structMem.html">Mem</a> *pLast;            <span class="comment">/* Last field of the record */</span>
<a name="l02264"></a>02264   <span class="keywordtype">int</span> nField;            <span class="comment">/* Number of fields in the record */</span>
<a name="l02265"></a>02265   <span class="keywordtype">char</span> *zAffinity;       <span class="comment">/* The affinity string for the record */</span>
<a name="l02266"></a>02266   <span class="keywordtype">int</span> file_format;       <span class="comment">/* File format to use for encoding */</span>
<a name="l02267"></a>02267   <span class="keywordtype">int</span> i;                 <span class="comment">/* Space used in zNewRecord[] */</span>
<a name="l02268"></a>02268 
<a name="l02269"></a>02269   nField = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02270"></a>02270   zAffinity = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>;
<a name="l02271"></a>02271   assert( nField&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>+nField&lt;=p-&gt;nMem );
<a name="l02272"></a>02272   pData0 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[nField];
<a name="l02273"></a>02273   nField = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l02274"></a>02274   pLast = &amp;pData0[nField-1];
<a name="l02275"></a>02275   file_format = p-&gt;<a class="code" href="structVdbe.html#a679ac87f7b835982cd7c1990fbc3605b">minWriteFileFormat</a>;
<a name="l02276"></a>02276 
<a name="l02277"></a>02277   <span class="comment">/* Loop through the elements that will make up the record to figure</span>
<a name="l02278"></a>02278 <span class="comment">  ** out how much space is required for the new record.</span>
<a name="l02279"></a>02279 <span class="comment">  */</span>
<a name="l02280"></a>02280   <span class="keywordflow">for</span>(pRec=pData0; pRec&lt;=pLast; pRec++){
<a name="l02281"></a>02281     <span class="keywordtype">int</span> len;
<a name="l02282"></a>02282     <span class="keywordflow">if</span>( zAffinity ){
<a name="l02283"></a>02283       <a class="code" href="vdbe_8c.html#a9ed2c1bcefa8734a1c341ba28a785486">applyAffinity</a>(pRec, zAffinity[pRec-pData0], encoding);
<a name="l02284"></a>02284     }
<a name="l02285"></a>02285     <span class="keywordflow">if</span>( pRec-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#a9433e8fe887266736d2e795fe0b71fd3">MEM_Zero</a> &amp;&amp; pRec-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>&gt;0 ){
<a name="l02286"></a>02286       <a class="code" href="vdbeInt_8h.html#a36013da16613d1014b153083d2f0a207">sqlite3VdbeMemExpandBlob</a>(pRec);
<a name="l02287"></a>02287     }
<a name="l02288"></a>02288     serial_type = <a class="code" href="vdbeaux_8c.html#af0cba819e11277d6247f823d022f5f74">sqlite3VdbeSerialType</a>(pRec, file_format);
<a name="l02289"></a>02289     len = <a class="code" href="vdbeaux_8c.html#a002b233ebea0d972e5bc2964f5fe5de6">sqlite3VdbeSerialTypeLen</a>(serial_type);
<a name="l02290"></a>02290     nData += len;
<a name="l02291"></a>02291     nHdr += <a class="code" href="sqliteInt_8h.html#a4c25fa3dcd7bf5ca327b4541bae4359d">sqlite3VarintLen</a>(serial_type);
<a name="l02292"></a>02292     <span class="keywordflow">if</span>( pRec-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a9433e8fe887266736d2e795fe0b71fd3">MEM_Zero</a> ){
<a name="l02293"></a>02293       <span class="comment">/* Only pure zero-filled BLOBs can be input to this Opcode.</span>
<a name="l02294"></a>02294 <span class="comment">      ** We do not allow blobs with a prefix and a zero-filled tail. */</span>
<a name="l02295"></a>02295       nZero += pRec-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l02296"></a>02296     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( len ){
<a name="l02297"></a>02297       nZero = 0;
<a name="l02298"></a>02298     }
<a name="l02299"></a>02299   }
<a name="l02300"></a>02300 
<a name="l02301"></a>02301   <span class="comment">/* Add the initial header varint and total the size */</span>
<a name="l02302"></a>02302   nHdr += nVarint = <a class="code" href="sqliteInt_8h.html#a4c25fa3dcd7bf5ca327b4541bae4359d">sqlite3VarintLen</a>(nHdr);
<a name="l02303"></a>02303   <span class="keywordflow">if</span>( nVarint&lt;<a class="code" href="sqliteInt_8h.html#a4c25fa3dcd7bf5ca327b4541bae4359d">sqlite3VarintLen</a>(nHdr) ){
<a name="l02304"></a>02304     nHdr++;
<a name="l02305"></a>02305   }
<a name="l02306"></a>02306   nByte = nHdr+nData-nZero;
<a name="l02307"></a>02307   <span class="keywordflow">if</span>( nByte&gt;db-&gt;<a class="code" href="structsqlite3.html#ad8acf663e1619905094c9dfe4125157b">aLimit</a>[<a class="code" href="sqlite3_8h.html#aeba56345f14b7febdafaaa4bc3949245">SQLITE_LIMIT_LENGTH</a>] ){
<a name="l02308"></a>02308     <span class="keywordflow">goto</span> too_big;
<a name="l02309"></a>02309   }
<a name="l02310"></a>02310 
<a name="l02311"></a>02311   <span class="comment">/* Make sure the output register has a buffer large enough to store </span>
<a name="l02312"></a>02312 <span class="comment">  ** the new record. The output register (pOp-&gt;p3) is not allowed to</span>
<a name="l02313"></a>02313 <span class="comment">  ** be one of the input registers (because the following call to</span>
<a name="l02314"></a>02314 <span class="comment">  ** sqlite3VdbeMemGrow() could clobber the value before it is used).</span>
<a name="l02315"></a>02315 <span class="comment">  */</span>
<a name="l02316"></a>02316   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> || pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;=pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>+pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> );
<a name="l02317"></a>02317   pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l02318"></a>02318   <span class="keywordflow">if</span>( <a class="code" href="vdbeInt_8h.html#ac934bc728baa7b73867a62722c30d311">sqlite3VdbeMemGrow</a>(pOut, nByte, 0) ){
<a name="l02319"></a>02319     <span class="keywordflow">goto</span> no_mem;
<a name="l02320"></a>02320   }
<a name="l02321"></a>02321   zNewRecord = (<a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> *)pOut-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323   <span class="comment">/* Write the record */</span>
<a name="l02324"></a>02324   i = <a class="code" href="sqliteInt_8h.html#a228d4c7a5f9148406b4f3279ecd1089c">putVarint32</a>(zNewRecord, nHdr);
<a name="l02325"></a>02325   <span class="keywordflow">for</span>(pRec=pData0; pRec&lt;=pLast; pRec++){
<a name="l02326"></a>02326     serial_type = <a class="code" href="vdbeaux_8c.html#af0cba819e11277d6247f823d022f5f74">sqlite3VdbeSerialType</a>(pRec, file_format);
<a name="l02327"></a>02327     i += <a class="code" href="sqliteInt_8h.html#a228d4c7a5f9148406b4f3279ecd1089c">putVarint32</a>(&amp;zNewRecord[i], serial_type);      <span class="comment">/* serial type */</span>
<a name="l02328"></a>02328   }
<a name="l02329"></a>02329   <span class="keywordflow">for</span>(pRec=pData0; pRec&lt;=pLast; pRec++){  <span class="comment">/* serial data */</span>
<a name="l02330"></a>02330     i += <a class="code" href="vdbeaux_8c.html#a7386a986968b44a9ab2ea83eca22bd90">sqlite3VdbeSerialPut</a>(&amp;zNewRecord[i], nByte-i, pRec, file_format);
<a name="l02331"></a>02331   }
<a name="l02332"></a>02332   assert( i==nByte );
<a name="l02333"></a>02333 
<a name="l02334"></a>02334   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l02335"></a>02335   pOut-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = nByte;
<a name="l02336"></a>02336   pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = MEM_Blob | MEM_Dyn;
<a name="l02337"></a>02337   pOut-&gt;<a class="code" href="structMem.html#a081ea2f86933d68a8940785b62f638ef">xDel</a> = 0;
<a name="l02338"></a>02338   <span class="keywordflow">if</span>( nZero ){
<a name="l02339"></a>02339     pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = nZero;
<a name="l02340"></a>02340     pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> |= <a class="code" href="vdbeInt_8h.html#a9433e8fe887266736d2e795fe0b71fd3">MEM_Zero</a>;
<a name="l02341"></a>02341   }
<a name="l02342"></a>02342   pOut-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>;  <span class="comment">/* In case the blob is ever converted to text */</span>
<a name="l02343"></a>02343   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pOut);
<a name="l02344"></a>02344   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pOut);
<a name="l02345"></a>02345   <span class="keywordflow">break</span>;
<a name="l02346"></a>02346 }
<a name="l02347"></a>02347 
<a name="l02348"></a>02348 <span class="comment">/* Opcode: Statement P1 * * * *</span>
<a name="l02349"></a>02349 <span class="comment">**</span>
<a name="l02350"></a>02350 <span class="comment">** Begin an individual statement transaction which is part of a larger</span>
<a name="l02351"></a>02351 <span class="comment">** transaction.  This is needed so that the statement</span>
<a name="l02352"></a>02352 <span class="comment">** can be rolled back after an error without having to roll back the</span>
<a name="l02353"></a>02353 <span class="comment">** entire transaction.  The statement transaction will automatically</span>
<a name="l02354"></a>02354 <span class="comment">** commit when the VDBE halts.</span>
<a name="l02355"></a>02355 <span class="comment">**</span>
<a name="l02356"></a>02356 <span class="comment">** If the database connection is currently in autocommit mode (that </span>
<a name="l02357"></a>02357 <span class="comment">** is to say, if it is in between BEGIN and COMMIT)</span>
<a name="l02358"></a>02358 <span class="comment">** and if there are no other active statements on the same database</span>
<a name="l02359"></a>02359 <span class="comment">** connection, then this operation is a no-op.  No statement transaction</span>
<a name="l02360"></a>02360 <span class="comment">** is needed since any error can use the normal ROLLBACK process to</span>
<a name="l02361"></a>02361 <span class="comment">** undo changes.</span>
<a name="l02362"></a>02362 <span class="comment">**</span>
<a name="l02363"></a>02363 <span class="comment">** If a statement transaction is started, then a statement journal file</span>
<a name="l02364"></a>02364 <span class="comment">** will be allocated and initialized.</span>
<a name="l02365"></a>02365 <span class="comment">**</span>
<a name="l02366"></a>02366 <span class="comment">** The statement is begun on the database file with index P1.  The main</span>
<a name="l02367"></a>02367 <span class="comment">** database file has an index of 0 and the file used for temporary tables</span>
<a name="l02368"></a>02368 <span class="comment">** has an index of 1.</span>
<a name="l02369"></a>02369 <span class="comment">*/</span>
<a name="l02370"></a>02370 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a718776e9ac8775b4c0047118fd9e7aa1">OP_Statement</a>: {
<a name="l02371"></a>02371   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a11baf5e051b2e4ea03c5d03c09bb624e">autoCommit</a>==0 || db-&gt;<a class="code" href="structsqlite3.html#ada07202e7fd80f275e2e5063d96b5cb0">activeVdbeCnt</a>&gt;1 ){
<a name="l02372"></a>02372     <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02373"></a>02373     <a class="code" href="structBtree.html">Btree</a> *pBt;
<a name="l02374"></a>02374     assert( i&gt;=0 &amp;&amp; i&lt;db-&gt;nDb );
<a name="l02375"></a>02375     assert( db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>!=0 );
<a name="l02376"></a>02376     pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l02377"></a>02377     assert( <a class="code" href="btree_8c.html#aeff539aa1765b2b7a18313c3cc26d0ba">sqlite3BtreeIsInTrans</a>(pBt) );
<a name="l02378"></a>02378     assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;i))!=0 );
<a name="l02379"></a>02379     <span class="keywordflow">if</span>( !<a class="code" href="btree_8c.html#ab0fb6d779e98974c2bcb108d7944cc28">sqlite3BtreeIsInStmt</a>(pBt) ){
<a name="l02380"></a>02380       rc = <a class="code" href="btree_8c.html#a19eb3dd7240d94ecb214abde8de779cc">sqlite3BtreeBeginStmt</a>(pBt);
<a name="l02381"></a>02381       p-&gt;<a class="code" href="structVdbe.html#a9f18480295980eda04c84fe74c5a4061">openedStatement</a> = 1;
<a name="l02382"></a>02382     }
<a name="l02383"></a>02383   }
<a name="l02384"></a>02384   <span class="keywordflow">break</span>;
<a name="l02385"></a>02385 }
<a name="l02386"></a>02386 
<a name="l02387"></a>02387 <span class="comment">/* Opcode: AutoCommit P1 P2 * * *</span>
<a name="l02388"></a>02388 <span class="comment">**</span>
<a name="l02389"></a>02389 <span class="comment">** Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll</span>
<a name="l02390"></a>02390 <span class="comment">** back any currently active btree transactions. If there are any active</span>
<a name="l02391"></a>02391 <span class="comment">** VMs (apart from this one), then the COMMIT or ROLLBACK statement fails.</span>
<a name="l02392"></a>02392 <span class="comment">**</span>
<a name="l02393"></a>02393 <span class="comment">** This instruction causes the VM to halt.</span>
<a name="l02394"></a>02394 <span class="comment">*/</span>
<a name="l02395"></a>02395 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a5f4b7235ae702a8ab89932312cd375de">OP_AutoCommit</a>: {
<a name="l02396"></a>02396   <span class="keywordtype">int</span> desiredAutoCommit = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02397"></a>02397   <span class="keywordtype">int</span> rollback = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l02398"></a>02398   <span class="keywordtype">int</span> turnOnAC = desiredAutoCommit &amp;&amp; !db-&gt;<a class="code" href="structsqlite3.html#a11baf5e051b2e4ea03c5d03c09bb624e">autoCommit</a>;
<a name="l02399"></a>02399 
<a name="l02400"></a>02400   assert( desiredAutoCommit==1 || desiredAutoCommit==0 );
<a name="l02401"></a>02401   assert( desiredAutoCommit==1 || rollback==0 );
<a name="l02402"></a>02402 
<a name="l02403"></a>02403   assert( db-&gt;<a class="code" href="structsqlite3.html#ada07202e7fd80f275e2e5063d96b5cb0">activeVdbeCnt</a>&gt;0 );  <span class="comment">/* At least this one VM is active */</span>
<a name="l02404"></a>02404 
<a name="l02405"></a>02405   <span class="keywordflow">if</span>( turnOnAC &amp;&amp; rollback &amp;&amp; db-&gt;<a class="code" href="structsqlite3.html#ada07202e7fd80f275e2e5063d96b5cb0">activeVdbeCnt</a>&gt;1 ){
<a name="l02406"></a>02406     <span class="comment">/* If this instruction implements a ROLLBACK and other VMs are</span>
<a name="l02407"></a>02407 <span class="comment">    ** still running, and a transaction is active, return an error indicating</span>
<a name="l02408"></a>02408 <span class="comment">    ** that the other VMs must complete first. </span>
<a name="l02409"></a>02409 <span class="comment">    */</span>
<a name="l02410"></a>02410     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;cannot rollback transaction - &quot;</span>
<a name="l02411"></a>02411         <span class="stringliteral">&quot;SQL statements in progress&quot;</span>);
<a name="l02412"></a>02412     rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l02413"></a>02413   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( turnOnAC &amp;&amp; !rollback &amp;&amp; db-&gt;<a class="code" href="structsqlite3.html#a632e51f8d35c1e8802639661e2fcd567">writeVdbeCnt</a>&gt;1 ){
<a name="l02414"></a>02414     <span class="comment">/* If this instruction implements a COMMIT and other VMs are writing</span>
<a name="l02415"></a>02415 <span class="comment">    ** return an error indicating that the other VMs must complete first. </span>
<a name="l02416"></a>02416 <span class="comment">    */</span>
<a name="l02417"></a>02417     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;cannot commit transaction - &quot;</span>
<a name="l02418"></a>02418         <span class="stringliteral">&quot;SQL statements in progress&quot;</span>);
<a name="l02419"></a>02419     rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l02420"></a>02420   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( desiredAutoCommit!=db-&gt;<a class="code" href="structsqlite3.html#a11baf5e051b2e4ea03c5d03c09bb624e">autoCommit</a> ){
<a name="l02421"></a>02421     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> ){
<a name="l02422"></a>02422       assert( desiredAutoCommit==1 );
<a name="l02423"></a>02423       <a class="code" href="main_8c.html#ad0f384ff433a7d7b300edd34a01faac2">sqlite3RollbackAll</a>(db);
<a name="l02424"></a>02424       db-&gt;<a class="code" href="structsqlite3.html#a11baf5e051b2e4ea03c5d03c09bb624e">autoCommit</a> = 1;
<a name="l02425"></a>02425     }<span class="keywordflow">else</span>{
<a name="l02426"></a>02426       db-&gt;<a class="code" href="structsqlite3.html#a11baf5e051b2e4ea03c5d03c09bb624e">autoCommit</a> = desiredAutoCommit;
<a name="l02427"></a>02427       <span class="keywordflow">if</span>( <a class="code" href="vdbeaux_8c.html#af186927cd7de8e0c35b3d3fdb584c3ab">sqlite3VdbeHalt</a>(p)==<a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a> ){
<a name="l02428"></a>02428         p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a> = pc;
<a name="l02429"></a>02429         db-&gt;<a class="code" href="structsqlite3.html#a11baf5e051b2e4ea03c5d03c09bb624e">autoCommit</a> = 1-desiredAutoCommit;
<a name="l02430"></a>02430         p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l02431"></a>02431         <span class="keywordflow">goto</span> vdbe_return;
<a name="l02432"></a>02432       }
<a name="l02433"></a>02433     }
<a name="l02434"></a>02434     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a>==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02435"></a>02435       rc = <a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a>;
<a name="l02436"></a>02436     }<span class="keywordflow">else</span>{
<a name="l02437"></a>02437       rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02438"></a>02438     }
<a name="l02439"></a>02439     <span class="keywordflow">goto</span> vdbe_return;
<a name="l02440"></a>02440   }<span class="keywordflow">else</span>{
<a name="l02441"></a>02441     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db,
<a name="l02442"></a>02442         (!desiredAutoCommit)?<span class="stringliteral">&quot;cannot start a transaction within a transaction&quot;</span>:(
<a name="l02443"></a>02443         (rollback)?<span class="stringliteral">&quot;cannot rollback - no transaction is active&quot;</span>:
<a name="l02444"></a>02444                    <span class="stringliteral">&quot;cannot commit - no transaction is active&quot;</span>));
<a name="l02445"></a>02445          
<a name="l02446"></a>02446     rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l02447"></a>02447   }
<a name="l02448"></a>02448   <span class="keywordflow">break</span>;
<a name="l02449"></a>02449 }
<a name="l02450"></a>02450 
<a name="l02451"></a>02451 <span class="comment">/* Opcode: Transaction P1 P2 * * *</span>
<a name="l02452"></a>02452 <span class="comment">**</span>
<a name="l02453"></a>02453 <span class="comment">** Begin a transaction.  The transaction ends when a Commit or Rollback</span>
<a name="l02454"></a>02454 <span class="comment">** opcode is encountered.  Depending on the ON CONFLICT setting, the</span>
<a name="l02455"></a>02455 <span class="comment">** transaction might also be rolled back if an error is encountered.</span>
<a name="l02456"></a>02456 <span class="comment">**</span>
<a name="l02457"></a>02457 <span class="comment">** P1 is the index of the database file on which the transaction is</span>
<a name="l02458"></a>02458 <span class="comment">** started.  Index 0 is the main database file and index 1 is the</span>
<a name="l02459"></a>02459 <span class="comment">** file used for temporary tables.  Indices of 2 or more are used for</span>
<a name="l02460"></a>02460 <span class="comment">** attached databases.</span>
<a name="l02461"></a>02461 <span class="comment">**</span>
<a name="l02462"></a>02462 <span class="comment">** If P2 is non-zero, then a write-transaction is started.  A RESERVED lock is</span>
<a name="l02463"></a>02463 <span class="comment">** obtained on the database file when a write-transaction is started.  No</span>
<a name="l02464"></a>02464 <span class="comment">** other process can start another write transaction while this transaction is</span>
<a name="l02465"></a>02465 <span class="comment">** underway.  Starting a write transaction also creates a rollback journal. A</span>
<a name="l02466"></a>02466 <span class="comment">** write transaction must be started before any changes can be made to the</span>
<a name="l02467"></a>02467 <span class="comment">** database.  If P2 is 2 or greater then an EXCLUSIVE lock is also obtained</span>
<a name="l02468"></a>02468 <span class="comment">** on the file.</span>
<a name="l02469"></a>02469 <span class="comment">**</span>
<a name="l02470"></a>02470 <span class="comment">** If P2 is zero, then a read-lock is obtained on the database file.</span>
<a name="l02471"></a>02471 <span class="comment">*/</span>
<a name="l02472"></a>02472 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a4b94e42b258f79e67949e9af065cbcc0">OP_Transaction</a>: {
<a name="l02473"></a>02473   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02474"></a>02474   <a class="code" href="structBtree.html">Btree</a> *pBt;
<a name="l02475"></a>02475 
<a name="l02476"></a>02476   assert( i&gt;=0 &amp;&amp; i&lt;db-&gt;nDb );
<a name="l02477"></a>02477   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;i))!=0 );
<a name="l02478"></a>02478   pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[i].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l02479"></a>02479 
<a name="l02480"></a>02480   <span class="keywordflow">if</span>( pBt ){
<a name="l02481"></a>02481     rc = <a class="code" href="btree_8c.html#aa347f2c69b05ad6cb2ebfad1c9c54718">sqlite3BtreeBeginTrans</a>(pBt, pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>);
<a name="l02482"></a>02482     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a> ){
<a name="l02483"></a>02483       p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a> = pc;
<a name="l02484"></a>02484       p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l02485"></a>02485       <span class="keywordflow">goto</span> vdbe_return;
<a name="l02486"></a>02486     }
<a name="l02487"></a>02487     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; rc!=<a class="code" href="sqlite3_8h.html#a1ee0a0db43018cda5ee64cf78abbd675">SQLITE_READONLY</a> <span class="comment">/* &amp;&amp; rc!=SQLITE_BUSY */</span> ){
<a name="l02488"></a>02488       <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l02489"></a>02489     }
<a name="l02490"></a>02490   }
<a name="l02491"></a>02491   <span class="keywordflow">break</span>;
<a name="l02492"></a>02492 }
<a name="l02493"></a>02493 
<a name="l02494"></a>02494 <span class="comment">/* Opcode: ReadCookie P1 P2 P3 * *</span>
<a name="l02495"></a>02495 <span class="comment">**</span>
<a name="l02496"></a>02496 <span class="comment">** Read cookie number P3 from database P1 and write it into register P2.</span>
<a name="l02497"></a>02497 <span class="comment">** P3==0 is the schema version.  P3==1 is the database format.</span>
<a name="l02498"></a>02498 <span class="comment">** P3==2 is the recommended pager cache size, and so forth.  P1==0 is</span>
<a name="l02499"></a>02499 <span class="comment">** the main database file and P1==1 is the database file used to store</span>
<a name="l02500"></a>02500 <span class="comment">** temporary tables.</span>
<a name="l02501"></a>02501 <span class="comment">**</span>
<a name="l02502"></a>02502 <span class="comment">** If P1 is negative, then this is a request to read the size of a</span>
<a name="l02503"></a>02503 <span class="comment">** databases free-list. P3 must be set to 1 in this case. The actual</span>
<a name="l02504"></a>02504 <span class="comment">** database accessed is ((P1+1)*-1). For example, a P1 parameter of -1</span>
<a name="l02505"></a>02505 <span class="comment">** corresponds to database 0 (&quot;main&quot;), a P1 of -2 is database 1 (&quot;temp&quot;).</span>
<a name="l02506"></a>02506 <span class="comment">**</span>
<a name="l02507"></a>02507 <span class="comment">** There must be a read-lock on the database (either a transaction</span>
<a name="l02508"></a>02508 <span class="comment">** must be started or there must be an open cursor) before</span>
<a name="l02509"></a>02509 <span class="comment">** executing this instruction.</span>
<a name="l02510"></a>02510 <span class="comment">*/</span>
<a name="l02511"></a>02511 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a9ecb99d849ba4dddc15a40ae35cefa3b">OP_ReadCookie</a>: {               <span class="comment">/* out2-prerelease */</span>
<a name="l02512"></a>02512   <span class="keywordtype">int</span> iMeta;
<a name="l02513"></a>02513   <span class="keywordtype">int</span> iDb = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02514"></a>02514   <span class="keywordtype">int</span> iCookie = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;
<a name="l02515"></a>02515 
<a name="l02516"></a>02516   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;<a class="code" href="btree_8h.html#a4e1ac7962950f2c2f7309d7e947764b4">SQLITE_N_BTREE_META</a> );
<a name="l02517"></a>02517   <span class="keywordflow">if</span>( iDb&lt;0 ){
<a name="l02518"></a>02518     iDb = (-1*(iDb+1));
<a name="l02519"></a>02519     iCookie *= -1;
<a name="l02520"></a>02520   }
<a name="l02521"></a>02521   assert( iDb&gt;=0 &amp;&amp; iDb&lt;db-&gt;nDb );
<a name="l02522"></a>02522   assert( db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>!=0 );
<a name="l02523"></a>02523   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;iDb))!=0 );
<a name="l02524"></a>02524   <span class="comment">/* The indexing of meta values at the schema layer is off by one from</span>
<a name="l02525"></a>02525 <span class="comment">  ** the indexing in the btree layer.  The btree considers meta[0] to</span>
<a name="l02526"></a>02526 <span class="comment">  ** be the number of free pages in the database (a read-only value)</span>
<a name="l02527"></a>02527 <span class="comment">  ** and meta[1] to be the schema cookie.  The schema layer considers</span>
<a name="l02528"></a>02528 <span class="comment">  ** meta[1] to be the schema cookie.  So we have to shift the index</span>
<a name="l02529"></a>02529 <span class="comment">  ** by one in the following statement.</span>
<a name="l02530"></a>02530 <span class="comment">  */</span>
<a name="l02531"></a>02531   rc = <a class="code" href="btree_8c.html#a927b663f431cd2f4edfac55d7018cbb6">sqlite3BtreeGetMeta</a>(db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>, 1 + iCookie, (<a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> *)&amp;iMeta);
<a name="l02532"></a>02532   pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = iMeta;
<a name="l02533"></a>02533   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l02534"></a>02534   <span class="keywordflow">break</span>;
<a name="l02535"></a>02535 }
<a name="l02536"></a>02536 
<a name="l02537"></a>02537 <span class="comment">/* Opcode: SetCookie P1 P2 P3 * *</span>
<a name="l02538"></a>02538 <span class="comment">**</span>
<a name="l02539"></a>02539 <span class="comment">** Write the content of register P3 (interpreted as an integer)</span>
<a name="l02540"></a>02540 <span class="comment">** into cookie number P2 of database P1.</span>
<a name="l02541"></a>02541 <span class="comment">** P2==0 is the schema version.  P2==1 is the database format.</span>
<a name="l02542"></a>02542 <span class="comment">** P2==2 is the recommended pager cache size, and so forth.  P1==0 is</span>
<a name="l02543"></a>02543 <span class="comment">** the main database file and P1==1 is the database file used to store</span>
<a name="l02544"></a>02544 <span class="comment">** temporary tables.</span>
<a name="l02545"></a>02545 <span class="comment">**</span>
<a name="l02546"></a>02546 <span class="comment">** A transaction must be started before executing this opcode.</span>
<a name="l02547"></a>02547 <span class="comment">*/</span>
<a name="l02548"></a>02548 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3c205910e0b1038b167b1dc6cae3b83e">OP_SetCookie</a>: {       <span class="comment">/* in3 */</span>
<a name="l02549"></a>02549   <a class="code" href="structDb.html">Db</a> *pDb;
<a name="l02550"></a>02550   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;<a class="code" href="btree_8h.html#a4e1ac7962950f2c2f7309d7e947764b4">SQLITE_N_BTREE_META</a> );
<a name="l02551"></a>02551   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;=0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a> );
<a name="l02552"></a>02552   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>))!=0 );
<a name="l02553"></a>02553   pDb = &amp;db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l02554"></a>02554   assert( pDb-&gt;<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>!=0 );
<a name="l02555"></a>02555   <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pIn3);
<a name="l02556"></a>02556   <span class="comment">/* See note about index shifting on OP_ReadCookie */</span>
<a name="l02557"></a>02557   rc = <a class="code" href="btree_8c.html#add955e8fdc68f4bc7a07d070984a3802">sqlite3BtreeUpdateMeta</a>(pDb-&gt;<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>, 1+pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, (<span class="keywordtype">int</span>)pIn3-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>);
<a name="l02558"></a>02558   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>==0 ){
<a name="l02559"></a>02559     <span class="comment">/* When the schema cookie changes, record the new cookie internally */</span>
<a name="l02560"></a>02560     pDb-&gt;<a class="code" href="structDb.html#afd8647a83a4a7053231b92814520d6d4">pSchema</a>-&gt;<a class="code" href="structSchema.html#a3eef54a64f4f962d64577646bd34a47c">schema_cookie</a> = pIn3-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l02561"></a>02561     db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> |= <a class="code" href="sqliteInt_8h.html#ac4ee799ffccd81c7967fde25523c6c6a">SQLITE_InternChanges</a>;
<a name="l02562"></a>02562   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>==1 ){
<a name="l02563"></a>02563     <span class="comment">/* Record changes in the file format */</span>
<a name="l02564"></a>02564     pDb-&gt;<a class="code" href="structDb.html#afd8647a83a4a7053231b92814520d6d4">pSchema</a>-&gt;<a class="code" href="structSchema.html#ab9f0371436e41b3080772995407a4cca">file_format</a> = pIn3-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l02565"></a>02565   }
<a name="l02566"></a>02566   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>==1 ){
<a name="l02567"></a>02567     <span class="comment">/* Invalidate all prepared statements whenever the TEMP database</span>
<a name="l02568"></a>02568 <span class="comment">    ** schema is changed.  Ticket #1644 */</span>
<a name="l02569"></a>02569     <a class="code" href="sqliteInt_8h.html#ac49dbebed4f062b16e866f024c262e95">sqlite3ExpirePreparedStatements</a>(db);
<a name="l02570"></a>02570   }
<a name="l02571"></a>02571   <span class="keywordflow">break</span>;
<a name="l02572"></a>02572 }
<a name="l02573"></a>02573 
<a name="l02574"></a>02574 <span class="comment">/* Opcode: VerifyCookie P1 P2 *</span>
<a name="l02575"></a>02575 <span class="comment">**</span>
<a name="l02576"></a>02576 <span class="comment">** Check the value of global database parameter number 0 (the</span>
<a name="l02577"></a>02577 <span class="comment">** schema version) and make sure it is equal to P2.  </span>
<a name="l02578"></a>02578 <span class="comment">** P1 is the database number which is 0 for the main database file</span>
<a name="l02579"></a>02579 <span class="comment">** and 1 for the file holding temporary tables and some higher number</span>
<a name="l02580"></a>02580 <span class="comment">** for auxiliary databases.</span>
<a name="l02581"></a>02581 <span class="comment">**</span>
<a name="l02582"></a>02582 <span class="comment">** The cookie changes its value whenever the database schema changes.</span>
<a name="l02583"></a>02583 <span class="comment">** This operation is used to detect when that the cookie has changed</span>
<a name="l02584"></a>02584 <span class="comment">** and that the current process needs to reread the schema.</span>
<a name="l02585"></a>02585 <span class="comment">**</span>
<a name="l02586"></a>02586 <span class="comment">** Either a transaction needs to have been started or an OP_Open needs</span>
<a name="l02587"></a>02587 <span class="comment">** to be executed (to establish a read lock) before this opcode is</span>
<a name="l02588"></a>02588 <span class="comment">** invoked.</span>
<a name="l02589"></a>02589 <span class="comment">*/</span>
<a name="l02590"></a>02590 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#af6461f533fb8e4b5c60d510b64566440">OP_VerifyCookie</a>: {
<a name="l02591"></a>02591   <span class="keywordtype">int</span> iMeta;
<a name="l02592"></a>02592   <a class="code" href="structBtree.html">Btree</a> *pBt;
<a name="l02593"></a>02593   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;=0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a> );
<a name="l02594"></a>02594   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>))!=0 );
<a name="l02595"></a>02595   pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l02596"></a>02596   <span class="keywordflow">if</span>( pBt ){
<a name="l02597"></a>02597     rc = <a class="code" href="btree_8c.html#a927b663f431cd2f4edfac55d7018cbb6">sqlite3BtreeGetMeta</a>(pBt, 1, (<a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> *)&amp;iMeta);
<a name="l02598"></a>02598   }<span class="keywordflow">else</span>{
<a name="l02599"></a>02599     rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02600"></a>02600     iMeta = 0;
<a name="l02601"></a>02601   }
<a name="l02602"></a>02602   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; iMeta!=pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> ){
<a name="l02603"></a>02603     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l02604"></a>02604     p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = <a class="code" href="malloc_8c.html#aa75e87f512f3cb7a48175b26dba47ebb">sqlite3DbStrDup</a>(db, <span class="stringliteral">&quot;database schema has changed&quot;</span>);
<a name="l02605"></a>02605     <span class="comment">/* If the schema-cookie from the database file matches the cookie </span>
<a name="l02606"></a>02606 <span class="comment">    ** stored with the in-memory representation of the schema, do</span>
<a name="l02607"></a>02607 <span class="comment">    ** not reload the schema from the database file.</span>
<a name="l02608"></a>02608 <span class="comment">    **</span>
<a name="l02609"></a>02609 <span class="comment">    ** If virtual-tables are in use, this is not just an optimization.</span>
<a name="l02610"></a>02610 <span class="comment">    ** Often, v-tables store their data in other SQLite tables, which</span>
<a name="l02611"></a>02611 <span class="comment">    ** are queried from within xNext() and other v-table methods using</span>
<a name="l02612"></a>02612 <span class="comment">    ** prepared queries. If such a query is out-of-date, we do not want to</span>
<a name="l02613"></a>02613 <span class="comment">    ** discard the database schema, as the user code implementing the</span>
<a name="l02614"></a>02614 <span class="comment">    ** v-table would have to be ready for the sqlite3_vtab structure itself</span>
<a name="l02615"></a>02615 <span class="comment">    ** to be invalidated whenever sqlite3_step() is called from within </span>
<a name="l02616"></a>02616 <span class="comment">    ** a v-table method.</span>
<a name="l02617"></a>02617 <span class="comment">    */</span>
<a name="l02618"></a>02618     <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>].<a class="code" href="structDb.html#afd8647a83a4a7053231b92814520d6d4">pSchema</a>-&gt;<a class="code" href="structSchema.html#a3eef54a64f4f962d64577646bd34a47c">schema_cookie</a>!=iMeta ){
<a name="l02619"></a>02619       <a class="code" href="build_8c.html#a67e7c0c4f9880fb86514ef03643b1cd2">sqlite3ResetInternalSchema</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>);
<a name="l02620"></a>02620     }
<a name="l02621"></a>02621 
<a name="l02622"></a>02622     <a class="code" href="sqliteInt_8h.html#ac49dbebed4f062b16e866f024c262e95">sqlite3ExpirePreparedStatements</a>(db);
<a name="l02623"></a>02623     rc = <a class="code" href="sqlite3_8h.html#a1671ab645a3331d997b4422dc334476a">SQLITE_SCHEMA</a>;
<a name="l02624"></a>02624   }
<a name="l02625"></a>02625   <span class="keywordflow">break</span>;
<a name="l02626"></a>02626 }
<a name="l02627"></a>02627 
<a name="l02628"></a>02628 <span class="comment">/* Opcode: OpenRead P1 P2 P3 P4 P5</span>
<a name="l02629"></a>02629 <span class="comment">**</span>
<a name="l02630"></a>02630 <span class="comment">** Open a read-only cursor for the database table whose root page is</span>
<a name="l02631"></a>02631 <span class="comment">** P2 in a database file.  The database file is determined by P3. </span>
<a name="l02632"></a>02632 <span class="comment">** P3==0 means the main database, P3==1 means the database used for </span>
<a name="l02633"></a>02633 <span class="comment">** temporary tables, and P3&gt;1 means used the corresponding attached</span>
<a name="l02634"></a>02634 <span class="comment">** database.  Give the new cursor an identifier of P1.  The P1</span>
<a name="l02635"></a>02635 <span class="comment">** values need not be contiguous but all P1 values should be small integers.</span>
<a name="l02636"></a>02636 <span class="comment">** It is an error for P1 to be negative.</span>
<a name="l02637"></a>02637 <span class="comment">**</span>
<a name="l02638"></a>02638 <span class="comment">** If P5!=0 then use the content of register P2 as the root page, not</span>
<a name="l02639"></a>02639 <span class="comment">** the value of P2 itself.</span>
<a name="l02640"></a>02640 <span class="comment">**</span>
<a name="l02641"></a>02641 <span class="comment">** There will be a read lock on the database whenever there is an</span>
<a name="l02642"></a>02642 <span class="comment">** open cursor.  If the database was unlocked prior to this instruction</span>
<a name="l02643"></a>02643 <span class="comment">** then a read lock is acquired as part of this instruction.  A read</span>
<a name="l02644"></a>02644 <span class="comment">** lock allows other processes to read the database but prohibits</span>
<a name="l02645"></a>02645 <span class="comment">** any other process from modifying the database.  The read lock is</span>
<a name="l02646"></a>02646 <span class="comment">** released when all cursors are closed.  If this instruction attempts</span>
<a name="l02647"></a>02647 <span class="comment">** to get a read lock but fails, the script terminates with an</span>
<a name="l02648"></a>02648 <span class="comment">** SQLITE_BUSY error code.</span>
<a name="l02649"></a>02649 <span class="comment">**</span>
<a name="l02650"></a>02650 <span class="comment">** The P4 value is a pointer to a KeyInfo structure that defines the</span>
<a name="l02651"></a>02651 <span class="comment">** content and collating sequence of indices.  P4 is NULL for cursors</span>
<a name="l02652"></a>02652 <span class="comment">** that are not pointing to indices.</span>
<a name="l02653"></a>02653 <span class="comment">**</span>
<a name="l02654"></a>02654 <span class="comment">** See also OpenWrite.</span>
<a name="l02655"></a>02655 <span class="comment">*/</span>
<a name="l02656"></a>02656 <span class="comment">/* Opcode: OpenWrite P1 P2 P3 P4 P5</span>
<a name="l02657"></a>02657 <span class="comment">**</span>
<a name="l02658"></a>02658 <span class="comment">** Open a read/write cursor named P1 on the table or index whose root</span>
<a name="l02659"></a>02659 <span class="comment">** page is P2.  Or if P5!=0 use the content of register P2 to find the</span>
<a name="l02660"></a>02660 <span class="comment">** root page.</span>
<a name="l02661"></a>02661 <span class="comment">**</span>
<a name="l02662"></a>02662 <span class="comment">** The P4 value is a pointer to a KeyInfo structure that defines the</span>
<a name="l02663"></a>02663 <span class="comment">** content and collating sequence of indices.  P4 is NULL for cursors</span>
<a name="l02664"></a>02664 <span class="comment">** that are not pointing to indices.</span>
<a name="l02665"></a>02665 <span class="comment">**</span>
<a name="l02666"></a>02666 <span class="comment">** This instruction works just like OpenRead except that it opens the cursor</span>
<a name="l02667"></a>02667 <span class="comment">** in read/write mode.  For a given table, there can be one or more read-only</span>
<a name="l02668"></a>02668 <span class="comment">** cursors or a single read/write cursor but not both.</span>
<a name="l02669"></a>02669 <span class="comment">**</span>
<a name="l02670"></a>02670 <span class="comment">** See also OpenRead.</span>
<a name="l02671"></a>02671 <span class="comment">*/</span>
<a name="l02672"></a>02672 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a0c72fbe4989449cdc9a69e1bbb2e91c2">OP_OpenRead</a>:
<a name="l02673"></a>02673 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a98af8f9fca78ddf04bbc472cf2761f10">OP_OpenWrite</a>: {
<a name="l02674"></a>02674   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02675"></a>02675   <span class="keywordtype">int</span> p2 = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l02676"></a>02676   <span class="keywordtype">int</span> iDb = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;
<a name="l02677"></a>02677   <span class="keywordtype">int</span> wrFlag;
<a name="l02678"></a>02678   <a class="code" href="structBtree.html">Btree</a> *pX;
<a name="l02679"></a>02679   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCur;
<a name="l02680"></a>02680   <a class="code" href="structDb.html">Db</a> *pDb;
<a name="l02681"></a>02681   
<a name="l02682"></a>02682   assert( iDb&gt;=0 &amp;&amp; iDb&lt;db-&gt;nDb );
<a name="l02683"></a>02683   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;iDb))!=0 );
<a name="l02684"></a>02684   pDb = &amp;db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb];
<a name="l02685"></a>02685   pX = pDb-&gt;<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l02686"></a>02686   assert( pX!=0 );
<a name="l02687"></a>02687   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a98af8f9fca78ddf04bbc472cf2761f10">OP_OpenWrite</a> ){
<a name="l02688"></a>02688     wrFlag = 1;
<a name="l02689"></a>02689     <span class="keywordflow">if</span>( pDb-&gt;<a class="code" href="structDb.html#afd8647a83a4a7053231b92814520d6d4">pSchema</a>-&gt;<a class="code" href="structSchema.html#ab9f0371436e41b3080772995407a4cca">file_format</a> &lt; p-&gt;<a class="code" href="structVdbe.html#a679ac87f7b835982cd7c1990fbc3605b">minWriteFileFormat</a> ){
<a name="l02690"></a>02690       p-&gt;<a class="code" href="structVdbe.html#a679ac87f7b835982cd7c1990fbc3605b">minWriteFileFormat</a> = pDb-&gt;<a class="code" href="structDb.html#afd8647a83a4a7053231b92814520d6d4">pSchema</a>-&gt;<a class="code" href="structSchema.html#ab9f0371436e41b3080772995407a4cca">file_format</a>;
<a name="l02691"></a>02691     }
<a name="l02692"></a>02692   }<span class="keywordflow">else</span>{
<a name="l02693"></a>02693     wrFlag = 0;
<a name="l02694"></a>02694   }
<a name="l02695"></a>02695   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> ){
<a name="l02696"></a>02696     assert( p2&gt;0 );
<a name="l02697"></a>02697     assert( p2&lt;=p-&gt;nMem );
<a name="l02698"></a>02698     pIn2 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[p2];
<a name="l02699"></a>02699     <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pIn2);
<a name="l02700"></a>02700     p2 = pIn2-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l02701"></a>02701     assert( p2&gt;=2 );
<a name="l02702"></a>02702   }
<a name="l02703"></a>02703   assert( i&gt;=0 );
<a name="l02704"></a>02704   pCur = <a class="code" href="vdbe_8c.html#a5e6a4a459c5d72f8cc5478bea910dfdf">allocateCursor</a>(p, i, &amp;pOp[-1], iDb, 1);
<a name="l02705"></a>02705   <span class="keywordflow">if</span>( pCur==0 ) <span class="keywordflow">goto</span> no_mem;
<a name="l02706"></a>02706   pCur-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = 1;
<a name="l02707"></a>02707   rc = <a class="code" href="btree_8c.html#a4b7ea579f2a4d5e2ac49e7ad5b5f47b7">sqlite3BtreeCursor</a>(pX, p2, wrFlag, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a27a7eaab2fd6a79638f134576847f446">p</a>, pCur-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>);
<a name="l02708"></a>02708   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a> ){
<a name="l02709"></a>02709     pCur-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a531b315fc943dd3990adb10e687ba737">pKeyInfo</a>;
<a name="l02710"></a>02710     pCur-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a>-&gt;<a class="code" href="structKeyInfo.html#a37972825f9a148668e979be12465e832">enc</a> = <a class="code" href="sqliteInt_8h.html#a8d01c7bc7577fdd8cae2d7f9e13ae88d">ENC</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>);
<a name="l02711"></a>02711   }<span class="keywordflow">else</span>{
<a name="l02712"></a>02712     pCur-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a> = 0;
<a name="l02713"></a>02713   }
<a name="l02714"></a>02714   <span class="keywordflow">switch</span>( rc ){
<a name="l02715"></a>02715     <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>: {
<a name="l02716"></a>02716       p-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a> = pc;
<a name="l02717"></a>02717       p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = rc = <a class="code" href="sqlite3_8h.html#a2404c3c65a25e31de96f71d709c6b7c1">SQLITE_BUSY</a>;
<a name="l02718"></a>02718       <span class="keywordflow">goto</span> vdbe_return;
<a name="l02719"></a>02719     }
<a name="l02720"></a>02720     <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>: {
<a name="l02721"></a>02721       <span class="keywordtype">int</span> flags = <a class="code" href="btree_8c.html#a723642d632e53c6ab42c61b504d1059f">sqlite3BtreeFlags</a>(pCur-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>);
<a name="l02722"></a>02722       <span class="comment">/* Sanity checking.  Only the lower four bits of the flags byte should</span>
<a name="l02723"></a>02723 <span class="comment">      ** be used.  Bit 3 (mask 0x08) is unpredictable.  The lower 3 bits</span>
<a name="l02724"></a>02724 <span class="comment">      ** (mask 0x07) should be either 5 (intkey+leafdata for tables) or</span>
<a name="l02725"></a>02725 <span class="comment">      ** 2 (zerodata for indices).  If these conditions are not met it can</span>
<a name="l02726"></a>02726 <span class="comment">      ** only mean that we are dealing with a corrupt database file</span>
<a name="l02727"></a>02727 <span class="comment">      */</span>
<a name="l02728"></a>02728       <span class="keywordflow">if</span>( (flags &amp; 0xf0)!=0 || ((flags &amp; 0x07)!=5 &amp;&amp; (flags &amp; 0x07)!=2) ){
<a name="l02729"></a>02729         rc = <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l02730"></a>02730         <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l02731"></a>02731       }
<a name="l02732"></a>02732       pCur-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> = (flags &amp; <a class="code" href="btree_8h.html#acd71692e8b09c8106ad4504cdd1065bc">BTREE_INTKEY</a>)!=0;
<a name="l02733"></a>02733       pCur-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> = (flags &amp; <a class="code" href="btree_8h.html#aca0cac010cf1fa6f4d1df39beb6a1f8d">BTREE_ZERODATA</a>)!=0;
<a name="l02734"></a>02734       <span class="comment">/* If P4==0 it means we are expected to open a table.  If P4!=0 then</span>
<a name="l02735"></a>02735 <span class="comment">      ** we expect to be opening an index.  If this is not what happened,</span>
<a name="l02736"></a>02736 <span class="comment">      ** then the database is corrupt</span>
<a name="l02737"></a>02737 <span class="comment">      */</span>
<a name="l02738"></a>02738       <span class="keywordflow">if</span>( (pCur-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a>)
<a name="l02739"></a>02739        || (pCur-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>!=<a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a>) ){
<a name="l02740"></a>02740         rc = <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l02741"></a>02741         <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l02742"></a>02742       }
<a name="l02743"></a>02743       <span class="keywordflow">break</span>;
<a name="l02744"></a>02744     }
<a name="l02745"></a>02745     <span class="keywordflow">case</span> <a class="code" href="sqlite3_8h.html#adb3ccb6413bc81a990cab25356ab092f">SQLITE_EMPTY</a>: {
<a name="l02746"></a>02746       pCur-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>!=<a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a>;
<a name="l02747"></a>02747       pCur-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> = !pCur-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a>;
<a name="l02748"></a>02748       pCur-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a> = 0;
<a name="l02749"></a>02749       rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l02750"></a>02750       <span class="keywordflow">break</span>;
<a name="l02751"></a>02751     }
<a name="l02752"></a>02752     <span class="keywordflow">default</span>: {
<a name="l02753"></a>02753       <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l02754"></a>02754     }
<a name="l02755"></a>02755   }
<a name="l02756"></a>02756   <span class="keywordflow">break</span>;
<a name="l02757"></a>02757 }
<a name="l02758"></a>02758 
<a name="l02759"></a>02759 <span class="comment">/* Opcode: OpenEphemeral P1 P2 * P4 *</span>
<a name="l02760"></a>02760 <span class="comment">**</span>
<a name="l02761"></a>02761 <span class="comment">** Open a new cursor P1 to a transient table.</span>
<a name="l02762"></a>02762 <span class="comment">** The cursor is always opened read/write even if </span>
<a name="l02763"></a>02763 <span class="comment">** the main database is read-only.  The transient or virtual</span>
<a name="l02764"></a>02764 <span class="comment">** table is deleted automatically when the cursor is closed.</span>
<a name="l02765"></a>02765 <span class="comment">**</span>
<a name="l02766"></a>02766 <span class="comment">** P2 is the number of columns in the virtual table.</span>
<a name="l02767"></a>02767 <span class="comment">** The cursor points to a BTree table if P4==0 and to a BTree index</span>
<a name="l02768"></a>02768 <span class="comment">** if P4 is not 0.  If P4 is not NULL, it points to a KeyInfo structure</span>
<a name="l02769"></a>02769 <span class="comment">** that defines the format of keys in the index.</span>
<a name="l02770"></a>02770 <span class="comment">**</span>
<a name="l02771"></a>02771 <span class="comment">** This opcode was once called OpenTemp.  But that created</span>
<a name="l02772"></a>02772 <span class="comment">** confusion because the term &quot;temp table&quot;, might refer either</span>
<a name="l02773"></a>02773 <span class="comment">** to a TEMP table at the SQL level, or to a table opened by</span>
<a name="l02774"></a>02774 <span class="comment">** this opcode.  Then this opcode was call OpenVirtual.  But</span>
<a name="l02775"></a>02775 <span class="comment">** that created confusion with the whole virtual-table idea.</span>
<a name="l02776"></a>02776 <span class="comment">*/</span>
<a name="l02777"></a>02777 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a2c9ec21e951d5ecf39b32e118d57a262">OP_OpenEphemeral</a>: {
<a name="l02778"></a>02778   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02779"></a>02779   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCx;
<a name="l02780"></a>02780   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> openFlags = 
<a name="l02781"></a>02781       <a class="code" href="sqlite3_8h.html#a3eb39cf04a78fae3b553b96d65f93419">SQLITE_OPEN_READWRITE</a> |
<a name="l02782"></a>02782       <a class="code" href="sqlite3_8h.html#a06cff06321a46ca610a29c8f125f9c08">SQLITE_OPEN_CREATE</a> |
<a name="l02783"></a>02783       <a class="code" href="sqlite3_8h.html#a3eace21577bcc4790a72a096c21ba645">SQLITE_OPEN_EXCLUSIVE</a> |
<a name="l02784"></a>02784       <a class="code" href="sqlite3_8h.html#a64253edf05cdfa93174ebf8fd4155e39">SQLITE_OPEN_DELETEONCLOSE</a> |
<a name="l02785"></a>02785       <a class="code" href="sqlite3_8h.html#afc7fbd65e1786cd345a6d87e8820d38e">SQLITE_OPEN_TRANSIENT_DB</a>;
<a name="l02786"></a>02786 
<a name="l02787"></a>02787   assert( i&gt;=0 );
<a name="l02788"></a>02788   pCx = <a class="code" href="vdbe_8c.html#a5e6a4a459c5d72f8cc5478bea910dfdf">allocateCursor</a>(p, i, pOp, -1, 1);
<a name="l02789"></a>02789   <span class="keywordflow">if</span>( pCx==0 ) <span class="keywordflow">goto</span> no_mem;
<a name="l02790"></a>02790   pCx-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = 1;
<a name="l02791"></a>02791   rc = <a class="code" href="main_8c.html#a8c0b466053ac0552d6e2bcbf4e57e8a9">sqlite3BtreeFactory</a>(db, 0, 1, <a class="code" href="sqliteLimit_8h.html#aa75e18b4d2785d9e7e813dcb46649b3d">SQLITE_DEFAULT_TEMP_CACHE_SIZE</a>, openFlags,
<a name="l02792"></a>02792                            &amp;pCx-&gt;<a class="code" href="structVdbeCursor.html#a287db3fe6d84102fad3d69494b565e9b">pBt</a>);
<a name="l02793"></a>02793   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02794"></a>02794     rc = <a class="code" href="btree_8c.html#aa347f2c69b05ad6cb2ebfad1c9c54718">sqlite3BtreeBeginTrans</a>(pCx-&gt;<a class="code" href="structVdbeCursor.html#a287db3fe6d84102fad3d69494b565e9b">pBt</a>, 1);
<a name="l02795"></a>02795   }
<a name="l02796"></a>02796   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02797"></a>02797     <span class="comment">/* If a transient index is required, create it by calling</span>
<a name="l02798"></a>02798 <span class="comment">    ** sqlite3BtreeCreateTable() with the BTREE_ZERODATA flag before</span>
<a name="l02799"></a>02799 <span class="comment">    ** opening it. If a transient table is required, just use the</span>
<a name="l02800"></a>02800 <span class="comment">    ** automatically created table with root-page 1 (an INTKEY table).</span>
<a name="l02801"></a>02801 <span class="comment">    */</span>
<a name="l02802"></a>02802     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a531b315fc943dd3990adb10e687ba737">pKeyInfo</a> ){
<a name="l02803"></a>02803       <span class="keywordtype">int</span> pgno;
<a name="l02804"></a>02804       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a296c71657317854839363a5e63a3c623">P4_KEYINFO</a> );
<a name="l02805"></a>02805       rc = <a class="code" href="btree_8c.html#a1084bedd105ea21f99beef334bbddd80">sqlite3BtreeCreateTable</a>(pCx-&gt;<a class="code" href="structVdbeCursor.html#a287db3fe6d84102fad3d69494b565e9b">pBt</a>, &amp;pgno, <a class="code" href="btree_8h.html#aca0cac010cf1fa6f4d1df39beb6a1f8d">BTREE_ZERODATA</a>); 
<a name="l02806"></a>02806       <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02807"></a>02807         assert( pgno==<a class="code" href="sqliteInt_8h.html#a55c81f26551028f4d36e84190993eaed">MASTER_ROOT</a>+1 );
<a name="l02808"></a>02808         rc = <a class="code" href="btree_8c.html#a4b7ea579f2a4d5e2ac49e7ad5b5f47b7">sqlite3BtreeCursor</a>(pCx-&gt;<a class="code" href="structVdbeCursor.html#a287db3fe6d84102fad3d69494b565e9b">pBt</a>, pgno, 1, 
<a name="l02809"></a>02809                                 (<a class="code" href="structKeyInfo.html">KeyInfo</a>*)pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>, pCx-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>);
<a name="l02810"></a>02810         pCx-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a531b315fc943dd3990adb10e687ba737">pKeyInfo</a>;
<a name="l02811"></a>02811         pCx-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a>-&gt;<a class="code" href="structKeyInfo.html#a37972825f9a148668e979be12465e832">enc</a> = <a class="code" href="sqliteInt_8h.html#a8d01c7bc7577fdd8cae2d7f9e13ae88d">ENC</a>(p-&gt;<a class="code" href="structVdbe.html#a495366101a593999f4d2ed905e839029">db</a>);
<a name="l02812"></a>02812       }
<a name="l02813"></a>02813       pCx-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> = 0;
<a name="l02814"></a>02814     }<span class="keywordflow">else</span>{
<a name="l02815"></a>02815       rc = <a class="code" href="btree_8c.html#a4b7ea579f2a4d5e2ac49e7ad5b5f47b7">sqlite3BtreeCursor</a>(pCx-&gt;<a class="code" href="structVdbeCursor.html#a287db3fe6d84102fad3d69494b565e9b">pBt</a>, <a class="code" href="sqliteInt_8h.html#a55c81f26551028f4d36e84190993eaed">MASTER_ROOT</a>, 1, 0, pCx-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>);
<a name="l02816"></a>02816       pCx-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> = 1;
<a name="l02817"></a>02817     }
<a name="l02818"></a>02818   }
<a name="l02819"></a>02819   pCx-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> = !pCx-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a>;
<a name="l02820"></a>02820   <span class="keywordflow">break</span>;
<a name="l02821"></a>02821 }
<a name="l02822"></a>02822 
<a name="l02823"></a>02823 <span class="comment">/* Opcode: OpenPseudo P1 P2 * * *</span>
<a name="l02824"></a>02824 <span class="comment">**</span>
<a name="l02825"></a>02825 <span class="comment">** Open a new cursor that points to a fake table that contains a single</span>
<a name="l02826"></a>02826 <span class="comment">** row of data.  Any attempt to write a second row of data causes the</span>
<a name="l02827"></a>02827 <span class="comment">** first row to be deleted.  All data is deleted when the cursor is</span>
<a name="l02828"></a>02828 <span class="comment">** closed.</span>
<a name="l02829"></a>02829 <span class="comment">**</span>
<a name="l02830"></a>02830 <span class="comment">** A pseudo-table created by this opcode is useful for holding the</span>
<a name="l02831"></a>02831 <span class="comment">** NEW or OLD tables in a trigger.  Also used to hold the a single</span>
<a name="l02832"></a>02832 <span class="comment">** row output from the sorter so that the row can be decomposed into</span>
<a name="l02833"></a>02833 <span class="comment">** individual columns using the OP_Column opcode.</span>
<a name="l02834"></a>02834 <span class="comment">**</span>
<a name="l02835"></a>02835 <span class="comment">** When OP_Insert is executed to insert a row in to the pseudo table,</span>
<a name="l02836"></a>02836 <span class="comment">** the pseudo-table cursor may or may not make it&apos;s own copy of the</span>
<a name="l02837"></a>02837 <span class="comment">** original row data. If P2 is 0, then the pseudo-table will copy the</span>
<a name="l02838"></a>02838 <span class="comment">** original row data. Otherwise, a pointer to the original memory cell</span>
<a name="l02839"></a>02839 <span class="comment">** is stored. In this case, the vdbe program must ensure that the </span>
<a name="l02840"></a>02840 <span class="comment">** memory cell containing the row data is not overwritten until the</span>
<a name="l02841"></a>02841 <span class="comment">** pseudo table is closed (or a new row is inserted into it).</span>
<a name="l02842"></a>02842 <span class="comment">*/</span>
<a name="l02843"></a>02843 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a4128984c342a0dd41b6d9c57c649ab29">OP_OpenPseudo</a>: {
<a name="l02844"></a>02844   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02845"></a>02845   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCx;
<a name="l02846"></a>02846   assert( i&gt;=0 );
<a name="l02847"></a>02847   pCx = <a class="code" href="vdbe_8c.html#a5e6a4a459c5d72f8cc5478bea910dfdf">allocateCursor</a>(p, i, &amp;pOp[-1], -1, 0);
<a name="l02848"></a>02848   <span class="keywordflow">if</span>( pCx==0 ) <span class="keywordflow">goto</span> no_mem;
<a name="l02849"></a>02849   pCx-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = 1;
<a name="l02850"></a>02850   pCx-&gt;<a class="code" href="structVdbeCursor.html#a762de613989f39beaf12a05af896300a">pseudoTable</a> = 1;
<a name="l02851"></a>02851   pCx-&gt;<a class="code" href="structVdbeCursor.html#a70576a23035c6f2aced72f2309e6f024">ephemPseudoTable</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l02852"></a>02852   pCx-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> = 1;
<a name="l02853"></a>02853   pCx-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> = 0;
<a name="l02854"></a>02854   <span class="keywordflow">break</span>;
<a name="l02855"></a>02855 }
<a name="l02856"></a>02856 
<a name="l02857"></a>02857 <span class="comment">/* Opcode: Close P1 * * * *</span>
<a name="l02858"></a>02858 <span class="comment">**</span>
<a name="l02859"></a>02859 <span class="comment">** Close a cursor previously opened as P1.  If P1 is not</span>
<a name="l02860"></a>02860 <span class="comment">** currently open, this instruction is a no-op.</span>
<a name="l02861"></a>02861 <span class="comment">*/</span>
<a name="l02862"></a>02862 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a0aa97845ae3b449f1745a6713f20f3a6">OP_Close</a>: {
<a name="l02863"></a>02863   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02864"></a>02864   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l02865"></a>02865   <a class="code" href="vdbeaux_8c.html#a6db711e5d25afe0e6b41bb62b5d45ee6">sqlite3VdbeFreeCursor</a>(p, p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]);
<a name="l02866"></a>02866   p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i] = 0;
<a name="l02867"></a>02867   <span class="keywordflow">break</span>;
<a name="l02868"></a>02868 }
<a name="l02869"></a>02869 
<a name="l02870"></a>02870 <span class="comment">/* Opcode: MoveGe P1 P2 P3 P4 *</span>
<a name="l02871"></a>02871 <span class="comment">**</span>
<a name="l02872"></a>02872 <span class="comment">** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), </span>
<a name="l02873"></a>02873 <span class="comment">** use the integer value in register P3 as a key. If cursor P1 refers </span>
<a name="l02874"></a>02874 <span class="comment">** to an SQL index, then P3 is the first in an array of P4 registers </span>
<a name="l02875"></a>02875 <span class="comment">** that are used as an unpacked index key. </span>
<a name="l02876"></a>02876 <span class="comment">**</span>
<a name="l02877"></a>02877 <span class="comment">** Reposition cursor P1 so that  it points to the smallest entry that </span>
<a name="l02878"></a>02878 <span class="comment">** is greater than or equal to the key value. If there are no records </span>
<a name="l02879"></a>02879 <span class="comment">** greater than or equal to the key and P2 is not zero, then jump to P2.</span>
<a name="l02880"></a>02880 <span class="comment">**</span>
<a name="l02881"></a>02881 <span class="comment">** A special feature of this opcode (and different from the</span>
<a name="l02882"></a>02882 <span class="comment">** related OP_MoveGt, OP_MoveLt, and OP_MoveLe) is that if P2 is</span>
<a name="l02883"></a>02883 <span class="comment">** zero and P1 is an SQL table (a b-tree with integer keys) then</span>
<a name="l02884"></a>02884 <span class="comment">** the seek is deferred until it is actually needed.  It might be</span>
<a name="l02885"></a>02885 <span class="comment">** the case that the cursor is never accessed.  By deferring the</span>
<a name="l02886"></a>02886 <span class="comment">** seek, we avoid unnecessary seeks.</span>
<a name="l02887"></a>02887 <span class="comment">**</span>
<a name="l02888"></a>02888 <span class="comment">** See also: Found, NotFound, Distinct, MoveLt, MoveGt, MoveLe</span>
<a name="l02889"></a>02889 <span class="comment">*/</span>
<a name="l02890"></a>02890 <span class="comment">/* Opcode: MoveGt P1 P2 P3 P4 *</span>
<a name="l02891"></a>02891 <span class="comment">**</span>
<a name="l02892"></a>02892 <span class="comment">** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), </span>
<a name="l02893"></a>02893 <span class="comment">** use the integer value in register P3 as a key. If cursor P1 refers </span>
<a name="l02894"></a>02894 <span class="comment">** to an SQL index, then P3 is the first in an array of P4 registers </span>
<a name="l02895"></a>02895 <span class="comment">** that are used as an unpacked index key. </span>
<a name="l02896"></a>02896 <span class="comment">**</span>
<a name="l02897"></a>02897 <span class="comment">** Reposition cursor P1 so that  it points to the smallest entry that </span>
<a name="l02898"></a>02898 <span class="comment">** is greater than the key value. If there are no records greater than </span>
<a name="l02899"></a>02899 <span class="comment">** the key and P2 is not zero, then jump to P2.</span>
<a name="l02900"></a>02900 <span class="comment">**</span>
<a name="l02901"></a>02901 <span class="comment">** See also: Found, NotFound, Distinct, MoveLt, MoveGe, MoveLe</span>
<a name="l02902"></a>02902 <span class="comment">*/</span>
<a name="l02903"></a>02903 <span class="comment">/* Opcode: MoveLt P1 P2 P3 P4 * </span>
<a name="l02904"></a>02904 <span class="comment">**</span>
<a name="l02905"></a>02905 <span class="comment">** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), </span>
<a name="l02906"></a>02906 <span class="comment">** use the integer value in register P3 as a key. If cursor P1 refers </span>
<a name="l02907"></a>02907 <span class="comment">** to an SQL index, then P3 is the first in an array of P4 registers </span>
<a name="l02908"></a>02908 <span class="comment">** that are used as an unpacked index key. </span>
<a name="l02909"></a>02909 <span class="comment">**</span>
<a name="l02910"></a>02910 <span class="comment">** Reposition cursor P1 so that  it points to the largest entry that </span>
<a name="l02911"></a>02911 <span class="comment">** is less than the key value. If there are no records less than </span>
<a name="l02912"></a>02912 <span class="comment">** the key and P2 is not zero, then jump to P2.</span>
<a name="l02913"></a>02913 <span class="comment">**</span>
<a name="l02914"></a>02914 <span class="comment">** See also: Found, NotFound, Distinct, MoveGt, MoveGe, MoveLe</span>
<a name="l02915"></a>02915 <span class="comment">*/</span>
<a name="l02916"></a>02916 <span class="comment">/* Opcode: MoveLe P1 P2 P3 P4 *</span>
<a name="l02917"></a>02917 <span class="comment">**</span>
<a name="l02918"></a>02918 <span class="comment">** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), </span>
<a name="l02919"></a>02919 <span class="comment">** use the integer value in register P3 as a key. If cursor P1 refers </span>
<a name="l02920"></a>02920 <span class="comment">** to an SQL index, then P3 is the first in an array of P4 registers </span>
<a name="l02921"></a>02921 <span class="comment">** that are used as an unpacked index key. </span>
<a name="l02922"></a>02922 <span class="comment">**</span>
<a name="l02923"></a>02923 <span class="comment">** Reposition cursor P1 so that it points to the largest entry that </span>
<a name="l02924"></a>02924 <span class="comment">** is less than or equal to the key value. If there are no records </span>
<a name="l02925"></a>02925 <span class="comment">** less than or equal to the key and P2 is not zero, then jump to P2.</span>
<a name="l02926"></a>02926 <span class="comment">**</span>
<a name="l02927"></a>02927 <span class="comment">** See also: Found, NotFound, Distinct, MoveGt, MoveGe, MoveLt</span>
<a name="l02928"></a>02928 <span class="comment">*/</span>
<a name="l02929"></a>02929 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3f150ff6af921d6c05dbef4ae6fb0e83">OP_MoveLt</a>:         <span class="comment">/* jump, in3 */</span>
<a name="l02930"></a>02930 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a8f37cd62b49195bfc0a0bc709fa5328d">OP_MoveLe</a>:         <span class="comment">/* jump, in3 */</span>
<a name="l02931"></a>02931 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a12380781df416d8ce7e57531bc9265c9">OP_MoveGe</a>:         <span class="comment">/* jump, in3 */</span>
<a name="l02932"></a>02932 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a81a079df922cabd4b2d6578fc6a8064a">OP_MoveGt</a>: {       <span class="comment">/* jump, in3 */</span>
<a name="l02933"></a>02933   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l02934"></a>02934   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l02935"></a>02935 
<a name="l02936"></a>02936   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l02937"></a>02937   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l02938"></a>02938   assert( pC!=0 );
<a name="l02939"></a>02939   <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>!=0 ){
<a name="l02940"></a>02940     <span class="keywordtype">int</span> res, oc;
<a name="l02941"></a>02941     oc = pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>;
<a name="l02942"></a>02942     pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = 0;
<a name="l02943"></a>02943     <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> ){
<a name="l02944"></a>02944       <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> iKey = <a class="code" href="vdbeInt_8h.html#af740891f040ec074e1a140d71c1cacba">sqlite3VdbeIntValue</a>(pIn3);
<a name="l02945"></a>02945       <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>==0 ){
<a name="l02946"></a>02946         assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a12380781df416d8ce7e57531bc9265c9">OP_MoveGe</a> );
<a name="l02947"></a>02947         pC-&gt;<a class="code" href="structVdbeCursor.html#af3c157d480c0597ba50aca227eb8e3b8">movetoTarget</a> = iKey;
<a name="l02948"></a>02948         pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = 0;
<a name="l02949"></a>02949         pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a> = 1;
<a name="l02950"></a>02950         <span class="keywordflow">break</span>;
<a name="l02951"></a>02951       }
<a name="l02952"></a>02952       rc = <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, 0, (<a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a>)iKey, 0, &amp;res);
<a name="l02953"></a>02953       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02954"></a>02954         <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l02955"></a>02955       }
<a name="l02956"></a>02956       pC-&gt;<a class="code" href="structVdbeCursor.html#af2ff971acc308c012c60b1e949c64411">lastRowid</a> = iKey;
<a name="l02957"></a>02957       pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = res==0;
<a name="l02958"></a>02958     }<span class="keywordflow">else</span>{
<a name="l02959"></a>02959       <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> r;
<a name="l02960"></a>02960       <span class="keywordtype">int</span> nField = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a69efeafb8cb87ea2a6feed61e877869a">i</a>;
<a name="l02961"></a>02961       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a985d1d22c0d0a5ceb7546b09e60d31ef">P4_INT32</a> );
<a name="l02962"></a>02962       assert( nField&gt;0 );
<a name="l02963"></a>02963       r.<a class="code" href="structUnpackedRecord.html#aeb43e7a1e300857cab2cbe98eacd575b">pKeyInfo</a> = pC-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a>;
<a name="l02964"></a>02964       r.<a class="code" href="structUnpackedRecord.html#a2c5062735cdbc5039679d255cc900668">nField</a> = nField;
<a name="l02965"></a>02965       <span class="keywordflow">if</span>( oc==<a class="code" href="opcodes_8h.html#a81a079df922cabd4b2d6578fc6a8064a">OP_MoveGt</a> || oc==<a class="code" href="opcodes_8h.html#a8f37cd62b49195bfc0a0bc709fa5328d">OP_MoveLe</a> ){
<a name="l02966"></a>02966         r.<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> = <a class="code" href="sqliteInt_8h.html#a3908fc771b61da3bcd4c146de8e1515f">UNPACKED_INCRKEY</a>;
<a name="l02967"></a>02967       }<span class="keywordflow">else</span>{
<a name="l02968"></a>02968         r.<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> = 0;
<a name="l02969"></a>02969       }
<a name="l02970"></a>02970       r.<a class="code" href="structUnpackedRecord.html#a3299c322ceb8b758dacc59701021ae9f">aMem</a> = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l02971"></a>02971       rc = <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, &amp;r, 0, 0, &amp;res);
<a name="l02972"></a>02972       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l02973"></a>02973         <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l02974"></a>02974       }
<a name="l02975"></a>02975       pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = 0;
<a name="l02976"></a>02976     }
<a name="l02977"></a>02977     pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a> = 0;
<a name="l02978"></a>02978     pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l02979"></a>02979 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l02980"></a>02980 <span class="preprocessor"></span>    sqlite3_search_count++;
<a name="l02981"></a>02981 <span class="preprocessor">#endif</span>
<a name="l02982"></a>02982 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( oc==<a class="code" href="opcodes_8h.html#a12380781df416d8ce7e57531bc9265c9">OP_MoveGe</a> || oc==<a class="code" href="opcodes_8h.html#a81a079df922cabd4b2d6578fc6a8064a">OP_MoveGt</a> ){
<a name="l02983"></a>02983       <span class="keywordflow">if</span>( res&lt;0 ){
<a name="l02984"></a>02984         rc = <a class="code" href="btree_8c.html#adf99ca89adc2e91557a41d6d11e97039">sqlite3BtreeNext</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, &amp;res);
<a name="l02985"></a>02985         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l02986"></a>02986         pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = 0;
<a name="l02987"></a>02987       }<span class="keywordflow">else</span>{
<a name="l02988"></a>02988         res = 0;
<a name="l02989"></a>02989       }
<a name="l02990"></a>02990     }<span class="keywordflow">else</span>{
<a name="l02991"></a>02991       assert( oc==<a class="code" href="opcodes_8h.html#a3f150ff6af921d6c05dbef4ae6fb0e83">OP_MoveLt</a> || oc==<a class="code" href="opcodes_8h.html#a8f37cd62b49195bfc0a0bc709fa5328d">OP_MoveLe</a> );
<a name="l02992"></a>02992       <span class="keywordflow">if</span>( res&gt;=0 ){
<a name="l02993"></a>02993         rc = <a class="code" href="btree_8c.html#af84d1157958331e8d900f0800409f60b">sqlite3BtreePrevious</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, &amp;res);
<a name="l02994"></a>02994         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l02995"></a>02995         pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = 0;
<a name="l02996"></a>02996       }<span class="keywordflow">else</span>{
<a name="l02997"></a>02997         <span class="comment">/* res might be negative because the table is empty.  Check to</span>
<a name="l02998"></a>02998 <span class="comment">        ** see if this is the case.</span>
<a name="l02999"></a>02999 <span class="comment">        */</span>
<a name="l03000"></a>03000         res = <a class="code" href="btree_8c.html#a1f64c2a112c9356bbfc401cd85b797e7">sqlite3BtreeEof</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>);
<a name="l03001"></a>03001       }
<a name="l03002"></a>03002     }
<a name="l03003"></a>03003     assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 );
<a name="l03004"></a>03004     <span class="keywordflow">if</span>( res ){
<a name="l03005"></a>03005       pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03006"></a>03006     }
<a name="l03007"></a>03007   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( !pC-&gt;<a class="code" href="structVdbeCursor.html#a762de613989f39beaf12a05af896300a">pseudoTable</a> ){
<a name="l03008"></a>03008     <span class="comment">/* This happens when attempting to open the sqlite3_master table</span>
<a name="l03009"></a>03009 <span class="comment">    ** for read access returns SQLITE_EMPTY. In this case always</span>
<a name="l03010"></a>03010 <span class="comment">    ** take the jump (since there are no records in the table).</span>
<a name="l03011"></a>03011 <span class="comment">    */</span>
<a name="l03012"></a>03012     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03013"></a>03013   }
<a name="l03014"></a>03014   <span class="keywordflow">break</span>;
<a name="l03015"></a>03015 }
<a name="l03016"></a>03016 
<a name="l03017"></a>03017 <span class="comment">/* Opcode: Found P1 P2 P3 * *</span>
<a name="l03018"></a>03018 <span class="comment">**</span>
<a name="l03019"></a>03019 <span class="comment">** Register P3 holds a blob constructed by MakeRecord.  P1 is an index.</span>
<a name="l03020"></a>03020 <span class="comment">** If an entry that matches the value in register p3 exists in P1 then</span>
<a name="l03021"></a>03021 <span class="comment">** jump to P2.  If the P3 value does not match any entry in P1</span>
<a name="l03022"></a>03022 <span class="comment">** then fall thru.  The P1 cursor is left pointing at the matching entry</span>
<a name="l03023"></a>03023 <span class="comment">** if it exists.</span>
<a name="l03024"></a>03024 <span class="comment">**</span>
<a name="l03025"></a>03025 <span class="comment">** This instruction is used to implement the IN operator where the</span>
<a name="l03026"></a>03026 <span class="comment">** left-hand side is a SELECT statement.  P1 may be a true index, or it</span>
<a name="l03027"></a>03027 <span class="comment">** may be a temporary index that holds the results of the SELECT</span>
<a name="l03028"></a>03028 <span class="comment">** statement.   This instruction is also used to implement the</span>
<a name="l03029"></a>03029 <span class="comment">** DISTINCT keyword in SELECT statements.</span>
<a name="l03030"></a>03030 <span class="comment">**</span>
<a name="l03031"></a>03031 <span class="comment">** This instruction checks if index P1 contains a record for which </span>
<a name="l03032"></a>03032 <span class="comment">** the first N serialized values exactly match the N serialized values</span>
<a name="l03033"></a>03033 <span class="comment">** in the record in register P3, where N is the total number of values in</span>
<a name="l03034"></a>03034 <span class="comment">** the P3 record (the P3 record is a prefix of the P1 record). </span>
<a name="l03035"></a>03035 <span class="comment">**</span>
<a name="l03036"></a>03036 <span class="comment">** See also: NotFound, IsUnique, NotExists</span>
<a name="l03037"></a>03037 <span class="comment">*/</span>
<a name="l03038"></a>03038 <span class="comment">/* Opcode: NotFound P1 P2 P3 * *</span>
<a name="l03039"></a>03039 <span class="comment">**</span>
<a name="l03040"></a>03040 <span class="comment">** Register P3 holds a blob constructed by MakeRecord.  P1 is</span>
<a name="l03041"></a>03041 <span class="comment">** an index.  If no entry exists in P1 that matches the blob then jump</span>
<a name="l03042"></a>03042 <span class="comment">** to P2.  If an entry does existing, fall through.  The cursor is left</span>
<a name="l03043"></a>03043 <span class="comment">** pointing to the entry that matches.</span>
<a name="l03044"></a>03044 <span class="comment">**</span>
<a name="l03045"></a>03045 <span class="comment">** See also: Found, NotExists, IsUnique</span>
<a name="l03046"></a>03046 <span class="comment">*/</span>
<a name="l03047"></a>03047 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a646435593665c4db8dd754f3b0465be4">OP_NotFound</a>:       <span class="comment">/* jump, in3 */</span>
<a name="l03048"></a>03048 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a03384798af27315459f2ae61550f915f">OP_Found</a>: {        <span class="comment">/* jump, in3 */</span>
<a name="l03049"></a>03049   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03050"></a>03050   <span class="keywordtype">int</span> alreadyExists = 0;
<a name="l03051"></a>03051   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03052"></a>03052   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03053"></a>03053   assert( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]!=0 );
<a name="l03054"></a>03054   <span class="keywordflow">if</span>( (pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i])-&gt;pCursor!=0 ){
<a name="l03055"></a>03055     <span class="keywordtype">int</span> res;
<a name="l03056"></a>03056     <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *pIdxKey;
<a name="l03057"></a>03057 
<a name="l03058"></a>03058     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a>==0 );
<a name="l03059"></a>03059     assert( pIn3-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; MEM_Blob );
<a name="l03060"></a>03060     pIdxKey = <a class="code" href="vdbe_8h.html#a3b886b85d57a0b60bc5be0478f55e8d9">sqlite3VdbeRecordUnpack</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a>, pIn3-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>, pIn3-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>,
<a name="l03061"></a>03061                                       aTempRec, <span class="keyword">sizeof</span>(aTempRec));
<a name="l03062"></a>03062     <span class="keywordflow">if</span>( pIdxKey==0 ){
<a name="l03063"></a>03063       <span class="keywordflow">goto</span> no_mem;
<a name="l03064"></a>03064     }
<a name="l03065"></a>03065     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a03384798af27315459f2ae61550f915f">OP_Found</a> ){
<a name="l03066"></a>03066       pIdxKey-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> |= <a class="code" href="sqliteInt_8h.html#ae23637243712af21268d993ba3c69d18">UNPACKED_PREFIX_MATCH</a>;
<a name="l03067"></a>03067     }
<a name="l03068"></a>03068     rc = <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, pIdxKey, 0, 0, &amp;res);
<a name="l03069"></a>03069     <a class="code" href="vdbe_8h.html#a92e9ed579bf09eeeb3b4006f669753a0">sqlite3VdbeDeleteUnpackedRecord</a>(pIdxKey);
<a name="l03070"></a>03070     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03071"></a>03071       <span class="keywordflow">break</span>;
<a name="l03072"></a>03072     }
<a name="l03073"></a>03073     alreadyExists = (res==0);
<a name="l03074"></a>03074     pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a> = 0;
<a name="l03075"></a>03075     pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03076"></a>03076   }
<a name="l03077"></a>03077   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a03384798af27315459f2ae61550f915f">OP_Found</a> ){
<a name="l03078"></a>03078     <span class="keywordflow">if</span>( alreadyExists ) pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03079"></a>03079   }<span class="keywordflow">else</span>{
<a name="l03080"></a>03080     <span class="keywordflow">if</span>( !alreadyExists ) pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03081"></a>03081   }
<a name="l03082"></a>03082   <span class="keywordflow">break</span>;
<a name="l03083"></a>03083 }
<a name="l03084"></a>03084 
<a name="l03085"></a>03085 <span class="comment">/* Opcode: IsUnique P1 P2 P3 P4 *</span>
<a name="l03086"></a>03086 <span class="comment">**</span>
<a name="l03087"></a>03087 <span class="comment">** The P3 register contains an integer record number.  Call this</span>
<a name="l03088"></a>03088 <span class="comment">** record number R.  The P4 register contains an index key created</span>
<a name="l03089"></a>03089 <span class="comment">** using MakeRecord.  Call it K.</span>
<a name="l03090"></a>03090 <span class="comment">**</span>
<a name="l03091"></a>03091 <span class="comment">** P1 is an index.  So it has no data and its key consists of a</span>
<a name="l03092"></a>03092 <span class="comment">** record generated by OP_MakeRecord where the last field is the </span>
<a name="l03093"></a>03093 <span class="comment">** rowid of the entry that the index refers to.</span>
<a name="l03094"></a>03094 <span class="comment">** </span>
<a name="l03095"></a>03095 <span class="comment">** This instruction asks if there is an entry in P1 where the</span>
<a name="l03096"></a>03096 <span class="comment">** fields matches K but the rowid is different from R.</span>
<a name="l03097"></a>03097 <span class="comment">** If there is no such entry, then there is an immediate</span>
<a name="l03098"></a>03098 <span class="comment">** jump to P2.  If any entry does exist where the index string</span>
<a name="l03099"></a>03099 <span class="comment">** matches K but the record number is not R, then the record</span>
<a name="l03100"></a>03100 <span class="comment">** number for that entry is written into P3 and control</span>
<a name="l03101"></a>03101 <span class="comment">** falls through to the next instruction.</span>
<a name="l03102"></a>03102 <span class="comment">**</span>
<a name="l03103"></a>03103 <span class="comment">** See also: NotFound, NotExists, Found</span>
<a name="l03104"></a>03104 <span class="comment">*/</span>
<a name="l03105"></a>03105 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3036524146b8ad9e7f603b27502e3f4a">OP_IsUnique</a>: {        <span class="comment">/* jump, in3 */</span>
<a name="l03106"></a>03106   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03107"></a>03107   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCx;
<a name="l03108"></a>03108   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;
<a name="l03109"></a>03109   <a class="code" href="structMem.html">Mem</a> *pK;
<a name="l03110"></a>03110   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> R;
<a name="l03111"></a>03111 
<a name="l03112"></a>03112   <span class="comment">/* Pop the value R off the top of the stack</span>
<a name="l03113"></a>03113 <span class="comment">  */</span>
<a name="l03114"></a>03114   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a985d1d22c0d0a5ceb7546b09e60d31ef">P4_INT32</a> );
<a name="l03115"></a>03115   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a69efeafb8cb87ea2a6feed61e877869a">i</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a69efeafb8cb87ea2a6feed61e877869a">i</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l03116"></a>03116   pK = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a69efeafb8cb87ea2a6feed61e877869a">i</a>];
<a name="l03117"></a>03117   <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pIn3);
<a name="l03118"></a>03118   R = pIn3-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l03119"></a>03119   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03120"></a>03120   pCx = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l03121"></a>03121   assert( pCx!=0 );
<a name="l03122"></a>03122   pCrsr = pCx-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>;
<a name="l03123"></a>03123   <span class="keywordflow">if</span>( pCrsr!=0 ){
<a name="l03124"></a>03124     <span class="keywordtype">int</span> res;
<a name="l03125"></a>03125     <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> v;                     <span class="comment">/* The record number that matches K */</span>
<a name="l03126"></a>03126     <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> *pIdxKey;   <span class="comment">/* Unpacked version of P4 */</span>
<a name="l03127"></a>03127 
<a name="l03128"></a>03128     <span class="comment">/* Make sure K is a string and make zKey point to K</span>
<a name="l03129"></a>03129 <span class="comment">    */</span>
<a name="l03130"></a>03130     assert( pK-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; MEM_Blob );
<a name="l03131"></a>03131     pIdxKey = <a class="code" href="vdbe_8h.html#a3b886b85d57a0b60bc5be0478f55e8d9">sqlite3VdbeRecordUnpack</a>(pCx-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a>, pK-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>, pK-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>,
<a name="l03132"></a>03132                                       aTempRec, <span class="keyword">sizeof</span>(aTempRec));
<a name="l03133"></a>03133     <span class="keywordflow">if</span>( pIdxKey==0 ){
<a name="l03134"></a>03134       <span class="keywordflow">goto</span> no_mem;
<a name="l03135"></a>03135     }
<a name="l03136"></a>03136     pIdxKey-&gt;<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> |= <a class="code" href="sqliteInt_8h.html#a1650685ebf83cd7720588c3ef7449f41">UNPACKED_IGNORE_ROWID</a>;
<a name="l03137"></a>03137 
<a name="l03138"></a>03138     <span class="comment">/* Search for an entry in P1 where all but the last rowid match K</span>
<a name="l03139"></a>03139 <span class="comment">    ** If there is no such entry, jump immediately to P2.</span>
<a name="l03140"></a>03140 <span class="comment">    */</span>
<a name="l03141"></a>03141     assert( pCx-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a>==0 );
<a name="l03142"></a>03142     pCx-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03143"></a>03143     rc = <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(pCrsr, pIdxKey, 0, 0, &amp;res);
<a name="l03144"></a>03144     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03145"></a>03145       <a class="code" href="vdbe_8h.html#a92e9ed579bf09eeeb3b4006f669753a0">sqlite3VdbeDeleteUnpackedRecord</a>(pIdxKey);
<a name="l03146"></a>03146       <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03147"></a>03147     }
<a name="l03148"></a>03148     <span class="keywordflow">if</span>( res&lt;0 ){
<a name="l03149"></a>03149       rc = <a class="code" href="btree_8c.html#adf99ca89adc2e91557a41d6d11e97039">sqlite3BtreeNext</a>(pCrsr, &amp;res);
<a name="l03150"></a>03150       <span class="keywordflow">if</span>( res ){
<a name="l03151"></a>03151         pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03152"></a>03152         <a class="code" href="vdbe_8h.html#a92e9ed579bf09eeeb3b4006f669753a0">sqlite3VdbeDeleteUnpackedRecord</a>(pIdxKey);
<a name="l03153"></a>03153         <span class="keywordflow">break</span>;
<a name="l03154"></a>03154       }
<a name="l03155"></a>03155     }
<a name="l03156"></a>03156     rc = <a class="code" href="vdbeaux_8c.html#a1fadd000b100ed3f3b10f697e73f1bd6">sqlite3VdbeIdxKeyCompare</a>(pCx, pIdxKey, &amp;res); 
<a name="l03157"></a>03157     <a class="code" href="vdbe_8h.html#a92e9ed579bf09eeeb3b4006f669753a0">sqlite3VdbeDeleteUnpackedRecord</a>(pIdxKey);
<a name="l03158"></a>03158     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03159"></a>03159     <span class="keywordflow">if</span>( res&gt;0 ){
<a name="l03160"></a>03160       pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03161"></a>03161       <span class="keywordflow">break</span>;
<a name="l03162"></a>03162     }
<a name="l03163"></a>03163 
<a name="l03164"></a>03164     <span class="comment">/* At this point, pCrsr is pointing to an entry in P1 where all but</span>
<a name="l03165"></a>03165 <span class="comment">    ** the final entry (the rowid) matches K.  Check to see if the</span>
<a name="l03166"></a>03166 <span class="comment">    ** final rowid column is different from R.  If it equals R then jump</span>
<a name="l03167"></a>03167 <span class="comment">    ** immediately to P2.</span>
<a name="l03168"></a>03168 <span class="comment">    */</span>
<a name="l03169"></a>03169     rc = <a class="code" href="vdbeaux_8c.html#ad5f1e2b1c24e382e4c64868bd2c8f707">sqlite3VdbeIdxRowid</a>(pCrsr, &amp;v);
<a name="l03170"></a>03170     <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03171"></a>03171       <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03172"></a>03172     }
<a name="l03173"></a>03173     <span class="keywordflow">if</span>( v==R ){
<a name="l03174"></a>03174       pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03175"></a>03175       <span class="keywordflow">break</span>;
<a name="l03176"></a>03176     }
<a name="l03177"></a>03177 
<a name="l03178"></a>03178     <span class="comment">/* The final varint of the key is different from R.  Store it back</span>
<a name="l03179"></a>03179 <span class="comment">    ** into register R3.  (The record number of an entry that violates</span>
<a name="l03180"></a>03180 <span class="comment">    ** a UNIQUE constraint.)</span>
<a name="l03181"></a>03181 <span class="comment">    */</span>
<a name="l03182"></a>03182     pIn3-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = v;
<a name="l03183"></a>03183     assert( pIn3-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l03184"></a>03184   }
<a name="l03185"></a>03185   <span class="keywordflow">break</span>;
<a name="l03186"></a>03186 }
<a name="l03187"></a>03187 
<a name="l03188"></a>03188 <span class="comment">/* Opcode: NotExists P1 P2 P3 * *</span>
<a name="l03189"></a>03189 <span class="comment">**</span>
<a name="l03190"></a>03190 <span class="comment">** Use the content of register P3 as a integer key.  If a record </span>
<a name="l03191"></a>03191 <span class="comment">** with that key does not exist in table of P1, then jump to P2. </span>
<a name="l03192"></a>03192 <span class="comment">** If the record does exist, then fall thru.  The cursor is left </span>
<a name="l03193"></a>03193 <span class="comment">** pointing to the record if it exists.</span>
<a name="l03194"></a>03194 <span class="comment">**</span>
<a name="l03195"></a>03195 <span class="comment">** The difference between this operation and NotFound is that this</span>
<a name="l03196"></a>03196 <span class="comment">** operation assumes the key is an integer and that P1 is a table whereas</span>
<a name="l03197"></a>03197 <span class="comment">** NotFound assumes key is a blob constructed from MakeRecord and</span>
<a name="l03198"></a>03198 <span class="comment">** P1 is an index.</span>
<a name="l03199"></a>03199 <span class="comment">**</span>
<a name="l03200"></a>03200 <span class="comment">** See also: Found, NotFound, IsUnique</span>
<a name="l03201"></a>03201 <span class="comment">*/</span>
<a name="l03202"></a>03202 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a52cd591f2f66a915ef7549c215806357">OP_NotExists</a>: {        <span class="comment">/* jump, in3 */</span>
<a name="l03203"></a>03203   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03204"></a>03204   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03205"></a>03205   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;
<a name="l03206"></a>03206   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03207"></a>03207   assert( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]!=0 );
<a name="l03208"></a>03208   <span class="keywordflow">if</span>( (pCrsr = (pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i])-&gt;pCursor)!=0 ){
<a name="l03209"></a>03209     <span class="keywordtype">int</span> res;
<a name="l03210"></a>03210     <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> iKey;
<a name="l03211"></a>03211     assert( pIn3-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l03212"></a>03212     assert( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> );
<a name="l03213"></a>03213     iKey = <a class="code" href="vdbeInt_8h.html#a9c2af9ac75017412987d9bcb3a670769">intToKey</a>(pIn3-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>);
<a name="l03214"></a>03214     rc = <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(pCrsr, 0, iKey, 0,&amp;res);
<a name="l03215"></a>03215     pC-&gt;<a class="code" href="structVdbeCursor.html#af2ff971acc308c012c60b1e949c64411">lastRowid</a> = pIn3-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l03216"></a>03216     pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = res==0;
<a name="l03217"></a>03217     pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = 0;
<a name="l03218"></a>03218     pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03219"></a>03219     <span class="comment">/* res might be uninitialized if rc!=SQLITE_OK.  But if rc!=SQLITE_OK</span>
<a name="l03220"></a>03220 <span class="comment">    ** processing is about to abort so we really do not care whether or not</span>
<a name="l03221"></a>03221 <span class="comment">    ** the following jump is taken.  (In other words, do not stress over</span>
<a name="l03222"></a>03222 <span class="comment">    ** the error that valgrind sometimes shows on the next statement when</span>
<a name="l03223"></a>03223 <span class="comment">    ** running ioerr.test and similar failure-recovery test scripts.) */</span>
<a name="l03224"></a>03224     <span class="keywordflow">if</span>( res!=0 ){
<a name="l03225"></a>03225       pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03226"></a>03226       assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a>==0 );
<a name="l03227"></a>03227     }
<a name="l03228"></a>03228   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( !pC-&gt;<a class="code" href="structVdbeCursor.html#a762de613989f39beaf12a05af896300a">pseudoTable</a> ){
<a name="l03229"></a>03229     <span class="comment">/* This happens when an attempt to open a read cursor on the </span>
<a name="l03230"></a>03230 <span class="comment">    ** sqlite_master table returns SQLITE_EMPTY.</span>
<a name="l03231"></a>03231 <span class="comment">    */</span>
<a name="l03232"></a>03232     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> );
<a name="l03233"></a>03233     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03234"></a>03234     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a>==0 );
<a name="l03235"></a>03235   }
<a name="l03236"></a>03236   <span class="keywordflow">break</span>;
<a name="l03237"></a>03237 }
<a name="l03238"></a>03238 
<a name="l03239"></a>03239 <span class="comment">/* Opcode: Sequence P1 P2 * * *</span>
<a name="l03240"></a>03240 <span class="comment">**</span>
<a name="l03241"></a>03241 <span class="comment">** Find the next available sequence number for cursor P1.</span>
<a name="l03242"></a>03242 <span class="comment">** Write the sequence number into register P2.</span>
<a name="l03243"></a>03243 <span class="comment">** The sequence number on the cursor is incremented after this</span>
<a name="l03244"></a>03244 <span class="comment">** instruction.  </span>
<a name="l03245"></a>03245 <span class="comment">*/</span>
<a name="l03246"></a>03246 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a76057aff58e5cef58bcdb0486a503a39">OP_Sequence</a>: {           <span class="comment">/* out2-prerelease */</span>
<a name="l03247"></a>03247   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03248"></a>03248   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03249"></a>03249   assert( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]!=0 );
<a name="l03250"></a>03250   pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]-&gt;<a class="code" href="structVdbeCursor.html#a4f11f0befb0dcf16273cc832ca6d92a5">seqCount</a>++;
<a name="l03251"></a>03251   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l03252"></a>03252   <span class="keywordflow">break</span>;
<a name="l03253"></a>03253 }
<a name="l03254"></a>03254 
<a name="l03255"></a>03255 
<a name="l03256"></a>03256 <span class="comment">/* Opcode: NewRowid P1 P2 P3 * *</span>
<a name="l03257"></a>03257 <span class="comment">**</span>
<a name="l03258"></a>03258 <span class="comment">** Get a new integer record number (a.k.a &quot;rowid&quot;) used as the key to a table.</span>
<a name="l03259"></a>03259 <span class="comment">** The record number is not previously used as a key in the database</span>
<a name="l03260"></a>03260 <span class="comment">** table that cursor P1 points to.  The new record number is written</span>
<a name="l03261"></a>03261 <span class="comment">** written to register P2.</span>
<a name="l03262"></a>03262 <span class="comment">**</span>
<a name="l03263"></a>03263 <span class="comment">** If P3&gt;0 then P3 is a register that holds the largest previously</span>
<a name="l03264"></a>03264 <span class="comment">** generated record number.  No new record numbers are allowed to be less</span>
<a name="l03265"></a>03265 <span class="comment">** than this value.  When this value reaches its maximum, a SQLITE_FULL</span>
<a name="l03266"></a>03266 <span class="comment">** error is generated.  The P3 register is updated with the generated</span>
<a name="l03267"></a>03267 <span class="comment">** record number.  This P3 mechanism is used to help implement the</span>
<a name="l03268"></a>03268 <span class="comment">** AUTOINCREMENT feature.</span>
<a name="l03269"></a>03269 <span class="comment">*/</span>
<a name="l03270"></a>03270 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aebc7e3a304f9b4b81abce298ff9704ec">OP_NewRowid</a>: {           <span class="comment">/* out2-prerelease */</span>
<a name="l03271"></a>03271   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03272"></a>03272   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> v = 0;
<a name="l03273"></a>03273   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03274"></a>03274   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03275"></a>03275   assert( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]!=0 );
<a name="l03276"></a>03276   <span class="keywordflow">if</span>( (pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i])-&gt;pCursor==0 ){
<a name="l03277"></a>03277     <span class="comment">/* The zero initialization above is all that is needed */</span>
<a name="l03278"></a>03278   }<span class="keywordflow">else</span>{
<a name="l03279"></a>03279     <span class="comment">/* The next rowid or record number (different terms for the same</span>
<a name="l03280"></a>03280 <span class="comment">    ** thing) is obtained in a two-step algorithm.</span>
<a name="l03281"></a>03281 <span class="comment">    **</span>
<a name="l03282"></a>03282 <span class="comment">    ** First we attempt to find the largest existing rowid and add one</span>
<a name="l03283"></a>03283 <span class="comment">    ** to that.  But if the largest existing rowid is already the maximum</span>
<a name="l03284"></a>03284 <span class="comment">    ** positive integer, we have to fall through to the second</span>
<a name="l03285"></a>03285 <span class="comment">    ** probabilistic algorithm</span>
<a name="l03286"></a>03286 <span class="comment">    **</span>
<a name="l03287"></a>03287 <span class="comment">    ** The second algorithm is to select a rowid at random and see if</span>
<a name="l03288"></a>03288 <span class="comment">    ** it already exists in the table.  If it does not exist, we have</span>
<a name="l03289"></a>03289 <span class="comment">    ** succeeded.  If the random rowid does exist, we select a new one</span>
<a name="l03290"></a>03290 <span class="comment">    ** and try again, up to 1000 times.</span>
<a name="l03291"></a>03291 <span class="comment">    **</span>
<a name="l03292"></a>03292 <span class="comment">    ** For a table with less than 2 billion entries, the probability</span>
<a name="l03293"></a>03293 <span class="comment">    ** of not finding a unused rowid is about 1.0e-300.  This is a </span>
<a name="l03294"></a>03294 <span class="comment">    ** non-zero probability, but it is still vanishingly small and should</span>
<a name="l03295"></a>03295 <span class="comment">    ** never cause a problem.  You are much, much more likely to have a</span>
<a name="l03296"></a>03296 <span class="comment">    ** hardware failure than for this algorithm to fail.</span>
<a name="l03297"></a>03297 <span class="comment">    **</span>
<a name="l03298"></a>03298 <span class="comment">    ** The analysis in the previous paragraph assumes that you have a good</span>
<a name="l03299"></a>03299 <span class="comment">    ** source of random numbers.  Is a library function like lrand48()</span>
<a name="l03300"></a>03300 <span class="comment">    ** good enough?  Maybe. Maybe not. It&apos;s hard to know whether there</span>
<a name="l03301"></a>03301 <span class="comment">    ** might be subtle bugs is some implementations of lrand48() that</span>
<a name="l03302"></a>03302 <span class="comment">    ** could cause problems. To avoid uncertainty, SQLite uses its own </span>
<a name="l03303"></a>03303 <span class="comment">    ** random number generator based on the RC4 algorithm.</span>
<a name="l03304"></a>03304 <span class="comment">    **</span>
<a name="l03305"></a>03305 <span class="comment">    ** To promote locality of reference for repetitive inserts, the</span>
<a name="l03306"></a>03306 <span class="comment">    ** first few attempts at choosing a random rowid pick values just a little</span>
<a name="l03307"></a>03307 <span class="comment">    ** larger than the previous rowid.  This has been shown experimentally</span>
<a name="l03308"></a>03308 <span class="comment">    ** to double the speed of the COPY operation.</span>
<a name="l03309"></a>03309 <span class="comment">    */</span>
<a name="l03310"></a>03310     <span class="keywordtype">int</span> res, rx=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>, cnt;
<a name="l03311"></a>03311     <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> x;
<a name="l03312"></a>03312     cnt = 0;
<a name="l03313"></a>03313     <span class="keywordflow">if</span>( (<a class="code" href="btree_8c.html#a723642d632e53c6ab42c61b504d1059f">sqlite3BtreeFlags</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>)&amp;(<a class="code" href="btree_8h.html#acd71692e8b09c8106ad4504cdd1065bc">BTREE_INTKEY</a>|<a class="code" href="btree_8h.html#aca0cac010cf1fa6f4d1df39beb6a1f8d">BTREE_ZERODATA</a>)) !=
<a name="l03314"></a>03314           <a class="code" href="btree_8h.html#acd71692e8b09c8106ad4504cdd1065bc">BTREE_INTKEY</a> ){
<a name="l03315"></a>03315       rc = <a class="code" href="sqliteInt_8h.html#a4b7e72e8edcbaa69661bc5c29fe63119">SQLITE_CORRUPT_BKPT</a>;
<a name="l03316"></a>03316       <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03317"></a>03317     }
<a name="l03318"></a>03318     assert( (<a class="code" href="btree_8c.html#a723642d632e53c6ab42c61b504d1059f">sqlite3BtreeFlags</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>) &amp; <a class="code" href="btree_8h.html#acd71692e8b09c8106ad4504cdd1065bc">BTREE_INTKEY</a>)!=0 );
<a name="l03319"></a>03319     assert( (<a class="code" href="btree_8c.html#a723642d632e53c6ab42c61b504d1059f">sqlite3BtreeFlags</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>) &amp; <a class="code" href="btree_8h.html#aca0cac010cf1fa6f4d1df39beb6a1f8d">BTREE_ZERODATA</a>)==0 );
<a name="l03320"></a>03320 
<a name="l03321"></a>03321 <span class="preprocessor">#ifdef SQLITE_32BIT_ROWID</span>
<a name="l03322"></a>03322 <span class="preprocessor"></span><span class="preprocessor">#   define MAX_ROWID 0x7fffffff</span>
<a name="l03323"></a>03323 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l03324"></a>03324 <span class="preprocessor"></span>    <span class="comment">/* Some compilers complain about constants of the form 0x7fffffffffffffff.</span>
<a name="l03325"></a>03325 <span class="comment">    ** Others complain about 0x7ffffffffffffffffLL.  The following macro seems</span>
<a name="l03326"></a>03326 <span class="comment">    ** to provide the constant while making all compilers happy.</span>
<a name="l03327"></a>03327 <span class="comment">    */</span>
<a name="l03328"></a>03328 <span class="preprocessor">#   define MAX_ROWID  ( (((u64)0x7fffffff)&lt;&lt;32) | (u64)0xffffffff )</span>
<a name="l03329"></a>03329 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03330"></a>03330 <span class="preprocessor"></span>
<a name="l03331"></a>03331     <span class="keywordflow">if</span>( !pC-&gt;<a class="code" href="structVdbeCursor.html#a067fff911d6d37190785a0cf5ba4fc8e">useRandomRowid</a> ){
<a name="l03332"></a>03332       <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a61c65a0cd36f85d13e9abdbebfe46e06">nextRowidValid</a> ){
<a name="l03333"></a>03333         v = pC-&gt;<a class="code" href="structVdbeCursor.html#a223d4a7f36b0548389efb23c3b23edbd">nextRowid</a>;
<a name="l03334"></a>03334       }<span class="keywordflow">else</span>{
<a name="l03335"></a>03335         rc = <a class="code" href="btree_8c.html#af4c43ac2d9ebc3f08a8fc2bbb181787b">sqlite3BtreeLast</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, &amp;res);
<a name="l03336"></a>03336         <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03337"></a>03337           <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03338"></a>03338         }
<a name="l03339"></a>03339         <span class="keywordflow">if</span>( res ){
<a name="l03340"></a>03340           v = 1;
<a name="l03341"></a>03341         }<span class="keywordflow">else</span>{
<a name="l03342"></a>03342           <a class="code" href="btree_8c.html#a2d5023d925e7eade74a33a94fbbc45e0">sqlite3BtreeKeySize</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, &amp;v);
<a name="l03343"></a>03343           v = <a class="code" href="vdbeInt_8h.html#a0d7ab028a08884fcdd3a349d8d319e1b">keyToInt</a>(v);
<a name="l03344"></a>03344           <span class="keywordflow">if</span>( v==<a class="code" href="vdbe_8c.html#a3becadcedff4e1f558d876c1be94cb08">MAX_ROWID</a> ){
<a name="l03345"></a>03345             pC-&gt;<a class="code" href="structVdbeCursor.html#a067fff911d6d37190785a0cf5ba4fc8e">useRandomRowid</a> = 1;
<a name="l03346"></a>03346           }<span class="keywordflow">else</span>{
<a name="l03347"></a>03347             v++;
<a name="l03348"></a>03348           }
<a name="l03349"></a>03349         }
<a name="l03350"></a>03350       }
<a name="l03351"></a>03351 
<a name="l03352"></a>03352 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOINCREMENT</span>
<a name="l03353"></a>03353 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a> ){
<a name="l03354"></a>03354         <a class="code" href="structMem.html">Mem</a> *pMem;
<a name="l03355"></a>03355         assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> ); <span class="comment">/* P3 is a valid memory cell */</span>
<a name="l03356"></a>03356         pMem = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l03357"></a>03357   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pMem);
<a name="l03358"></a>03358         <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pMem);
<a name="l03359"></a>03359         assert( (pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>)!=0 );  <span class="comment">/* mem(P3) holds an integer */</span>
<a name="l03360"></a>03360         <span class="keywordflow">if</span>( pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>==<a class="code" href="vdbe_8c.html#a3becadcedff4e1f558d876c1be94cb08">MAX_ROWID</a> || pC-&gt;<a class="code" href="structVdbeCursor.html#a067fff911d6d37190785a0cf5ba4fc8e">useRandomRowid</a> ){
<a name="l03361"></a>03361           rc = <a class="code" href="sqlite3_8h.html#a0e968a73ba9e13561c5dbf38f6ac7402">SQLITE_FULL</a>;
<a name="l03362"></a>03362           <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03363"></a>03363         }
<a name="l03364"></a>03364         <span class="keywordflow">if</span>( v&lt;pMem-&gt;u.i+1 ){
<a name="l03365"></a>03365           v = pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> + 1;
<a name="l03366"></a>03366         }
<a name="l03367"></a>03367         pMem-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = v;
<a name="l03368"></a>03368       }
<a name="l03369"></a>03369 <span class="preprocessor">#endif</span>
<a name="l03370"></a>03370 <span class="preprocessor"></span>
<a name="l03371"></a>03371       <span class="keywordflow">if</span>( v&lt;<a class="code" href="vdbe_8c.html#a3becadcedff4e1f558d876c1be94cb08">MAX_ROWID</a> ){
<a name="l03372"></a>03372         pC-&gt;<a class="code" href="structVdbeCursor.html#a61c65a0cd36f85d13e9abdbebfe46e06">nextRowidValid</a> = 1;
<a name="l03373"></a>03373         pC-&gt;<a class="code" href="structVdbeCursor.html#a223d4a7f36b0548389efb23c3b23edbd">nextRowid</a> = v+1;
<a name="l03374"></a>03374       }<span class="keywordflow">else</span>{
<a name="l03375"></a>03375         pC-&gt;<a class="code" href="structVdbeCursor.html#a61c65a0cd36f85d13e9abdbebfe46e06">nextRowidValid</a> = 0;
<a name="l03376"></a>03376       }
<a name="l03377"></a>03377     }
<a name="l03378"></a>03378     <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a067fff911d6d37190785a0cf5ba4fc8e">useRandomRowid</a> ){
<a name="l03379"></a>03379       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>==0 );  <span class="comment">/* SQLITE_FULL must have occurred prior to this */</span>
<a name="l03380"></a>03380       v = db-&gt;<a class="code" href="structsqlite3.html#a216e3825ececaf0c35694db0b15f9be5">priorNewRowid</a>;
<a name="l03381"></a>03381       cnt = 0;
<a name="l03382"></a>03382       <span class="keywordflow">do</span>{
<a name="l03383"></a>03383         <span class="keywordflow">if</span>( cnt==0 &amp;&amp; (v&amp;0xffffff)==v ){
<a name="l03384"></a>03384           v++;
<a name="l03385"></a>03385         }<span class="keywordflow">else</span>{
<a name="l03386"></a>03386           <a class="code" href="random_8c.html#a1431cd360c32f40da9dec267d29eb998">sqlite3_randomness</a>(<span class="keyword">sizeof</span>(v), &amp;v);
<a name="l03387"></a>03387           <span class="keywordflow">if</span>( cnt&lt;5 ) v &amp;= 0xffffff;
<a name="l03388"></a>03388         }
<a name="l03389"></a>03389         <span class="keywordflow">if</span>( v==0 ) <span class="keywordflow">continue</span>;
<a name="l03390"></a>03390         x = <a class="code" href="vdbeInt_8h.html#a9c2af9ac75017412987d9bcb3a670769">intToKey</a>(v);
<a name="l03391"></a>03391         rx = <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, 0, (<a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a>)x, 0, &amp;res);
<a name="l03392"></a>03392         cnt++;
<a name="l03393"></a>03393       }<span class="keywordflow">while</span>( cnt&lt;100 &amp;&amp; rx==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; res==0 );
<a name="l03394"></a>03394       db-&gt;<a class="code" href="structsqlite3.html#a216e3825ececaf0c35694db0b15f9be5">priorNewRowid</a> = v;
<a name="l03395"></a>03395       <span class="keywordflow">if</span>( rx==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; res==0 ){
<a name="l03396"></a>03396         rc = <a class="code" href="sqlite3_8h.html#a0e968a73ba9e13561c5dbf38f6ac7402">SQLITE_FULL</a>;
<a name="l03397"></a>03397         <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03398"></a>03398       }
<a name="l03399"></a>03399     }
<a name="l03400"></a>03400     pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = 0;
<a name="l03401"></a>03401     pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a> = 0;
<a name="l03402"></a>03402     pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03403"></a>03403   }
<a name="l03404"></a>03404   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l03405"></a>03405   pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = v;
<a name="l03406"></a>03406   <span class="keywordflow">break</span>;
<a name="l03407"></a>03407 }
<a name="l03408"></a>03408 
<a name="l03409"></a>03409 <span class="comment">/* Opcode: Insert P1 P2 P3 P4 P5</span>
<a name="l03410"></a>03410 <span class="comment">**</span>
<a name="l03411"></a>03411 <span class="comment">** Write an entry into the table of cursor P1.  A new entry is</span>
<a name="l03412"></a>03412 <span class="comment">** created if it doesn&apos;t already exist or the data for an existing</span>
<a name="l03413"></a>03413 <span class="comment">** entry is overwritten.  The data is the value stored register</span>
<a name="l03414"></a>03414 <span class="comment">** number P2. The key is stored in register P3. The key must</span>
<a name="l03415"></a>03415 <span class="comment">** be an integer.</span>
<a name="l03416"></a>03416 <span class="comment">**</span>
<a name="l03417"></a>03417 <span class="comment">** If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is</span>
<a name="l03418"></a>03418 <span class="comment">** incremented (otherwise not).  If the OPFLAG_LASTROWID flag of P5 is set,</span>
<a name="l03419"></a>03419 <span class="comment">** then rowid is stored for subsequent return by the</span>
<a name="l03420"></a>03420 <span class="comment">** sqlite3_last_insert_rowid() function (otherwise it is unmodified).</span>
<a name="l03421"></a>03421 <span class="comment">**</span>
<a name="l03422"></a>03422 <span class="comment">** Parameter P4 may point to a string containing the table-name, or</span>
<a name="l03423"></a>03423 <span class="comment">** may be NULL. If it is not NULL, then the update-hook </span>
<a name="l03424"></a>03424 <span class="comment">** (sqlite3.xUpdateCallback) is invoked following a successful insert.</span>
<a name="l03425"></a>03425 <span class="comment">**</span>
<a name="l03426"></a>03426 <span class="comment">** (WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically</span>
<a name="l03427"></a>03427 <span class="comment">** allocated, then ownership of P2 is transferred to the pseudo-cursor</span>
<a name="l03428"></a>03428 <span class="comment">** and register P2 becomes ephemeral.  If the cursor is changed, the</span>
<a name="l03429"></a>03429 <span class="comment">** value of register P2 will then change.  Make sure this does not</span>
<a name="l03430"></a>03430 <span class="comment">** cause any problems.)</span>
<a name="l03431"></a>03431 <span class="comment">**</span>
<a name="l03432"></a>03432 <span class="comment">** This instruction only works on tables.  The equivalent instruction</span>
<a name="l03433"></a>03433 <span class="comment">** for indices is OP_IdxInsert.</span>
<a name="l03434"></a>03434 <span class="comment">*/</span>
<a name="l03435"></a>03435 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#af8ec5cb3f4bce8e904b41f713c2c7d86">OP_Insert</a>: {
<a name="l03436"></a>03436   <a class="code" href="structMem.html">Mem</a> *pData = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l03437"></a>03437   <a class="code" href="structMem.html">Mem</a> *pKey = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l03438"></a>03438 
<a name="l03439"></a>03439   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> iKey;   <span class="comment">/* The integer ROWID or key for the record to be inserted */</span>
<a name="l03440"></a>03440   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03441"></a>03441   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03442"></a>03442   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03443"></a>03443   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l03444"></a>03444   assert( pC!=0 );
<a name="l03445"></a>03445   assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>!=0 || pC-&gt;<a class="code" href="structVdbeCursor.html#a762de613989f39beaf12a05af896300a">pseudoTable</a> );
<a name="l03446"></a>03446   assert( pKey-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l03447"></a>03447   assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> );
<a name="l03448"></a>03448   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pData);
<a name="l03449"></a>03449   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pKey);
<a name="l03450"></a>03450 
<a name="l03451"></a>03451   iKey = <a class="code" href="vdbeInt_8h.html#a9c2af9ac75017412987d9bcb3a670769">intToKey</a>(pKey-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>);
<a name="l03452"></a>03452   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> &amp; <a class="code" href="sqliteInt_8h.html#ab2b23e0c009e6f489e6fae4bc0f84ddf">OPFLAG_NCHANGE</a> ) p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a>++;
<a name="l03453"></a>03453   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> &amp; <a class="code" href="sqliteInt_8h.html#a8d4d2b610d66b579ce21b2f4b2b68e97">OPFLAG_LASTROWID</a> ) db-&gt;<a class="code" href="structsqlite3.html#a9fff52fc4eb087fbb3e3271994fa5198">lastRowid</a> = pKey-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l03454"></a>03454   <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a61c65a0cd36f85d13e9abdbebfe46e06">nextRowidValid</a> &amp;&amp; pKey-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>&gt;=pC-&gt;<a class="code" href="structVdbeCursor.html#a223d4a7f36b0548389efb23c3b23edbd">nextRowid</a> ){
<a name="l03455"></a>03455     pC-&gt;<a class="code" href="structVdbeCursor.html#a61c65a0cd36f85d13e9abdbebfe46e06">nextRowidValid</a> = 0;
<a name="l03456"></a>03456   }
<a name="l03457"></a>03457   <span class="keywordflow">if</span>( pData-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a> ){
<a name="l03458"></a>03458     pData-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> = 0;
<a name="l03459"></a>03459     pData-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = 0;
<a name="l03460"></a>03460   }<span class="keywordflow">else</span>{
<a name="l03461"></a>03461     assert( pData-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; (MEM_Blob|MEM_Str) );
<a name="l03462"></a>03462   }
<a name="l03463"></a>03463   <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a762de613989f39beaf12a05af896300a">pseudoTable</a> ){
<a name="l03464"></a>03464     <span class="keywordflow">if</span>( !pC-&gt;<a class="code" href="structVdbeCursor.html#a70576a23035c6f2aced72f2309e6f024">ephemPseudoTable</a> ){
<a name="l03465"></a>03465       <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pC-&gt;<a class="code" href="structVdbeCursor.html#a24a939339569b64ed386652955df6be7">pData</a>);
<a name="l03466"></a>03466     }
<a name="l03467"></a>03467     pC-&gt;<a class="code" href="structVdbeCursor.html#a512ffc273980f3371397ab6d1d055328">iKey</a> = iKey;
<a name="l03468"></a>03468     pC-&gt;<a class="code" href="structVdbeCursor.html#ae321ce63d59409703a48a48d82d24830">nData</a> = pData-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>;
<a name="l03469"></a>03469     <span class="keywordflow">if</span>( pData-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>==pData-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> || pC-&gt;<a class="code" href="structVdbeCursor.html#a70576a23035c6f2aced72f2309e6f024">ephemPseudoTable</a> ){
<a name="l03470"></a>03470       pC-&gt;<a class="code" href="structVdbeCursor.html#a24a939339569b64ed386652955df6be7">pData</a> = pData-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>;
<a name="l03471"></a>03471       <span class="keywordflow">if</span>( !pC-&gt;<a class="code" href="structVdbeCursor.html#a70576a23035c6f2aced72f2309e6f024">ephemPseudoTable</a> ){
<a name="l03472"></a>03472         pData-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp;= ~MEM_Dyn;
<a name="l03473"></a>03473         pData-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> |= MEM_Ephem;
<a name="l03474"></a>03474         pData-&gt;<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l03475"></a>03475       }
<a name="l03476"></a>03476     }<span class="keywordflow">else</span>{
<a name="l03477"></a>03477       pC-&gt;<a class="code" href="structVdbeCursor.html#a24a939339569b64ed386652955df6be7">pData</a> = <a class="code" href="malloc_8c.html#a8c1a33577a57524c7c6eef3d9e64e742">sqlite3Malloc</a>( pC-&gt;<a class="code" href="structVdbeCursor.html#ae321ce63d59409703a48a48d82d24830">nData</a>+2 );
<a name="l03478"></a>03478       <span class="keywordflow">if</span>( !pC-&gt;<a class="code" href="structVdbeCursor.html#a24a939339569b64ed386652955df6be7">pData</a> ) <span class="keywordflow">goto</span> no_mem;
<a name="l03479"></a>03479       memcpy(pC-&gt;<a class="code" href="structVdbeCursor.html#a24a939339569b64ed386652955df6be7">pData</a>, pData-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, pC-&gt;<a class="code" href="structVdbeCursor.html#ae321ce63d59409703a48a48d82d24830">nData</a>);
<a name="l03480"></a>03480       pC-&gt;<a class="code" href="structVdbeCursor.html#a24a939339569b64ed386652955df6be7">pData</a>[pC-&gt;<a class="code" href="structVdbeCursor.html#ae321ce63d59409703a48a48d82d24830">nData</a>] = 0;
<a name="l03481"></a>03481       pC-&gt;<a class="code" href="structVdbeCursor.html#a24a939339569b64ed386652955df6be7">pData</a>[pC-&gt;<a class="code" href="structVdbeCursor.html#ae321ce63d59409703a48a48d82d24830">nData</a>+1] = 0;
<a name="l03482"></a>03482     }
<a name="l03483"></a>03483     pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = 0;
<a name="l03484"></a>03484   }<span class="keywordflow">else</span>{
<a name="l03485"></a>03485     <span class="keywordtype">int</span> nZero;
<a name="l03486"></a>03486     <span class="keywordflow">if</span>( pData-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a9433e8fe887266736d2e795fe0b71fd3">MEM_Zero</a> ){
<a name="l03487"></a>03487       nZero = pData-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l03488"></a>03488     }<span class="keywordflow">else</span>{
<a name="l03489"></a>03489       nZero = 0;
<a name="l03490"></a>03490     }
<a name="l03491"></a>03491     rc = <a class="code" href="btree_8c.html#ac8350b4906a921dc24f69e4c14b202ff">sqlite3BtreeInsert</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, 0, iKey,
<a name="l03492"></a>03492                             pData-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>, pData-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>, nZero,
<a name="l03493"></a>03493                             pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> &amp; <a class="code" href="sqliteInt_8h.html#a2402d52d244d3dcbc0bb4d6a796194a0">OPFLAG_APPEND</a>);
<a name="l03494"></a>03494   }
<a name="l03495"></a>03495   
<a name="l03496"></a>03496   pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = 0;
<a name="l03497"></a>03497   pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a> = 0;
<a name="l03498"></a>03498   pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03499"></a>03499 
<a name="l03500"></a>03500   <span class="comment">/* Invoke the update-hook if required. */</span>
<a name="l03501"></a>03501   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; db-&gt;<a class="code" href="structsqlite3.html#a9177ce33e670ba38c97046e21482414a">xUpdateCallback</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a> ){
<a name="l03502"></a>03502     <span class="keyword">const</span> <span class="keywordtype">char</span> *zDb = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[pC-&gt;<a class="code" href="structVdbeCursor.html#a1215b7b0d1bbd882d6bfb8b118712d89">iDb</a>].<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>;
<a name="l03503"></a>03503     <span class="keyword">const</span> <span class="keywordtype">char</span> *zTbl = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>;
<a name="l03504"></a>03504     <span class="keywordtype">int</span> op = ((pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> &amp; <a class="code" href="sqliteInt_8h.html#ad5739cc164787601efa915c0bd0a8426">OPFLAG_ISUPDATE</a>) ? <a class="code" href="sqlite3_8h.html#abe5e121cf6a85525dae8c65cea7edd48">SQLITE_UPDATE</a> : <a class="code" href="sqlite3_8h.html#a0d32c3f24fcfd33411eecb1e4da64a40">SQLITE_INSERT</a>);
<a name="l03505"></a>03505     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> );
<a name="l03506"></a>03506     db-&gt;<a class="code" href="structsqlite3.html#a9177ce33e670ba38c97046e21482414a">xUpdateCallback</a>(db-&gt;<a class="code" href="structsqlite3.html#ab4269aa44fea9906fe94045336f13d2a">pUpdateArg</a>, op, zDb, zTbl, iKey);
<a name="l03507"></a>03507     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a1215b7b0d1bbd882d6bfb8b118712d89">iDb</a>&gt;=0 );
<a name="l03508"></a>03508   }
<a name="l03509"></a>03509   <span class="keywordflow">break</span>;
<a name="l03510"></a>03510 }
<a name="l03511"></a>03511 
<a name="l03512"></a>03512 <span class="comment">/* Opcode: Delete P1 P2 * P4 *</span>
<a name="l03513"></a>03513 <span class="comment">**</span>
<a name="l03514"></a>03514 <span class="comment">** Delete the record at which the P1 cursor is currently pointing.</span>
<a name="l03515"></a>03515 <span class="comment">**</span>
<a name="l03516"></a>03516 <span class="comment">** The cursor will be left pointing at either the next or the previous</span>
<a name="l03517"></a>03517 <span class="comment">** record in the table. If it is left pointing at the next record, then</span>
<a name="l03518"></a>03518 <span class="comment">** the next Next instruction will be a no-op.  Hence it is OK to delete</span>
<a name="l03519"></a>03519 <span class="comment">** a record from within an Next loop.</span>
<a name="l03520"></a>03520 <span class="comment">**</span>
<a name="l03521"></a>03521 <span class="comment">** If the OPFLAG_NCHANGE flag of P2 is set, then the row change count is</span>
<a name="l03522"></a>03522 <span class="comment">** incremented (otherwise not).</span>
<a name="l03523"></a>03523 <span class="comment">**</span>
<a name="l03524"></a>03524 <span class="comment">** P1 must not be pseudo-table.  It has to be a real table with</span>
<a name="l03525"></a>03525 <span class="comment">** multiple rows.</span>
<a name="l03526"></a>03526 <span class="comment">**</span>
<a name="l03527"></a>03527 <span class="comment">** If P4 is not NULL, then it is the name of the table that P1 is</span>
<a name="l03528"></a>03528 <span class="comment">** pointing to.  The update hook will be invoked, if it exists.</span>
<a name="l03529"></a>03529 <span class="comment">** If P4 is not NULL then the P1 cursor must have been positioned</span>
<a name="l03530"></a>03530 <span class="comment">** using OP_NotFound prior to invoking this opcode.</span>
<a name="l03531"></a>03531 <span class="comment">*/</span>
<a name="l03532"></a>03532 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3ddfc1d8b57d3d7c1031e36538cffc76">OP_Delete</a>: {
<a name="l03533"></a>03533   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03534"></a>03534   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> iKey;
<a name="l03535"></a>03535   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03536"></a>03536 
<a name="l03537"></a>03537   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03538"></a>03538   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l03539"></a>03539   assert( pC!=0 );
<a name="l03540"></a>03540   assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>!=0 );  <span class="comment">/* Only valid for real tables, no pseudotables */</span>
<a name="l03541"></a>03541 
<a name="l03542"></a>03542   <span class="comment">/* If the update-hook will be invoked, set iKey to the rowid of the</span>
<a name="l03543"></a>03543 <span class="comment">  ** row being deleted.</span>
<a name="l03544"></a>03544 <span class="comment">  */</span>
<a name="l03545"></a>03545   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a9177ce33e670ba38c97046e21482414a">xUpdateCallback</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a> ){
<a name="l03546"></a>03546     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> );
<a name="l03547"></a>03547     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> );  <span class="comment">/* lastRowid set by previous OP_NotFound */</span>
<a name="l03548"></a>03548     iKey = pC-&gt;<a class="code" href="structVdbeCursor.html#af2ff971acc308c012c60b1e949c64411">lastRowid</a>;
<a name="l03549"></a>03549   }
<a name="l03550"></a>03550 
<a name="l03551"></a>03551   rc = <a class="code" href="vdbeaux_8c.html#a0e6c6ab44bba69b7b9d4e5b8c461dfe2">sqlite3VdbeCursorMoveto</a>(pC);
<a name="l03552"></a>03552   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03553"></a>03553   rc = <a class="code" href="btree_8c.html#af7b69d3ad801b9277863e15be6639a72">sqlite3BtreeDelete</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>);
<a name="l03554"></a>03554   pC-&gt;<a class="code" href="structVdbeCursor.html#a61c65a0cd36f85d13e9abdbebfe46e06">nextRowidValid</a> = 0;
<a name="l03555"></a>03555   pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03556"></a>03556 
<a name="l03557"></a>03557   <span class="comment">/* Invoke the update-hook if required. */</span>
<a name="l03558"></a>03558   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; db-&gt;<a class="code" href="structsqlite3.html#a9177ce33e670ba38c97046e21482414a">xUpdateCallback</a> &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a> ){
<a name="l03559"></a>03559     <span class="keyword">const</span> <span class="keywordtype">char</span> *zDb = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[pC-&gt;<a class="code" href="structVdbeCursor.html#a1215b7b0d1bbd882d6bfb8b118712d89">iDb</a>].<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>;
<a name="l03560"></a>03560     <span class="keyword">const</span> <span class="keywordtype">char</span> *zTbl = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>;
<a name="l03561"></a>03561     db-&gt;<a class="code" href="structsqlite3.html#a9177ce33e670ba38c97046e21482414a">xUpdateCallback</a>(db-&gt;<a class="code" href="structsqlite3.html#ab4269aa44fea9906fe94045336f13d2a">pUpdateArg</a>, <a class="code" href="sqlite3_8h.html#ad68e72e7bbe70d79e4ca2016455cdf8d">SQLITE_DELETE</a>, zDb, zTbl, iKey);
<a name="l03562"></a>03562     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a1215b7b0d1bbd882d6bfb8b118712d89">iDb</a>&gt;=0 );
<a name="l03563"></a>03563   }
<a name="l03564"></a>03564   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> &amp; <a class="code" href="sqliteInt_8h.html#ab2b23e0c009e6f489e6fae4bc0f84ddf">OPFLAG_NCHANGE</a> ) p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a>++;
<a name="l03565"></a>03565   <span class="keywordflow">break</span>;
<a name="l03566"></a>03566 }
<a name="l03567"></a>03567 
<a name="l03568"></a>03568 <span class="comment">/* Opcode: ResetCount P1 * *</span>
<a name="l03569"></a>03569 <span class="comment">**</span>
<a name="l03570"></a>03570 <span class="comment">** This opcode resets the VMs internal change counter to 0. If P1 is true,</span>
<a name="l03571"></a>03571 <span class="comment">** then the value of the change counter is copied to the database handle</span>
<a name="l03572"></a>03572 <span class="comment">** change counter (returned by subsequent calls to sqlite3_changes())</span>
<a name="l03573"></a>03573 <span class="comment">** before it is reset. This is used by trigger programs.</span>
<a name="l03574"></a>03574 <span class="comment">*/</span>
<a name="l03575"></a>03575 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a5b4df0de7fac8429c759850234aa1192">OP_ResetCount</a>: {
<a name="l03576"></a>03576   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> ){
<a name="l03577"></a>03577     <a class="code" href="sqliteInt_8h.html#a20b9440f5f5fde83614215876ac0e13a">sqlite3VdbeSetChanges</a>(db, p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a>);
<a name="l03578"></a>03578   }
<a name="l03579"></a>03579   p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a> = 0;
<a name="l03580"></a>03580   <span class="keywordflow">break</span>;
<a name="l03581"></a>03581 }
<a name="l03582"></a>03582 
<a name="l03583"></a>03583 <span class="comment">/* Opcode: RowData P1 P2 * * *</span>
<a name="l03584"></a>03584 <span class="comment">**</span>
<a name="l03585"></a>03585 <span class="comment">** Write into register P2 the complete row data for cursor P1.</span>
<a name="l03586"></a>03586 <span class="comment">** There is no interpretation of the data.  </span>
<a name="l03587"></a>03587 <span class="comment">** It is just copied onto the P2 register exactly as </span>
<a name="l03588"></a>03588 <span class="comment">** it is found in the database file.</span>
<a name="l03589"></a>03589 <span class="comment">**</span>
<a name="l03590"></a>03590 <span class="comment">** If the P1 cursor must be pointing to a valid row (not a NULL row)</span>
<a name="l03591"></a>03591 <span class="comment">** of a real table, not a pseudo-table.</span>
<a name="l03592"></a>03592 <span class="comment">*/</span>
<a name="l03593"></a>03593 <span class="comment">/* Opcode: RowKey P1 P2 * * *</span>
<a name="l03594"></a>03594 <span class="comment">**</span>
<a name="l03595"></a>03595 <span class="comment">** Write into register P2 the complete row key for cursor P1.</span>
<a name="l03596"></a>03596 <span class="comment">** There is no interpretation of the data.  </span>
<a name="l03597"></a>03597 <span class="comment">** The key is copied onto the P3 register exactly as </span>
<a name="l03598"></a>03598 <span class="comment">** it is found in the database file.</span>
<a name="l03599"></a>03599 <span class="comment">**</span>
<a name="l03600"></a>03600 <span class="comment">** If the P1 cursor must be pointing to a valid row (not a NULL row)</span>
<a name="l03601"></a>03601 <span class="comment">** of a real table, not a pseudo-table.</span>
<a name="l03602"></a>03602 <span class="comment">*/</span>
<a name="l03603"></a>03603 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ac1f5032a0dca76f4035f5b5fb993c6a6">OP_RowKey</a>:
<a name="l03604"></a>03604 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a0b79ef76a9edf3c8132fa4cb96d842ef">OP_RowData</a>: {
<a name="l03605"></a>03605   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03606"></a>03606   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03607"></a>03607   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;
<a name="l03608"></a>03608   <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> n;
<a name="l03609"></a>03609 
<a name="l03610"></a>03610   pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l03611"></a>03611 
<a name="l03612"></a>03612   <span class="comment">/* Note that RowKey and RowData are really exactly the same instruction */</span>
<a name="l03613"></a>03613   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03614"></a>03614   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l03615"></a>03615   assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> || pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#ac1f5032a0dca76f4035f5b5fb993c6a6">OP_RowKey</a> );
<a name="l03616"></a>03616   assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> || pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#a0b79ef76a9edf3c8132fa4cb96d842ef">OP_RowData</a> );
<a name="l03617"></a>03617   assert( pC!=0 );
<a name="l03618"></a>03618   assert( pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a>==0 );
<a name="l03619"></a>03619   assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a762de613989f39beaf12a05af896300a">pseudoTable</a>==0 );
<a name="l03620"></a>03620   assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>!=0 );
<a name="l03621"></a>03621   pCrsr = pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>;
<a name="l03622"></a>03622   rc = <a class="code" href="vdbeaux_8c.html#a0e6c6ab44bba69b7b9d4e5b8c461dfe2">sqlite3VdbeCursorMoveto</a>(pC);
<a name="l03623"></a>03623   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03624"></a>03624   <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> ){
<a name="l03625"></a>03625     <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> n64;
<a name="l03626"></a>03626     assert( !pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a> );
<a name="l03627"></a>03627     <a class="code" href="btree_8c.html#a2d5023d925e7eade74a33a94fbbc45e0">sqlite3BtreeKeySize</a>(pCrsr, &amp;n64);
<a name="l03628"></a>03628     <span class="keywordflow">if</span>( n64&gt;db-&gt;<a class="code" href="structsqlite3.html#ad8acf663e1619905094c9dfe4125157b">aLimit</a>[<a class="code" href="sqlite3_8h.html#aeba56345f14b7febdafaaa4bc3949245">SQLITE_LIMIT_LENGTH</a>] ){
<a name="l03629"></a>03629       <span class="keywordflow">goto</span> too_big;
<a name="l03630"></a>03630     }
<a name="l03631"></a>03631     n = n64;
<a name="l03632"></a>03632   }<span class="keywordflow">else</span>{
<a name="l03633"></a>03633     <a class="code" href="btree_8c.html#a8c49974ebd7131c7789e3bdb7fd41c96">sqlite3BtreeDataSize</a>(pCrsr, &amp;n);
<a name="l03634"></a>03634     <span class="keywordflow">if</span>( n&gt;db-&gt;<a class="code" href="structsqlite3.html#ad8acf663e1619905094c9dfe4125157b">aLimit</a>[<a class="code" href="sqlite3_8h.html#aeba56345f14b7febdafaaa4bc3949245">SQLITE_LIMIT_LENGTH</a>] ){
<a name="l03635"></a>03635       <span class="keywordflow">goto</span> too_big;
<a name="l03636"></a>03636     }
<a name="l03637"></a>03637   }
<a name="l03638"></a>03638   <span class="keywordflow">if</span>( <a class="code" href="vdbeInt_8h.html#ac934bc728baa7b73867a62722c30d311">sqlite3VdbeMemGrow</a>(pOut, n, 0) ){
<a name="l03639"></a>03639     <span class="keywordflow">goto</span> no_mem;
<a name="l03640"></a>03640   }
<a name="l03641"></a>03641   pOut-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a> = n;
<a name="l03642"></a>03642   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, MEM_Blob);
<a name="l03643"></a>03643   <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a60a947acdb24b640fe0ff6112d0ae104">isIndex</a> ){
<a name="l03644"></a>03644     rc = <a class="code" href="btree_8c.html#aed214bf6f1ee501ac77d819ef9fe12ee">sqlite3BtreeKey</a>(pCrsr, 0, n, pOut-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>);
<a name="l03645"></a>03645   }<span class="keywordflow">else</span>{
<a name="l03646"></a>03646     rc = <a class="code" href="btree_8c.html#a173bbb37f94d673235e12e2ae3ba8d41">sqlite3BtreeData</a>(pCrsr, 0, n, pOut-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>);
<a name="l03647"></a>03647   }
<a name="l03648"></a>03648   pOut-&gt;<a class="code" href="structMem.html#af437c99e92b8e729b70f82fa94e96bff">enc</a> = <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>;  <span class="comment">/* In case the blob is ever cast to text */</span>
<a name="l03649"></a>03649   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pOut);
<a name="l03650"></a>03650   <span class="keywordflow">break</span>;
<a name="l03651"></a>03651 }
<a name="l03652"></a>03652 
<a name="l03653"></a>03653 <span class="comment">/* Opcode: Rowid P1 P2 * * *</span>
<a name="l03654"></a>03654 <span class="comment">**</span>
<a name="l03655"></a>03655 <span class="comment">** Store in register P2 an integer which is the key of the table entry that</span>
<a name="l03656"></a>03656 <span class="comment">** P1 is currently point to.</span>
<a name="l03657"></a>03657 <span class="comment">*/</span>
<a name="l03658"></a>03658 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a5a05393545770c35a6071b83679e6be7">OP_Rowid</a>: {                 <span class="comment">/* out2-prerelease */</span>
<a name="l03659"></a>03659   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03660"></a>03660   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03661"></a>03661   <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> v;
<a name="l03662"></a>03662 
<a name="l03663"></a>03663   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03664"></a>03664   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l03665"></a>03665   assert( pC!=0 );
<a name="l03666"></a>03666   rc = <a class="code" href="vdbeaux_8c.html#a0e6c6ab44bba69b7b9d4e5b8c461dfe2">sqlite3VdbeCursorMoveto</a>(pC);
<a name="l03667"></a>03667   <span class="keywordflow">if</span>( rc ) <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03668"></a>03668   <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> ){
<a name="l03669"></a>03669     v = pC-&gt;<a class="code" href="structVdbeCursor.html#af2ff971acc308c012c60b1e949c64411">lastRowid</a>;
<a name="l03670"></a>03670   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a762de613989f39beaf12a05af896300a">pseudoTable</a> ){
<a name="l03671"></a>03671     v = <a class="code" href="vdbeInt_8h.html#a0d7ab028a08884fcdd3a349d8d319e1b">keyToInt</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a512ffc273980f3371397ab6d1d055328">iKey</a>);
<a name="l03672"></a>03672   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> ){
<a name="l03673"></a>03673     <span class="comment">/* Leave the rowid set to a NULL */</span>
<a name="l03674"></a>03674     <span class="keywordflow">break</span>;
<a name="l03675"></a>03675   }<span class="keywordflow">else</span>{
<a name="l03676"></a>03676     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>!=0 );
<a name="l03677"></a>03677     <a class="code" href="btree_8c.html#a2d5023d925e7eade74a33a94fbbc45e0">sqlite3BtreeKeySize</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>, &amp;v);
<a name="l03678"></a>03678     v = <a class="code" href="vdbeInt_8h.html#a0d7ab028a08884fcdd3a349d8d319e1b">keyToInt</a>(v);
<a name="l03679"></a>03679   }
<a name="l03680"></a>03680   pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = v;
<a name="l03681"></a>03681   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l03682"></a>03682   <span class="keywordflow">break</span>;
<a name="l03683"></a>03683 }
<a name="l03684"></a>03684 
<a name="l03685"></a>03685 <span class="comment">/* Opcode: NullRow P1 * * * *</span>
<a name="l03686"></a>03686 <span class="comment">**</span>
<a name="l03687"></a>03687 <span class="comment">** Move the cursor P1 to a null row.  Any OP_Column operations</span>
<a name="l03688"></a>03688 <span class="comment">** that occur while the cursor is on the null row will always</span>
<a name="l03689"></a>03689 <span class="comment">** write a NULL.</span>
<a name="l03690"></a>03690 <span class="comment">*/</span>
<a name="l03691"></a>03691 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a8436c9b66cd27597a1ddd5c5b05d4baf">OP_NullRow</a>: {
<a name="l03692"></a>03692   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03693"></a>03693   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03694"></a>03694 
<a name="l03695"></a>03695   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03696"></a>03696   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l03697"></a>03697   assert( pC!=0 );
<a name="l03698"></a>03698   pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = 1;
<a name="l03699"></a>03699   pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = 0;
<a name="l03700"></a>03700   <span class="keywordflow">if</span>( pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a> ){
<a name="l03701"></a>03701     <a class="code" href="btree_8c.html#a1b4b9b532ff7779a50f6482c723b3b50">sqlite3BtreeClearCursor</a>(pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>);
<a name="l03702"></a>03702   }
<a name="l03703"></a>03703   <span class="keywordflow">break</span>;
<a name="l03704"></a>03704 }
<a name="l03705"></a>03705 
<a name="l03706"></a>03706 <span class="comment">/* Opcode: Last P1 P2 * * *</span>
<a name="l03707"></a>03707 <span class="comment">**</span>
<a name="l03708"></a>03708 <span class="comment">** The next use of the Rowid or Column or Next instruction for P1 </span>
<a name="l03709"></a>03709 <span class="comment">** will refer to the last entry in the database table or index.</span>
<a name="l03710"></a>03710 <span class="comment">** If the table or index is empty and P2&gt;0, then jump immediately to P2.</span>
<a name="l03711"></a>03711 <span class="comment">** If P2 is 0 or if the table or index is not empty, fall through</span>
<a name="l03712"></a>03712 <span class="comment">** to the following instruction.</span>
<a name="l03713"></a>03713 <span class="comment">*/</span>
<a name="l03714"></a>03714 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a82f28b02bb768fdd0d4035a89cf976a7">OP_Last</a>: {        <span class="comment">/* jump */</span>
<a name="l03715"></a>03715   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03716"></a>03716   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03717"></a>03717   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;
<a name="l03718"></a>03718   <span class="keywordtype">int</span> res;
<a name="l03719"></a>03719 
<a name="l03720"></a>03720   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03721"></a>03721   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l03722"></a>03722   assert( pC!=0 );
<a name="l03723"></a>03723   pCrsr = pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>;
<a name="l03724"></a>03724   assert( pCrsr!=0 );
<a name="l03725"></a>03725   rc = <a class="code" href="btree_8c.html#af4c43ac2d9ebc3f08a8fc2bbb181787b">sqlite3BtreeLast</a>(pCrsr, &amp;res);
<a name="l03726"></a>03726   pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = res;
<a name="l03727"></a>03727   pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a> = 0;
<a name="l03728"></a>03728   pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03729"></a>03729   <span class="keywordflow">if</span>( res &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 ){
<a name="l03730"></a>03730     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03731"></a>03731   }
<a name="l03732"></a>03732   <span class="keywordflow">break</span>;
<a name="l03733"></a>03733 }
<a name="l03734"></a>03734 
<a name="l03735"></a>03735 
<a name="l03736"></a>03736 <span class="comment">/* Opcode: Sort P1 P2 * * *</span>
<a name="l03737"></a>03737 <span class="comment">**</span>
<a name="l03738"></a>03738 <span class="comment">** This opcode does exactly the same thing as OP_Rewind except that</span>
<a name="l03739"></a>03739 <span class="comment">** it increments an undocumented global variable used for testing.</span>
<a name="l03740"></a>03740 <span class="comment">**</span>
<a name="l03741"></a>03741 <span class="comment">** Sorting is accomplished by writing records into a sorting index,</span>
<a name="l03742"></a>03742 <span class="comment">** then rewinding that index and playing it back from beginning to</span>
<a name="l03743"></a>03743 <span class="comment">** end.  We use the OP_Sort opcode instead of OP_Rewind to do the</span>
<a name="l03744"></a>03744 <span class="comment">** rewinding so that the global variable will be incremented and</span>
<a name="l03745"></a>03745 <span class="comment">** regression tests can determine whether or not the optimizer is</span>
<a name="l03746"></a>03746 <span class="comment">** correctly optimizing out sorts.</span>
<a name="l03747"></a>03747 <span class="comment">*/</span>
<a name="l03748"></a>03748 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ac14882b8b45b0b02087d19aa96f9029d">OP_Sort</a>: {        <span class="comment">/* jump */</span>
<a name="l03749"></a>03749 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l03750"></a>03750 <span class="preprocessor"></span>  sqlite3_sort_count++;
<a name="l03751"></a>03751   sqlite3_search_count--;
<a name="l03752"></a>03752 <span class="preprocessor">#endif</span>
<a name="l03753"></a>03753 <span class="preprocessor"></span>  p-&gt;<a class="code" href="structVdbe.html#a0b004ab552ad92159afcfad1a8b6237d">aCounter</a>[<a class="code" href="sqlite3_8h.html#a4238439563e9849daae4d9b54cadde3a">SQLITE_STMTSTATUS_SORT</a>-1]++;
<a name="l03754"></a>03754   <span class="comment">/* Fall through into OP_Rewind */</span>
<a name="l03755"></a>03755 }
<a name="l03756"></a>03756 <span class="comment">/* Opcode: Rewind P1 P2 * * *</span>
<a name="l03757"></a>03757 <span class="comment">**</span>
<a name="l03758"></a>03758 <span class="comment">** The next use of the Rowid or Column or Next instruction for P1 </span>
<a name="l03759"></a>03759 <span class="comment">** will refer to the first entry in the database table or index.</span>
<a name="l03760"></a>03760 <span class="comment">** If the table or index is empty and P2&gt;0, then jump immediately to P2.</span>
<a name="l03761"></a>03761 <span class="comment">** If P2 is 0 or if the table or index is not empty, fall through</span>
<a name="l03762"></a>03762 <span class="comment">** to the following instruction.</span>
<a name="l03763"></a>03763 <span class="comment">*/</span>
<a name="l03764"></a>03764 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a28fb38e44ff4ec2b00eeccac19c44c60">OP_Rewind</a>: {        <span class="comment">/* jump */</span>
<a name="l03765"></a>03765   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03766"></a>03766   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03767"></a>03767   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;
<a name="l03768"></a>03768   <span class="keywordtype">int</span> res;
<a name="l03769"></a>03769 
<a name="l03770"></a>03770   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03771"></a>03771   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i];
<a name="l03772"></a>03772   assert( pC!=0 );
<a name="l03773"></a>03773   <span class="keywordflow">if</span>( (pCrsr = pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>)!=0 ){
<a name="l03774"></a>03774     rc = <a class="code" href="btree_8c.html#a035892f63f56d5ac4ebe289d51cb0b9a">sqlite3BtreeFirst</a>(pCrsr, &amp;res);
<a name="l03775"></a>03775     pC-&gt;<a class="code" href="structVdbeCursor.html#a00d121ca0f21e7381aacb89adf40e8b6">atFirst</a> = res==0;
<a name="l03776"></a>03776     pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a> = 0;
<a name="l03777"></a>03777     pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03778"></a>03778   }<span class="keywordflow">else</span>{
<a name="l03779"></a>03779     res = 1;
<a name="l03780"></a>03780   }
<a name="l03781"></a>03781   pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = res;
<a name="l03782"></a>03782   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&lt;p-&gt;<a class="code" href="structVdbe.html#a81e72e6812c71e13651f81cc3a6ca1d0">nOp</a> );
<a name="l03783"></a>03783   <span class="keywordflow">if</span>( res ){
<a name="l03784"></a>03784     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03785"></a>03785   }
<a name="l03786"></a>03786   <span class="keywordflow">break</span>;
<a name="l03787"></a>03787 }
<a name="l03788"></a>03788 
<a name="l03789"></a>03789 <span class="comment">/* Opcode: Next P1 P2 * * *</span>
<a name="l03790"></a>03790 <span class="comment">**</span>
<a name="l03791"></a>03791 <span class="comment">** Advance cursor P1 so that it points to the next key/data pair in its</span>
<a name="l03792"></a>03792 <span class="comment">** table or index.  If there are no more key/value pairs then fall through</span>
<a name="l03793"></a>03793 <span class="comment">** to the following instruction.  But if the cursor advance was successful,</span>
<a name="l03794"></a>03794 <span class="comment">** jump immediately to P2.</span>
<a name="l03795"></a>03795 <span class="comment">**</span>
<a name="l03796"></a>03796 <span class="comment">** The P1 cursor must be for a real table, not a pseudo-table.</span>
<a name="l03797"></a>03797 <span class="comment">**</span>
<a name="l03798"></a>03798 <span class="comment">** See also: Prev</span>
<a name="l03799"></a>03799 <span class="comment">*/</span>
<a name="l03800"></a>03800 <span class="comment">/* Opcode: Prev P1 P2 * * *</span>
<a name="l03801"></a>03801 <span class="comment">**</span>
<a name="l03802"></a>03802 <span class="comment">** Back up cursor P1 so that it points to the previous key/data pair in its</span>
<a name="l03803"></a>03803 <span class="comment">** table or index.  If there is no previous key/value pairs then fall through</span>
<a name="l03804"></a>03804 <span class="comment">** to the following instruction.  But if the cursor backup was successful,</span>
<a name="l03805"></a>03805 <span class="comment">** jump immediately to P2.</span>
<a name="l03806"></a>03806 <span class="comment">**</span>
<a name="l03807"></a>03807 <span class="comment">** The P1 cursor must be for a real table, not a pseudo-table.</span>
<a name="l03808"></a>03808 <span class="comment">*/</span>
<a name="l03809"></a>03809 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ac0b6604f9f9a15223fa7323d090a5a18">OP_Prev</a>:          <span class="comment">/* jump */</span>
<a name="l03810"></a>03810 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a>: {        <span class="comment">/* jump */</span>
<a name="l03811"></a>03811   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03812"></a>03812   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;
<a name="l03813"></a>03813   <span class="keywordtype">int</span> res;
<a name="l03814"></a>03814 
<a name="l03815"></a>03815   <a class="code" href="vdbe_8c.html#ac7ee506756b15c8b7da860830e1393af">CHECK_FOR_INTERRUPT</a>;
<a name="l03816"></a>03816   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;=0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;p-&gt;<a class="code" href="structVdbe.html#aa12a6a1075311bd5d89bc69eaefc6351">nCursor</a> );
<a name="l03817"></a>03817   pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l03818"></a>03818   <span class="keywordflow">if</span>( pC==0 ){
<a name="l03819"></a>03819     <span class="keywordflow">break</span>;  <span class="comment">/* See ticket #2273 */</span>
<a name="l03820"></a>03820   }
<a name="l03821"></a>03821   pCrsr = pC-&gt;<a class="code" href="structVdbeCursor.html#a9ecb4ab9f7374f92da69f03fc336c293">pCursor</a>;
<a name="l03822"></a>03822   assert( pCrsr );
<a name="l03823"></a>03823   res = 1;
<a name="l03824"></a>03824   assert( pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a>==0 );
<a name="l03825"></a>03825   rc = pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#adf8e031febcce68f636485a794500718">OP_Next</a> ? <a class="code" href="btree_8c.html#adf99ca89adc2e91557a41d6d11e97039">sqlite3BtreeNext</a>(pCrsr, &amp;res) :
<a name="l03826"></a>03826                               <a class="code" href="btree_8c.html#af84d1157958331e8d900f0800409f60b">sqlite3BtreePrevious</a>(pCrsr, &amp;res);
<a name="l03827"></a>03827   pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = res;
<a name="l03828"></a>03828   pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03829"></a>03829   <span class="keywordflow">if</span>( res==0 ){
<a name="l03830"></a>03830     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l03831"></a>03831     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> ) p-&gt;<a class="code" href="structVdbe.html#a0b004ab552ad92159afcfad1a8b6237d">aCounter</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>-1]++;
<a name="l03832"></a>03832 <span class="preprocessor">#ifdef SQLITE_TEST</span>
<a name="l03833"></a>03833 <span class="preprocessor"></span>    sqlite3_search_count++;
<a name="l03834"></a>03834 <span class="preprocessor">#endif</span>
<a name="l03835"></a>03835 <span class="preprocessor"></span>  }
<a name="l03836"></a>03836   pC-&gt;<a class="code" href="structVdbeCursor.html#a2dabf623f6e3c31aa8310c72ec1843bf">rowidIsValid</a> = 0;
<a name="l03837"></a>03837   <span class="keywordflow">break</span>;
<a name="l03838"></a>03838 }
<a name="l03839"></a>03839 
<a name="l03840"></a>03840 <span class="comment">/* Opcode: IdxInsert P1 P2 P3 * *</span>
<a name="l03841"></a>03841 <span class="comment">**</span>
<a name="l03842"></a>03842 <span class="comment">** Register P2 holds a SQL index key made using the</span>
<a name="l03843"></a>03843 <span class="comment">** MakeIdxRec instructions.  This opcode writes that key</span>
<a name="l03844"></a>03844 <span class="comment">** into the index P1.  Data for the entry is nil.</span>
<a name="l03845"></a>03845 <span class="comment">**</span>
<a name="l03846"></a>03846 <span class="comment">** P3 is a flag that provides a hint to the b-tree layer that this</span>
<a name="l03847"></a>03847 <span class="comment">** insert is likely to be an append.</span>
<a name="l03848"></a>03848 <span class="comment">**</span>
<a name="l03849"></a>03849 <span class="comment">** This instruction only works for indices.  The equivalent instruction</span>
<a name="l03850"></a>03850 <span class="comment">** for tables is OP_Insert.</span>
<a name="l03851"></a>03851 <span class="comment">*/</span>
<a name="l03852"></a>03852 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a8459d42180c78f800cee8d98dc8fe3ea">OP_IdxInsert</a>: {        <span class="comment">/* in2 */</span>
<a name="l03853"></a>03853   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03854"></a>03854   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03855"></a>03855   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;
<a name="l03856"></a>03856   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03857"></a>03857   assert( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]!=0 );
<a name="l03858"></a>03858   assert( pIn2-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; MEM_Blob );
<a name="l03859"></a>03859   <span class="keywordflow">if</span>( (pCrsr = (pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i])-&gt;pCursor)!=0 ){
<a name="l03860"></a>03860     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a>==0 );
<a name="l03861"></a>03861     rc = <a class="code" href="vdbe_8c.html#a69b8bf9ca78e4cf90c8553b34e2ad336">ExpandBlob</a>(pIn2);
<a name="l03862"></a>03862     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03863"></a>03863       <span class="keywordtype">int</span> nKey = pIn2-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>;
<a name="l03864"></a>03864       <span class="keyword">const</span> <span class="keywordtype">char</span> *zKey = pIn2-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>;
<a name="l03865"></a>03865       rc = <a class="code" href="btree_8c.html#ac8350b4906a921dc24f69e4c14b202ff">sqlite3BtreeInsert</a>(pCrsr, zKey, nKey, <span class="stringliteral">&quot;&quot;</span>, 0, 0, pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>);
<a name="l03866"></a>03866       assert( pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a>==0 );
<a name="l03867"></a>03867       pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03868"></a>03868     }
<a name="l03869"></a>03869   }
<a name="l03870"></a>03870   <span class="keywordflow">break</span>;
<a name="l03871"></a>03871 }
<a name="l03872"></a>03872 
<a name="l03873"></a>03873 <span class="comment">/* Opcode: IdxDelete P1 P2 P3 * *</span>
<a name="l03874"></a>03874 <span class="comment">**</span>
<a name="l03875"></a>03875 <span class="comment">** The content of P3 registers starting at register P2 form</span>
<a name="l03876"></a>03876 <span class="comment">** an unpacked index key. This opcode removes that entry from the </span>
<a name="l03877"></a>03877 <span class="comment">** index opened by cursor P1.</span>
<a name="l03878"></a>03878 <span class="comment">*/</span>
<a name="l03879"></a>03879 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a9e469db61bb15b081bd369bcb362558e">OP_IdxDelete</a>: {
<a name="l03880"></a>03880   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03881"></a>03881   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03882"></a>03882   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;
<a name="l03883"></a>03883   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 );
<a name="l03884"></a>03884   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>+pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l03885"></a>03885   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03886"></a>03886   assert( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]!=0 );
<a name="l03887"></a>03887   <span class="keywordflow">if</span>( (pCrsr = (pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i])-&gt;pCursor)!=0 ){
<a name="l03888"></a>03888     <span class="keywordtype">int</span> res;
<a name="l03889"></a>03889     <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> r;
<a name="l03890"></a>03890     r.<a class="code" href="structUnpackedRecord.html#aeb43e7a1e300857cab2cbe98eacd575b">pKeyInfo</a> = pC-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a>;
<a name="l03891"></a>03891     r.<a class="code" href="structUnpackedRecord.html#a2c5062735cdbc5039679d255cc900668">nField</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;
<a name="l03892"></a>03892     r.<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> = 0;
<a name="l03893"></a>03893     r.<a class="code" href="structUnpackedRecord.html#a3299c322ceb8b758dacc59701021ae9f">aMem</a> = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l03894"></a>03894     rc = <a class="code" href="btree_8c.html#a66c22a67309882d7dca3abf10ea22c97">sqlite3BtreeMovetoUnpacked</a>(pCrsr, &amp;r, 0, 0, &amp;res);
<a name="l03895"></a>03895     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; res==0 ){
<a name="l03896"></a>03896       rc = <a class="code" href="btree_8c.html#af7b69d3ad801b9277863e15be6639a72">sqlite3BtreeDelete</a>(pCrsr);
<a name="l03897"></a>03897     }
<a name="l03898"></a>03898     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a>==0 );
<a name="l03899"></a>03899     pC-&gt;<a class="code" href="structVdbeCursor.html#a68c2c0945d5922ca8d9bcb790276df44">cacheStatus</a> = <a class="code" href="vdbeInt_8h.html#ab56aaec86079165a0999d4c37616cef1">CACHE_STALE</a>;
<a name="l03900"></a>03900   }
<a name="l03901"></a>03901   <span class="keywordflow">break</span>;
<a name="l03902"></a>03902 }
<a name="l03903"></a>03903 
<a name="l03904"></a>03904 <span class="comment">/* Opcode: IdxRowid P1 P2 * * *</span>
<a name="l03905"></a>03905 <span class="comment">**</span>
<a name="l03906"></a>03906 <span class="comment">** Write into register P2 an integer which is the last entry in the record at</span>
<a name="l03907"></a>03907 <span class="comment">** the end of the index key pointed to by cursor P1.  This integer should be</span>
<a name="l03908"></a>03908 <span class="comment">** the rowid of the table entry to which this index entry points.</span>
<a name="l03909"></a>03909 <span class="comment">**</span>
<a name="l03910"></a>03910 <span class="comment">** See also: Rowid, MakeIdxRec.</span>
<a name="l03911"></a>03911 <span class="comment">*/</span>
<a name="l03912"></a>03912 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a372ae42237bb1c3a693f057d84e3aa5b">OP_IdxRowid</a>: {              <span class="comment">/* out2-prerelease */</span>
<a name="l03913"></a>03913   <span class="keywordtype">int</span> i = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03914"></a>03914   <a class="code" href="structBtCursor.html">BtCursor</a> *pCrsr;
<a name="l03915"></a>03915   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03916"></a>03916 
<a name="l03917"></a>03917   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03918"></a>03918   assert( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]!=0 );
<a name="l03919"></a>03919   <span class="keywordflow">if</span>( (pCrsr = (pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i])-&gt;pCursor)!=0 ){
<a name="l03920"></a>03920     <a class="code" href="sqliteInt_8h.html#a2a0f0f4ae7001eb54351f77ea1cdbcfd">i64</a> rowid;
<a name="l03921"></a>03921 
<a name="l03922"></a>03922     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a>==0 );
<a name="l03923"></a>03923     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#a2c9ae9907e6649324d65d8cbd889806e">isTable</a>==0 );
<a name="l03924"></a>03924     <span class="keywordflow">if</span>( !pC-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> ){
<a name="l03925"></a>03925       rc = <a class="code" href="vdbeaux_8c.html#ad5f1e2b1c24e382e4c64868bd2c8f707">sqlite3VdbeIdxRowid</a>(pCrsr, &amp;rowid);
<a name="l03926"></a>03926       <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l03927"></a>03927         <span class="keywordflow">goto</span> abort_due_to_error;
<a name="l03928"></a>03928       }
<a name="l03929"></a>03929       <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l03930"></a>03930       pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = rowid;
<a name="l03931"></a>03931     }
<a name="l03932"></a>03932   }
<a name="l03933"></a>03933   <span class="keywordflow">break</span>;
<a name="l03934"></a>03934 }
<a name="l03935"></a>03935 
<a name="l03936"></a>03936 <span class="comment">/* Opcode: IdxGE P1 P2 P3 P4 P5</span>
<a name="l03937"></a>03937 <span class="comment">**</span>
<a name="l03938"></a>03938 <span class="comment">** The P4 register values beginning with P3 form an unpacked index </span>
<a name="l03939"></a>03939 <span class="comment">** key that omits the ROWID.  Compare this key value against the index </span>
<a name="l03940"></a>03940 <span class="comment">** that P1 is currently pointing to, ignoring the ROWID on the P1 index.</span>
<a name="l03941"></a>03941 <span class="comment">**</span>
<a name="l03942"></a>03942 <span class="comment">** If the P1 index entry is greater than or equal to the key value</span>
<a name="l03943"></a>03943 <span class="comment">** then jump to P2.  Otherwise fall through to the next instruction.</span>
<a name="l03944"></a>03944 <span class="comment">**</span>
<a name="l03945"></a>03945 <span class="comment">** If P5 is non-zero then the key value is increased by an epsilon </span>
<a name="l03946"></a>03946 <span class="comment">** prior to the comparison.  This make the opcode work like IdxGT except</span>
<a name="l03947"></a>03947 <span class="comment">** that if the key from register P3 is a prefix of the key in the cursor,</span>
<a name="l03948"></a>03948 <span class="comment">** the result is false whereas it would be true with IdxGT.</span>
<a name="l03949"></a>03949 <span class="comment">*/</span>
<a name="l03950"></a>03950 <span class="comment">/* Opcode: IdxLT P1 P2 P3 * P5</span>
<a name="l03951"></a>03951 <span class="comment">**</span>
<a name="l03952"></a>03952 <span class="comment">** The P4 register values beginning with P3 form an unpacked index </span>
<a name="l03953"></a>03953 <span class="comment">** key that omits the ROWID.  Compare this key value against the index </span>
<a name="l03954"></a>03954 <span class="comment">** that P1 is currently pointing to, ignoring the ROWID on the P1 index.</span>
<a name="l03955"></a>03955 <span class="comment">**</span>
<a name="l03956"></a>03956 <span class="comment">** If the P1 index entry is less than the key value then jump to P2.</span>
<a name="l03957"></a>03957 <span class="comment">** Otherwise fall through to the next instruction.</span>
<a name="l03958"></a>03958 <span class="comment">**</span>
<a name="l03959"></a>03959 <span class="comment">** If P5 is non-zero then the key value is increased by an epsilon prior </span>
<a name="l03960"></a>03960 <span class="comment">** to the comparison.  This makes the opcode work like IdxLE.</span>
<a name="l03961"></a>03961 <span class="comment">*/</span>
<a name="l03962"></a>03962 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ac021e76deac29fea2fa6abcc39bb94a4">OP_IdxLT</a>:          <span class="comment">/* jump, in3 */</span>
<a name="l03963"></a>03963 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aa8d1efdb322995dccc4b70e4126f34f7">OP_IdxGE</a>: {        <span class="comment">/* jump, in3 */</span>
<a name="l03964"></a>03964   <span class="keywordtype">int</span> i= pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l03965"></a>03965   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pC;
<a name="l03966"></a>03966 
<a name="l03967"></a>03967   assert( i&gt;=0 &amp;&amp; i&lt;p-&gt;nCursor );
<a name="l03968"></a>03968   assert( p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i]!=0 );
<a name="l03969"></a>03969   <span class="keywordflow">if</span>( (pC = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[i])-&gt;pCursor!=0 ){
<a name="l03970"></a>03970     <span class="keywordtype">int</span> res;
<a name="l03971"></a>03971     <a class="code" href="structUnpackedRecord.html">UnpackedRecord</a> r;
<a name="l03972"></a>03972     assert( pC-&gt;<a class="code" href="structVdbeCursor.html#ad2da7e0fd569b01c89c18e4dff1b335d">deferredMoveto</a>==0 );
<a name="l03973"></a>03973     assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>==0 || pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>==1 );
<a name="l03974"></a>03974     assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a985d1d22c0d0a5ceb7546b09e60d31ef">P4_INT32</a> );
<a name="l03975"></a>03975     r.<a class="code" href="structUnpackedRecord.html#aeb43e7a1e300857cab2cbe98eacd575b">pKeyInfo</a> = pC-&gt;<a class="code" href="structVdbeCursor.html#a72a6c26ab2ab2ad699dfb45703ea4765">pKeyInfo</a>;
<a name="l03976"></a>03976     r.<a class="code" href="structUnpackedRecord.html#a2c5062735cdbc5039679d255cc900668">nField</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a69efeafb8cb87ea2a6feed61e877869a">i</a>;
<a name="l03977"></a>03977     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a> ){
<a name="l03978"></a>03978       r.<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> = <a class="code" href="sqliteInt_8h.html#a3908fc771b61da3bcd4c146de8e1515f">UNPACKED_INCRKEY</a> | <a class="code" href="sqliteInt_8h.html#a1650685ebf83cd7720588c3ef7449f41">UNPACKED_IGNORE_ROWID</a>;
<a name="l03979"></a>03979     }<span class="keywordflow">else</span>{
<a name="l03980"></a>03980       r.<a class="code" href="structUnpackedRecord.html#a133514faed51f2eda9a26b838fe2c21d">flags</a> = <a class="code" href="sqliteInt_8h.html#a1650685ebf83cd7720588c3ef7449f41">UNPACKED_IGNORE_ROWID</a>;
<a name="l03981"></a>03981     }
<a name="l03982"></a>03982     r.<a class="code" href="structUnpackedRecord.html#a3299c322ceb8b758dacc59701021ae9f">aMem</a> = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l03983"></a>03983     rc = <a class="code" href="vdbeaux_8c.html#a1fadd000b100ed3f3b10f697e73f1bd6">sqlite3VdbeIdxKeyCompare</a>(pC, &amp;r, &amp;res);
<a name="l03984"></a>03984     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#ac021e76deac29fea2fa6abcc39bb94a4">OP_IdxLT</a> ){
<a name="l03985"></a>03985       res = -res;
<a name="l03986"></a>03986     }<span class="keywordflow">else</span>{
<a name="l03987"></a>03987       assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#aa8d1efdb322995dccc4b70e4126f34f7">OP_IdxGE</a> );
<a name="l03988"></a>03988       res++;
<a name="l03989"></a>03989     }
<a name="l03990"></a>03990     <span class="keywordflow">if</span>( res&gt;0 ){
<a name="l03991"></a>03991       pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1 ;
<a name="l03992"></a>03992     }
<a name="l03993"></a>03993   }
<a name="l03994"></a>03994   <span class="keywordflow">break</span>;
<a name="l03995"></a>03995 }
<a name="l03996"></a>03996 
<a name="l03997"></a>03997 <span class="comment">/* Opcode: Destroy P1 P2 P3 * *</span>
<a name="l03998"></a>03998 <span class="comment">**</span>
<a name="l03999"></a>03999 <span class="comment">** Delete an entire database table or index whose root page in the database</span>
<a name="l04000"></a>04000 <span class="comment">** file is given by P1.</span>
<a name="l04001"></a>04001 <span class="comment">**</span>
<a name="l04002"></a>04002 <span class="comment">** The table being destroyed is in the main database file if P3==0.  If</span>
<a name="l04003"></a>04003 <span class="comment">** P3==1 then the table to be clear is in the auxiliary database file</span>
<a name="l04004"></a>04004 <span class="comment">** that is used to store tables create using CREATE TEMPORARY TABLE.</span>
<a name="l04005"></a>04005 <span class="comment">**</span>
<a name="l04006"></a>04006 <span class="comment">** If AUTOVACUUM is enabled then it is possible that another root page</span>
<a name="l04007"></a>04007 <span class="comment">** might be moved into the newly deleted root page in order to keep all</span>
<a name="l04008"></a>04008 <span class="comment">** root pages contiguous at the beginning of the database.  The former</span>
<a name="l04009"></a>04009 <span class="comment">** value of the root page that moved - its value before the move occurred -</span>
<a name="l04010"></a>04010 <span class="comment">** is stored in register P2.  If no page </span>
<a name="l04011"></a>04011 <span class="comment">** movement was required (because the table being dropped was already </span>
<a name="l04012"></a>04012 <span class="comment">** the last one in the database) then a zero is stored in register P2.</span>
<a name="l04013"></a>04013 <span class="comment">** If AUTOVACUUM is disabled then a zero is stored in register P2.</span>
<a name="l04014"></a>04014 <span class="comment">**</span>
<a name="l04015"></a>04015 <span class="comment">** See also: Clear</span>
<a name="l04016"></a>04016 <span class="comment">*/</span>
<a name="l04017"></a>04017 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#abf530c50cef0171dc29ae47b684e44b1">OP_Destroy</a>: {     <span class="comment">/* out2-prerelease */</span>
<a name="l04018"></a>04018   <span class="keywordtype">int</span> iMoved;
<a name="l04019"></a>04019   <span class="keywordtype">int</span> iCnt;
<a name="l04020"></a>04020 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04021"></a>04021 <span class="preprocessor"></span>  <a class="code" href="structVdbe.html">Vdbe</a> *pVdbe;
<a name="l04022"></a>04022   iCnt = 0;
<a name="l04023"></a>04023   <span class="keywordflow">for</span>(pVdbe=db-&gt;<a class="code" href="structsqlite3.html#a596f0301f43c5e25575c2a1403f8b571">pVdbe</a>; pVdbe; pVdbe=pVdbe-&gt;<a class="code" href="structVdbe.html#a9d52c1a2d64f132c6994eeac00063df9">pNext</a>){
<a name="l04024"></a>04024     <span class="keywordflow">if</span>( pVdbe-&gt;<a class="code" href="structVdbe.html#acde0845bd790a560770e186f7c8030fd">magic</a>==<a class="code" href="vdbeInt_8h.html#af3737d82d7edf97fffb59baf1592a528">VDBE_MAGIC_RUN</a> &amp;&amp; pVdbe-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a>&lt;2 &amp;&amp; pVdbe-&gt;<a class="code" href="structVdbe.html#ae25264a36877487fb58814608a46689c">pc</a>&gt;=0 ){
<a name="l04025"></a>04025       iCnt++;
<a name="l04026"></a>04026     }
<a name="l04027"></a>04027   }
<a name="l04028"></a>04028 <span class="preprocessor">#else</span>
<a name="l04029"></a>04029 <span class="preprocessor"></span>  iCnt = db-&gt;<a class="code" href="structsqlite3.html#ada07202e7fd80f275e2e5063d96b5cb0">activeVdbeCnt</a>;
<a name="l04030"></a>04030 <span class="preprocessor">#endif</span>
<a name="l04031"></a>04031 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( iCnt&gt;1 ){
<a name="l04032"></a>04032     rc = <a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a>;
<a name="l04033"></a>04033     p-&gt;<a class="code" href="structVdbe.html#accafc9e9bac961a2e34daa1190cc228a">errorAction</a> = <a class="code" href="sqliteInt_8h.html#a85c6194b7bf400f16d92ac6f9ab98fb7">OE_Abort</a>;
<a name="l04034"></a>04034   }<span class="keywordflow">else</span>{
<a name="l04035"></a>04035     <span class="keywordtype">int</span> iDb = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;
<a name="l04036"></a>04036     assert( iCnt==1 );
<a name="l04037"></a>04037     assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;iDb))!=0 );
<a name="l04038"></a>04038     rc = <a class="code" href="btree_8c.html#ac250178f8867eca8fa7161c524a712d9">sqlite3BtreeDropTable</a>(db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, &amp;iMoved);
<a name="l04039"></a>04039     <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l04040"></a>04040     pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = iMoved;
<a name="l04041"></a>04041 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOVACUUM</span>
<a name="l04042"></a>04042 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> &amp;&amp; iMoved!=0 ){
<a name="l04043"></a>04043       <a class="code" href="build_8c.html#add3444d65064778ff6783e737ecf11a7">sqlite3RootPageMoved</a>(&amp;db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb], iMoved, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>);
<a name="l04044"></a>04044     }
<a name="l04045"></a>04045 <span class="preprocessor">#endif</span>
<a name="l04046"></a>04046 <span class="preprocessor"></span>  }
<a name="l04047"></a>04047   <span class="keywordflow">break</span>;
<a name="l04048"></a>04048 }
<a name="l04049"></a>04049 
<a name="l04050"></a>04050 <span class="comment">/* Opcode: Clear P1 P2 P3</span>
<a name="l04051"></a>04051 <span class="comment">**</span>
<a name="l04052"></a>04052 <span class="comment">** Delete all contents of the database table or index whose root page</span>
<a name="l04053"></a>04053 <span class="comment">** in the database file is given by P1.  But, unlike Destroy, do not</span>
<a name="l04054"></a>04054 <span class="comment">** remove the table or index from the database file.</span>
<a name="l04055"></a>04055 <span class="comment">**</span>
<a name="l04056"></a>04056 <span class="comment">** The table being clear is in the main database file if P2==0.  If</span>
<a name="l04057"></a>04057 <span class="comment">** P2==1 then the table to be clear is in the auxiliary database file</span>
<a name="l04058"></a>04058 <span class="comment">** that is used to store tables create using CREATE TEMPORARY TABLE.</span>
<a name="l04059"></a>04059 <span class="comment">**</span>
<a name="l04060"></a>04060 <span class="comment">** If the P3 value is non-zero, then the table refered to must be an</span>
<a name="l04061"></a>04061 <span class="comment">** intkey table (an SQL table, not an index). In this case the row change </span>
<a name="l04062"></a>04062 <span class="comment">** count is incremented by the number of rows in the table being cleared. </span>
<a name="l04063"></a>04063 <span class="comment">** If P3 is greater than zero, then the value stored in register P3 is</span>
<a name="l04064"></a>04064 <span class="comment">** also incremented by the number of rows in the table being cleared.</span>
<a name="l04065"></a>04065 <span class="comment">**</span>
<a name="l04066"></a>04066 <span class="comment">** See also: Destroy</span>
<a name="l04067"></a>04067 <span class="comment">*/</span>
<a name="l04068"></a>04068 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#af4c6c0fe5e517e7efe4e9c8867e51035">OP_Clear</a>: {
<a name="l04069"></a>04069   <span class="keywordtype">int</span> nChange = 0;
<a name="l04070"></a>04070   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>))!=0 );
<a name="l04071"></a>04071   rc = <a class="code" href="btree_8c.html#a460a707ac90ca3a7ff013b102cf68b2c">sqlite3BtreeClearTable</a>(
<a name="l04072"></a>04072       db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, (pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a> ? &amp;nChange : 0)
<a name="l04073"></a>04073   );
<a name="l04074"></a>04074   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a> ){
<a name="l04075"></a>04075     p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a> += nChange;
<a name="l04076"></a>04076     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 ){
<a name="l04077"></a>04077       p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>].<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> += nChange;
<a name="l04078"></a>04078     }
<a name="l04079"></a>04079   }
<a name="l04080"></a>04080   <span class="keywordflow">break</span>;
<a name="l04081"></a>04081 }
<a name="l04082"></a>04082 
<a name="l04083"></a>04083 <span class="comment">/* Opcode: CreateTable P1 P2 * * *</span>
<a name="l04084"></a>04084 <span class="comment">**</span>
<a name="l04085"></a>04085 <span class="comment">** Allocate a new table in the main database file if P1==0 or in the</span>
<a name="l04086"></a>04086 <span class="comment">** auxiliary database file if P1==1 or in an attached database if</span>
<a name="l04087"></a>04087 <span class="comment">** P1&gt;1.  Write the root page number of the new table into</span>
<a name="l04088"></a>04088 <span class="comment">** register P2</span>
<a name="l04089"></a>04089 <span class="comment">**</span>
<a name="l04090"></a>04090 <span class="comment">** The difference between a table and an index is this:  A table must</span>
<a name="l04091"></a>04091 <span class="comment">** have a 4-byte integer key and can have arbitrary data.  An index</span>
<a name="l04092"></a>04092 <span class="comment">** has an arbitrary key but no data.</span>
<a name="l04093"></a>04093 <span class="comment">**</span>
<a name="l04094"></a>04094 <span class="comment">** See also: CreateIndex</span>
<a name="l04095"></a>04095 <span class="comment">*/</span>
<a name="l04096"></a>04096 <span class="comment">/* Opcode: CreateIndex P1 P2 * * *</span>
<a name="l04097"></a>04097 <span class="comment">**</span>
<a name="l04098"></a>04098 <span class="comment">** Allocate a new index in the main database file if P1==0 or in the</span>
<a name="l04099"></a>04099 <span class="comment">** auxiliary database file if P1==1 or in an attached database if</span>
<a name="l04100"></a>04100 <span class="comment">** P1&gt;1.  Write the root page number of the new table into</span>
<a name="l04101"></a>04101 <span class="comment">** register P2.</span>
<a name="l04102"></a>04102 <span class="comment">**</span>
<a name="l04103"></a>04103 <span class="comment">** See documentation on OP_CreateTable for additional information.</span>
<a name="l04104"></a>04104 <span class="comment">*/</span>
<a name="l04105"></a>04105 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a0aed2bd80a8e22152f572094f808d995">OP_CreateIndex</a>:            <span class="comment">/* out2-prerelease */</span>
<a name="l04106"></a>04106 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ae1e2900c350aaf6837a53b18229753d3">OP_CreateTable</a>: {          <span class="comment">/* out2-prerelease */</span>
<a name="l04107"></a>04107   <span class="keywordtype">int</span> pgno;
<a name="l04108"></a>04108   <span class="keywordtype">int</span> flags;
<a name="l04109"></a>04109   <a class="code" href="structDb.html">Db</a> *pDb;
<a name="l04110"></a>04110   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;=0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a> );
<a name="l04111"></a>04111   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>))!=0 );
<a name="l04112"></a>04112   pDb = &amp;db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l04113"></a>04113   assert( pDb-&gt;<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>!=0 );
<a name="l04114"></a>04114   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#ae12a8e7a8f5f7ba39fa379c9ad287837">opcode</a>==<a class="code" href="opcodes_8h.html#ae1e2900c350aaf6837a53b18229753d3">OP_CreateTable</a> ){
<a name="l04115"></a>04115     <span class="comment">/* flags = BTREE_INTKEY; */</span>
<a name="l04116"></a>04116     flags = <a class="code" href="btree_8h.html#a97adec44805e5b3226186d2f5d735a1d">BTREE_LEAFDATA</a>|<a class="code" href="btree_8h.html#acd71692e8b09c8106ad4504cdd1065bc">BTREE_INTKEY</a>;
<a name="l04117"></a>04117   }<span class="keywordflow">else</span>{
<a name="l04118"></a>04118     flags = <a class="code" href="btree_8h.html#aca0cac010cf1fa6f4d1df39beb6a1f8d">BTREE_ZERODATA</a>;
<a name="l04119"></a>04119   }
<a name="l04120"></a>04120   rc = <a class="code" href="btree_8c.html#a1084bedd105ea21f99beef334bbddd80">sqlite3BtreeCreateTable</a>(pDb-&gt;<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>, &amp;pgno, flags);
<a name="l04121"></a>04121   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04122"></a>04122     pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = pgno;
<a name="l04123"></a>04123     <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l04124"></a>04124   }
<a name="l04125"></a>04125   <span class="keywordflow">break</span>;
<a name="l04126"></a>04126 }
<a name="l04127"></a>04127 
<a name="l04128"></a>04128 <span class="comment">/* Opcode: ParseSchema P1 P2 * P4 *</span>
<a name="l04129"></a>04129 <span class="comment">**</span>
<a name="l04130"></a>04130 <span class="comment">** Read and parse all entries from the SQLITE_MASTER table of database P1</span>
<a name="l04131"></a>04131 <span class="comment">** that match the WHERE clause P4.  P2 is the &quot;force&quot; flag.   Always do</span>
<a name="l04132"></a>04132 <span class="comment">** the parsing if P2 is true.  If P2 is false, then this routine is a</span>
<a name="l04133"></a>04133 <span class="comment">** no-op if the schema is not currently loaded.  In other words, if P2</span>
<a name="l04134"></a>04134 <span class="comment">** is false, the SQLITE_MASTER table is only parsed if the rest of the</span>
<a name="l04135"></a>04135 <span class="comment">** schema is already loaded into the symbol table.</span>
<a name="l04136"></a>04136 <span class="comment">**</span>
<a name="l04137"></a>04137 <span class="comment">** This opcode invokes the parser to create a new virtual machine,</span>
<a name="l04138"></a>04138 <span class="comment">** then runs the new virtual machine.  It is thus a re-entrant opcode.</span>
<a name="l04139"></a>04139 <span class="comment">*/</span>
<a name="l04140"></a>04140 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a981a42c3f7d3d6e5d7023d4ce3ef354d">OP_ParseSchema</a>: {
<a name="l04141"></a>04141   <span class="keywordtype">char</span> *zSql;
<a name="l04142"></a>04142   <span class="keywordtype">int</span> iDb = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l04143"></a>04143   <span class="keyword">const</span> <span class="keywordtype">char</span> *zMaster;
<a name="l04144"></a>04144   <a class="code" href="structInitData.html">InitData</a> initData;
<a name="l04145"></a>04145 
<a name="l04146"></a>04146   assert( iDb&gt;=0 &amp;&amp; iDb&lt;db-&gt;nDb );
<a name="l04147"></a>04147   <span class="keywordflow">if</span>( !pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> &amp;&amp; !<a class="code" href="sqliteInt_8h.html#a7a2fa1b984bf800e8ba8c9accf449834">DbHasProperty</a>(db, iDb, <a class="code" href="sqliteInt_8h.html#a72c3d0884e544aa67cea3d4751dced73">DB_SchemaLoaded</a>) ){
<a name="l04148"></a>04148     <span class="keywordflow">break</span>;
<a name="l04149"></a>04149   }
<a name="l04150"></a>04150   zMaster = <a class="code" href="sqliteInt_8h.html#a0393ad099b2c180c4c26c32c251baf37">SCHEMA_TABLE</a>(iDb);
<a name="l04151"></a>04151   initData.<a class="code" href="structInitData.html#adc9e29c56e0392076e92d7f4b29fa272">db</a> = db;
<a name="l04152"></a>04152   initData.<a class="code" href="structInitData.html#ad6c7953b49d351cd9fb14e3394010689">iDb</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l04153"></a>04153   initData.<a class="code" href="structInitData.html#aa8aef34241ec214f038b38932ffe1357">pzErrMsg</a> = &amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>;
<a name="l04154"></a>04154   zSql = <a class="code" href="printf_8c.html#a565f1e5e7ec859ec4e815ed15d42a415">sqlite3MPrintf</a>(db,
<a name="l04155"></a>04155      <span class="stringliteral">&quot;SELECT name, rootpage, sql FROM &apos;%q&apos;.%s WHERE %s&quot;</span>,
<a name="l04156"></a>04156      db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>, zMaster, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l04157"></a>04157   <span class="keywordflow">if</span>( zSql==0 ) <span class="keywordflow">goto</span> no_mem;
<a name="l04158"></a>04158   (void)<a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db);
<a name="l04159"></a>04159   assert( db-&gt;<a class="code" href="structsqlite3.html#a14bb7fbfa6b662021069fcdf6b334d70">init</a>.<a class="code" href="structsqlite3_1_1sqlite3InitInfo.html#a6ac01842e0ae68023cb60fea93bd8688">busy</a>==0 );
<a name="l04160"></a>04160   db-&gt;<a class="code" href="structsqlite3.html#a14bb7fbfa6b662021069fcdf6b334d70">init</a>.<a class="code" href="structsqlite3_1_1sqlite3InitInfo.html#a6ac01842e0ae68023cb60fea93bd8688">busy</a> = 1;
<a name="l04161"></a>04161   initData.<a class="code" href="structInitData.html#a627153a3de2c4d159ae44ebc03961592">rc</a> = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04162"></a>04162   assert( !db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> );
<a name="l04163"></a>04163   rc = <a class="code" href="legacy_8c.html#ada787486cf95a994521cfd0c64e853e4">sqlite3_exec</a>(db, zSql, <a class="code" href="prepare_8c.html#ad97a9053636c29ea602f2211d5c53314">sqlite3InitCallback</a>, &amp;initData, 0);
<a name="l04164"></a>04164   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ) rc = initData.<a class="code" href="structInitData.html#a627153a3de2c4d159ae44ebc03961592">rc</a>;
<a name="l04165"></a>04165   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zSql);
<a name="l04166"></a>04166   db-&gt;<a class="code" href="structsqlite3.html#a14bb7fbfa6b662021069fcdf6b334d70">init</a>.<a class="code" href="structsqlite3_1_1sqlite3InitInfo.html#a6ac01842e0ae68023cb60fea93bd8688">busy</a> = 0;
<a name="l04167"></a>04167   (void)<a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db);
<a name="l04168"></a>04168   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a> ){
<a name="l04169"></a>04169     <span class="keywordflow">goto</span> no_mem;
<a name="l04170"></a>04170   }
<a name="l04171"></a>04171   <span class="keywordflow">break</span>;  
<a name="l04172"></a>04172 }
<a name="l04173"></a>04173 
<a name="l04174"></a>04174 <span class="preprocessor">#if !defined(SQLITE_OMIT_ANALYZE) &amp;&amp; !defined(SQLITE_OMIT_PARSER)</span>
<a name="l04175"></a>04175 <span class="preprocessor"></span><span class="comment">/* Opcode: LoadAnalysis P1 * * * *</span>
<a name="l04176"></a>04176 <span class="comment">**</span>
<a name="l04177"></a>04177 <span class="comment">** Read the sqlite_stat1 table for database P1 and load the content</span>
<a name="l04178"></a>04178 <span class="comment">** of that table into the internal index hash table.  This will cause</span>
<a name="l04179"></a>04179 <span class="comment">** the analysis to be used when preparing all subsequent queries.</span>
<a name="l04180"></a>04180 <span class="comment">*/</span>
<a name="l04181"></a>04181 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ae06ed1824ffd992a7aa81c1f9209f543">OP_LoadAnalysis</a>: {
<a name="l04182"></a>04182   <span class="keywordtype">int</span> iDb = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>;
<a name="l04183"></a>04183   assert( iDb&gt;=0 &amp;&amp; iDb&lt;db-&gt;nDb );
<a name="l04184"></a>04184   rc = <a class="code" href="analyze_8c.html#a33e56439dd87d2f769188eee389f15ee">sqlite3AnalysisLoad</a>(db, iDb);
<a name="l04185"></a>04185   <span class="keywordflow">break</span>;  
<a name="l04186"></a>04186 }
<a name="l04187"></a>04187 <span class="preprocessor">#endif </span><span class="comment">/* !defined(SQLITE_OMIT_ANALYZE) &amp;&amp; !defined(SQLITE_OMIT_PARSER)  */</span>
<a name="l04188"></a>04188 
<a name="l04189"></a>04189 <span class="comment">/* Opcode: DropTable P1 * * P4 *</span>
<a name="l04190"></a>04190 <span class="comment">**</span>
<a name="l04191"></a>04191 <span class="comment">** Remove the internal (in-memory) data structures that describe</span>
<a name="l04192"></a>04192 <span class="comment">** the table named P4 in database P1.  This is called after a table</span>
<a name="l04193"></a>04193 <span class="comment">** is dropped in order to keep the internal representation of the</span>
<a name="l04194"></a>04194 <span class="comment">** schema consistent with what is on disk.</span>
<a name="l04195"></a>04195 <span class="comment">*/</span>
<a name="l04196"></a>04196 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aaef85bc4146c2c057675248ba69659f9">OP_DropTable</a>: {
<a name="l04197"></a>04197   <a class="code" href="build_8c.html#a63cdd820a44d7ab54455435d5503e9e4">sqlite3UnlinkAndDeleteTable</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l04198"></a>04198   <span class="keywordflow">break</span>;
<a name="l04199"></a>04199 }
<a name="l04200"></a>04200 
<a name="l04201"></a>04201 <span class="comment">/* Opcode: DropIndex P1 * * P4 *</span>
<a name="l04202"></a>04202 <span class="comment">**</span>
<a name="l04203"></a>04203 <span class="comment">** Remove the internal (in-memory) data structures that describe</span>
<a name="l04204"></a>04204 <span class="comment">** the index named P4 in database P1.  This is called after an index</span>
<a name="l04205"></a>04205 <span class="comment">** is dropped in order to keep the internal representation of the</span>
<a name="l04206"></a>04206 <span class="comment">** schema consistent with what is on disk.</span>
<a name="l04207"></a>04207 <span class="comment">*/</span>
<a name="l04208"></a>04208 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a811f77f3df4148913d1f4b7676bb8f65">OP_DropIndex</a>: {
<a name="l04209"></a>04209   <a class="code" href="build_8c.html#a5986dac54e4f3c68df6d3682ea4ba551">sqlite3UnlinkAndDeleteIndex</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l04210"></a>04210   <span class="keywordflow">break</span>;
<a name="l04211"></a>04211 }
<a name="l04212"></a>04212 
<a name="l04213"></a>04213 <span class="comment">/* Opcode: DropTrigger P1 * * P4 *</span>
<a name="l04214"></a>04214 <span class="comment">**</span>
<a name="l04215"></a>04215 <span class="comment">** Remove the internal (in-memory) data structures that describe</span>
<a name="l04216"></a>04216 <span class="comment">** the trigger named P4 in database P1.  This is called after a trigger</span>
<a name="l04217"></a>04217 <span class="comment">** is dropped in order to keep the internal representation of the</span>
<a name="l04218"></a>04218 <span class="comment">** schema consistent with what is on disk.</span>
<a name="l04219"></a>04219 <span class="comment">*/</span>
<a name="l04220"></a>04220 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aa56534d5de687cfed65b67ca7b4a2264">OP_DropTrigger</a>: {
<a name="l04221"></a>04221   <a class="code" href="sqliteInt_8h.html#a9feeda90b8de864f84c8eb0034a53181">sqlite3UnlinkAndDeleteTrigger</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l04222"></a>04222   <span class="keywordflow">break</span>;
<a name="l04223"></a>04223 }
<a name="l04224"></a>04224 
<a name="l04225"></a>04225 
<a name="l04226"></a>04226 <span class="preprocessor">#ifndef SQLITE_OMIT_INTEGRITY_CHECK</span>
<a name="l04227"></a>04227 <span class="preprocessor"></span><span class="comment">/* Opcode: IntegrityCk P1 P2 P3 * P5</span>
<a name="l04228"></a>04228 <span class="comment">**</span>
<a name="l04229"></a>04229 <span class="comment">** Do an analysis of the currently open database.  Store in</span>
<a name="l04230"></a>04230 <span class="comment">** register P1 the text of an error message describing any problems.</span>
<a name="l04231"></a>04231 <span class="comment">** If no problems are found, store a NULL in register P1.</span>
<a name="l04232"></a>04232 <span class="comment">**</span>
<a name="l04233"></a>04233 <span class="comment">** The register P3 contains the maximum number of allowed errors.</span>
<a name="l04234"></a>04234 <span class="comment">** At most reg(P3) errors will be reported.</span>
<a name="l04235"></a>04235 <span class="comment">** In other words, the analysis stops as soon as reg(P1) errors are </span>
<a name="l04236"></a>04236 <span class="comment">** seen.  Reg(P1) is updated with the number of errors remaining.</span>
<a name="l04237"></a>04237 <span class="comment">**</span>
<a name="l04238"></a>04238 <span class="comment">** The root page numbers of all tables in the database are integer</span>
<a name="l04239"></a>04239 <span class="comment">** stored in reg(P1), reg(P1+1), reg(P1+2), ....  There are P2 tables</span>
<a name="l04240"></a>04240 <span class="comment">** total.</span>
<a name="l04241"></a>04241 <span class="comment">**</span>
<a name="l04242"></a>04242 <span class="comment">** If P5 is not zero, the check is done on the auxiliary database</span>
<a name="l04243"></a>04243 <span class="comment">** file, not the main database file.</span>
<a name="l04244"></a>04244 <span class="comment">**</span>
<a name="l04245"></a>04245 <span class="comment">** This opcode is used to implement the integrity_check pragma.</span>
<a name="l04246"></a>04246 <span class="comment">*/</span>
<a name="l04247"></a>04247 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ab87b9e393019c4fc146d703e448301d2">OP_IntegrityCk</a>: {
<a name="l04248"></a>04248   <span class="keywordtype">int</span> nRoot;      <span class="comment">/* Number of tables to check.  (Number of root pages.) */</span>
<a name="l04249"></a>04249   <span class="keywordtype">int</span> *aRoot;     <span class="comment">/* Array of rootpage numbers for tables to be checked */</span>
<a name="l04250"></a>04250   <span class="keywordtype">int</span> j;          <span class="comment">/* Loop counter */</span>
<a name="l04251"></a>04251   <span class="keywordtype">int</span> nErr;       <span class="comment">/* Number of errors reported */</span>
<a name="l04252"></a>04252   <span class="keywordtype">char</span> *z;        <span class="comment">/* Text of the error report */</span>
<a name="l04253"></a>04253   <a class="code" href="structMem.html">Mem</a> *pnErr;     <span class="comment">/* Register keeping track of errors remaining */</span>
<a name="l04254"></a>04254   
<a name="l04255"></a>04255   nRoot = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l04256"></a>04256   assert( nRoot&gt;0 );
<a name="l04257"></a>04257   aRoot = <a class="code" href="malloc_8c.html#a043f868d32456bd7cdca4a62837277c1">sqlite3DbMallocRaw</a>(db, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*(nRoot+1) );
<a name="l04258"></a>04258   <span class="keywordflow">if</span>( aRoot==0 ) <span class="keywordflow">goto</span> no_mem;
<a name="l04259"></a>04259   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l04260"></a>04260   pnErr = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l04261"></a>04261   assert( (pnErr-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>)!=0 );
<a name="l04262"></a>04262   assert( (pnErr-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; (MEM_Str|MEM_Blob))==0 );
<a name="l04263"></a>04263   pIn1 = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l04264"></a>04264   <span class="keywordflow">for</span>(j=0; j&lt;nRoot; j++){
<a name="l04265"></a>04265     aRoot[j] = <a class="code" href="vdbeInt_8h.html#af740891f040ec074e1a140d71c1cacba">sqlite3VdbeIntValue</a>(&amp;pIn1[j]);
<a name="l04266"></a>04266   }
<a name="l04267"></a>04267   aRoot[j] = 0;
<a name="l04268"></a>04268   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a> );
<a name="l04269"></a>04269   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>))!=0 );
<a name="l04270"></a>04270   z = <a class="code" href="btree_8c.html#ae5fa1180c69f3527516c08636efc36e5">sqlite3BtreeIntegrityCheck</a>(db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>, aRoot, nRoot,
<a name="l04271"></a>04271                                  pnErr-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>, &amp;nErr);
<a name="l04272"></a>04272   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, aRoot);
<a name="l04273"></a>04273   pnErr-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> -= nErr;
<a name="l04274"></a>04274   <a class="code" href="vdbeInt_8h.html#a312cd58d3f6b7a2d9c73579685b20c02">sqlite3VdbeMemSetNull</a>(pIn1);
<a name="l04275"></a>04275   <span class="keywordflow">if</span>( nErr==0 ){
<a name="l04276"></a>04276     assert( z==0 );
<a name="l04277"></a>04277   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( z==0 ){
<a name="l04278"></a>04278     <span class="keywordflow">goto</span> no_mem;
<a name="l04279"></a>04279   }<span class="keywordflow">else</span>{
<a name="l04280"></a>04280     <a class="code" href="vdbeInt_8h.html#aba781c78989d5481ac168c09108c0ba8">sqlite3VdbeMemSetStr</a>(pIn1, z, -1, <a class="code" href="sqlite3_8h.html#a7a65f15cad0da22be8ebc0c70f526d32">SQLITE_UTF8</a>, <a class="code" href="malloc_8c.html#a89d4380358f918be2a8e2171d95bbb04">sqlite3_free</a>);
<a name="l04281"></a>04281   }
<a name="l04282"></a>04282   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pIn1);
<a name="l04283"></a>04283   <a class="code" href="vdbeInt_8h.html#a94f53f04621df5bca68190710998b086">sqlite3VdbeChangeEncoding</a>(pIn1, encoding);
<a name="l04284"></a>04284   <span class="keywordflow">break</span>;
<a name="l04285"></a>04285 }
<a name="l04286"></a>04286 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_INTEGRITY_CHECK */</span>
<a name="l04287"></a>04287 
<a name="l04288"></a>04288 <span class="comment">/* Opcode: FifoWrite P1 * * * *</span>
<a name="l04289"></a>04289 <span class="comment">**</span>
<a name="l04290"></a>04290 <span class="comment">** Write the integer from register P1 into the Fifo.</span>
<a name="l04291"></a>04291 <span class="comment">*/</span>
<a name="l04292"></a>04292 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#abfb7ae19ba10c754395e060b68ee2c8b">OP_FifoWrite</a>: {        <span class="comment">/* in1 */</span>
<a name="l04293"></a>04293   p-&gt;<a class="code" href="structVdbe.html#ab9222d0ba3c069da606602bc772cb05d">sFifo</a>.<a class="code" href="structFifo.html#ae8fa7a6632817de1b0b22f01eea1d0e6">db</a> = db;
<a name="l04294"></a>04294   <span class="keywordflow">if</span>( <a class="code" href="vdbefifo_8c.html#a503f5d77feccefdd0cd38e4d2f04e42d">sqlite3VdbeFifoPush</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#ab9222d0ba3c069da606602bc772cb05d">sFifo</a>, <a class="code" href="vdbeInt_8h.html#af740891f040ec074e1a140d71c1cacba">sqlite3VdbeIntValue</a>(pIn1))==<a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a> ){
<a name="l04295"></a>04295     <span class="keywordflow">goto</span> no_mem;
<a name="l04296"></a>04296   }
<a name="l04297"></a>04297   <span class="keywordflow">break</span>;
<a name="l04298"></a>04298 }
<a name="l04299"></a>04299 
<a name="l04300"></a>04300 <span class="comment">/* Opcode: FifoRead P1 P2 * * *</span>
<a name="l04301"></a>04301 <span class="comment">**</span>
<a name="l04302"></a>04302 <span class="comment">** Attempt to read a single integer from the Fifo.  Store that</span>
<a name="l04303"></a>04303 <span class="comment">** integer in register P1.</span>
<a name="l04304"></a>04304 <span class="comment">** </span>
<a name="l04305"></a>04305 <span class="comment">** If the Fifo is empty jump to P2.</span>
<a name="l04306"></a>04306 <span class="comment">*/</span>
<a name="l04307"></a>04307 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a3c56ad2c709d6a37d137b7d6f82ccbfd">OP_FifoRead</a>: {         <span class="comment">/* jump */</span>
<a name="l04308"></a>04308   <a class="code" href="vdbe_8c.html#ac7ee506756b15c8b7da860830e1393af">CHECK_FOR_INTERRUPT</a>;
<a name="l04309"></a>04309   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l04310"></a>04310   pOut = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l04311"></a>04311   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l04312"></a>04312   <span class="keywordflow">if</span>( <a class="code" href="vdbefifo_8c.html#a8d4a8e6b5ca0978ad26ce82b8662093e">sqlite3VdbeFifoPop</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#ab9222d0ba3c069da606602bc772cb05d">sFifo</a>, &amp;pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>)==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l04313"></a>04313     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l04314"></a>04314   }
<a name="l04315"></a>04315   <span class="keywordflow">break</span>;
<a name="l04316"></a>04316 }
<a name="l04317"></a>04317 
<a name="l04318"></a>04318 <span class="preprocessor">#ifndef SQLITE_OMIT_TRIGGER</span>
<a name="l04319"></a>04319 <span class="preprocessor"></span><span class="comment">/* Opcode: ContextPush * * * </span>
<a name="l04320"></a>04320 <span class="comment">**</span>
<a name="l04321"></a>04321 <span class="comment">** Save the current Vdbe context such that it can be restored by a ContextPop</span>
<a name="l04322"></a>04322 <span class="comment">** opcode. The context stores the last insert row id, the last statement change</span>
<a name="l04323"></a>04323 <span class="comment">** count, and the current statement change count.</span>
<a name="l04324"></a>04324 <span class="comment">*/</span>
<a name="l04325"></a>04325 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#afcf0c174876631b07023f2f62d08a6b8">OP_ContextPush</a>: {
<a name="l04326"></a>04326   <span class="keywordtype">int</span> i = p-&gt;<a class="code" href="structVdbe.html#a93d6a431e8a27b85754243e341ab6c31">contextStackTop</a>++;
<a name="l04327"></a>04327   <a class="code" href="structContext.html">Context</a> *pContext;
<a name="l04328"></a>04328 
<a name="l04329"></a>04329   assert( i&gt;=0 );
<a name="l04330"></a>04330   <span class="comment">/* FIX ME: This should be allocated as part of the vdbe at compile-time */</span>
<a name="l04331"></a>04331   <span class="keywordflow">if</span>( i&gt;=p-&gt;<a class="code" href="structVdbe.html#a7a1b3e41da59c4aff65c250809c14ce5">contextStackDepth</a> ){
<a name="l04332"></a>04332     p-&gt;<a class="code" href="structVdbe.html#a7a1b3e41da59c4aff65c250809c14ce5">contextStackDepth</a> = i+1;
<a name="l04333"></a>04333     p-&gt;<a class="code" href="structVdbe.html#a994114f03c89cdc3f011c48be8eb4bd4">contextStack</a> = <a class="code" href="malloc_8c.html#ae141b4f66af57a6828c083c6926fa5c0">sqlite3DbReallocOrFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#a994114f03c89cdc3f011c48be8eb4bd4">contextStack</a>,
<a name="l04334"></a>04334                                           <span class="keyword">sizeof</span>(<a class="code" href="structContext.html">Context</a>)*(i+1));
<a name="l04335"></a>04335     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structVdbe.html#a994114f03c89cdc3f011c48be8eb4bd4">contextStack</a>==0 ) <span class="keywordflow">goto</span> no_mem;
<a name="l04336"></a>04336   }
<a name="l04337"></a>04337   pContext = &amp;p-&gt;<a class="code" href="structVdbe.html#a994114f03c89cdc3f011c48be8eb4bd4">contextStack</a>[i];
<a name="l04338"></a>04338   pContext-&gt;<a class="code" href="structContext.html#a47135a3f0adbaaa814f03a8e07f43e93">lastRowid</a> = db-&gt;<a class="code" href="structsqlite3.html#a9fff52fc4eb087fbb3e3271994fa5198">lastRowid</a>;
<a name="l04339"></a>04339   pContext-&gt;<a class="code" href="structContext.html#aec1fdba640dd9f1e8f683c38264e92fa">nChange</a> = p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a>;
<a name="l04340"></a>04340   pContext-&gt;<a class="code" href="structContext.html#ab80b78ed84a5d01f2f7fafc88bf339e5">sFifo</a> = p-&gt;<a class="code" href="structVdbe.html#ab9222d0ba3c069da606602bc772cb05d">sFifo</a>;
<a name="l04341"></a>04341   <a class="code" href="vdbefifo_8c.html#a757d030d665293c6dad6a2a8cb441acb">sqlite3VdbeFifoInit</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#ab9222d0ba3c069da606602bc772cb05d">sFifo</a>, db);
<a name="l04342"></a>04342   <span class="keywordflow">break</span>;
<a name="l04343"></a>04343 }
<a name="l04344"></a>04344 
<a name="l04345"></a>04345 <span class="comment">/* Opcode: ContextPop * * * </span>
<a name="l04346"></a>04346 <span class="comment">**</span>
<a name="l04347"></a>04347 <span class="comment">** Restore the Vdbe context to the state it was in when contextPush was last</span>
<a name="l04348"></a>04348 <span class="comment">** executed. The context stores the last insert row id, the last statement</span>
<a name="l04349"></a>04349 <span class="comment">** change count, and the current statement change count.</span>
<a name="l04350"></a>04350 <span class="comment">*/</span>
<a name="l04351"></a>04351 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#acfc339ecef8669d2d1119acb40b37f0e">OP_ContextPop</a>: {
<a name="l04352"></a>04352   <a class="code" href="structContext.html">Context</a> *pContext = &amp;p-&gt;<a class="code" href="structVdbe.html#a994114f03c89cdc3f011c48be8eb4bd4">contextStack</a>[--p-&gt;<a class="code" href="structVdbe.html#a93d6a431e8a27b85754243e341ab6c31">contextStackTop</a>];
<a name="l04353"></a>04353   assert( p-&gt;<a class="code" href="structVdbe.html#a93d6a431e8a27b85754243e341ab6c31">contextStackTop</a>&gt;=0 );
<a name="l04354"></a>04354   db-&gt;<a class="code" href="structsqlite3.html#a9fff52fc4eb087fbb3e3271994fa5198">lastRowid</a> = pContext-&gt;<a class="code" href="structContext.html#a47135a3f0adbaaa814f03a8e07f43e93">lastRowid</a>;
<a name="l04355"></a>04355   p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a> = pContext-&gt;<a class="code" href="structContext.html#aec1fdba640dd9f1e8f683c38264e92fa">nChange</a>;
<a name="l04356"></a>04356   <a class="code" href="vdbefifo_8c.html#af910addcbc65dfbaf85415e99524f158">sqlite3VdbeFifoClear</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#ab9222d0ba3c069da606602bc772cb05d">sFifo</a>);
<a name="l04357"></a>04357   p-&gt;<a class="code" href="structVdbe.html#ab9222d0ba3c069da606602bc772cb05d">sFifo</a> = pContext-&gt;<a class="code" href="structContext.html#ab80b78ed84a5d01f2f7fafc88bf339e5">sFifo</a>;
<a name="l04358"></a>04358   <span class="keywordflow">break</span>;
<a name="l04359"></a>04359 }
<a name="l04360"></a>04360 <span class="preprocessor">#endif </span><span class="comment">/* #ifndef SQLITE_OMIT_TRIGGER */</span>
<a name="l04361"></a>04361 
<a name="l04362"></a>04362 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTOINCREMENT</span>
<a name="l04363"></a>04363 <span class="preprocessor"></span><span class="comment">/* Opcode: MemMax P1 P2 * * *</span>
<a name="l04364"></a>04364 <span class="comment">**</span>
<a name="l04365"></a>04365 <span class="comment">** Set the value of register P1 to the maximum of its current value</span>
<a name="l04366"></a>04366 <span class="comment">** and the value in register P2.</span>
<a name="l04367"></a>04367 <span class="comment">**</span>
<a name="l04368"></a>04368 <span class="comment">** This instruction throws an error if the memory cell is not initially</span>
<a name="l04369"></a>04369 <span class="comment">** an integer.</span>
<a name="l04370"></a>04370 <span class="comment">*/</span>
<a name="l04371"></a>04371 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a23e5aec151480e0962baaf2ed063f823">OP_MemMax</a>: {        <span class="comment">/* in1, in2 */</span>
<a name="l04372"></a>04372   <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pIn1);
<a name="l04373"></a>04373   <a class="code" href="vdbeInt_8h.html#a00abd73b6c46847487b9959d334aed9b">sqlite3VdbeMemIntegerify</a>(pIn2);
<a name="l04374"></a>04374   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>&lt;pIn2-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>){
<a name="l04375"></a>04375     pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = pIn2-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l04376"></a>04376   }
<a name="l04377"></a>04377   <span class="keywordflow">break</span>;
<a name="l04378"></a>04378 }
<a name="l04379"></a>04379 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_AUTOINCREMENT */</span>
<a name="l04380"></a>04380 
<a name="l04381"></a>04381 <span class="comment">/* Opcode: IfPos P1 P2 * * *</span>
<a name="l04382"></a>04382 <span class="comment">**</span>
<a name="l04383"></a>04383 <span class="comment">** If the value of register P1 is 1 or greater, jump to P2.</span>
<a name="l04384"></a>04384 <span class="comment">**</span>
<a name="l04385"></a>04385 <span class="comment">** It is illegal to use this instruction on a register that does</span>
<a name="l04386"></a>04386 <span class="comment">** not contain an integer.  An assertion fault will result if you try.</span>
<a name="l04387"></a>04387 <span class="comment">*/</span>
<a name="l04388"></a>04388 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#ac568254599af4699a2e12fc88dbc69f9">OP_IfPos</a>: {        <span class="comment">/* jump, in1 */</span>
<a name="l04389"></a>04389   assert( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l04390"></a>04390   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>&gt;0 ){
<a name="l04391"></a>04391      pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l04392"></a>04392   }
<a name="l04393"></a>04393   <span class="keywordflow">break</span>;
<a name="l04394"></a>04394 }
<a name="l04395"></a>04395 
<a name="l04396"></a>04396 <span class="comment">/* Opcode: IfNeg P1 P2 * * *</span>
<a name="l04397"></a>04397 <span class="comment">**</span>
<a name="l04398"></a>04398 <span class="comment">** If the value of register P1 is less than zero, jump to P2. </span>
<a name="l04399"></a>04399 <span class="comment">**</span>
<a name="l04400"></a>04400 <span class="comment">** It is illegal to use this instruction on a register that does</span>
<a name="l04401"></a>04401 <span class="comment">** not contain an integer.  An assertion fault will result if you try.</span>
<a name="l04402"></a>04402 <span class="comment">*/</span>
<a name="l04403"></a>04403 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a66f73634ca0913466adfd77fce117008">OP_IfNeg</a>: {        <span class="comment">/* jump, in1 */</span>
<a name="l04404"></a>04404   assert( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l04405"></a>04405   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>&lt;0 ){
<a name="l04406"></a>04406      pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l04407"></a>04407   }
<a name="l04408"></a>04408   <span class="keywordflow">break</span>;
<a name="l04409"></a>04409 }
<a name="l04410"></a>04410 
<a name="l04411"></a>04411 <span class="comment">/* Opcode: IfZero P1 P2 * * *</span>
<a name="l04412"></a>04412 <span class="comment">**</span>
<a name="l04413"></a>04413 <span class="comment">** If the value of register P1 is exactly 0, jump to P2. </span>
<a name="l04414"></a>04414 <span class="comment">**</span>
<a name="l04415"></a>04415 <span class="comment">** It is illegal to use this instruction on a register that does</span>
<a name="l04416"></a>04416 <span class="comment">** not contain an integer.  An assertion fault will result if you try.</span>
<a name="l04417"></a>04417 <span class="comment">*/</span>
<a name="l04418"></a>04418 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a7837488e178923feb7ef30cbe6372278">OP_IfZero</a>: {        <span class="comment">/* jump, in1 */</span>
<a name="l04419"></a>04419   assert( pIn1-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l04420"></a>04420   <span class="keywordflow">if</span>( pIn1-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>==0 ){
<a name="l04421"></a>04421      pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l04422"></a>04422   }
<a name="l04423"></a>04423   <span class="keywordflow">break</span>;
<a name="l04424"></a>04424 }
<a name="l04425"></a>04425 
<a name="l04426"></a>04426 <span class="comment">/* Opcode: AggStep * P2 P3 P4 P5</span>
<a name="l04427"></a>04427 <span class="comment">**</span>
<a name="l04428"></a>04428 <span class="comment">** Execute the step function for an aggregate.  The</span>
<a name="l04429"></a>04429 <span class="comment">** function has P5 arguments.   P4 is a pointer to the FuncDef</span>
<a name="l04430"></a>04430 <span class="comment">** structure that specifies the function.  Use register</span>
<a name="l04431"></a>04431 <span class="comment">** P3 as the accumulator.</span>
<a name="l04432"></a>04432 <span class="comment">**</span>
<a name="l04433"></a>04433 <span class="comment">** The P5 arguments are taken from register P2 and its</span>
<a name="l04434"></a>04434 <span class="comment">** successors.</span>
<a name="l04435"></a>04435 <span class="comment">*/</span>
<a name="l04436"></a>04436 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a02bdc453117200f5aa03b46e9243be71">OP_AggStep</a>: {
<a name="l04437"></a>04437   <span class="keywordtype">int</span> n = pOp-&gt;<a class="code" href="structVdbeOp.html#a5e807981f52d29c06a5b6d4a8f2f4595">p5</a>;
<a name="l04438"></a>04438   <span class="keywordtype">int</span> i;
<a name="l04439"></a>04439   <a class="code" href="structMem.html">Mem</a> *pMem, *pRec;
<a name="l04440"></a>04440   <a class="code" href="structsqlite3__context.html">sqlite3_context</a> ctx;
<a name="l04441"></a>04441   <a class="code" href="structMem.html">sqlite3_value</a> **apVal;
<a name="l04442"></a>04442 
<a name="l04443"></a>04443   assert( n&gt;=0 );
<a name="l04444"></a>04444   pRec = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>];
<a name="l04445"></a>04445   apVal = p-&gt;<a class="code" href="structVdbe.html#a74fd4612c55ac2fde475096a4d2605b5">apArg</a>;
<a name="l04446"></a>04446   assert( apVal || n==0 );
<a name="l04447"></a>04447   <span class="keywordflow">for</span>(i=0; i&lt;n; i++, pRec++){
<a name="l04448"></a>04448     apVal[i] = pRec;
<a name="l04449"></a>04449     <a class="code" href="vdbe_8c.html#a5bd05ac6e7d78cc6314d4d02b0e32793">storeTypeInfo</a>(pRec, encoding);
<a name="l04450"></a>04450   }
<a name="l04451"></a>04451   ctx.<a class="code" href="structsqlite3__context.html#af4215c87be2c0cb10868f623a552a2aa">pFunc</a> = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a041e9019dd14f775e7dc639e35127d39">pFunc</a>;
<a name="l04452"></a>04452   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l04453"></a>04453   ctx.<a class="code" href="structsqlite3__context.html#a7b84aa5920329cb0eb943832175b48b5">pMem</a> = pMem = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l04454"></a>04454   pMem-&gt;<a class="code" href="structMem.html#a5a613756e096c221ec68077c28424d84">n</a>++;
<a name="l04455"></a>04455   ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>.<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>;
<a name="l04456"></a>04456   ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>.<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a> = 0;
<a name="l04457"></a>04457   ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>.<a class="code" href="structMem.html#a68cd8f196d9dc8ab27845e1b4abbc95c">zMalloc</a> = 0;
<a name="l04458"></a>04458   ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>.<a class="code" href="structMem.html#a081ea2f86933d68a8940785b62f638ef">xDel</a> = 0;
<a name="l04459"></a>04459   ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>.<a class="code" href="structMem.html#a478da33d1e83a23931b372f9ddc706f2">db</a> = db;
<a name="l04460"></a>04460   ctx.<a class="code" href="structsqlite3__context.html#ae4351b8da8c6d2676074612c1b8d4af5">isError</a> = 0;
<a name="l04461"></a>04461   ctx.<a class="code" href="structsqlite3__context.html#a4e4b12fb65814515fdb967559693f816">pColl</a> = 0;
<a name="l04462"></a>04462   <span class="keywordflow">if</span>( ctx.<a class="code" href="structsqlite3__context.html#af4215c87be2c0cb10868f623a552a2aa">pFunc</a>-&gt;<a class="code" href="structFuncDef.html#aed4dc88e58b7582668bcaf425c4d053f">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#ad57f921244a73d0689df7276b0a5a7d5">SQLITE_FUNC_NEEDCOLL</a> ){
<a name="l04463"></a>04463     assert( pOp&gt;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a> );
<a name="l04464"></a>04464     assert( pOp[-1].p4type==<a class="code" href="vdbe_8h.html#a75b33b0e5ede33c0da0a513e3ff9cdb8">P4_COLLSEQ</a> );
<a name="l04465"></a>04465     assert( pOp[-1].opcode==<a class="code" href="opcodes_8h.html#a389d9861bd3309094d8496cf44592380">OP_CollSeq</a> );
<a name="l04466"></a>04466     ctx.<a class="code" href="structsqlite3__context.html#a4e4b12fb65814515fdb967559693f816">pColl</a> = pOp[-1].<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aaf1833fde93e43f42bac11511a0e9910">pColl</a>;
<a name="l04467"></a>04467   }
<a name="l04468"></a>04468   (ctx.<a class="code" href="structsqlite3__context.html#af4215c87be2c0cb10868f623a552a2aa">pFunc</a>-&gt;<a class="code" href="structFuncDef.html#ab1d1c623844534b17ea3ccce3f815464">xStep</a>)(&amp;ctx, n, apVal);
<a name="l04469"></a>04469   <span class="keywordflow">if</span>( ctx.<a class="code" href="structsqlite3__context.html#ae4351b8da8c6d2676074612c1b8d4af5">isError</a> ){
<a name="l04470"></a>04470     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(&amp;ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>));
<a name="l04471"></a>04471     rc = ctx.<a class="code" href="structsqlite3__context.html#ae4351b8da8c6d2676074612c1b8d4af5">isError</a>;
<a name="l04472"></a>04472   }
<a name="l04473"></a>04473   <a class="code" href="vdbeInt_8h.html#a434c5e63064c9ac7d87e61fe2e775fc1">sqlite3VdbeMemRelease</a>(&amp;ctx.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>);
<a name="l04474"></a>04474   <span class="keywordflow">break</span>;
<a name="l04475"></a>04475 }
<a name="l04476"></a>04476 
<a name="l04477"></a>04477 <span class="comment">/* Opcode: AggFinal P1 P2 * P4 *</span>
<a name="l04478"></a>04478 <span class="comment">**</span>
<a name="l04479"></a>04479 <span class="comment">** Execute the finalizer function for an aggregate.  P1 is</span>
<a name="l04480"></a>04480 <span class="comment">** the memory location that is the accumulator for the aggregate.</span>
<a name="l04481"></a>04481 <span class="comment">**</span>
<a name="l04482"></a>04482 <span class="comment">** P2 is the number of arguments that the step function takes and</span>
<a name="l04483"></a>04483 <span class="comment">** P4 is a pointer to the FuncDef for this function.  The P2</span>
<a name="l04484"></a>04484 <span class="comment">** argument is not used by this opcode.  It is only there to disambiguate</span>
<a name="l04485"></a>04485 <span class="comment">** functions that can take varying numbers of arguments.  The</span>
<a name="l04486"></a>04486 <span class="comment">** P4 argument is only needed for the degenerate case where</span>
<a name="l04487"></a>04487 <span class="comment">** the step function was not previously called.</span>
<a name="l04488"></a>04488 <span class="comment">*/</span>
<a name="l04489"></a>04489 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a143e9a199ff47a8040e681863887a4c7">OP_AggFinal</a>: {
<a name="l04490"></a>04490   <a class="code" href="structMem.html">Mem</a> *pMem;
<a name="l04491"></a>04491   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l04492"></a>04492   pMem = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l04493"></a>04493   assert( (pMem-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> &amp; ~(<a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>|<a class="code" href="vdbeInt_8h.html#acabfe7d13c1ee8b1aa2631ff54ea75f3">MEM_Agg</a>))==0 );
<a name="l04494"></a>04494   rc = <a class="code" href="vdbeInt_8h.html#ac3ced1876f20666b66f106db2c341906">sqlite3VdbeMemFinalize</a>(pMem, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a041e9019dd14f775e7dc639e35127d39">pFunc</a>);
<a name="l04495"></a>04495   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a> ){
<a name="l04496"></a>04496     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="sqlite3_8h.html#a766575996a443f3405e197e0d74e3a9e">sqlite3_value_text</a>(pMem));
<a name="l04497"></a>04497   }
<a name="l04498"></a>04498   <a class="code" href="vdbeInt_8h.html#a94f53f04621df5bca68190710998b086">sqlite3VdbeChangeEncoding</a>(pMem, encoding);
<a name="l04499"></a>04499   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pMem);
<a name="l04500"></a>04500   <span class="keywordflow">if</span>( <a class="code" href="vdbeInt_8h.html#ad54b97fcfa33086c7313ef1754d65362">sqlite3VdbeMemTooBig</a>(pMem) ){
<a name="l04501"></a>04501     <span class="keywordflow">goto</span> too_big;
<a name="l04502"></a>04502   }
<a name="l04503"></a>04503   <span class="keywordflow">break</span>;
<a name="l04504"></a>04504 }
<a name="l04505"></a>04505 
<a name="l04506"></a>04506 
<a name="l04507"></a>04507 <span class="preprocessor">#if !defined(SQLITE_OMIT_VACUUM) &amp;&amp; !defined(SQLITE_OMIT_ATTACH)</span>
<a name="l04508"></a>04508 <span class="preprocessor"></span><span class="comment">/* Opcode: Vacuum * * * * *</span>
<a name="l04509"></a>04509 <span class="comment">**</span>
<a name="l04510"></a>04510 <span class="comment">** Vacuum the entire database.  This opcode will cause other virtual</span>
<a name="l04511"></a>04511 <span class="comment">** machines to be created and run.  It may not be called from within</span>
<a name="l04512"></a>04512 <span class="comment">** a transaction.</span>
<a name="l04513"></a>04513 <span class="comment">*/</span>
<a name="l04514"></a>04514 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a8a8a40eb980c9b23c656bf62476493f9">OP_Vacuum</a>: {
<a name="l04515"></a>04515   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse; 
<a name="l04516"></a>04516   rc = <a class="code" href="sqliteInt_8h.html#a3eb343636c4e452f5da63891522633d6">sqlite3RunVacuum</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db);
<a name="l04517"></a>04517   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04518"></a>04518   <span class="keywordflow">break</span>;
<a name="l04519"></a>04519 }
<a name="l04520"></a>04520 <span class="preprocessor">#endif</span>
<a name="l04521"></a>04521 <span class="preprocessor"></span>
<a name="l04522"></a>04522 <span class="preprocessor">#if !defined(SQLITE_OMIT_AUTOVACUUM)</span>
<a name="l04523"></a>04523 <span class="preprocessor"></span><span class="comment">/* Opcode: IncrVacuum P1 P2 * * *</span>
<a name="l04524"></a>04524 <span class="comment">**</span>
<a name="l04525"></a>04525 <span class="comment">** Perform a single step of the incremental vacuum procedure on</span>
<a name="l04526"></a>04526 <span class="comment">** the P1 database. If the vacuum has finished, jump to instruction</span>
<a name="l04527"></a>04527 <span class="comment">** P2. Otherwise, fall through to the next instruction.</span>
<a name="l04528"></a>04528 <span class="comment">*/</span>
<a name="l04529"></a>04529 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a211fbdef03e8a0c872bc6e27f258f784">OP_IncrVacuum</a>: {        <span class="comment">/* jump */</span>
<a name="l04530"></a>04530   <a class="code" href="structBtree.html">Btree</a> *pBt;
<a name="l04531"></a>04531 
<a name="l04532"></a>04532   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&gt;=0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>&lt;db-&gt;<a class="code" href="structsqlite3.html#a03d047bc289999b0e39d8637f0762489">nDb</a> );
<a name="l04533"></a>04533   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>))!=0 );
<a name="l04534"></a>04534   pBt = db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>;
<a name="l04535"></a>04535   rc = <a class="code" href="btree_8c.html#acd8b8c1daba4ffc422e5efe414f60cf4">sqlite3BtreeIncrVacuum</a>(pBt);
<a name="l04536"></a>04536   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#afd1d7cc5f2e803af5e944f548e28f141">SQLITE_DONE</a> ){
<a name="l04537"></a>04537     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l04538"></a>04538     rc = <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>;
<a name="l04539"></a>04539   }
<a name="l04540"></a>04540   <span class="keywordflow">break</span>;
<a name="l04541"></a>04541 }
<a name="l04542"></a>04542 <span class="preprocessor">#endif</span>
<a name="l04543"></a>04543 <span class="preprocessor"></span>
<a name="l04544"></a>04544 <span class="comment">/* Opcode: Expire P1 * * * *</span>
<a name="l04545"></a>04545 <span class="comment">**</span>
<a name="l04546"></a>04546 <span class="comment">** Cause precompiled statements to become expired. An expired statement</span>
<a name="l04547"></a>04547 <span class="comment">** fails with an error code of SQLITE_SCHEMA if it is ever executed </span>
<a name="l04548"></a>04548 <span class="comment">** (via sqlite3_step()).</span>
<a name="l04549"></a>04549 <span class="comment">** </span>
<a name="l04550"></a>04550 <span class="comment">** If P1 is 0, then all SQL statements become expired. If P1 is non-zero,</span>
<a name="l04551"></a>04551 <span class="comment">** then only the currently executing statement is affected. </span>
<a name="l04552"></a>04552 <span class="comment">*/</span>
<a name="l04553"></a>04553 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a78605af1570cfef575f7d040f001ef10">OP_Expire</a>: {
<a name="l04554"></a>04554   <span class="keywordflow">if</span>( !pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> ){
<a name="l04555"></a>04555     <a class="code" href="sqliteInt_8h.html#ac49dbebed4f062b16e866f024c262e95">sqlite3ExpirePreparedStatements</a>(db);
<a name="l04556"></a>04556   }<span class="keywordflow">else</span>{
<a name="l04557"></a>04557     p-&gt;<a class="code" href="structVdbe.html#ab281d7519a1e6f60163eab9b15048eda">expired</a> = 1;
<a name="l04558"></a>04558   }
<a name="l04559"></a>04559   <span class="keywordflow">break</span>;
<a name="l04560"></a>04560 }
<a name="l04561"></a>04561 
<a name="l04562"></a>04562 <span class="preprocessor">#ifndef SQLITE_OMIT_SHARED_CACHE</span>
<a name="l04563"></a>04563 <span class="preprocessor"></span><span class="comment">/* Opcode: TableLock P1 P2 P3 P4 *</span>
<a name="l04564"></a>04564 <span class="comment">**</span>
<a name="l04565"></a>04565 <span class="comment">** Obtain a lock on a particular table. This instruction is only used when</span>
<a name="l04566"></a>04566 <span class="comment">** the shared-cache feature is enabled. </span>
<a name="l04567"></a>04567 <span class="comment">**</span>
<a name="l04568"></a>04568 <span class="comment">** If P1 is  the index of the database in sqlite3.aDb[] of the database</span>
<a name="l04569"></a>04569 <span class="comment">** on which the lock is acquired.  A readlock is obtained if P3==0 or</span>
<a name="l04570"></a>04570 <span class="comment">** a write lock if P3==1.</span>
<a name="l04571"></a>04571 <span class="comment">**</span>
<a name="l04572"></a>04572 <span class="comment">** P2 contains the root-page of the table to lock.</span>
<a name="l04573"></a>04573 <span class="comment">**</span>
<a name="l04574"></a>04574 <span class="comment">** P4 contains a pointer to the name of the table being locked. This is only</span>
<a name="l04575"></a>04575 <span class="comment">** used to generate an error message if the lock cannot be obtained.</span>
<a name="l04576"></a>04576 <span class="comment">*/</span>
<a name="l04577"></a>04577 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a750be03141ab0f75a5665306f504f0af">OP_TableLock</a>: {
<a name="l04578"></a>04578   <span class="keywordtype">int</span> p1 = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>; 
<a name="l04579"></a>04579   <a class="code" href="sqliteInt_8h.html#a74a0f6424ae628af25f23f0a35f6ead3">u8</a> isWriteLock = pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>;
<a name="l04580"></a>04580   assert( p1&gt;=0 &amp;&amp; p1&lt;db-&gt;nDb );
<a name="l04581"></a>04581   assert( (p-&gt;<a class="code" href="structVdbe.html#a30b4e20cc4e4dc9f6652f37d86759fcb">btreeMask</a> &amp; (1&lt;&lt;p1))!=0 );
<a name="l04582"></a>04582   assert( isWriteLock==0 || isWriteLock==1 );
<a name="l04583"></a>04583   rc = <a class="code" href="btree_8c.html#ac35d9d8d0f266255426a432a77d08942">sqlite3BtreeLockTable</a>(db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[p1].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, isWriteLock);
<a name="l04584"></a>04584   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#ab1a65dcef7ac3d761c7f0a07e3428a58">SQLITE_LOCKED</a> ){
<a name="l04585"></a>04585     <span class="keyword">const</span> <span class="keywordtype">char</span> *z = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>;
<a name="l04586"></a>04586     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;database table is locked: %s&quot;</span>, z);
<a name="l04587"></a>04587   }
<a name="l04588"></a>04588   <span class="keywordflow">break</span>;
<a name="l04589"></a>04589 }
<a name="l04590"></a>04590 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_SHARED_CACHE */</span>
<a name="l04591"></a>04591 
<a name="l04592"></a>04592 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04593"></a>04593 <span class="preprocessor"></span><span class="comment">/* Opcode: VBegin * * * P4 *</span>
<a name="l04594"></a>04594 <span class="comment">**</span>
<a name="l04595"></a>04595 <span class="comment">** P4 may be a pointer to an sqlite3_vtab structure. If so, call the </span>
<a name="l04596"></a>04596 <span class="comment">** xBegin method for that table.</span>
<a name="l04597"></a>04597 <span class="comment">**</span>
<a name="l04598"></a>04598 <span class="comment">** Also, whether or not P4 is set, check that this is not being called from</span>
<a name="l04599"></a>04599 <span class="comment">** within a callback to a virtual table xSync() method. If it is, set the</span>
<a name="l04600"></a>04600 <span class="comment">** error code to SQLITE_LOCKED.</span>
<a name="l04601"></a>04601 <span class="comment">*/</span>
<a name="l04602"></a>04602 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a848b22e17cc1f1297ab05531030c9e92">OP_VBegin</a>: {
<a name="l04603"></a>04603   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a47739d78857f4d8fe62b4a5e0d721345">pVtab</a>;
<a name="l04604"></a>04604   rc = <a class="code" href="sqliteInt_8h.html#abdc5f94e9562d909ba32168ff6b01ce3">sqlite3VtabBegin</a>(db, pVtab);
<a name="l04605"></a>04605   <span class="keywordflow">if</span>( pVtab ){
<a name="l04606"></a>04606     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l04607"></a>04607     p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>;
<a name="l04608"></a>04608     pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l04609"></a>04609   }
<a name="l04610"></a>04610   <span class="keywordflow">break</span>;
<a name="l04611"></a>04611 }
<a name="l04612"></a>04612 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l04613"></a>04613 
<a name="l04614"></a>04614 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04615"></a>04615 <span class="preprocessor"></span><span class="comment">/* Opcode: VCreate P1 * * P4 *</span>
<a name="l04616"></a>04616 <span class="comment">**</span>
<a name="l04617"></a>04617 <span class="comment">** P4 is the name of a virtual table in database P1. Call the xCreate method</span>
<a name="l04618"></a>04618 <span class="comment">** for that table.</span>
<a name="l04619"></a>04619 <span class="comment">*/</span>
<a name="l04620"></a>04620 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a95f66d60979d7637c6088c2ac85a2b82">OP_VCreate</a>: {
<a name="l04621"></a>04621   rc = <a class="code" href="sqliteInt_8h.html#a1231e3799c456638bf26bee86911486a">sqlite3VtabCallCreate</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>, &amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l04622"></a>04622   <span class="keywordflow">break</span>;
<a name="l04623"></a>04623 }
<a name="l04624"></a>04624 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l04625"></a>04625 
<a name="l04626"></a>04626 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04627"></a>04627 <span class="preprocessor"></span><span class="comment">/* Opcode: VDestroy P1 * * P4 *</span>
<a name="l04628"></a>04628 <span class="comment">**</span>
<a name="l04629"></a>04629 <span class="comment">** P4 is the name of a virtual table in database P1.  Call the xDestroy method</span>
<a name="l04630"></a>04630 <span class="comment">** of that table.</span>
<a name="l04631"></a>04631 <span class="comment">*/</span>
<a name="l04632"></a>04632 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#accd47d5ad85a981d887f202557daad64">OP_VDestroy</a>: {
<a name="l04633"></a>04633   p-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a> = 2;
<a name="l04634"></a>04634   rc = <a class="code" href="sqliteInt_8h.html#a60ddbe3bf37aee4c819047a012f85046">sqlite3VtabCallDestroy</a>(db, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l04635"></a>04635   p-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a> = 0;
<a name="l04636"></a>04636   <span class="keywordflow">break</span>;
<a name="l04637"></a>04637 }
<a name="l04638"></a>04638 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l04639"></a>04639 
<a name="l04640"></a>04640 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04641"></a>04641 <span class="preprocessor"></span><span class="comment">/* Opcode: VOpen P1 * * P4 *</span>
<a name="l04642"></a>04642 <span class="comment">**</span>
<a name="l04643"></a>04643 <span class="comment">** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.</span>
<a name="l04644"></a>04644 <span class="comment">** P1 is a cursor number.  This opcode opens a cursor to the virtual</span>
<a name="l04645"></a>04645 <span class="comment">** table and stores that cursor in P1.</span>
<a name="l04646"></a>04646 <span class="comment">*/</span>
<a name="l04647"></a>04647 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a46978f7bad0f7fd6157acf8eddaae12e">OP_VOpen</a>: {
<a name="l04648"></a>04648   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCur = 0;
<a name="l04649"></a>04649   <a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pVtabCursor = 0;
<a name="l04650"></a>04650 
<a name="l04651"></a>04651   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a47739d78857f4d8fe62b4a5e0d721345">pVtab</a>;
<a name="l04652"></a>04652   <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule = (<a class="code" href="structsqlite3__module.html">sqlite3_module</a> *)pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>;
<a name="l04653"></a>04653 
<a name="l04654"></a>04654   assert(pVtab &amp;&amp; pModule);
<a name="l04655"></a>04655   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04656"></a>04656   rc = pModule-&gt;<a class="code" href="structsqlite3__module.html#a2cb9f8c149617189efa6ceec0a3211e9">xOpen</a>(pVtab, &amp;pVtabCursor);
<a name="l04657"></a>04657   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l04658"></a>04658   p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>;
<a name="l04659"></a>04659   pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l04660"></a>04660   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04661"></a>04661   <span class="keywordflow">if</span>( <a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a>==rc ){
<a name="l04662"></a>04662     <span class="comment">/* Initialize sqlite3_vtab_cursor base class */</span>
<a name="l04663"></a>04663     pVtabCursor-&gt;<a class="code" href="structsqlite3__vtab__cursor.html#a2989d9f84a35506c3ef9fe9e9ecd3365">pVtab</a> = pVtab;
<a name="l04664"></a>04664 
<a name="l04665"></a>04665     <span class="comment">/* Initialise vdbe cursor object */</span>
<a name="l04666"></a>04666     pCur = <a class="code" href="vdbe_8c.html#a5e6a4a459c5d72f8cc5478bea910dfdf">allocateCursor</a>(p, pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, &amp;pOp[-1], -1, 0);
<a name="l04667"></a>04667     <span class="keywordflow">if</span>( pCur ){
<a name="l04668"></a>04668       pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a> = pVtabCursor;
<a name="l04669"></a>04669       pCur-&gt;<a class="code" href="structVdbeCursor.html#ab385a7fa060ff00bbe9e6861bb599505">pModule</a> = pVtabCursor-&gt;<a class="code" href="structsqlite3__vtab__cursor.html#a2989d9f84a35506c3ef9fe9e9ecd3365">pVtab</a>-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>;
<a name="l04670"></a>04670     }<span class="keywordflow">else</span>{
<a name="l04671"></a>04671       db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l04672"></a>04672       pModule-&gt;<a class="code" href="structsqlite3__module.html#a514c66634a5297ca9879947fa6f8f10f">xClose</a>(pVtabCursor);
<a name="l04673"></a>04673     }
<a name="l04674"></a>04674   }
<a name="l04675"></a>04675   <span class="keywordflow">break</span>;
<a name="l04676"></a>04676 }
<a name="l04677"></a>04677 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l04678"></a>04678 
<a name="l04679"></a>04679 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04680"></a>04680 <span class="preprocessor"></span><span class="comment">/* Opcode: VFilter P1 P2 P3 P4 *</span>
<a name="l04681"></a>04681 <span class="comment">**</span>
<a name="l04682"></a>04682 <span class="comment">** P1 is a cursor opened using VOpen.  P2 is an address to jump to if</span>
<a name="l04683"></a>04683 <span class="comment">** the filtered result set is empty.</span>
<a name="l04684"></a>04684 <span class="comment">**</span>
<a name="l04685"></a>04685 <span class="comment">** P4 is either NULL or a string that was generated by the xBestIndex</span>
<a name="l04686"></a>04686 <span class="comment">** method of the module.  The interpretation of the P4 string is left</span>
<a name="l04687"></a>04687 <span class="comment">** to the module implementation.</span>
<a name="l04688"></a>04688 <span class="comment">**</span>
<a name="l04689"></a>04689 <span class="comment">** This opcode invokes the xFilter method on the virtual table specified</span>
<a name="l04690"></a>04690 <span class="comment">** by P1.  The integer query plan parameter to xFilter is stored in register</span>
<a name="l04691"></a>04691 <span class="comment">** P3. Register P3+1 stores the argc parameter to be passed to the</span>
<a name="l04692"></a>04692 <span class="comment">** xFilter method. Registers P3+2..P3+1+argc are the argc</span>
<a name="l04693"></a>04693 <span class="comment">** additional parameters which are passed to</span>
<a name="l04694"></a>04694 <span class="comment">** xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.</span>
<a name="l04695"></a>04695 <span class="comment">**</span>
<a name="l04696"></a>04696 <span class="comment">** A jump is made to P2 if the result set after filtering would be empty.</span>
<a name="l04697"></a>04697 <span class="comment">*/</span>
<a name="l04698"></a>04698 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a8ee396bf68f267316ea560fa54587ed2">OP_VFilter</a>: {   <span class="comment">/* jump */</span>
<a name="l04699"></a>04699   <span class="keywordtype">int</span> nArg;
<a name="l04700"></a>04700   <span class="keywordtype">int</span> iQuery;
<a name="l04701"></a>04701   <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule;
<a name="l04702"></a>04702   <a class="code" href="structMem.html">Mem</a> *pQuery = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l04703"></a>04703   <a class="code" href="structMem.html">Mem</a> *pArgc = &amp;pQuery[1];
<a name="l04704"></a>04704   <a class="code" href="structsqlite3__vtab__cursor.html">sqlite3_vtab_cursor</a> *pVtabCursor;
<a name="l04705"></a>04705   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab;
<a name="l04706"></a>04706 
<a name="l04707"></a>04707   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCur = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l04708"></a>04708 
<a name="l04709"></a>04709   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pQuery);
<a name="l04710"></a>04710   assert( pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a> );
<a name="l04711"></a>04711   pVtabCursor = pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>;
<a name="l04712"></a>04712   pVtab = pVtabCursor-&gt;<a class="code" href="structsqlite3__vtab__cursor.html#a2989d9f84a35506c3ef9fe9e9ecd3365">pVtab</a>;
<a name="l04713"></a>04713   pModule = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>;
<a name="l04714"></a>04714 
<a name="l04715"></a>04715   <span class="comment">/* Grab the index number and argc parameters */</span>
<a name="l04716"></a>04716   assert( (pQuery-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>&amp;<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>)!=0 &amp;&amp; pArgc-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a>==<a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a> );
<a name="l04717"></a>04717   nArg = pArgc-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l04718"></a>04718   iQuery = pQuery-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a>;
<a name="l04719"></a>04719 
<a name="l04720"></a>04720   <span class="comment">/* Invoke the xFilter method */</span>
<a name="l04721"></a>04721   {
<a name="l04722"></a>04722     <span class="keywordtype">int</span> res = 0;
<a name="l04723"></a>04723     <span class="keywordtype">int</span> i;
<a name="l04724"></a>04724     <a class="code" href="structMem.html">Mem</a> **apArg = p-&gt;<a class="code" href="structVdbe.html#a74fd4612c55ac2fde475096a4d2605b5">apArg</a>;
<a name="l04725"></a>04725     <span class="keywordflow">for</span>(i = 0; i&lt;nArg; i++){
<a name="l04726"></a>04726       apArg[i] = &amp;pArgc[i+1];
<a name="l04727"></a>04727       <a class="code" href="vdbe_8c.html#a5bd05ac6e7d78cc6314d4d02b0e32793">storeTypeInfo</a>(apArg[i], 0);
<a name="l04728"></a>04728     }
<a name="l04729"></a>04729 
<a name="l04730"></a>04730     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04731"></a>04731     <a class="code" href="sqliteInt_8h.html#abea58f5048efa3c3820a4ade28047696">sqlite3VtabLock</a>(pVtab);
<a name="l04732"></a>04732     p-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a> = 1;
<a name="l04733"></a>04733     rc = pModule-&gt;<a class="code" href="structsqlite3__module.html#a1ddde32dcae461910096ebb2c42d1a6a">xFilter</a>(pVtabCursor, iQuery, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>, nArg, apArg);
<a name="l04734"></a>04734     p-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a> = 0;
<a name="l04735"></a>04735     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l04736"></a>04736     p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>;
<a name="l04737"></a>04737     pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l04738"></a>04738     <a class="code" href="sqliteInt_8h.html#a13ba8c3126d20b116817f197da61f0c9">sqlite3VtabUnlock</a>(db, pVtab);
<a name="l04739"></a>04739     <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04740"></a>04740       res = pModule-&gt;<a class="code" href="structsqlite3__module.html#ae10cf7d9a7edfecf1daa34a214bf6a64">xEof</a>(pVtabCursor);
<a name="l04741"></a>04741     }
<a name="l04742"></a>04742     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04743"></a>04743 
<a name="l04744"></a>04744     <span class="keywordflow">if</span>( res ){
<a name="l04745"></a>04745       pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l04746"></a>04746     }
<a name="l04747"></a>04747   }
<a name="l04748"></a>04748   pCur-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> = 0;
<a name="l04749"></a>04749 
<a name="l04750"></a>04750   <span class="keywordflow">break</span>;
<a name="l04751"></a>04751 }
<a name="l04752"></a>04752 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l04753"></a>04753 
<a name="l04754"></a>04754 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04755"></a>04755 <span class="preprocessor"></span><span class="comment">/* Opcode: VRowid P1 P2 * * *</span>
<a name="l04756"></a>04756 <span class="comment">**</span>
<a name="l04757"></a>04757 <span class="comment">** Store into register P2  the rowid of</span>
<a name="l04758"></a>04758 <span class="comment">** the virtual-table that the P1 cursor is pointing to.</span>
<a name="l04759"></a>04759 <span class="comment">*/</span>
<a name="l04760"></a>04760 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a7ad2caeb5a9037efc76f219cb8a1005f">OP_VRowid</a>: {             <span class="comment">/* out2-prerelease */</span>
<a name="l04761"></a>04761   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab;
<a name="l04762"></a>04762   <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule;
<a name="l04763"></a>04763   <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> iRow;
<a name="l04764"></a>04764   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCur = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l04765"></a>04765 
<a name="l04766"></a>04766   assert( pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a> );
<a name="l04767"></a>04767   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> ){
<a name="l04768"></a>04768     <span class="keywordflow">break</span>;
<a name="l04769"></a>04769   }
<a name="l04770"></a>04770   pVtab = pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>-&gt;<a class="code" href="structsqlite3__vtab__cursor.html#a2989d9f84a35506c3ef9fe9e9ecd3365">pVtab</a>;
<a name="l04771"></a>04771   pModule = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>;
<a name="l04772"></a>04772   assert( pModule-&gt;<a class="code" href="structsqlite3__module.html#a1e119b28bd3ad706d1982aaa938aac79">xRowid</a> );
<a name="l04773"></a>04773   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04774"></a>04774   rc = pModule-&gt;<a class="code" href="structsqlite3__module.html#a1e119b28bd3ad706d1982aaa938aac79">xRowid</a>(pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>, &amp;iRow);
<a name="l04775"></a>04775   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l04776"></a>04776   p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>;
<a name="l04777"></a>04777   pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l04778"></a>04778   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04779"></a>04779   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(pOut, <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>);
<a name="l04780"></a>04780   pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = iRow;
<a name="l04781"></a>04781   <span class="keywordflow">break</span>;
<a name="l04782"></a>04782 }
<a name="l04783"></a>04783 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l04784"></a>04784 
<a name="l04785"></a>04785 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04786"></a>04786 <span class="preprocessor"></span><span class="comment">/* Opcode: VColumn P1 P2 P3 * *</span>
<a name="l04787"></a>04787 <span class="comment">**</span>
<a name="l04788"></a>04788 <span class="comment">** Store the value of the P2-th column of</span>
<a name="l04789"></a>04789 <span class="comment">** the row of the virtual-table that the </span>
<a name="l04790"></a>04790 <span class="comment">** P1 cursor is pointing to into register P3.</span>
<a name="l04791"></a>04791 <span class="comment">*/</span>
<a name="l04792"></a>04792 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a7f4539d99d02ffbc7a253053d49a49ac">OP_VColumn</a>: {
<a name="l04793"></a>04793   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab;
<a name="l04794"></a>04794   <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule;
<a name="l04795"></a>04795   <a class="code" href="structMem.html">Mem</a> *pDest;
<a name="l04796"></a>04796   <a class="code" href="structsqlite3__context.html">sqlite3_context</a> sContext;
<a name="l04797"></a>04797 
<a name="l04798"></a>04798   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCur = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l04799"></a>04799   assert( pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a> );
<a name="l04800"></a>04800   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&gt;0 &amp;&amp; pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>&lt;=p-&gt;<a class="code" href="structVdbe.html#a10a19309607617a75d3722219d3c7615">nMem</a> );
<a name="l04801"></a>04801   pDest = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l04802"></a>04802   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> ){
<a name="l04803"></a>04803     <a class="code" href="vdbeInt_8h.html#a312cd58d3f6b7a2d9c73579685b20c02">sqlite3VdbeMemSetNull</a>(pDest);
<a name="l04804"></a>04804     <span class="keywordflow">break</span>;
<a name="l04805"></a>04805   }
<a name="l04806"></a>04806   pVtab = pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>-&gt;<a class="code" href="structsqlite3__vtab__cursor.html#a2989d9f84a35506c3ef9fe9e9ecd3365">pVtab</a>;
<a name="l04807"></a>04807   pModule = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>;
<a name="l04808"></a>04808   assert( pModule-&gt;<a class="code" href="structsqlite3__module.html#a4c82dc60335ba40c816cdd6c4dce2950">xColumn</a> );
<a name="l04809"></a>04809   memset(&amp;sContext, 0, <span class="keyword">sizeof</span>(sContext));
<a name="l04810"></a>04810 
<a name="l04811"></a>04811   <span class="comment">/* The output cell may already have a buffer allocated. Move</span>
<a name="l04812"></a>04812 <span class="comment">  ** the current contents to sContext.s so in case the user-function </span>
<a name="l04813"></a>04813 <span class="comment">  ** can use the already allocated buffer instead of allocating a </span>
<a name="l04814"></a>04814 <span class="comment">  ** new one.</span>
<a name="l04815"></a>04815 <span class="comment">  */</span>
<a name="l04816"></a>04816   <a class="code" href="vdbeInt_8h.html#ac6decc64fa0cfb686d6e548953d7705a">sqlite3VdbeMemMove</a>(&amp;sContext.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>, pDest);
<a name="l04817"></a>04817   <a class="code" href="vdbeInt_8h.html#a8703eafa553a17c57a19b4429465b389">MemSetTypeFlag</a>(&amp;sContext.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>, <a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>);
<a name="l04818"></a>04818 
<a name="l04819"></a>04819   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04820"></a>04820   rc = pModule-&gt;<a class="code" href="structsqlite3__module.html#a4c82dc60335ba40c816cdd6c4dce2950">xColumn</a>(pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>, &amp;sContext, pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>);
<a name="l04821"></a>04821   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l04822"></a>04822   p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>;
<a name="l04823"></a>04823   pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l04824"></a>04824 
<a name="l04825"></a>04825   <span class="comment">/* Copy the result of the function to the P3 register. We</span>
<a name="l04826"></a>04826 <span class="comment">  ** do this regardless of whether or not an error occured to ensure any</span>
<a name="l04827"></a>04827 <span class="comment">  ** dynamic allocation in sContext.s (a Mem struct) is  released.</span>
<a name="l04828"></a>04828 <span class="comment">  */</span>
<a name="l04829"></a>04829   <a class="code" href="vdbeInt_8h.html#a94f53f04621df5bca68190710998b086">sqlite3VdbeChangeEncoding</a>(&amp;sContext.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>, encoding);
<a name="l04830"></a>04830   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pDest);
<a name="l04831"></a>04831   <a class="code" href="vdbeInt_8h.html#ac6decc64fa0cfb686d6e548953d7705a">sqlite3VdbeMemMove</a>(pDest, &amp;sContext.<a class="code" href="structsqlite3__context.html#a53d44518a1f7f57ce5a2d73b6e8d2c14">s</a>);
<a name="l04832"></a>04832   <a class="code" href="vdbe_8c.html#a1802d63183704aff0a36182937915cd5">UPDATE_MAX_BLOBSIZE</a>(pDest);
<a name="l04833"></a>04833 
<a name="l04834"></a>04834   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ){
<a name="l04835"></a>04835     <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04836"></a>04836   }
<a name="l04837"></a>04837   <span class="keywordflow">if</span>( <a class="code" href="vdbeInt_8h.html#ad54b97fcfa33086c7313ef1754d65362">sqlite3VdbeMemTooBig</a>(pDest) ){
<a name="l04838"></a>04838     <span class="keywordflow">goto</span> too_big;
<a name="l04839"></a>04839   }
<a name="l04840"></a>04840   <span class="keywordflow">break</span>;
<a name="l04841"></a>04841 }
<a name="l04842"></a>04842 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l04843"></a>04843 
<a name="l04844"></a>04844 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04845"></a>04845 <span class="preprocessor"></span><span class="comment">/* Opcode: VNext P1 P2 * * *</span>
<a name="l04846"></a>04846 <span class="comment">**</span>
<a name="l04847"></a>04847 <span class="comment">** Advance virtual table P1 to the next row in its result set and</span>
<a name="l04848"></a>04848 <span class="comment">** jump to instruction P2.  Or, if the virtual table has reached</span>
<a name="l04849"></a>04849 <span class="comment">** the end of its result set, then fall through to the next instruction.</span>
<a name="l04850"></a>04850 <span class="comment">*/</span>
<a name="l04851"></a>04851 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aaa87c642373311ebf2c89a120def52de">OP_VNext</a>: {   <span class="comment">/* jump */</span>
<a name="l04852"></a>04852   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab;
<a name="l04853"></a>04853   <span class="keyword">const</span> <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule;
<a name="l04854"></a>04854   <span class="keywordtype">int</span> res = 0;
<a name="l04855"></a>04855 
<a name="l04856"></a>04856   <a class="code" href="structVdbeCursor.html">VdbeCursor</a> *pCur = p-&gt;<a class="code" href="structVdbe.html#a8bd1b6ecdc16918e10ee1ae90b4e19ef">apCsr</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l04857"></a>04857   assert( pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a> );
<a name="l04858"></a>04858   <span class="keywordflow">if</span>( pCur-&gt;<a class="code" href="structVdbeCursor.html#af7c01a62f0445440e4200f7601ab0a15">nullRow</a> ){
<a name="l04859"></a>04859     <span class="keywordflow">break</span>;
<a name="l04860"></a>04860   }
<a name="l04861"></a>04861   pVtab = pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>-&gt;<a class="code" href="structsqlite3__vtab__cursor.html#a2989d9f84a35506c3ef9fe9e9ecd3365">pVtab</a>;
<a name="l04862"></a>04862   pModule = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>;
<a name="l04863"></a>04863   assert( pModule-&gt;<a class="code" href="structsqlite3__module.html#aa739d9a2081db7bf786f1f9fb9d92264">xNext</a> );
<a name="l04864"></a>04864 
<a name="l04865"></a>04865   <span class="comment">/* Invoke the xNext() method of the module. There is no way for the</span>
<a name="l04866"></a>04866 <span class="comment">  ** underlying implementation to return an error if one occurs during</span>
<a name="l04867"></a>04867 <span class="comment">  ** xNext(). Instead, if an error occurs, true is returned (indicating that </span>
<a name="l04868"></a>04868 <span class="comment">  ** data is available) and the error code returned when xColumn or</span>
<a name="l04869"></a>04869 <span class="comment">  ** some other method is next invoked on the save virtual table cursor.</span>
<a name="l04870"></a>04870 <span class="comment">  */</span>
<a name="l04871"></a>04871   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04872"></a>04872   <a class="code" href="sqliteInt_8h.html#abea58f5048efa3c3820a4ade28047696">sqlite3VtabLock</a>(pVtab);
<a name="l04873"></a>04873   p-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a> = 1;
<a name="l04874"></a>04874   rc = pModule-&gt;<a class="code" href="structsqlite3__module.html#aa739d9a2081db7bf786f1f9fb9d92264">xNext</a>(pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>);
<a name="l04875"></a>04875   p-&gt;<a class="code" href="structVdbe.html#a3b715d5a30b4d2751e638cfd2cefab62">inVtabMethod</a> = 0;
<a name="l04876"></a>04876   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l04877"></a>04877   p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>;
<a name="l04878"></a>04878   pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l04879"></a>04879   <a class="code" href="sqliteInt_8h.html#a13ba8c3126d20b116817f197da61f0c9">sqlite3VtabUnlock</a>(db, pVtab);
<a name="l04880"></a>04880   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04881"></a>04881     res = pModule-&gt;<a class="code" href="structsqlite3__module.html#ae10cf7d9a7edfecf1daa34a214bf6a64">xEof</a>(pCur-&gt;<a class="code" href="structVdbeCursor.html#a2f58fca4f47a313a461f40a0ac553bf5">pVtabCursor</a>);
<a name="l04882"></a>04882   }
<a name="l04883"></a>04883   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04884"></a>04884 
<a name="l04885"></a>04885   <span class="keywordflow">if</span>( !res ){
<a name="l04886"></a>04886     <span class="comment">/* If there is data, jump to P2 */</span>
<a name="l04887"></a>04887     pc = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a> - 1;
<a name="l04888"></a>04888   }
<a name="l04889"></a>04889   <span class="keywordflow">break</span>;
<a name="l04890"></a>04890 }
<a name="l04891"></a>04891 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l04892"></a>04892 
<a name="l04893"></a>04893 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04894"></a>04894 <span class="preprocessor"></span><span class="comment">/* Opcode: VRename P1 * * P4 *</span>
<a name="l04895"></a>04895 <span class="comment">**</span>
<a name="l04896"></a>04896 <span class="comment">** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.</span>
<a name="l04897"></a>04897 <span class="comment">** This opcode invokes the corresponding xRename method. The value</span>
<a name="l04898"></a>04898 <span class="comment">** in register P1 is passed as the zName argument to the xRename method.</span>
<a name="l04899"></a>04899 <span class="comment">*/</span>
<a name="l04900"></a>04900 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a1ecd8fe88dc779c985afc94e5810945b">OP_VRename</a>: {
<a name="l04901"></a>04901   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a47739d78857f4d8fe62b4a5e0d721345">pVtab</a>;
<a name="l04902"></a>04902   <a class="code" href="structMem.html">Mem</a> *pName = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>];
<a name="l04903"></a>04903   assert( pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>-&gt;<a class="code" href="structsqlite3__module.html#af886782e9a1ea5c4b131b2bc373c8092">xRename</a> );
<a name="l04904"></a>04904   <a class="code" href="vdbe_8c.html#a5b53a62063ec152ad85f08c5b6e36949">REGISTER_TRACE</a>(pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>, pName);
<a name="l04905"></a>04905 
<a name="l04906"></a>04906   <a class="code" href="vdbe_8c.html#a9aa45b1a0b74041d343d26d5bff08377">Stringify</a>(pName, encoding);
<a name="l04907"></a>04907 
<a name="l04908"></a>04908   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04909"></a>04909   <a class="code" href="sqliteInt_8h.html#abea58f5048efa3c3820a4ade28047696">sqlite3VtabLock</a>(pVtab);
<a name="l04910"></a>04910   rc = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>-&gt;<a class="code" href="structsqlite3__module.html#af886782e9a1ea5c4b131b2bc373c8092">xRename</a>(pVtab, pName-&gt;<a class="code" href="structMem.html#a85c51a0b445063ba913693517860f5ea">z</a>);
<a name="l04911"></a>04911   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l04912"></a>04912   p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>;
<a name="l04913"></a>04913   pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l04914"></a>04914   <a class="code" href="sqliteInt_8h.html#a13ba8c3126d20b116817f197da61f0c9">sqlite3VtabUnlock</a>(db, pVtab);
<a name="l04915"></a>04915   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04916"></a>04916 
<a name="l04917"></a>04917   <span class="keywordflow">break</span>;
<a name="l04918"></a>04918 }
<a name="l04919"></a>04919 <span class="preprocessor">#endif</span>
<a name="l04920"></a>04920 <span class="preprocessor"></span>
<a name="l04921"></a>04921 <span class="preprocessor">#ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<a name="l04922"></a>04922 <span class="preprocessor"></span><span class="comment">/* Opcode: VUpdate P1 P2 P3 P4 *</span>
<a name="l04923"></a>04923 <span class="comment">**</span>
<a name="l04924"></a>04924 <span class="comment">** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.</span>
<a name="l04925"></a>04925 <span class="comment">** This opcode invokes the corresponding xUpdate method. P2 values</span>
<a name="l04926"></a>04926 <span class="comment">** are contiguous memory cells starting at P3 to pass to the xUpdate </span>
<a name="l04927"></a>04927 <span class="comment">** invocation. The value in register (P3+P2-1) corresponds to the </span>
<a name="l04928"></a>04928 <span class="comment">** p2th element of the argv array passed to xUpdate.</span>
<a name="l04929"></a>04929 <span class="comment">**</span>
<a name="l04930"></a>04930 <span class="comment">** The xUpdate method will do a DELETE or an INSERT or both.</span>
<a name="l04931"></a>04931 <span class="comment">** The argv[0] element (which corresponds to memory cell P3)</span>
<a name="l04932"></a>04932 <span class="comment">** is the rowid of a row to delete.  If argv[0] is NULL then no </span>
<a name="l04933"></a>04933 <span class="comment">** deletion occurs.  The argv[1] element is the rowid of the new </span>
<a name="l04934"></a>04934 <span class="comment">** row.  This can be NULL to have the virtual table select the new </span>
<a name="l04935"></a>04935 <span class="comment">** rowid for itself.  The subsequent elements in the array are </span>
<a name="l04936"></a>04936 <span class="comment">** the values of columns in the new row.</span>
<a name="l04937"></a>04937 <span class="comment">**</span>
<a name="l04938"></a>04938 <span class="comment">** If P2==1 then no insert is performed.  argv[0] is the rowid of</span>
<a name="l04939"></a>04939 <span class="comment">** a row to delete.</span>
<a name="l04940"></a>04940 <span class="comment">**</span>
<a name="l04941"></a>04941 <span class="comment">** P1 is a boolean flag. If it is set to true and the xUpdate call</span>
<a name="l04942"></a>04942 <span class="comment">** is successful, then the value returned by sqlite3_last_insert_rowid() </span>
<a name="l04943"></a>04943 <span class="comment">** is set to the value of the rowid for the row just inserted.</span>
<a name="l04944"></a>04944 <span class="comment">*/</span>
<a name="l04945"></a>04945 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#aca34cb921c1d7e1998a2a3c78b29c831">OP_VUpdate</a>: {
<a name="l04946"></a>04946   <a class="code" href="structsqlite3__vtab.html">sqlite3_vtab</a> *pVtab = pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#a47739d78857f4d8fe62b4a5e0d721345">pVtab</a>;
<a name="l04947"></a>04947   <a class="code" href="structsqlite3__module.html">sqlite3_module</a> *pModule = (<a class="code" href="structsqlite3__module.html">sqlite3_module</a> *)pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#a4ef8198ca611b73a9b23054dd1e91e2b">pModule</a>;
<a name="l04948"></a>04948   <span class="keywordtype">int</span> nArg = pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>;
<a name="l04949"></a>04949   assert( pOp-&gt;<a class="code" href="structVdbeOp.html#a124dee58d3e0d73c7dfaf811a3311023">p4type</a>==<a class="code" href="vdbe_8h.html#a7a5cdd538a2cb9cf421f7e2f14b3947f">P4_VTAB</a> );
<a name="l04950"></a>04950   <span class="keywordflow">if</span>( pModule-&gt;<a class="code" href="structsqlite3__module.html#a029d0713dbb3c847a6de773a0a179605">xUpdate</a>==0 ){
<a name="l04951"></a>04951     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;read-only table&quot;</span>);
<a name="l04952"></a>04952     rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l04953"></a>04953   }<span class="keywordflow">else</span>{
<a name="l04954"></a>04954     <span class="keywordtype">int</span> i;
<a name="l04955"></a>04955     <a class="code" href="sqlite3_8h.html#a520a95f9080c018b2fade39885bd2e2a">sqlite_int64</a> rowid;
<a name="l04956"></a>04956     <a class="code" href="structMem.html">Mem</a> **apArg = p-&gt;<a class="code" href="structVdbe.html#a74fd4612c55ac2fde475096a4d2605b5">apArg</a>;
<a name="l04957"></a>04957     <a class="code" href="structMem.html">Mem</a> *pX = &amp;p-&gt;<a class="code" href="structVdbe.html#ac36776c53b6ec9054a2826ec83f29953">aMem</a>[pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>];
<a name="l04958"></a>04958     <span class="keywordflow">for</span>(i=0; i&lt;nArg; i++){
<a name="l04959"></a>04959       <a class="code" href="vdbe_8c.html#a5bd05ac6e7d78cc6314d4d02b0e32793">storeTypeInfo</a>(pX, 0);
<a name="l04960"></a>04960       apArg[i] = pX;
<a name="l04961"></a>04961       pX++;
<a name="l04962"></a>04962     }
<a name="l04963"></a>04963     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#afd5afdeac4ae868c2bcb8a2246eefaf0">sqlite3SafetyOff</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04964"></a>04964     <a class="code" href="sqliteInt_8h.html#abea58f5048efa3c3820a4ade28047696">sqlite3VtabLock</a>(pVtab);
<a name="l04965"></a>04965     rc = pModule-&gt;<a class="code" href="structsqlite3__module.html#a029d0713dbb3c847a6de773a0a179605">xUpdate</a>(pVtab, nArg, apArg, &amp;rowid);
<a name="l04966"></a>04966     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>);
<a name="l04967"></a>04967     p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a> = pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a>;
<a name="l04968"></a>04968     pVtab-&gt;<a class="code" href="structsqlite3__vtab.html#afc50eadfdd7cef876633d460deba48d6">zErrMsg</a> = 0;
<a name="l04969"></a>04969     <a class="code" href="sqliteInt_8h.html#a13ba8c3126d20b116817f197da61f0c9">sqlite3VtabUnlock</a>(db, pVtab);
<a name="l04970"></a>04970     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a5478b816780572bc0098dd1e2076ded2">sqlite3SafetyOn</a>(db) ) <span class="keywordflow">goto</span> abort_due_to_misuse;
<a name="l04971"></a>04971     <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a> &amp;&amp; rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04972"></a>04972       assert( nArg&gt;1 &amp;&amp; apArg[0] &amp;&amp; (apArg[0]-&gt;flags&amp;<a class="code" href="vdbeInt_8h.html#ab9581fff4e5313170a5937b0ff0706c6">MEM_Null</a>) );
<a name="l04973"></a>04973       db-&gt;<a class="code" href="structsqlite3.html#a9fff52fc4eb087fbb3e3271994fa5198">lastRowid</a> = rowid;
<a name="l04974"></a>04974     }
<a name="l04975"></a>04975     p-&gt;<a class="code" href="structVdbe.html#a59d1ece56f21e260cdd0fef936242b28">nChange</a>++;
<a name="l04976"></a>04976   }
<a name="l04977"></a>04977   <span class="keywordflow">break</span>;
<a name="l04978"></a>04978 }
<a name="l04979"></a>04979 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_OMIT_VIRTUALTABLE */</span>
<a name="l04980"></a>04980 
<a name="l04981"></a>04981 <span class="preprocessor">#ifndef  SQLITE_OMIT_PAGER_PRAGMAS</span>
<a name="l04982"></a>04982 <span class="preprocessor"></span><span class="comment">/* Opcode: Pagecount P1 P2 * * *</span>
<a name="l04983"></a>04983 <span class="comment">**</span>
<a name="l04984"></a>04984 <span class="comment">** Write the current number of pages in database P1 to memory cell P2.</span>
<a name="l04985"></a>04985 <span class="comment">*/</span>
<a name="l04986"></a>04986 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a48e9f14975cd660c71e459a22c808074">OP_Pagecount</a>: {            <span class="comment">/* out2-prerelease */</span>
<a name="l04987"></a>04987   <span class="keywordtype">int</span> p1 = pOp-&gt;<a class="code" href="structVdbeOp.html#a17c8326a1e3ac5612d4aaaa88f383b3b">p1</a>; 
<a name="l04988"></a>04988   <span class="keywordtype">int</span> nPage;
<a name="l04989"></a>04989   <a class="code" href="structPager.html">Pager</a> *pPager = <a class="code" href="btree_8c.html#aba94a511fed188b724c1c956e55dbd57">sqlite3BtreePager</a>(db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[p1].<a class="code" href="structDb.html#a0633e5a6abfc39246d07cc6a417a5852">pBt</a>);
<a name="l04990"></a>04990 
<a name="l04991"></a>04991   rc = <a class="code" href="pager_8c.html#a6d8fdd988248746fc0c3bb7befb25d4a">sqlite3PagerPagecount</a>(pPager, &amp;nPage);
<a name="l04992"></a>04992   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l04993"></a>04993     pOut-&gt;<a class="code" href="structMem.html#a209bf3317161d1e33af9fe8b512f4974">flags</a> = <a class="code" href="vdbeInt_8h.html#a11312d45cc641efb0cd7bc95d476d933">MEM_Int</a>;
<a name="l04994"></a>04994     pOut-&gt;<a class="code" href="structMem.html#aaed128402175db606f948d4d73786734">u</a>.<a class="code" href="structMem.html#a48360645ba68c4fbbe651a7b7cd5764a">i</a> = nPage;
<a name="l04995"></a>04995   }
<a name="l04996"></a>04996   <span class="keywordflow">break</span>;
<a name="l04997"></a>04997 }
<a name="l04998"></a>04998 <span class="preprocessor">#endif</span>
<a name="l04999"></a>04999 <span class="preprocessor"></span>
<a name="l05000"></a>05000 <span class="preprocessor">#ifndef SQLITE_OMIT_TRACE</span>
<a name="l05001"></a>05001 <span class="preprocessor"></span><span class="comment">/* Opcode: Trace * * * P4 *</span>
<a name="l05002"></a>05002 <span class="comment">**</span>
<a name="l05003"></a>05003 <span class="comment">** If tracing is enabled (by the sqlite3_trace()) interface, then</span>
<a name="l05004"></a>05004 <span class="comment">** the UTF-8 string contained in P4 is emitted on the trace callback.</span>
<a name="l05005"></a>05005 <span class="comment">*/</span>
<a name="l05006"></a>05006 <span class="keywordflow">case</span> <a class="code" href="opcodes_8h.html#a373f164d317ad0443c7e4ac692214c45">OP_Trace</a>: {
<a name="l05007"></a>05007   <span class="keywordflow">if</span>( pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a> ){
<a name="l05008"></a>05008     <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#ae438713860c36ad393eb28702b67fec5">xTrace</a> ){
<a name="l05009"></a>05009       db-&gt;<a class="code" href="structsqlite3.html#ae438713860c36ad393eb28702b67fec5">xTrace</a>(db-&gt;<a class="code" href="structsqlite3.html#ae0920576e4e92f1b736255fcfad649d1">pTraceArg</a>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l05010"></a>05010     }
<a name="l05011"></a>05011 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l05012"></a>05012 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( (db-&gt;<a class="code" href="structsqlite3.html#a8dac784e669d6b8a9f936d3193c1aaec">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a8ff2bd4585f1f950fdd304fcb5d9e709">SQLITE_SqlTrace</a>)!=0 ){
<a name="l05013"></a>05013       sqlite3DebugPrintf(<span class="stringliteral">&quot;SQL-trace: %s\n&quot;</span>, pOp-&gt;<a class="code" href="structVdbeOp.html#a3bbb4382e6b11d1e0a7f157844e4e91d">p4</a>.<a class="code" href="structVdbeOp.html#aa9221aa6dd0a193b1760e4ecfc7376a7">z</a>);
<a name="l05014"></a>05014     }
<a name="l05015"></a>05015 <span class="preprocessor">#endif </span><span class="comment">/* SQLITE_DEBUG */</span>
<a name="l05016"></a>05016   }
<a name="l05017"></a>05017   <span class="keywordflow">break</span>;
<a name="l05018"></a>05018 }
<a name="l05019"></a>05019 <span class="preprocessor">#endif</span>
<a name="l05020"></a>05020 <span class="preprocessor"></span>
<a name="l05021"></a>05021 
<a name="l05022"></a>05022 <span class="comment">/* Opcode: Noop * * * * *</span>
<a name="l05023"></a>05023 <span class="comment">**</span>
<a name="l05024"></a>05024 <span class="comment">** Do nothing.  This instruction is often useful as a jump</span>
<a name="l05025"></a>05025 <span class="comment">** destination.</span>
<a name="l05026"></a>05026 <span class="comment">*/</span>
<a name="l05027"></a>05027 <span class="comment">/*</span>
<a name="l05028"></a>05028 <span class="comment">** The magic Explain opcode are only inserted when explain==2 (which</span>
<a name="l05029"></a>05029 <span class="comment">** is to say when the EXPLAIN QUERY PLAN syntax is used.)</span>
<a name="l05030"></a>05030 <span class="comment">** This opcode records information from the optimizer.  It is the</span>
<a name="l05031"></a>05031 <span class="comment">** the same as a no-op.  This opcodesnever appears in a real VM program.</span>
<a name="l05032"></a>05032 <span class="comment">*/</span>
<a name="l05033"></a>05033 <span class="keywordflow">default</span>: {          <span class="comment">/* This is really OP_Noop and OP_Explain */</span>
<a name="l05034"></a>05034   <span class="keywordflow">break</span>;
<a name="l05035"></a>05035 }
<a name="l05036"></a>05036 
<a name="l05037"></a>05037 <span class="comment">/*****************************************************************************</span>
<a name="l05038"></a>05038 <span class="comment">** The cases of the switch statement above this line should all be indented</span>
<a name="l05039"></a>05039 <span class="comment">** by 6 spaces.  But the left-most 6 spaces have been removed to improve the</span>
<a name="l05040"></a>05040 <span class="comment">** readability.  From this point on down, the normal indentation rules are</span>
<a name="l05041"></a>05041 <span class="comment">** restored.</span>
<a name="l05042"></a>05042 <span class="comment">*****************************************************************************/</span>
<a name="l05043"></a>05043     }
<a name="l05044"></a>05044 
<a name="l05045"></a>05045 <span class="preprocessor">#ifdef VDBE_PROFILE</span>
<a name="l05046"></a>05046 <span class="preprocessor"></span>    {
<a name="l05047"></a>05047       <a class="code" href="sqliteInt_8h.html#a0e0cdb443a471891a042a6bfdc4644ca">u64</a> elapsed = <a class="code" href="hwtime_8h.html#ae0de71b2be73b39d4e3aae0ecf872ef2">sqlite3Hwtime</a>() - start;
<a name="l05048"></a>05048       pOp-&gt;cycles += elapsed;
<a name="l05049"></a>05049       pOp-&gt;cnt++;
<a name="l05050"></a>05050 <span class="preprocessor">#if 0</span>
<a name="l05051"></a>05051 <span class="preprocessor"></span>        fprintf(stdout, <span class="stringliteral">&quot;%10llu &quot;</span>, elapsed);
<a name="l05052"></a>05052         sqlite3VdbePrintOp(stdout, origPc, &amp;p-&gt;<a class="code" href="structVdbe.html#a1ba82f08947b275dd72a3e3095ad02d5">aOp</a>[origPc]);
<a name="l05053"></a>05053 <span class="preprocessor">#endif</span>
<a name="l05054"></a>05054 <span class="preprocessor"></span>    }
<a name="l05055"></a>05055 <span class="preprocessor">#endif</span>
<a name="l05056"></a>05056 <span class="preprocessor"></span>
<a name="l05057"></a>05057     <span class="comment">/* The following code adds nothing to the actual functionality</span>
<a name="l05058"></a>05058 <span class="comment">    ** of the program.  It is only here for testing and debugging.</span>
<a name="l05059"></a>05059 <span class="comment">    ** On the other hand, it does burn CPU cycles every time through</span>
<a name="l05060"></a>05060 <span class="comment">    ** the evaluator loop.  So we can leave it out when NDEBUG is defined.</span>
<a name="l05061"></a>05061 <span class="comment">    */</span>
<a name="l05062"></a>05062 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l05063"></a>05063 <span class="preprocessor"></span>    assert( pc&gt;=-1 &amp;&amp; pc&lt;p-&gt;nOp );
<a name="l05064"></a>05064 
<a name="l05065"></a>05065 <span class="preprocessor">#ifdef SQLITE_DEBUG</span>
<a name="l05066"></a>05066 <span class="preprocessor"></span>    <span class="keywordflow">if</span>( p-&gt;trace ){
<a name="l05067"></a>05067       <span class="keywordflow">if</span>( rc!=0 ) fprintf(p-&gt;trace,<span class="stringliteral">&quot;rc=%d\n&quot;</span>,rc);
<a name="l05068"></a>05068       <span class="keywordflow">if</span>( opProperty &amp; OPFLG_OUT2_PRERELEASE ){
<a name="l05069"></a>05069         registerTrace(p-&gt;trace, pOp-&gt;<a class="code" href="structVdbeOp.html#aba021fa9d30343c16794d9b76d8bffcd">p2</a>, pOut);
<a name="l05070"></a>05070       }
<a name="l05071"></a>05071       <span class="keywordflow">if</span>( opProperty &amp; <a class="code" href="opcodes_8h.html#a3f5aec92398056b314c0b759de82ab52">OPFLG_OUT3</a> ){
<a name="l05072"></a>05072         registerTrace(p-&gt;trace, pOp-&gt;<a class="code" href="structVdbeOp.html#ad7ef3319da20d5423b8cc5da6995d193">p3</a>, pOut);
<a name="l05073"></a>05073       }
<a name="l05074"></a>05074     }
<a name="l05075"></a>05075 <span class="preprocessor">#endif  </span><span class="comment">/* SQLITE_DEBUG */</span>
<a name="l05076"></a>05076 <span class="preprocessor">#endif  </span><span class="comment">/* NDEBUG */</span>
<a name="l05077"></a>05077   }  <span class="comment">/* The end of the for(;;) loop the loops through opcodes */</span>
<a name="l05078"></a>05078 
<a name="l05079"></a>05079   <span class="comment">/* If we reach this point, it means that execution is finished with</span>
<a name="l05080"></a>05080 <span class="comment">  ** an error of some kind.</span>
<a name="l05081"></a>05081 <span class="comment">  */</span>
<a name="l05082"></a>05082 vdbe_error_halt:
<a name="l05083"></a>05083   assert( rc );
<a name="l05084"></a>05084   p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = rc;
<a name="l05085"></a>05085   <a class="code" href="vdbeaux_8c.html#af186927cd7de8e0c35b3d3fdb584c3ab">sqlite3VdbeHalt</a>(p);
<a name="l05086"></a>05086   <span class="keywordflow">if</span>( rc==<a class="code" href="sqlite3_8h.html#a51c0d3d9c66efa031416bc47ca5a2431">SQLITE_IOERR_NOMEM</a> ) db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l05087"></a>05087   rc = <a class="code" href="sqlite3_8h.html#afda25cd6575e87558d2b7cd4a6585f2f">SQLITE_ERROR</a>;
<a name="l05088"></a>05088 
<a name="l05089"></a>05089   <span class="comment">/* This is the only way out of this procedure.  We have to</span>
<a name="l05090"></a>05090 <span class="comment">  ** release the mutexes on btrees that were acquired at the</span>
<a name="l05091"></a>05091 <span class="comment">  ** top. */</span>
<a name="l05092"></a>05092 vdbe_return:
<a name="l05093"></a>05093   <a class="code" href="btree_8h.html#a6505eb1c64d02f88a1f044f6c633fc90">sqlite3BtreeMutexArrayLeave</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#aeeff59f076cad0b73997113e4e29bd76">aMutex</a>);
<a name="l05094"></a>05094   <span class="keywordflow">return</span> rc;
<a name="l05095"></a>05095 
<a name="l05096"></a>05096   <span class="comment">/* Jump to here if a string or blob larger than SQLITE_MAX_LENGTH</span>
<a name="l05097"></a>05097 <span class="comment">  ** is encountered.</span>
<a name="l05098"></a>05098 <span class="comment">  */</span>
<a name="l05099"></a>05099 too_big:
<a name="l05100"></a>05100   <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;string or blob too big&quot;</span>);
<a name="l05101"></a>05101   rc = <a class="code" href="sqlite3_8h.html#a88e41cbe09fb26a267081d59316ef126">SQLITE_TOOBIG</a>;
<a name="l05102"></a>05102   <span class="keywordflow">goto</span> vdbe_error_halt;
<a name="l05103"></a>05103 
<a name="l05104"></a>05104   <span class="comment">/* Jump to here if a malloc() fails.</span>
<a name="l05105"></a>05105 <span class="comment">  */</span>
<a name="l05106"></a>05106 no_mem:
<a name="l05107"></a>05107   db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> = 1;
<a name="l05108"></a>05108   <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;out of memory&quot;</span>);
<a name="l05109"></a>05109   rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l05110"></a>05110   <span class="keywordflow">goto</span> vdbe_error_halt;
<a name="l05111"></a>05111 
<a name="l05112"></a>05112   <span class="comment">/* Jump to here for an SQLITE_MISUSE error.</span>
<a name="l05113"></a>05113 <span class="comment">  */</span>
<a name="l05114"></a>05114 abort_due_to_misuse:
<a name="l05115"></a>05115   rc = <a class="code" href="sqlite3_8h.html#a34f01e4ee909e6b68be040868f7503bc">SQLITE_MISUSE</a>;
<a name="l05116"></a>05116   <span class="comment">/* Fall thru into abort_due_to_error */</span>
<a name="l05117"></a>05117 
<a name="l05118"></a>05118   <span class="comment">/* Jump to here for any other kind of fatal error.  The &quot;rc&quot; variable</span>
<a name="l05119"></a>05119 <span class="comment">  ** should hold the error number.</span>
<a name="l05120"></a>05120 <span class="comment">  */</span>
<a name="l05121"></a>05121 abort_due_to_error:
<a name="l05122"></a>05122   assert( p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>==0 );
<a name="l05123"></a>05123   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ) rc = <a class="code" href="sqlite3_8h.html#a9e34c7a5186dc9095e108e517eaac9f6">SQLITE_NOMEM</a>;
<a name="l05124"></a>05124   <span class="keywordflow">if</span>( rc!=<a class="code" href="sqlite3_8h.html#a51c0d3d9c66efa031416bc47ca5a2431">SQLITE_IOERR_NOMEM</a> ){
<a name="l05125"></a>05125     <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="main_8c.html#a02d1b390ceb669b8e689f27ea7134cad">sqlite3ErrStr</a>(rc));
<a name="l05126"></a>05126   }
<a name="l05127"></a>05127   <span class="keywordflow">goto</span> vdbe_error_halt;
<a name="l05128"></a>05128 
<a name="l05129"></a>05129   <span class="comment">/* Jump to here if the sqlite3_interrupt() API sets the interrupt</span>
<a name="l05130"></a>05130 <span class="comment">  ** flag.</span>
<a name="l05131"></a>05131 <span class="comment">  */</span>
<a name="l05132"></a>05132 abort_due_to_interrupt:
<a name="l05133"></a>05133   assert( db-&gt;<a class="code" href="structsqlite3.html#aa5db6567b0e7d5009c52e0307b1cf095">u1</a>.<a class="code" href="structsqlite3.html#a80b995fd97507bbf978d6960adde53f8">isInterrupted</a> );
<a name="l05134"></a>05134   rc = <a class="code" href="sqlite3_8h.html#a03c9b25faf07d0e47ce7a1b1e46b2adc">SQLITE_INTERRUPT</a>;
<a name="l05135"></a>05135   p-&gt;<a class="code" href="structVdbe.html#af82fb0227a5b8db9d3b9bdb03964a4a0">rc</a> = rc;
<a name="l05136"></a>05136   <a class="code" href="malloc_8c.html#af1c1714a3fa3d522e9909a10b3e69cfb">sqlite3SetString</a>(&amp;p-&gt;<a class="code" href="structVdbe.html#add7679059dd1e3cd483ddcb9153ca844">zErrMsg</a>, db, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="main_8c.html#a02d1b390ceb669b8e689f27ea7134cad">sqlite3ErrStr</a>(rc));
<a name="l05137"></a>05137   <span class="keywordflow">goto</span> vdbe_error_halt;
<a name="l05138"></a>05138 }
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:57 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
