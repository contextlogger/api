<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ContextLogger2 Logger Daemon Internals: resolve.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_53e7feede50ae4cb655a635f658a2b4e.html">sqlite3h</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_a0c08fff43b69094a2511677d8587129.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_05c6b5177aad09a72e8ee1adc608dac0.html">sqlite3</a>
  </div>
</div>
<div class="contents">
<h1>resolve.c</h1><a href="resolve_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">** 2008 August 18</span>
<a name="l00003"></a>00003 <span class="comment">**</span>
<a name="l00004"></a>00004 <span class="comment">** The author disclaims copyright to this source code.  In place of</span>
<a name="l00005"></a>00005 <span class="comment">** a legal notice, here is a blessing:</span>
<a name="l00006"></a>00006 <span class="comment">**</span>
<a name="l00007"></a>00007 <span class="comment">**    May you do good and not evil.</span>
<a name="l00008"></a>00008 <span class="comment">**    May you find forgiveness for yourself and forgive others.</span>
<a name="l00009"></a>00009 <span class="comment">**    May you share freely, never taking more than you give.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">*************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment">**</span>
<a name="l00013"></a>00013 <span class="comment">** This file contains routines used for walking the parser tree and</span>
<a name="l00014"></a>00014 <span class="comment">** resolve all identifiers by associating them with a particular</span>
<a name="l00015"></a>00015 <span class="comment">** table and column.</span>
<a name="l00016"></a>00016 <span class="comment">**</span>
<a name="l00017"></a>00017 <span class="comment">** $Id: resolve.c,v 1.10 2008/10/19 21:03:27 drh Exp $</span>
<a name="l00018"></a>00018 <span class="comment">*/</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="sqliteInt_8h.html">sqliteInt.h</a>&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/*</span>
<a name="l00024"></a>00024 <span class="comment">** Turn the pExpr expression into an alias for the iCol-th column of the</span>
<a name="l00025"></a>00025 <span class="comment">** result set in pEList.</span>
<a name="l00026"></a>00026 <span class="comment">**</span>
<a name="l00027"></a>00027 <span class="comment">** If the result set column is a simple column reference, then this routine</span>
<a name="l00028"></a>00028 <span class="comment">** makes an exact copy.  But for any other kind of expression, this</span>
<a name="l00029"></a>00029 <span class="comment">** routine make a copy of the result set column as the argument to the</span>
<a name="l00030"></a>00030 <span class="comment">** TK_AS operator.  The TK_AS operator causes the expression to be</span>
<a name="l00031"></a>00031 <span class="comment">** evaluated just once and then reused for each alias.</span>
<a name="l00032"></a>00032 <span class="comment">**</span>
<a name="l00033"></a>00033 <span class="comment">** The reason for suppressing the TK_AS term when the expression is a simple</span>
<a name="l00034"></a>00034 <span class="comment">** column reference is so that the column reference will be recognized as</span>
<a name="l00035"></a>00035 <span class="comment">** usable by indices within the WHERE clause processing logic. </span>
<a name="l00036"></a>00036 <span class="comment">**</span>
<a name="l00037"></a>00037 <span class="comment">** Hack:  The TK_AS operator is inhibited if zType[0]==&apos;G&apos;.  This means</span>
<a name="l00038"></a>00038 <span class="comment">** that in a GROUP BY clause, the expression is evaluated twice.  Hence:</span>
<a name="l00039"></a>00039 <span class="comment">**</span>
<a name="l00040"></a>00040 <span class="comment">**     SELECT random()%5 AS x, count(*) FROM tab GROUP BY x</span>
<a name="l00041"></a>00041 <span class="comment">**</span>
<a name="l00042"></a>00042 <span class="comment">** Is equivalent to:</span>
<a name="l00043"></a>00043 <span class="comment">**</span>
<a name="l00044"></a>00044 <span class="comment">**     SELECT random()%5 AS x, count(*) FROM tab GROUP BY random()%5</span>
<a name="l00045"></a>00045 <span class="comment">**</span>
<a name="l00046"></a>00046 <span class="comment">** The result of random()%5 in the GROUP BY clause is probably different</span>
<a name="l00047"></a>00047 <span class="comment">** from the result in the result-set.  We might fix this someday.  Or</span>
<a name="l00048"></a>00048 <span class="comment">** then again, we might not...</span>
<a name="l00049"></a>00049 <span class="comment">*/</span>
<a name="l00050"></a><a class="code" href="resolve_8c.html#ad52379b88e14575e95e757bbdef9cac1">00050</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="resolve_8c.html#ad52379b88e14575e95e757bbdef9cac1">resolveAlias</a>(
<a name="l00051"></a>00051   <a class="code" href="structParse.html">Parse</a> *pParse,         <span class="comment">/* Parsing context */</span>
<a name="l00052"></a>00052   <a class="code" href="structExprList.html">ExprList</a> *pEList,      <span class="comment">/* A result set */</span>
<a name="l00053"></a>00053   <span class="keywordtype">int</span> iCol,              <span class="comment">/* A column in the result set.  0..pEList-&gt;nExpr-1 */</span>
<a name="l00054"></a>00054   <a class="code" href="structExpr.html">Expr</a> *pExpr,           <span class="comment">/* Transform this into an alias to the result set */</span>
<a name="l00055"></a>00055   <span class="keyword">const</span> <span class="keywordtype">char</span> *zType      <span class="comment">/* &quot;GROUP&quot; or &quot;ORDER&quot; or &quot;&quot; */</span>
<a name="l00056"></a>00056 ){
<a name="l00057"></a>00057   <a class="code" href="structExpr.html">Expr</a> *pOrig;           <span class="comment">/* The iCol-th column of the result set */</span>
<a name="l00058"></a>00058   <a class="code" href="structExpr.html">Expr</a> *pDup;            <span class="comment">/* Copy of pOrig */</span>
<a name="l00059"></a>00059   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>;           <span class="comment">/* The database connection */</span>
<a name="l00060"></a>00060 
<a name="l00061"></a>00061   assert( iCol&gt;=0 &amp;&amp; iCol&lt;pEList-&gt;nExpr );
<a name="l00062"></a>00062   pOrig = pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[iCol].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l00063"></a>00063   assert( pOrig!=0 );
<a name="l00064"></a>00064   assert( pOrig-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a67a45edf1b125cd363bd7746f0138604">EP_Resolved</a> );
<a name="l00065"></a>00065   db = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00066"></a>00066   pDup = <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db, pOrig);
<a name="l00067"></a>00067   <span class="keywordflow">if</span>( pDup==0 ) <span class="keywordflow">return</span>;
<a name="l00068"></a>00068   <span class="keywordflow">if</span>( pDup-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>!=<a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a> &amp;&amp; zType[0]!=<span class="charliteral">&apos;G&apos;</span> ){
<a name="l00069"></a>00069     pDup = <a class="code" href="expr_8c.html#aa30fc567fcbf034446870df4e14930bc">sqlite3PExpr</a>(pParse, <a class="code" href="parse_8h.html#af6696f60fd3ba68c26dd8b817f210170">TK_AS</a>, pDup, 0, 0);
<a name="l00070"></a>00070     <span class="keywordflow">if</span>( pDup==0 ) <span class="keywordflow">return</span>;
<a name="l00071"></a>00071     <span class="keywordflow">if</span>( pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[iCol].<a class="code" href="structExprList_1_1ExprList__item.html#a06fc9fdfb94d35ec6ca742da23609239">iAlias</a>==0 ){
<a name="l00072"></a>00072       pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[iCol].<a class="code" href="structExprList_1_1ExprList__item.html#a06fc9fdfb94d35ec6ca742da23609239">iAlias</a> = ++pParse-&gt;<a class="code" href="structParse.html#a47336e4cdbb0edeeac919980c8cde018">nAlias</a>;
<a name="l00073"></a>00073     }
<a name="l00074"></a>00074     pDup-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a> = pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[iCol].<a class="code" href="structExprList_1_1ExprList__item.html#a06fc9fdfb94d35ec6ca742da23609239">iAlias</a>;
<a name="l00075"></a>00075   }
<a name="l00076"></a>00076   <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a8504ef15835e9661eeb00e1cbe530b33">EP_ExpCollate</a> ){
<a name="l00077"></a>00077     pDup-&gt;<a class="code" href="structExpr.html#a4ef09e21aaa9d61567b89714e25abfb9">pColl</a> = pExpr-&gt;<a class="code" href="structExpr.html#a4ef09e21aaa9d61567b89714e25abfb9">pColl</a>;
<a name="l00078"></a>00078     pDup-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> |= <a class="code" href="sqliteInt_8h.html#a8504ef15835e9661eeb00e1cbe530b33">EP_ExpCollate</a>;
<a name="l00079"></a>00079   }
<a name="l00080"></a>00080   <a class="code" href="expr_8c.html#a4fc26bd1612c2ac4f9e53a30a26ad282">sqlite3ExprClear</a>(db, pExpr);
<a name="l00081"></a>00081   memcpy(pExpr, pDup, <span class="keyword">sizeof</span>(*pExpr));
<a name="l00082"></a>00082   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, pDup);
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">/*</span>
<a name="l00086"></a>00086 <span class="comment">** Given the name of a column of the form X.Y.Z or Y.Z or just Z, look up</span>
<a name="l00087"></a>00087 <span class="comment">** that name in the set of source tables in pSrcList and make the pExpr </span>
<a name="l00088"></a>00088 <span class="comment">** expression node refer back to that source column.  The following changes</span>
<a name="l00089"></a>00089 <span class="comment">** are made to pExpr:</span>
<a name="l00090"></a>00090 <span class="comment">**</span>
<a name="l00091"></a>00091 <span class="comment">**    pExpr-&gt;iDb           Set the index in db-&gt;aDb[] of the database X</span>
<a name="l00092"></a>00092 <span class="comment">**                         (even if X is implied).</span>
<a name="l00093"></a>00093 <span class="comment">**    pExpr-&gt;iTable        Set to the cursor number for the table obtained</span>
<a name="l00094"></a>00094 <span class="comment">**                         from pSrcList.</span>
<a name="l00095"></a>00095 <span class="comment">**    pExpr-&gt;pTab          Points to the Table structure of X.Y (even if</span>
<a name="l00096"></a>00096 <span class="comment">**                         X and/or Y are implied.)</span>
<a name="l00097"></a>00097 <span class="comment">**    pExpr-&gt;iColumn       Set to the column number within the table.</span>
<a name="l00098"></a>00098 <span class="comment">**    pExpr-&gt;op            Set to TK_COLUMN.</span>
<a name="l00099"></a>00099 <span class="comment">**    pExpr-&gt;pLeft         Any expression this points to is deleted</span>
<a name="l00100"></a>00100 <span class="comment">**    pExpr-&gt;pRight        Any expression this points to is deleted.</span>
<a name="l00101"></a>00101 <span class="comment">**</span>
<a name="l00102"></a>00102 <span class="comment">** The pDbToken is the name of the database (the &quot;X&quot;).  This value may be</span>
<a name="l00103"></a>00103 <span class="comment">** NULL meaning that name is of the form Y.Z or Z.  Any available database</span>
<a name="l00104"></a>00104 <span class="comment">** can be used.  The pTableToken is the name of the table (the &quot;Y&quot;).  This</span>
<a name="l00105"></a>00105 <span class="comment">** value can be NULL if pDbToken is also NULL.  If pTableToken is NULL it</span>
<a name="l00106"></a>00106 <span class="comment">** means that the form of the name is Z and that columns from any table</span>
<a name="l00107"></a>00107 <span class="comment">** can be used.</span>
<a name="l00108"></a>00108 <span class="comment">**</span>
<a name="l00109"></a>00109 <span class="comment">** If the name cannot be resolved unambiguously, leave an error message</span>
<a name="l00110"></a>00110 <span class="comment">** in pParse and return non-zero.  Return zero on success.</span>
<a name="l00111"></a>00111 <span class="comment">*/</span>
<a name="l00112"></a><a class="code" href="resolve_8c.html#a1185f0ac34c5a013d3a7c8855dabcbb1">00112</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="resolve_8c.html#a1185f0ac34c5a013d3a7c8855dabcbb1">lookupName</a>(
<a name="l00113"></a>00113   <a class="code" href="structParse.html">Parse</a> *pParse,       <span class="comment">/* The parsing context */</span>
<a name="l00114"></a>00114   <a class="code" href="structToken.html">Token</a> *pDbToken,     <span class="comment">/* Name of the database containing table, or NULL */</span>
<a name="l00115"></a>00115   <a class="code" href="structToken.html">Token</a> *pTableToken,  <span class="comment">/* Name of table containing column, or NULL */</span>
<a name="l00116"></a>00116   <a class="code" href="structToken.html">Token</a> *pColumnToken, <span class="comment">/* Name of the column. */</span>
<a name="l00117"></a>00117   <a class="code" href="structNameContext.html">NameContext</a> *pNC,    <span class="comment">/* The name context used to resolve the name */</span>
<a name="l00118"></a>00118   <a class="code" href="structExpr.html">Expr</a> *pExpr          <span class="comment">/* Make this EXPR node point to the selected column */</span>
<a name="l00119"></a>00119 ){
<a name="l00120"></a>00120   <span class="keywordtype">char</span> *zDb = 0;       <span class="comment">/* Name of the database.  The &quot;X&quot; in X.Y.Z */</span>
<a name="l00121"></a>00121   <span class="keywordtype">char</span> *zTab = 0;      <span class="comment">/* Name of the table.  The &quot;Y&quot; in X.Y.Z or Y.Z */</span>
<a name="l00122"></a>00122   <span class="keywordtype">char</span> *zCol = 0;      <span class="comment">/* Name of the column.  The &quot;Z&quot; */</span>
<a name="l00123"></a>00123   <span class="keywordtype">int</span> <a class="code" href="structsqlite3PrngType.html#af5bbbc5d1cf9f4ef337781adda96f8d5">i</a>, <a class="code" href="structsqlite3PrngType.html#af26dbd92b84629c51ba3e2903ac8947a">j</a>;            <span class="comment">/* Loop counters */</span>
<a name="l00124"></a>00124   <span class="keywordtype">int</span> cnt = 0;                      <span class="comment">/* Number of matching column names */</span>
<a name="l00125"></a>00125   <span class="keywordtype">int</span> cntTab = 0;                   <span class="comment">/* Number of matching table names */</span>
<a name="l00126"></a>00126   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;         <span class="comment">/* The database connection */</span>
<a name="l00127"></a>00127   <span class="keyword">struct </span>SrcList_item *pItem;       <span class="comment">/* Use for looping over pSrcList items */</span>
<a name="l00128"></a>00128   <span class="keyword">struct </span>SrcList_item *pMatch = 0;  <span class="comment">/* The matching pSrcList item */</span>
<a name="l00129"></a>00129   <a class="code" href="structNameContext.html">NameContext</a> *pTopNC = pNC;        <span class="comment">/* First namecontext in the list */</span>
<a name="l00130"></a>00130   <a class="code" href="structSchema.html">Schema</a> *pSchema = 0;              <span class="comment">/* Schema of the expression */</span>
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   assert( pColumnToken &amp;&amp; pColumnToken-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a> ); <span class="comment">/* The Z in X.Y.Z cannot be NULL */</span>
<a name="l00133"></a>00133 
<a name="l00134"></a>00134   <span class="comment">/* Dequote and zero-terminate the names */</span>
<a name="l00135"></a>00135   zDb = <a class="code" href="build_8c.html#a19bf99e43ecbf922cb3bba8777dbc381">sqlite3NameFromToken</a>(db, pDbToken);
<a name="l00136"></a>00136   zTab = <a class="code" href="build_8c.html#a19bf99e43ecbf922cb3bba8777dbc381">sqlite3NameFromToken</a>(db, pTableToken);
<a name="l00137"></a>00137   zCol = <a class="code" href="build_8c.html#a19bf99e43ecbf922cb3bba8777dbc381">sqlite3NameFromToken</a>(db, pColumnToken);
<a name="l00138"></a>00138   <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00139"></a>00139     <span class="keywordflow">goto</span> lookupname_end;
<a name="l00140"></a>00140   }
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="comment">/* Initialize the node to no-match */</span>
<a name="l00143"></a>00143   pExpr-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a> = -1;
<a name="l00144"></a>00144   pExpr-&gt;<a class="code" href="structExpr.html#a27c8824b41d853eeeebe61cf3ac1ae5a">pTab</a> = 0;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   <span class="comment">/* Start at the inner-most context and move outward until a match is found */</span>
<a name="l00147"></a>00147   <span class="keywordflow">while</span>( pNC &amp;&amp; cnt==0 ){
<a name="l00148"></a>00148     <a class="code" href="structExprList.html">ExprList</a> *pEList;
<a name="l00149"></a>00149     <a class="code" href="structSrcList.html">SrcList</a> *pSrcList = pNC-&gt;<a class="code" href="structNameContext.html#a6ede21da33e2e9bd3d0c5fe90a3ec72c">pSrcList</a>;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151     <span class="keywordflow">if</span>( pSrcList ){
<a name="l00152"></a>00152       <span class="keywordflow">for</span>(i=0, pItem=pSrcList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>; i&lt;pSrcList-&gt;nSrc; i++, pItem++){
<a name="l00153"></a>00153         <a class="code" href="structTable.html">Table</a> *pTab;
<a name="l00154"></a>00154         <span class="keywordtype">int</span> iDb;
<a name="l00155"></a>00155         <a class="code" href="structColumn.html">Column</a> *pCol;
<a name="l00156"></a>00156   
<a name="l00157"></a>00157         pTab = pItem-&gt;pTab;
<a name="l00158"></a>00158         assert( pTab!=0 &amp;&amp; pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>!=0 );
<a name="l00159"></a>00159         iDb = <a class="code" href="prepare_8c.html#aecd8922611e561d76d5e9f16655e8a7c">sqlite3SchemaToIndex</a>(db, pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>);
<a name="l00160"></a>00160         assert( pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>&gt;0 );
<a name="l00161"></a>00161         <span class="keywordflow">if</span>( zTab ){
<a name="l00162"></a>00162           <span class="keywordflow">if</span>( pItem-&gt;zAlias ){
<a name="l00163"></a>00163             <span class="keywordtype">char</span> *zTabName = pItem-&gt;zAlias;
<a name="l00164"></a>00164             <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(zTabName, zTab)!=0 ) <span class="keywordflow">continue</span>;
<a name="l00165"></a>00165           }<span class="keywordflow">else</span>{
<a name="l00166"></a>00166             <span class="keywordtype">char</span> *zTabName = pTab-&gt;<a class="code" href="structTable.html#a20ca62607d6da596b1016b76cf677809">zName</a>;
<a name="l00167"></a>00167             <span class="keywordflow">if</span>( zTabName==0 || <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(zTabName, zTab)!=0 ) <span class="keywordflow">continue</span>;
<a name="l00168"></a>00168             <span class="keywordflow">if</span>( zDb!=0 &amp;&amp; <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(db-&gt;<a class="code" href="structsqlite3.html#a0abe1dccdea5f43e6c49360b42749697">aDb</a>[iDb].<a class="code" href="structDb.html#a6df2b5d7c8fd68e92cea961d9e3b279b">zName</a>, zDb)!=0 ){
<a name="l00169"></a>00169               <span class="keywordflow">continue</span>;
<a name="l00170"></a>00170             }
<a name="l00171"></a>00171           }
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173         <span class="keywordflow">if</span>( 0==(cntTab++) ){
<a name="l00174"></a>00174           pExpr-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a> = pItem-&gt;iCursor;
<a name="l00175"></a>00175           pExpr-&gt;<a class="code" href="structExpr.html#a27c8824b41d853eeeebe61cf3ac1ae5a">pTab</a> = pTab;
<a name="l00176"></a>00176           pSchema = pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>;
<a name="l00177"></a>00177           pMatch = pItem;
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179         <span class="keywordflow">for</span>(j=0, pCol=pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>; j&lt;pTab-&gt;nCol; j++, pCol++){
<a name="l00180"></a>00180           <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(pCol-&gt;<a class="code" href="structColumn.html#a6450a4e9fde68b3a2d79425d826eccc3">zName</a>, zCol)==0 ){
<a name="l00181"></a>00181             <a class="code" href="structIdList.html">IdList</a> *pUsing;
<a name="l00182"></a>00182             cnt++;
<a name="l00183"></a>00183             pExpr-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a> = pItem-&gt;iCursor;
<a name="l00184"></a>00184             pExpr-&gt;<a class="code" href="structExpr.html#a27c8824b41d853eeeebe61cf3ac1ae5a">pTab</a> = pTab;
<a name="l00185"></a>00185             pMatch = pItem;
<a name="l00186"></a>00186             pSchema = pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>;
<a name="l00187"></a>00187             <span class="comment">/* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */</span>
<a name="l00188"></a>00188             pExpr-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a> = j==pTab-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a> ? -1 : j;
<a name="l00189"></a>00189             <span class="keywordflow">if</span>( i&lt;pSrcList-&gt;nSrc-1 ){
<a name="l00190"></a>00190               <span class="keywordflow">if</span>( pItem[1].jointype &amp; <a class="code" href="sqliteInt_8h.html#a5fc008d35ff992e0c1cca19cd600b476">JT_NATURAL</a> ){
<a name="l00191"></a>00191                 <span class="comment">/* If this match occurred in the left table of a natural join,</span>
<a name="l00192"></a>00192 <span class="comment">                ** then skip the right table to avoid a duplicate match */</span>
<a name="l00193"></a>00193                 pItem++;
<a name="l00194"></a>00194                 i++;
<a name="l00195"></a>00195               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( (pUsing = pItem[1].pUsing)!=0 ){
<a name="l00196"></a>00196                 <span class="comment">/* If this match occurs on a column that is in the USING clause</span>
<a name="l00197"></a>00197 <span class="comment">                ** of a join, skip the search of the right table of the join</span>
<a name="l00198"></a>00198 <span class="comment">                ** to avoid a duplicate match there. */</span>
<a name="l00199"></a>00199                 <span class="keywordtype">int</span> k;
<a name="l00200"></a>00200                 <span class="keywordflow">for</span>(k=0; k&lt;pUsing-&gt;nId; k++){
<a name="l00201"></a>00201                   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(pUsing-&gt;a[k].zName, zCol)==0 ){
<a name="l00202"></a>00202                     pItem++;
<a name="l00203"></a>00203                     i++;
<a name="l00204"></a>00204                     <span class="keywordflow">break</span>;
<a name="l00205"></a>00205                   }
<a name="l00206"></a>00206                 }
<a name="l00207"></a>00207               }
<a name="l00208"></a>00208             }
<a name="l00209"></a>00209             <span class="keywordflow">break</span>;
<a name="l00210"></a>00210           }
<a name="l00211"></a>00211         }
<a name="l00212"></a>00212       }
<a name="l00213"></a>00213     }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="preprocessor">#ifndef SQLITE_OMIT_TRIGGER</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span>    <span class="comment">/* If we have not already resolved the name, then maybe </span>
<a name="l00217"></a>00217 <span class="comment">    ** it is a new.* or old.* trigger argument reference</span>
<a name="l00218"></a>00218 <span class="comment">    */</span>
<a name="l00219"></a>00219     <span class="keywordflow">if</span>( zDb==0 &amp;&amp; zTab!=0 &amp;&amp; cnt==0 &amp;&amp; pParse-&gt;<a class="code" href="structParse.html#a1ae8776978de122f725acd37784522ed">trigStack</a>!=0 ){
<a name="l00220"></a>00220       <a class="code" href="structTriggerStack.html">TriggerStack</a> *pTriggerStack = pParse-&gt;<a class="code" href="structParse.html#a1ae8776978de122f725acd37784522ed">trigStack</a>;
<a name="l00221"></a>00221       <a class="code" href="structTable.html">Table</a> *pTab = 0;
<a name="l00222"></a>00222       <a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a> *piColMask;
<a name="l00223"></a>00223       <span class="keywordflow">if</span>( pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#aaa2f7172de0450219e6ee99864a030bb">newIdx</a> != -1 &amp;&amp; <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(<span class="stringliteral">&quot;new&quot;</span>, zTab) == 0 ){
<a name="l00224"></a>00224         pExpr-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a> = pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#aaa2f7172de0450219e6ee99864a030bb">newIdx</a>;
<a name="l00225"></a>00225         assert( pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#a3ba86bbbdd3780f8a1df171643c03819">pTab</a> );
<a name="l00226"></a>00226         pTab = pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#a3ba86bbbdd3780f8a1df171643c03819">pTab</a>;
<a name="l00227"></a>00227         piColMask = &amp;(pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#a9bbd36e6a81a1394df456908fbfd65cc">newColMask</a>);
<a name="l00228"></a>00228       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#a6499348b4eebb46d7d335881964adb68">oldIdx</a> != -1 &amp;&amp; <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(<span class="stringliteral">&quot;old&quot;</span>, zTab)==0 ){
<a name="l00229"></a>00229         pExpr-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a> = pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#a6499348b4eebb46d7d335881964adb68">oldIdx</a>;
<a name="l00230"></a>00230         assert( pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#a3ba86bbbdd3780f8a1df171643c03819">pTab</a> );
<a name="l00231"></a>00231         pTab = pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#a3ba86bbbdd3780f8a1df171643c03819">pTab</a>;
<a name="l00232"></a>00232         piColMask = &amp;(pTriggerStack-&gt;<a class="code" href="structTriggerStack.html#ab19d11774bb435ac600b87cf52ff0681">oldColMask</a>);
<a name="l00233"></a>00233       }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235       <span class="keywordflow">if</span>( pTab ){ 
<a name="l00236"></a>00236         <span class="keywordtype">int</span> iCol;
<a name="l00237"></a>00237         <a class="code" href="structColumn.html">Column</a> *pCol = pTab-&gt;<a class="code" href="structTable.html#a87ec3b706ecf9545bd9ed582a12ce3e7">aCol</a>;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239         pSchema = pTab-&gt;<a class="code" href="structTable.html#a1d6ce038a061722cebaeba0f3ffceacf">pSchema</a>;
<a name="l00240"></a>00240         cntTab++;
<a name="l00241"></a>00241         <span class="keywordflow">for</span>(iCol=0; iCol &lt; pTab-&gt;<a class="code" href="structTable.html#a2b3925b85368f0367322ab66bf289163">nCol</a>; iCol++, pCol++) {
<a name="l00242"></a>00242           <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(pCol-&gt;<a class="code" href="structColumn.html#a6450a4e9fde68b3a2d79425d826eccc3">zName</a>, zCol)==0 ){
<a name="l00243"></a>00243             cnt++;
<a name="l00244"></a>00244             pExpr-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a> = iCol==pTab-&gt;<a class="code" href="structTable.html#ab6c8b60da43ccc8a2e2b5b65cc74058f">iPKey</a> ? -1 : iCol;
<a name="l00245"></a>00245             pExpr-&gt;<a class="code" href="structExpr.html#a27c8824b41d853eeeebe61cf3ac1ae5a">pTab</a> = pTab;
<a name="l00246"></a>00246             <span class="keywordflow">if</span>( iCol&gt;=0 ){
<a name="l00247"></a>00247               <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( iCol==31 );
<a name="l00248"></a>00248               <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( iCol==32 );
<a name="l00249"></a>00249               *piColMask |= ((<a class="code" href="sqliteInt_8h.html#a03ad5adfaeb9b7640dde78a0cc390319">u32</a>)1&lt;&lt;iCol) | (iCol&gt;=32?0xffffffff:0);
<a name="l00250"></a>00250             }
<a name="l00251"></a>00251             <span class="keywordflow">break</span>;
<a name="l00252"></a>00252           }
<a name="l00253"></a>00253         }
<a name="l00254"></a>00254       }
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256 <span class="preprocessor">#endif </span><span class="comment">/* !defined(SQLITE_OMIT_TRIGGER) */</span>
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     <span class="comment">/*</span>
<a name="l00259"></a>00259 <span class="comment">    ** Perhaps the name is a reference to the ROWID</span>
<a name="l00260"></a>00260 <span class="comment">    */</span>
<a name="l00261"></a>00261     <span class="keywordflow">if</span>( cnt==0 &amp;&amp; cntTab==1 &amp;&amp; <a class="code" href="expr_8c.html#a8e6c995eb12a56470a6faf997c587c78">sqlite3IsRowid</a>(zCol) ){
<a name="l00262"></a>00262       cnt = 1;
<a name="l00263"></a>00263       pExpr-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a> = -1;
<a name="l00264"></a>00264       pExpr-&gt;<a class="code" href="structExpr.html#aeb51b76e606d6fbae234e38473bf3dc9">affinity</a> = <a class="code" href="sqliteInt_8h.html#a45e5dc1cc144e55d53389ac9d1066924">SQLITE_AFF_INTEGER</a>;
<a name="l00265"></a>00265     }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267     <span class="comment">/*</span>
<a name="l00268"></a>00268 <span class="comment">    ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z</span>
<a name="l00269"></a>00269 <span class="comment">    ** might refer to an result-set alias.  This happens, for example, when</span>
<a name="l00270"></a>00270 <span class="comment">    ** we are resolving names in the WHERE clause of the following command:</span>
<a name="l00271"></a>00271 <span class="comment">    **</span>
<a name="l00272"></a>00272 <span class="comment">    **     SELECT a+b AS x FROM table WHERE x&lt;10;</span>
<a name="l00273"></a>00273 <span class="comment">    **</span>
<a name="l00274"></a>00274 <span class="comment">    ** In cases like this, replace pExpr with a copy of the expression that</span>
<a name="l00275"></a>00275 <span class="comment">    ** forms the result set entry (&quot;a+b&quot; in the example) and return immediately.</span>
<a name="l00276"></a>00276 <span class="comment">    ** Note that the expression in the result set should have already been</span>
<a name="l00277"></a>00277 <span class="comment">    ** resolved by the time the WHERE clause is resolved.</span>
<a name="l00278"></a>00278 <span class="comment">    */</span>
<a name="l00279"></a>00279     <span class="keywordflow">if</span>( cnt==0 &amp;&amp; (pEList = pNC-&gt;<a class="code" href="structNameContext.html#a8c752d7fb9b28179156c569cc57ba6f2">pEList</a>)!=0 &amp;&amp; zTab==0 ){
<a name="l00280"></a>00280       <span class="keywordflow">for</span>(j=0; j&lt;pEList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>; j++){
<a name="l00281"></a>00281         <span class="keywordtype">char</span> *zAs = pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[j].<a class="code" href="structExprList_1_1ExprList__item.html#af278eb03a1169c73d144547adaf9b04f">zName</a>;
<a name="l00282"></a>00282         <span class="keywordflow">if</span>( zAs!=0 &amp;&amp; <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(zAs, zCol)==0 ){
<a name="l00283"></a>00283           <a class="code" href="structExpr.html">Expr</a> *pOrig;
<a name="l00284"></a>00284           assert( pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>==0 &amp;&amp; pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>==0 );
<a name="l00285"></a>00285           assert( pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>==0 );
<a name="l00286"></a>00286           assert( pExpr-&gt;<a class="code" href="structExpr.html#a54e5186fdf157f8b4ae178919d8ff6b3">pSelect</a>==0 );
<a name="l00287"></a>00287           pOrig = pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[j].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l00288"></a>00288           <span class="keywordflow">if</span>( !pNC-&gt;<a class="code" href="structNameContext.html#a78dc76c1493dd2f74f5f1ec661039665">allowAgg</a> &amp;&amp; <a class="code" href="sqliteInt_8h.html#a70ceb3fd7e20d6b0565b359158c7f1d7">ExprHasProperty</a>(pOrig, <a class="code" href="sqliteInt_8h.html#a3e4e7c58ecba751cc608e357bc15f932">EP_Agg</a>) ){
<a name="l00289"></a>00289             <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;misuse of aliased aggregate %s&quot;</span>, zAs);
<a name="l00290"></a>00290             <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zCol);
<a name="l00291"></a>00291             <span class="keywordflow">return</span> 2;
<a name="l00292"></a>00292           }
<a name="l00293"></a>00293           <a class="code" href="resolve_8c.html#ad52379b88e14575e95e757bbdef9cac1">resolveAlias</a>(pParse, pEList, j, pExpr, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00294"></a>00294           cnt = 1;
<a name="l00295"></a>00295           pMatch = 0;
<a name="l00296"></a>00296           assert( zTab==0 &amp;&amp; zDb==0 );
<a name="l00297"></a>00297           <span class="keywordflow">goto</span> lookupname_end_2;
<a name="l00298"></a>00298         }
<a name="l00299"></a>00299       } 
<a name="l00300"></a>00300     }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     <span class="comment">/* Advance to the next name context.  The loop will exit when either</span>
<a name="l00303"></a>00303 <span class="comment">    ** we have a match (cnt&gt;0) or when we run out of name contexts.</span>
<a name="l00304"></a>00304 <span class="comment">    */</span>
<a name="l00305"></a>00305     <span class="keywordflow">if</span>( cnt==0 ){
<a name="l00306"></a>00306       pNC = pNC-&gt;<a class="code" href="structNameContext.html#a82ce0ec8a3cc3d792e1f38bb5e0ad5fc">pNext</a>;
<a name="l00307"></a>00307     }
<a name="l00308"></a>00308   }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310   <span class="comment">/*</span>
<a name="l00311"></a>00311 <span class="comment">  ** If X and Y are NULL (in other words if only the column name Z is</span>
<a name="l00312"></a>00312 <span class="comment">  ** supplied) and the value of Z is enclosed in double-quotes, then</span>
<a name="l00313"></a>00313 <span class="comment">  ** Z is a string literal if it doesn&apos;t match any column names.  In that</span>
<a name="l00314"></a>00314 <span class="comment">  ** case, we need to return right away and not make any changes to</span>
<a name="l00315"></a>00315 <span class="comment">  ** pExpr.</span>
<a name="l00316"></a>00316 <span class="comment">  **</span>
<a name="l00317"></a>00317 <span class="comment">  ** Because no reference was made to outer contexts, the pNC-&gt;nRef</span>
<a name="l00318"></a>00318 <span class="comment">  ** fields are not changed in any context.</span>
<a name="l00319"></a>00319 <span class="comment">  */</span>
<a name="l00320"></a>00320   <span class="keywordflow">if</span>( cnt==0 &amp;&amp; zTab==0 &amp;&amp; pColumnToken-&gt;<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>[0]==<span class="charliteral">&apos;&quot;&apos;</span> ){
<a name="l00321"></a>00321     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zCol);
<a name="l00322"></a>00322     pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a> = <a class="code" href="parse_8h.html#a9810f9bc21f26ee9b8d7b374534ff54b">TK_STRING</a>;
<a name="l00323"></a>00323     pExpr-&gt;<a class="code" href="structExpr.html#a27c8824b41d853eeeebe61cf3ac1ae5a">pTab</a> = 0;
<a name="l00324"></a>00324     <span class="keywordflow">return</span> 0;
<a name="l00325"></a>00325   }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327   <span class="comment">/*</span>
<a name="l00328"></a>00328 <span class="comment">  ** cnt==0 means there was not match.  cnt&gt;1 means there were two or</span>
<a name="l00329"></a>00329 <span class="comment">  ** more matches.  Either way, we have an error.</span>
<a name="l00330"></a>00330 <span class="comment">  */</span>
<a name="l00331"></a>00331   <span class="keywordflow">if</span>( cnt!=1 ){
<a name="l00332"></a>00332     <span class="keyword">const</span> <span class="keywordtype">char</span> *zErr;
<a name="l00333"></a>00333     zErr = cnt==0 ? <span class="stringliteral">&quot;no such column&quot;</span> : <span class="stringliteral">&quot;ambiguous column name&quot;</span>;
<a name="l00334"></a>00334     <span class="keywordflow">if</span>( zDb ){
<a name="l00335"></a>00335       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;%s: %s.%s.%s&quot;</span>, zErr, zDb, zTab, zCol);
<a name="l00336"></a>00336     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( zTab ){
<a name="l00337"></a>00337       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;%s: %s.%s&quot;</span>, zErr, zTab, zCol);
<a name="l00338"></a>00338     }<span class="keywordflow">else</span>{
<a name="l00339"></a>00339       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;%s: %s&quot;</span>, zErr, zCol);
<a name="l00340"></a>00340     }
<a name="l00341"></a>00341     pTopNC-&gt;<a class="code" href="structNameContext.html#aba0b89b42e945c4c96d57a8fe011329c">nErr</a>++;
<a name="l00342"></a>00342   }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="comment">/* If a column from a table in pSrcList is referenced, then record</span>
<a name="l00345"></a>00345 <span class="comment">  ** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes</span>
<a name="l00346"></a>00346 <span class="comment">  ** bit 0 to be set.  Column 1 sets bit 1.  And so forth.  If the</span>
<a name="l00347"></a>00347 <span class="comment">  ** column number is greater than the number of bits in the bitmask</span>
<a name="l00348"></a>00348 <span class="comment">  ** then set the high-order bit of the bitmask.</span>
<a name="l00349"></a>00349 <span class="comment">  */</span>
<a name="l00350"></a>00350   <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>&gt;=0 &amp;&amp; pMatch!=0 ){
<a name="l00351"></a>00351     <span class="keywordtype">int</span> n = pExpr-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a>;
<a name="l00352"></a>00352     <a class="code" href="sqliteInt_8h.html#ac924d5076cc035902693033beb99b047">testcase</a>( n==<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)*8-1 );
<a name="l00353"></a>00353     <span class="keywordflow">if</span>( n&gt;=<span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)*8 ){
<a name="l00354"></a>00354       n = <span class="keyword">sizeof</span>(<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)*8-1;
<a name="l00355"></a>00355     }
<a name="l00356"></a>00356     assert( pMatch-&gt;iCursor==pExpr-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a> );
<a name="l00357"></a>00357     pMatch-&gt;colUsed |= ((<a class="code" href="sqliteInt_8h.html#afa77b629897c4457bfdc47d364ba5c3f">Bitmask</a>)1)&lt;&lt;n;
<a name="l00358"></a>00358   }
<a name="l00359"></a>00359 
<a name="l00360"></a>00360 lookupname_end:
<a name="l00361"></a>00361   <span class="comment">/* Clean up and return</span>
<a name="l00362"></a>00362 <span class="comment">  */</span>
<a name="l00363"></a>00363   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zDb);
<a name="l00364"></a>00364   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zTab);
<a name="l00365"></a>00365   <a class="code" href="expr_8c.html#a8503bb02b6cb0343caf2391ca8cfc266">sqlite3ExprDelete</a>(db, pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>);
<a name="l00366"></a>00366   pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a> = 0;
<a name="l00367"></a>00367   <a class="code" href="expr_8c.html#a8503bb02b6cb0343caf2391ca8cfc266">sqlite3ExprDelete</a>(db, pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>);
<a name="l00368"></a>00368   pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a> = 0;
<a name="l00369"></a>00369   pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a> = <a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a>;
<a name="l00370"></a>00370 lookupname_end_2:
<a name="l00371"></a>00371   <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zCol);
<a name="l00372"></a>00372   <span class="keywordflow">if</span>( cnt==1 ){
<a name="l00373"></a>00373     assert( pNC!=0 );
<a name="l00374"></a>00374     <a class="code" href="auth_8c.html#a1a9b6da6d50ebd2c7d3d0157a7f4b8dc">sqlite3AuthRead</a>(pParse, pExpr, pSchema, pNC-&gt;<a class="code" href="structNameContext.html#a6ede21da33e2e9bd3d0c5fe90a3ec72c">pSrcList</a>);
<a name="l00375"></a>00375     <span class="comment">/* Increment the nRef value on all name contexts from TopNC up to</span>
<a name="l00376"></a>00376 <span class="comment">    ** the point where the name matched. */</span>
<a name="l00377"></a>00377     <span class="keywordflow">for</span>(;;){
<a name="l00378"></a>00378       assert( pTopNC!=0 );
<a name="l00379"></a>00379       pTopNC-&gt;<a class="code" href="structNameContext.html#ad68616ce2a58fa1b135e0dcf953bdc97">nRef</a>++;
<a name="l00380"></a>00380       <span class="keywordflow">if</span>( pTopNC==pNC ) <span class="keywordflow">break</span>;
<a name="l00381"></a>00381       pTopNC = pTopNC-&gt;<a class="code" href="structNameContext.html#a82ce0ec8a3cc3d792e1f38bb5e0ad5fc">pNext</a>;
<a name="l00382"></a>00382     }
<a name="l00383"></a>00383     <span class="keywordflow">return</span> 0;
<a name="l00384"></a>00384   } <span class="keywordflow">else</span> {
<a name="l00385"></a>00385     <span class="keywordflow">return</span> 1;
<a name="l00386"></a>00386   }
<a name="l00387"></a>00387 }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 <span class="comment">/*</span>
<a name="l00390"></a>00390 <span class="comment">** This routine is callback for sqlite3WalkExpr().</span>
<a name="l00391"></a>00391 <span class="comment">**</span>
<a name="l00392"></a>00392 <span class="comment">** Resolve symbolic names into TK_COLUMN operators for the current</span>
<a name="l00393"></a>00393 <span class="comment">** node in the expression tree.  Return 0 to continue the search down</span>
<a name="l00394"></a>00394 <span class="comment">** the tree or 2 to abort the tree walk.</span>
<a name="l00395"></a>00395 <span class="comment">**</span>
<a name="l00396"></a>00396 <span class="comment">** This routine also does error checking and name resolution for</span>
<a name="l00397"></a>00397 <span class="comment">** function names.  The operator for aggregate functions is changed</span>
<a name="l00398"></a>00398 <span class="comment">** to TK_AGG_FUNCTION.</span>
<a name="l00399"></a>00399 <span class="comment">*/</span>
<a name="l00400"></a><a class="code" href="resolve_8c.html#a0687a8650fd8a4ebbf5c2c5a75a8fb13">00400</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="resolve_8c.html#a0687a8650fd8a4ebbf5c2c5a75a8fb13">resolveExprStep</a>(<a class="code" href="structWalker.html">Walker</a> *pWalker, <a class="code" href="structExpr.html">Expr</a> *pExpr){
<a name="l00401"></a>00401   <a class="code" href="structNameContext.html">NameContext</a> *pNC;
<a name="l00402"></a>00402   <a class="code" href="structParse.html">Parse</a> *pParse;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404   pNC = pWalker-&gt;<a class="code" href="structWalker.html#a0479a19ba29888e2ab092e7f2b3cf13a">u</a>.<a class="code" href="structWalker.html#adbf5872a6c5a9311adbfe01c0e444388">pNC</a>;
<a name="l00405"></a>00405   assert( pNC!=0 );
<a name="l00406"></a>00406   pParse = pNC-&gt;<a class="code" href="structNameContext.html#a14635249bf75d5e18124089571dd2386">pParse</a>;
<a name="l00407"></a>00407   assert( pParse==pWalker-&gt;<a class="code" href="structWalker.html#ac6e8e756b5da8f187b9cf6b94560f352">pParse</a> );
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#ab366d36e303293e9d0b252fc054478cc">ExprHasAnyProperty</a>(pExpr, <a class="code" href="sqliteInt_8h.html#a67a45edf1b125cd363bd7746f0138604">EP_Resolved</a>) ) <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a692431abc1f48e71c14b403d1e392adf">WRC_Prune</a>;
<a name="l00410"></a>00410   <a class="code" href="sqliteInt_8h.html#aedc713d2783c34ef92b63ba28c495dfe">ExprSetProperty</a>(pExpr, <a class="code" href="sqliteInt_8h.html#a67a45edf1b125cd363bd7746f0138604">EP_Resolved</a>);
<a name="l00411"></a>00411 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00412"></a>00412 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pNC-&gt;<a class="code" href="structNameContext.html#a6ede21da33e2e9bd3d0c5fe90a3ec72c">pSrcList</a> &amp;&amp; pNC-&gt;<a class="code" href="structNameContext.html#a6ede21da33e2e9bd3d0c5fe90a3ec72c">pSrcList</a>-&gt;<a class="code" href="structSrcList.html#aae88b994b131fea8c733aa609bae7e6e">nAlloc</a>&gt;0 ){
<a name="l00413"></a>00413     <a class="code" href="structSrcList.html">SrcList</a> *pSrcList = pNC-&gt;<a class="code" href="structNameContext.html#a6ede21da33e2e9bd3d0c5fe90a3ec72c">pSrcList</a>;
<a name="l00414"></a>00414     <span class="keywordtype">int</span> i;
<a name="l00415"></a>00415     <span class="keywordflow">for</span>(i=0; i&lt;pNC-&gt;<a class="code" href="structNameContext.html#a6ede21da33e2e9bd3d0c5fe90a3ec72c">pSrcList</a>-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>; i++){
<a name="l00416"></a>00416       assert( pSrcList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[i].<a class="code" href="structSrcList_1_1SrcList__item.html#af2e8aae90bd7a00b814db5a2d31f6607">iCursor</a>&gt;=0 &amp;&amp; pSrcList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[i].<a class="code" href="structSrcList_1_1SrcList__item.html#af2e8aae90bd7a00b814db5a2d31f6607">iCursor</a>&lt;pParse-&gt;<a class="code" href="structParse.html#a6b3a46e1f275962fa8808dddba20ba23">nTab</a>);
<a name="l00417"></a>00417     }
<a name="l00418"></a>00418   }
<a name="l00419"></a>00419 <span class="preprocessor">#endif</span>
<a name="l00420"></a>00420 <span class="preprocessor"></span>  <span class="keywordflow">switch</span>( pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a> ){
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="preprocessor">#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) &amp;&amp; !defined(SQLITE_OMIT_SUBQUERY)</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span>    <span class="comment">/* The special operator TK_ROW means use the rowid for the first</span>
<a name="l00424"></a>00424 <span class="comment">    ** column in the FROM clause.  This is used by the LIMIT and ORDER BY</span>
<a name="l00425"></a>00425 <span class="comment">    ** clause processing on UPDATE and DELETE statements.</span>
<a name="l00426"></a>00426 <span class="comment">    */</span>
<a name="l00427"></a>00427     <span class="keywordflow">case</span> <a class="code" href="parse_8h.html#a9f04d043ac0815e5db5dd8396b621930">TK_ROW</a>: {
<a name="l00428"></a>00428       <a class="code" href="structSrcList.html">SrcList</a> *pSrcList = pNC-&gt;<a class="code" href="structNameContext.html#a6ede21da33e2e9bd3d0c5fe90a3ec72c">pSrcList</a>;
<a name="l00429"></a>00429       <span class="keyword">struct </span>SrcList_item *pItem;
<a name="l00430"></a>00430       assert( pSrcList &amp;&amp; pSrcList-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>==1 );
<a name="l00431"></a>00431       pItem = pSrcList-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>; 
<a name="l00432"></a>00432       pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a> = <a class="code" href="parse_8h.html#aa9797d74ed12e3d684448443027d1167">TK_COLUMN</a>;
<a name="l00433"></a>00433       pExpr-&gt;<a class="code" href="structExpr.html#a27c8824b41d853eeeebe61cf3ac1ae5a">pTab</a> = pItem-&gt;pTab;
<a name="l00434"></a>00434       pExpr-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a> = pItem-&gt;iCursor;
<a name="l00435"></a>00435       pExpr-&gt;<a class="code" href="structExpr.html#ad4f6ca9306015f5b6b608bda7baedc9e">iColumn</a> = -1;
<a name="l00436"></a>00436       pExpr-&gt;<a class="code" href="structExpr.html#aeb51b76e606d6fbae234e38473bf3dc9">affinity</a> = <a class="code" href="sqliteInt_8h.html#a45e5dc1cc144e55d53389ac9d1066924">SQLITE_AFF_INTEGER</a>;
<a name="l00437"></a>00437       <span class="keywordflow">break</span>;
<a name="l00438"></a>00438     }
<a name="l00439"></a>00439 <span class="preprocessor">#endif </span><span class="comment">/* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) &amp;&amp; !defined(SQLITE_OMIT_SUBQUERY) */</span>
<a name="l00440"></a>00440 
<a name="l00441"></a>00441     <span class="comment">/* A lone identifier is the name of a column.</span>
<a name="l00442"></a>00442 <span class="comment">    */</span>
<a name="l00443"></a>00443     <span class="keywordflow">case</span> <a class="code" href="parse_8h.html#afe9cd6ccefe30f67bf0b9c83421d270b">TK_ID</a>: {
<a name="l00444"></a>00444       <a class="code" href="resolve_8c.html#a1185f0ac34c5a013d3a7c8855dabcbb1">lookupName</a>(pParse, 0, 0, &amp;pExpr-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>, pNC, pExpr);
<a name="l00445"></a>00445       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a692431abc1f48e71c14b403d1e392adf">WRC_Prune</a>;
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447   
<a name="l00448"></a>00448     <span class="comment">/* A table name and column name:     ID.ID</span>
<a name="l00449"></a>00449 <span class="comment">    ** Or a database, table and column:  ID.ID.ID</span>
<a name="l00450"></a>00450 <span class="comment">    */</span>
<a name="l00451"></a>00451     <span class="keywordflow">case</span> <a class="code" href="parse_8h.html#a41093e546c611510c67b3f5c74ba9eb8">TK_DOT</a>: {
<a name="l00452"></a>00452       <a class="code" href="structToken.html">Token</a> *pColumn;
<a name="l00453"></a>00453       <a class="code" href="structToken.html">Token</a> *pTable;
<a name="l00454"></a>00454       <a class="code" href="structToken.html">Token</a> *pDb;
<a name="l00455"></a>00455       <a class="code" href="structExpr.html">Expr</a> *pRight;
<a name="l00456"></a>00456 
<a name="l00457"></a>00457       <span class="comment">/* if( pSrcList==0 ) break; */</span>
<a name="l00458"></a>00458       pRight = pExpr-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>;
<a name="l00459"></a>00459       <span class="keywordflow">if</span>( pRight-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#afe9cd6ccefe30f67bf0b9c83421d270b">TK_ID</a> ){
<a name="l00460"></a>00460         pDb = 0;
<a name="l00461"></a>00461         pTable = &amp;pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>;
<a name="l00462"></a>00462         pColumn = &amp;pRight-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>;
<a name="l00463"></a>00463       }<span class="keywordflow">else</span>{
<a name="l00464"></a>00464         assert( pRight-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#a41093e546c611510c67b3f5c74ba9eb8">TK_DOT</a> );
<a name="l00465"></a>00465         pDb = &amp;pExpr-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>;
<a name="l00466"></a>00466         pTable = &amp;pRight-&gt;<a class="code" href="structExpr.html#a0a78282ae0d696f4a25013a12e38b1ba">pLeft</a>-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>;
<a name="l00467"></a>00467         pColumn = &amp;pRight-&gt;<a class="code" href="structExpr.html#aaec0df173c619d6c9f1e3c81d035dc24">pRight</a>-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>;
<a name="l00468"></a>00468       }
<a name="l00469"></a>00469       <a class="code" href="resolve_8c.html#a1185f0ac34c5a013d3a7c8855dabcbb1">lookupName</a>(pParse, pDb, pTable, pColumn, pNC, pExpr);
<a name="l00470"></a>00470       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a692431abc1f48e71c14b403d1e392adf">WRC_Prune</a>;
<a name="l00471"></a>00471     }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473     <span class="comment">/* Resolve function names</span>
<a name="l00474"></a>00474 <span class="comment">    */</span>
<a name="l00475"></a>00475     <span class="keywordflow">case</span> <a class="code" href="parse_8h.html#a0e2794405dc0ab82a1d3ff291f1abf47">TK_CONST_FUNC</a>:
<a name="l00476"></a>00476     <span class="keywordflow">case</span> <a class="code" href="parse_8h.html#a3f3d91dcf238a34b77f1146c26c28f9b">TK_FUNCTION</a>: {
<a name="l00477"></a>00477       <a class="code" href="structExprList.html">ExprList</a> *pList = pExpr-&gt;<a class="code" href="structExpr.html#ac7107bf192a8080b919350925cc35dd8">pList</a>;    <span class="comment">/* The argument list */</span>
<a name="l00478"></a>00478       <span class="keywordtype">int</span> n = pList ? pList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a> : 0;  <span class="comment">/* Number of arguments */</span>
<a name="l00479"></a>00479       <span class="keywordtype">int</span> no_such_func = 0;       <span class="comment">/* True if no such function exists */</span>
<a name="l00480"></a>00480       <span class="keywordtype">int</span> wrong_num_args = 0;     <span class="comment">/* True if wrong number of arguments */</span>
<a name="l00481"></a>00481       <span class="keywordtype">int</span> is_agg = 0;             <span class="comment">/* True if is an aggregate function */</span>
<a name="l00482"></a>00482       <span class="keywordtype">int</span> auth;                   <span class="comment">/* Authorization to use the function */</span>
<a name="l00483"></a>00483       <span class="keywordtype">int</span> nId;                    <span class="comment">/* Number of characters in function name */</span>
<a name="l00484"></a>00484       <span class="keyword">const</span> <span class="keywordtype">char</span> *zId;            <span class="comment">/* The function name. */</span>
<a name="l00485"></a>00485       <a class="code" href="structFuncDef.html">FuncDef</a> *pDef;              <span class="comment">/* Information about the function */</span>
<a name="l00486"></a>00486       <span class="keywordtype">int</span> enc = <a class="code" href="sqliteInt_8h.html#a8d01c7bc7577fdd8cae2d7f9e13ae88d">ENC</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>);  <span class="comment">/* The database encoding */</span>
<a name="l00487"></a>00487 
<a name="l00488"></a>00488       zId = (<span class="keywordtype">char</span>*)pExpr-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>;
<a name="l00489"></a>00489       nId = pExpr-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>.<a class="code" href="structToken.html#a53adf03e2ba58b7967932f40d29e7fb9">n</a>;
<a name="l00490"></a>00490       pDef = <a class="code" href="callback_8c.html#a870a1bb77d2892c267108aab1bb63c89">sqlite3FindFunction</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>, zId, nId, n, enc, 0);
<a name="l00491"></a>00491       <span class="keywordflow">if</span>( pDef==0 ){
<a name="l00492"></a>00492         pDef = <a class="code" href="callback_8c.html#a870a1bb77d2892c267108aab1bb63c89">sqlite3FindFunction</a>(pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>, zId, nId, -1, enc, 0);
<a name="l00493"></a>00493         <span class="keywordflow">if</span>( pDef==0 ){
<a name="l00494"></a>00494           no_such_func = 1;
<a name="l00495"></a>00495         }<span class="keywordflow">else</span>{
<a name="l00496"></a>00496           wrong_num_args = 1;
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498       }<span class="keywordflow">else</span>{
<a name="l00499"></a>00499         is_agg = pDef-&gt;<a class="code" href="structFuncDef.html#a1cfd07fdfe22ff504ea7f36c0752c1da">xFunc</a>==0;
<a name="l00500"></a>00500       }
<a name="l00501"></a>00501 <span class="preprocessor">#ifndef SQLITE_OMIT_AUTHORIZATION</span>
<a name="l00502"></a>00502 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( pDef ){
<a name="l00503"></a>00503         auth = <a class="code" href="auth_8c.html#a7c993bc216f5c07cf032f3123167d658">sqlite3AuthCheck</a>(pParse, <a class="code" href="sqlite3_8h.html#a17deed69f2e7023742c487b95c66381e">SQLITE_FUNCTION</a>, 0, pDef-&gt;<a class="code" href="structFuncDef.html#a1135e622a3a505c7c463e975846ef926">zName</a>, 0);
<a name="l00504"></a>00504         <span class="keywordflow">if</span>( auth!=<a class="code" href="sqlite3_8h.html#a650d09c7bec7ddadb7c8aa3519dc842c">SQLITE_OK</a> ){
<a name="l00505"></a>00505           <span class="keywordflow">if</span>( auth==<a class="code" href="sqlite3_8h.html#aac54c702b6175785e3300e9172b5f9bb">SQLITE_DENY</a> ){
<a name="l00506"></a>00506             <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;not authorized to use function: %s&quot;</span>,
<a name="l00507"></a>00507                                     pDef-&gt;<a class="code" href="structFuncDef.html#a1135e622a3a505c7c463e975846ef926">zName</a>);
<a name="l00508"></a>00508             pNC-&gt;<a class="code" href="structNameContext.html#aba0b89b42e945c4c96d57a8fe011329c">nErr</a>++;
<a name="l00509"></a>00509           }
<a name="l00510"></a>00510           pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a> = <a class="code" href="parse_8h.html#a46eb52a90a0a11358d9d6cfba8430ee2">TK_NULL</a>;
<a name="l00511"></a>00511           <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a692431abc1f48e71c14b403d1e392adf">WRC_Prune</a>;
<a name="l00512"></a>00512         }
<a name="l00513"></a>00513       }
<a name="l00514"></a>00514 <span class="preprocessor">#endif</span>
<a name="l00515"></a>00515 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( is_agg &amp;&amp; !pNC-&gt;<a class="code" href="structNameContext.html#a78dc76c1493dd2f74f5f1ec661039665">allowAgg</a> ){
<a name="l00516"></a>00516         <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;misuse of aggregate function %.*s()&quot;</span>, nId,zId);
<a name="l00517"></a>00517         pNC-&gt;<a class="code" href="structNameContext.html#aba0b89b42e945c4c96d57a8fe011329c">nErr</a>++;
<a name="l00518"></a>00518         is_agg = 0;
<a name="l00519"></a>00519       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( no_such_func ){
<a name="l00520"></a>00520         <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;no such function: %.*s&quot;</span>, nId, zId);
<a name="l00521"></a>00521         pNC-&gt;<a class="code" href="structNameContext.html#aba0b89b42e945c4c96d57a8fe011329c">nErr</a>++;
<a name="l00522"></a>00522       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( wrong_num_args ){
<a name="l00523"></a>00523         <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse,<span class="stringliteral">&quot;wrong number of arguments to function %.*s()&quot;</span>,
<a name="l00524"></a>00524              nId, zId);
<a name="l00525"></a>00525         pNC-&gt;<a class="code" href="structNameContext.html#aba0b89b42e945c4c96d57a8fe011329c">nErr</a>++;
<a name="l00526"></a>00526       }
<a name="l00527"></a>00527       <span class="keywordflow">if</span>( is_agg ){
<a name="l00528"></a>00528         pExpr-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a> = <a class="code" href="parse_8h.html#a7dcde0a0e72df2033dda1af5a499ff10">TK_AGG_FUNCTION</a>;
<a name="l00529"></a>00529         pNC-&gt;<a class="code" href="structNameContext.html#a6edabae39c69ad9a748f9ea519d9f56e">hasAgg</a> = 1;
<a name="l00530"></a>00530       }
<a name="l00531"></a>00531       <span class="keywordflow">if</span>( is_agg ) pNC-&gt;<a class="code" href="structNameContext.html#a78dc76c1493dd2f74f5f1ec661039665">allowAgg</a> = 0;
<a name="l00532"></a>00532       <a class="code" href="sqliteInt_8h.html#a9ebef266ec135692ccddabb8d38708d8">sqlite3WalkExprList</a>(pWalker, pList);
<a name="l00533"></a>00533       <span class="keywordflow">if</span>( is_agg ) pNC-&gt;<a class="code" href="structNameContext.html#a78dc76c1493dd2f74f5f1ec661039665">allowAgg</a> = 1;
<a name="l00534"></a>00534       <span class="comment">/* FIX ME:  Compute pExpr-&gt;affinity based on the expected return</span>
<a name="l00535"></a>00535 <span class="comment">      ** type of the function </span>
<a name="l00536"></a>00536 <span class="comment">      */</span>
<a name="l00537"></a>00537       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a692431abc1f48e71c14b403d1e392adf">WRC_Prune</a>;
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539 <span class="preprocessor">#ifndef SQLITE_OMIT_SUBQUERY</span>
<a name="l00540"></a>00540 <span class="preprocessor"></span>    <span class="keywordflow">case</span> <a class="code" href="parse_8h.html#a6a61efcf344e9ae3cda8d1e8b6c7bc04">TK_SELECT</a>:
<a name="l00541"></a>00541     <span class="keywordflow">case</span> <a class="code" href="parse_8h.html#af0a21200f6b3f6d0cfa78c663eef5805">TK_EXISTS</a>:
<a name="l00542"></a>00542 <span class="preprocessor">#endif</span>
<a name="l00543"></a>00543 <span class="preprocessor"></span>    <span class="keywordflow">case</span> <a class="code" href="parse_8h.html#a6437312264a013b5bf1539ffe8a65e94">TK_IN</a>: {
<a name="l00544"></a>00544       <span class="keywordflow">if</span>( pExpr-&gt;<a class="code" href="structExpr.html#a54e5186fdf157f8b4ae178919d8ff6b3">pSelect</a> ){
<a name="l00545"></a>00545         <span class="keywordtype">int</span> nRef = pNC-&gt;<a class="code" href="structNameContext.html#ad68616ce2a58fa1b135e0dcf953bdc97">nRef</a>;
<a name="l00546"></a>00546 <span class="preprocessor">#ifndef SQLITE_OMIT_CHECK</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( pNC-&gt;<a class="code" href="structNameContext.html#a8098661d47980e74f56c686772dcaf85">isCheck</a> ){
<a name="l00548"></a>00548           <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse,<span class="stringliteral">&quot;subqueries prohibited in CHECK constraints&quot;</span>);
<a name="l00549"></a>00549         }
<a name="l00550"></a>00550 <span class="preprocessor">#endif</span>
<a name="l00551"></a>00551 <span class="preprocessor"></span>        <a class="code" href="sqliteInt_8h.html#a36f4ec0cb85c2ced6f5b860f4bcf7217">sqlite3WalkSelect</a>(pWalker, pExpr-&gt;<a class="code" href="structExpr.html#a54e5186fdf157f8b4ae178919d8ff6b3">pSelect</a>);
<a name="l00552"></a>00552         assert( pNC-&gt;<a class="code" href="structNameContext.html#ad68616ce2a58fa1b135e0dcf953bdc97">nRef</a>&gt;=nRef );
<a name="l00553"></a>00553         <span class="keywordflow">if</span>( nRef!=pNC-&gt;<a class="code" href="structNameContext.html#ad68616ce2a58fa1b135e0dcf953bdc97">nRef</a> ){
<a name="l00554"></a>00554           <a class="code" href="sqliteInt_8h.html#aedc713d2783c34ef92b63ba28c495dfe">ExprSetProperty</a>(pExpr, <a class="code" href="sqliteInt_8h.html#aadfd459fc9842c0605235220fbabba58">EP_VarSelect</a>);
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556       }
<a name="l00557"></a>00557       <span class="keywordflow">break</span>;
<a name="l00558"></a>00558     }
<a name="l00559"></a>00559 <span class="preprocessor">#ifndef SQLITE_OMIT_CHECK</span>
<a name="l00560"></a>00560 <span class="preprocessor"></span>    <span class="keywordflow">case</span> <a class="code" href="parse_8h.html#ab0618a9ee137c31ec3134eb20dd71ac7">TK_VARIABLE</a>: {
<a name="l00561"></a>00561       <span class="keywordflow">if</span>( pNC-&gt;<a class="code" href="structNameContext.html#a8098661d47980e74f56c686772dcaf85">isCheck</a> ){
<a name="l00562"></a>00562         <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse,<span class="stringliteral">&quot;parameters prohibited in CHECK constraints&quot;</span>);
<a name="l00563"></a>00563       }
<a name="l00564"></a>00564       <span class="keywordflow">break</span>;
<a name="l00565"></a>00565     }
<a name="l00566"></a>00566 <span class="preprocessor">#endif</span>
<a name="l00567"></a>00567 <span class="preprocessor"></span>  }
<a name="l00568"></a>00568   <span class="keywordflow">return</span> (pParse-&gt;<a class="code" href="structParse.html#ac7206f0c7e580ab32b7dfb20950bb1c9">nErr</a> || pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a>) ? <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a> : <a class="code" href="sqliteInt_8h.html#af2b76e0710293323692ec862d54f69a3">WRC_Continue</a>;
<a name="l00569"></a>00569 }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 <span class="comment">/*</span>
<a name="l00572"></a>00572 <span class="comment">** pEList is a list of expressions which are really the result set of the</span>
<a name="l00573"></a>00573 <span class="comment">** a SELECT statement.  pE is a term in an ORDER BY or GROUP BY clause.</span>
<a name="l00574"></a>00574 <span class="comment">** This routine checks to see if pE is a simple identifier which corresponds</span>
<a name="l00575"></a>00575 <span class="comment">** to the AS-name of one of the terms of the expression list.  If it is,</span>
<a name="l00576"></a>00576 <span class="comment">** this routine return an integer between 1 and N where N is the number of</span>
<a name="l00577"></a>00577 <span class="comment">** elements in pEList, corresponding to the matching entry.  If there is</span>
<a name="l00578"></a>00578 <span class="comment">** no match, or if pE is not a simple identifier, then this routine</span>
<a name="l00579"></a>00579 <span class="comment">** return 0.</span>
<a name="l00580"></a>00580 <span class="comment">**</span>
<a name="l00581"></a>00581 <span class="comment">** pEList has been resolved.  pE has not.</span>
<a name="l00582"></a>00582 <span class="comment">*/</span>
<a name="l00583"></a><a class="code" href="resolve_8c.html#abb95777576695ea71cdd95e0c17382f8">00583</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="resolve_8c.html#abb95777576695ea71cdd95e0c17382f8">resolveAsName</a>(
<a name="l00584"></a>00584   <a class="code" href="structParse.html">Parse</a> *pParse,     <span class="comment">/* Parsing context for error messages */</span>
<a name="l00585"></a>00585   <a class="code" href="structExprList.html">ExprList</a> *pEList,  <span class="comment">/* List of expressions to scan */</span>
<a name="l00586"></a>00586   <a class="code" href="structExpr.html">Expr</a> *pE           <span class="comment">/* Expression we are trying to match */</span>
<a name="l00587"></a>00587 ){
<a name="l00588"></a>00588   <span class="keywordtype">int</span> i;             <span class="comment">/* Loop counter */</span>
<a name="l00589"></a>00589 
<a name="l00590"></a>00590   <span class="keywordflow">if</span>( pE-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#afe9cd6ccefe30f67bf0b9c83421d270b">TK_ID</a> || (pE-&gt;<a class="code" href="structExpr.html#a101c55ddb6c149d95f0327831eb78225">op</a>==<a class="code" href="parse_8h.html#a9810f9bc21f26ee9b8d7b374534ff54b">TK_STRING</a> &amp;&amp; pE-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>.<a class="code" href="structToken.html#a27654081d5afd48666ef407d6a34d490">z</a>[0]!=<span class="charliteral">&apos;\&apos;&apos;</span>) ){
<a name="l00591"></a>00591     <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00592"></a>00592     <span class="keywordtype">char</span> *zCol = <a class="code" href="build_8c.html#a19bf99e43ecbf922cb3bba8777dbc381">sqlite3NameFromToken</a>(db, &amp;pE-&gt;<a class="code" href="structExpr.html#ae646739f183bab67ee40ab463f428125">token</a>);
<a name="l00593"></a>00593     <span class="keywordflow">if</span>( zCol==0 ){
<a name="l00594"></a>00594       <span class="keywordflow">return</span> -1;
<a name="l00595"></a>00595     }
<a name="l00596"></a>00596     <span class="keywordflow">for</span>(i=0; i&lt;pEList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>; i++){
<a name="l00597"></a>00597       <span class="keywordtype">char</span> *zAs = pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#af278eb03a1169c73d144547adaf9b04f">zName</a>;
<a name="l00598"></a>00598       <span class="keywordflow">if</span>( zAs!=0 &amp;&amp; <a class="code" href="sqliteInt_8h.html#ae3fd8e3be3ee260b4be7afe7b9d23406">sqlite3StrICmp</a>(zAs, zCol)==0 ){
<a name="l00599"></a>00599         <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zCol);
<a name="l00600"></a>00600         <span class="keywordflow">return</span> i+1;
<a name="l00601"></a>00601       }
<a name="l00602"></a>00602     }
<a name="l00603"></a>00603     <a class="code" href="malloc_8c.html#a8ca215f2395ca90fd180460afb2eba9d">sqlite3DbFree</a>(db, zCol);
<a name="l00604"></a>00604   }
<a name="l00605"></a>00605   <span class="keywordflow">return</span> 0;
<a name="l00606"></a>00606 }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 <span class="comment">/*</span>
<a name="l00609"></a>00609 <span class="comment">** pE is a pointer to an expression which is a single term in the</span>
<a name="l00610"></a>00610 <span class="comment">** ORDER BY of a compound SELECT.  The expression has not been</span>
<a name="l00611"></a>00611 <span class="comment">** name resolved.</span>
<a name="l00612"></a>00612 <span class="comment">**</span>
<a name="l00613"></a>00613 <span class="comment">** At the point this routine is called, we already know that the</span>
<a name="l00614"></a>00614 <span class="comment">** ORDER BY term is not an integer index into the result set.  That</span>
<a name="l00615"></a>00615 <span class="comment">** case is handled by the calling routine.</span>
<a name="l00616"></a>00616 <span class="comment">**</span>
<a name="l00617"></a>00617 <span class="comment">** Attempt to match pE against result set columns in the left-most</span>
<a name="l00618"></a>00618 <span class="comment">** SELECT statement.  Return the index i of the matching column,</span>
<a name="l00619"></a>00619 <span class="comment">** as an indication to the caller that it should sort by the i-th column.</span>
<a name="l00620"></a>00620 <span class="comment">** The left-most column is 1.  In other words, the value returned is the</span>
<a name="l00621"></a>00621 <span class="comment">** same integer value that would be used in the SQL statement to indicate</span>
<a name="l00622"></a>00622 <span class="comment">** the column.</span>
<a name="l00623"></a>00623 <span class="comment">**</span>
<a name="l00624"></a>00624 <span class="comment">** If there is no match, return 0.  Return -1 if an error occurs.</span>
<a name="l00625"></a>00625 <span class="comment">*/</span>
<a name="l00626"></a><a class="code" href="resolve_8c.html#ac7f7eabdc769257622ad90aac3e02fe6">00626</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="resolve_8c.html#ac7f7eabdc769257622ad90aac3e02fe6">resolveOrderByTermToExprList</a>(
<a name="l00627"></a>00627   <a class="code" href="structParse.html">Parse</a> *pParse,     <span class="comment">/* Parsing context for error messages */</span>
<a name="l00628"></a>00628   <a class="code" href="structSelect.html">Select</a> *pSelect,   <span class="comment">/* The SELECT statement with the ORDER BY clause */</span>
<a name="l00629"></a>00629   <a class="code" href="structExpr.html">Expr</a> *pE           <span class="comment">/* The specific ORDER BY term */</span>
<a name="l00630"></a>00630 ){
<a name="l00631"></a>00631   <span class="keywordtype">int</span> i;             <span class="comment">/* Loop counter */</span>
<a name="l00632"></a>00632   <a class="code" href="structExprList.html">ExprList</a> *pEList;  <span class="comment">/* The columns of the result set */</span>
<a name="l00633"></a>00633   <a class="code" href="structNameContext.html">NameContext</a> nc;    <span class="comment">/* Name context for resolving pE */</span>
<a name="l00634"></a>00634 
<a name="l00635"></a>00635   assert( <a class="code" href="expr_8c.html#ae6f241af6b7d1e232ef12fec49267832">sqlite3ExprIsInteger</a>(pE, &amp;i)==0 );
<a name="l00636"></a>00636   pEList = pSelect-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>;
<a name="l00637"></a>00637 
<a name="l00638"></a>00638   <span class="comment">/* Resolve all names in the ORDER BY term expression</span>
<a name="l00639"></a>00639 <span class="comment">  */</span>
<a name="l00640"></a>00640   memset(&amp;nc, 0, <span class="keyword">sizeof</span>(nc));
<a name="l00641"></a>00641   nc.<a class="code" href="structNameContext.html#a14635249bf75d5e18124089571dd2386">pParse</a> = pParse;
<a name="l00642"></a>00642   nc.<a class="code" href="structNameContext.html#a6ede21da33e2e9bd3d0c5fe90a3ec72c">pSrcList</a> = pSelect-&gt;<a class="code" href="structSelect.html#a4e3b9b176a8e1b4af988405ff1f090db">pSrc</a>;
<a name="l00643"></a>00643   nc.<a class="code" href="structNameContext.html#a8c752d7fb9b28179156c569cc57ba6f2">pEList</a> = pEList;
<a name="l00644"></a>00644   nc.<a class="code" href="structNameContext.html#a78dc76c1493dd2f74f5f1ec661039665">allowAgg</a> = 1;
<a name="l00645"></a>00645   nc.<a class="code" href="structNameContext.html#aba0b89b42e945c4c96d57a8fe011329c">nErr</a> = 0;
<a name="l00646"></a>00646   <span class="keywordflow">if</span>( <a class="code" href="resolve_8c.html#afc8765990fa4299c3dc9bd295ae85291">sqlite3ResolveExprNames</a>(&amp;nc, pE) ){
<a name="l00647"></a>00647     <a class="code" href="sqliteInt_8h.html#adefec0a5695945b931b323dec7fcd22d">sqlite3ErrorClear</a>(pParse);
<a name="l00648"></a>00648     <span class="keywordflow">return</span> 0;
<a name="l00649"></a>00649   }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651   <span class="comment">/* Try to match the ORDER BY expression against an expression</span>
<a name="l00652"></a>00652 <span class="comment">  ** in the result set.  Return an 1-based index of the matching</span>
<a name="l00653"></a>00653 <span class="comment">  ** result-set entry.</span>
<a name="l00654"></a>00654 <span class="comment">  */</span>
<a name="l00655"></a>00655   <span class="keywordflow">for</span>(i=0; i&lt;pEList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>; i++){
<a name="l00656"></a>00656     <span class="keywordflow">if</span>( <a class="code" href="expr_8c.html#a936b53013e4bc0ff2e46d7def7acb9e4">sqlite3ExprCompare</a>(pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>, pE) ){
<a name="l00657"></a>00657       <span class="keywordflow">return</span> i+1;
<a name="l00658"></a>00658     }
<a name="l00659"></a>00659   }
<a name="l00660"></a>00660 
<a name="l00661"></a>00661   <span class="comment">/* If no match, return 0. */</span>
<a name="l00662"></a>00662   <span class="keywordflow">return</span> 0;
<a name="l00663"></a>00663 }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 <span class="comment">/*</span>
<a name="l00666"></a>00666 <span class="comment">** Generate an ORDER BY or GROUP BY term out-of-range error.</span>
<a name="l00667"></a>00667 <span class="comment">*/</span>
<a name="l00668"></a><a class="code" href="resolve_8c.html#abaf80a4194f11e3f8515a85ab94f670b">00668</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="resolve_8c.html#abaf80a4194f11e3f8515a85ab94f670b">resolveOutOfRangeError</a>(
<a name="l00669"></a>00669   <a class="code" href="structParse.html">Parse</a> *pParse,         <span class="comment">/* The error context into which to write the error */</span>
<a name="l00670"></a>00670   <span class="keyword">const</span> <span class="keywordtype">char</span> *zType,     <span class="comment">/* &quot;ORDER&quot; or &quot;GROUP&quot; */</span>
<a name="l00671"></a>00671   <span class="keywordtype">int</span> i,                 <span class="comment">/* The index (1-based) of the term out of range */</span>
<a name="l00672"></a>00672   <span class="keywordtype">int</span> mx                 <span class="comment">/* Largest permissible value of i */</span>
<a name="l00673"></a>00673 ){
<a name="l00674"></a>00674   <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, 
<a name="l00675"></a>00675     <span class="stringliteral">&quot;%r %s BY term out of range - should be &quot;</span>
<a name="l00676"></a>00676     <span class="stringliteral">&quot;between 1 and %d&quot;</span>, i, zType, mx);
<a name="l00677"></a>00677 }
<a name="l00678"></a>00678 
<a name="l00679"></a>00679 <span class="comment">/*</span>
<a name="l00680"></a>00680 <span class="comment">** Analyze the ORDER BY clause in a compound SELECT statement.   Modify</span>
<a name="l00681"></a>00681 <span class="comment">** each term of the ORDER BY clause is a constant integer between 1</span>
<a name="l00682"></a>00682 <span class="comment">** and N where N is the number of columns in the compound SELECT.</span>
<a name="l00683"></a>00683 <span class="comment">**</span>
<a name="l00684"></a>00684 <span class="comment">** ORDER BY terms that are already an integer between 1 and N are</span>
<a name="l00685"></a>00685 <span class="comment">** unmodified.  ORDER BY terms that are integers outside the range of</span>
<a name="l00686"></a>00686 <span class="comment">** 1 through N generate an error.  ORDER BY terms that are expressions</span>
<a name="l00687"></a>00687 <span class="comment">** are matched against result set expressions of compound SELECT</span>
<a name="l00688"></a>00688 <span class="comment">** beginning with the left-most SELECT and working toward the right.</span>
<a name="l00689"></a>00689 <span class="comment">** At the first match, the ORDER BY expression is transformed into</span>
<a name="l00690"></a>00690 <span class="comment">** the integer column number.</span>
<a name="l00691"></a>00691 <span class="comment">**</span>
<a name="l00692"></a>00692 <span class="comment">** Return the number of errors seen.</span>
<a name="l00693"></a>00693 <span class="comment">*/</span>
<a name="l00694"></a><a class="code" href="resolve_8c.html#a462c5aa49cfd6aad6a92fa60ddefc569">00694</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="resolve_8c.html#a462c5aa49cfd6aad6a92fa60ddefc569">resolveCompoundOrderBy</a>(
<a name="l00695"></a>00695   <a class="code" href="structParse.html">Parse</a> *pParse,        <span class="comment">/* Parsing context.  Leave error messages here */</span>
<a name="l00696"></a>00696   <a class="code" href="structSelect.html">Select</a> *pSelect       <span class="comment">/* The SELECT statement containing the ORDER BY */</span>
<a name="l00697"></a>00697 ){
<a name="l00698"></a>00698   <span class="keywordtype">int</span> i;
<a name="l00699"></a>00699   <a class="code" href="structExprList.html">ExprList</a> *pOrderBy;
<a name="l00700"></a>00700   <a class="code" href="structExprList.html">ExprList</a> *pEList;
<a name="l00701"></a>00701   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>;
<a name="l00702"></a>00702   <span class="keywordtype">int</span> moreToDo = 1;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704   pOrderBy = pSelect-&gt;<a class="code" href="structSelect.html#a73c474cd4a9a9b9aa4e3187d8bf2d886">pOrderBy</a>;
<a name="l00705"></a>00705   <span class="keywordflow">if</span>( pOrderBy==0 ) <span class="keywordflow">return</span> 0;
<a name="l00706"></a>00706   db = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00707"></a>00707 <span class="preprocessor">#if SQLITE_MAX_COLUMN</span>
<a name="l00708"></a>00708 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>&gt;db-&gt;<a class="code" href="structsqlite3.html#ad8acf663e1619905094c9dfe4125157b">aLimit</a>[<a class="code" href="sqlite3_8h.html#a2094f8f2bb22f8d1bdbaace43aca70d4">SQLITE_LIMIT_COLUMN</a>] ){
<a name="l00709"></a>00709     <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;too many terms in ORDER BY clause&quot;</span>);
<a name="l00710"></a>00710     <span class="keywordflow">return</span> 1;
<a name="l00711"></a>00711   }
<a name="l00712"></a>00712 <span class="preprocessor">#endif</span>
<a name="l00713"></a>00713 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i=0; i&lt;pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>; i++){
<a name="l00714"></a>00714     pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#a84aad270c98e28a725a840aac3ee8576">done</a> = 0;
<a name="l00715"></a>00715   }
<a name="l00716"></a>00716   pSelect-&gt;<a class="code" href="structSelect.html#a96aa0caf60390b8f5e88589639205c40">pNext</a> = 0;
<a name="l00717"></a>00717   <span class="keywordflow">while</span>( pSelect-&gt;<a class="code" href="structSelect.html#a51d1a253b0aba5a54b11b3bf3896d056">pPrior</a> ){
<a name="l00718"></a>00718     pSelect-&gt;<a class="code" href="structSelect.html#a51d1a253b0aba5a54b11b3bf3896d056">pPrior</a>-&gt;<a class="code" href="structSelect.html#a96aa0caf60390b8f5e88589639205c40">pNext</a> = pSelect;
<a name="l00719"></a>00719     pSelect = pSelect-&gt;<a class="code" href="structSelect.html#a51d1a253b0aba5a54b11b3bf3896d056">pPrior</a>;
<a name="l00720"></a>00720   }
<a name="l00721"></a>00721   <span class="keywordflow">while</span>( pSelect &amp;&amp; moreToDo ){
<a name="l00722"></a>00722     <span class="keyword">struct </span>ExprList_item *pItem;
<a name="l00723"></a>00723     moreToDo = 0;
<a name="l00724"></a>00724     pEList = pSelect-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>;
<a name="l00725"></a>00725     assert( pEList!=0 );
<a name="l00726"></a>00726     <span class="keywordflow">for</span>(i=0, pItem=pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>; i&lt;pOrderBy-&gt;nExpr; i++, pItem++){
<a name="l00727"></a>00727       <span class="keywordtype">int</span> iCol = -1;
<a name="l00728"></a>00728       <a class="code" href="structExpr.html">Expr</a> *pE, *pDup;
<a name="l00729"></a>00729       <span class="keywordflow">if</span>( pItem-&gt;done ) <span class="keywordflow">continue</span>;
<a name="l00730"></a>00730       pE = pItem-&gt;pExpr;
<a name="l00731"></a>00731       <span class="keywordflow">if</span>( <a class="code" href="expr_8c.html#ae6f241af6b7d1e232ef12fec49267832">sqlite3ExprIsInteger</a>(pE, &amp;iCol) ){
<a name="l00732"></a>00732         <span class="keywordflow">if</span>( iCol&lt;0 || iCol&gt;pEList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a> ){
<a name="l00733"></a>00733           <a class="code" href="resolve_8c.html#abaf80a4194f11e3f8515a85ab94f670b">resolveOutOfRangeError</a>(pParse, <span class="stringliteral">&quot;ORDER&quot;</span>, i+1, pEList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>);
<a name="l00734"></a>00734           <span class="keywordflow">return</span> 1;
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736       }<span class="keywordflow">else</span>{
<a name="l00737"></a>00737         iCol = <a class="code" href="resolve_8c.html#abb95777576695ea71cdd95e0c17382f8">resolveAsName</a>(pParse, pEList, pE);
<a name="l00738"></a>00738         <span class="keywordflow">if</span>( iCol==0 ){
<a name="l00739"></a>00739           pDup = <a class="code" href="expr_8c.html#a924d6257714f00536c68782ce42f103d">sqlite3ExprDup</a>(db, pE);
<a name="l00740"></a>00740           <span class="keywordflow">if</span>( !db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l00741"></a>00741             assert(pDup);
<a name="l00742"></a>00742             iCol = <a class="code" href="resolve_8c.html#ac7f7eabdc769257622ad90aac3e02fe6">resolveOrderByTermToExprList</a>(pParse, pSelect, pDup);
<a name="l00743"></a>00743           }
<a name="l00744"></a>00744           <a class="code" href="expr_8c.html#a8503bb02b6cb0343caf2391ca8cfc266">sqlite3ExprDelete</a>(db, pDup);
<a name="l00745"></a>00745         }
<a name="l00746"></a>00746         <span class="keywordflow">if</span>( iCol&lt;0 ){
<a name="l00747"></a>00747           <span class="keywordflow">return</span> 1;
<a name="l00748"></a>00748         }
<a name="l00749"></a>00749       }
<a name="l00750"></a>00750       <span class="keywordflow">if</span>( iCol&gt;0 ){
<a name="l00751"></a>00751         <a class="code" href="structCollSeq.html">CollSeq</a> *pColl = pE-&gt;<a class="code" href="structExpr.html#a4ef09e21aaa9d61567b89714e25abfb9">pColl</a>;
<a name="l00752"></a>00752         <span class="keywordtype">int</span> flags = pE-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> &amp; <a class="code" href="sqliteInt_8h.html#a8504ef15835e9661eeb00e1cbe530b33">EP_ExpCollate</a>;
<a name="l00753"></a>00753         <a class="code" href="expr_8c.html#a8503bb02b6cb0343caf2391ca8cfc266">sqlite3ExprDelete</a>(db, pE);
<a name="l00754"></a>00754         pItem-&gt;pExpr = pE = <a class="code" href="expr_8c.html#a1033316115be02c18a6fd8946f3e4a61">sqlite3Expr</a>(db, <a class="code" href="parse_8h.html#a9630e9dd96af624355f0f641613038ae">TK_INTEGER</a>, 0, 0, 0);
<a name="l00755"></a>00755         <span class="keywordflow">if</span>( pE==0 ) <span class="keywordflow">return</span> 1;
<a name="l00756"></a>00756         pE-&gt;<a class="code" href="structExpr.html#a4ef09e21aaa9d61567b89714e25abfb9">pColl</a> = pColl;
<a name="l00757"></a>00757         pE-&gt;<a class="code" href="structExpr.html#ad6013561807a4a5182ce928f263bc3bf">flags</a> |= <a class="code" href="sqliteInt_8h.html#a97c9aaf68bc36c991a85ff52855359f8">EP_IntValue</a> | flags;
<a name="l00758"></a>00758         pE-&gt;<a class="code" href="structExpr.html#af8e273f4d7d173bfb5996ed09054611c">iTable</a> = iCol;
<a name="l00759"></a>00759         pItem-&gt;iCol = iCol;
<a name="l00760"></a>00760         pItem-&gt;done = 1;
<a name="l00761"></a>00761       }<span class="keywordflow">else</span>{
<a name="l00762"></a>00762         moreToDo = 1;
<a name="l00763"></a>00763       }
<a name="l00764"></a>00764     }
<a name="l00765"></a>00765     pSelect = pSelect-&gt;<a class="code" href="structSelect.html#a96aa0caf60390b8f5e88589639205c40">pNext</a>;
<a name="l00766"></a>00766   }
<a name="l00767"></a>00767   <span class="keywordflow">for</span>(i=0; i&lt;pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>; i++){
<a name="l00768"></a>00768     <span class="keywordflow">if</span>( pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#a84aad270c98e28a725a840aac3ee8576">done</a>==0 ){
<a name="l00769"></a>00769       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;%r ORDER BY term does not match any &quot;</span>
<a name="l00770"></a>00770             <span class="stringliteral">&quot;column in the result set&quot;</span>, i+1);
<a name="l00771"></a>00771       <span class="keywordflow">return</span> 1;
<a name="l00772"></a>00772     }
<a name="l00773"></a>00773   }
<a name="l00774"></a>00774   <span class="keywordflow">return</span> 0;
<a name="l00775"></a>00775 }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="comment">/*</span>
<a name="l00778"></a>00778 <span class="comment">** Check every term in the ORDER BY or GROUP BY clause pOrderBy of</span>
<a name="l00779"></a>00779 <span class="comment">** the SELECT statement pSelect.  If any term is reference to a</span>
<a name="l00780"></a>00780 <span class="comment">** result set expression (as determined by the ExprList.a.iCol field)</span>
<a name="l00781"></a>00781 <span class="comment">** then convert that term into a copy of the corresponding result set</span>
<a name="l00782"></a>00782 <span class="comment">** column.</span>
<a name="l00783"></a>00783 <span class="comment">**</span>
<a name="l00784"></a>00784 <span class="comment">** If any errors are detected, add an error message to pParse and</span>
<a name="l00785"></a>00785 <span class="comment">** return non-zero.  Return zero if no errors are seen.</span>
<a name="l00786"></a>00786 <span class="comment">*/</span>
<a name="l00787"></a><a class="code" href="sqliteInt_8h.html#a54d9236d2d46b9c3ba7aa5ce888da071">00787</a> <span class="keywordtype">int</span> <a class="code" href="resolve_8c.html#a35c6c68fba6c9eed6a70a9a73f87422b">sqlite3ResolveOrderGroupBy</a>(
<a name="l00788"></a>00788   <a class="code" href="structParse.html">Parse</a> *pParse,        <span class="comment">/* Parsing context.  Leave error messages here */</span>
<a name="l00789"></a>00789   <a class="code" href="structSelect.html">Select</a> *pSelect,      <span class="comment">/* The SELECT statement containing the clause */</span>
<a name="l00790"></a>00790   <a class="code" href="structExprList.html">ExprList</a> *pOrderBy,   <span class="comment">/* The ORDER BY or GROUP BY clause to be processed */</span>
<a name="l00791"></a>00791   <span class="keyword">const</span> <span class="keywordtype">char</span> *zType     <span class="comment">/* &quot;ORDER&quot; or &quot;GROUP&quot; */</span>
<a name="l00792"></a>00792 ){
<a name="l00793"></a>00793   <span class="keywordtype">int</span> i;
<a name="l00794"></a>00794   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a> = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00795"></a>00795   <a class="code" href="structExprList.html">ExprList</a> *pEList;
<a name="l00796"></a>00796   <span class="keyword">struct </span>ExprList_item *pItem;
<a name="l00797"></a>00797 
<a name="l00798"></a>00798   <span class="keywordflow">if</span>( pOrderBy==0 || pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ) <span class="keywordflow">return</span> 0;
<a name="l00799"></a>00799 <span class="preprocessor">#if SQLITE_MAX_COLUMN</span>
<a name="l00800"></a>00800 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pOrderBy-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>&gt;db-&gt;<a class="code" href="structsqlite3.html#ad8acf663e1619905094c9dfe4125157b">aLimit</a>[<a class="code" href="sqlite3_8h.html#a2094f8f2bb22f8d1bdbaace43aca70d4">SQLITE_LIMIT_COLUMN</a>] ){
<a name="l00801"></a>00801     <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;too many terms in %s BY clause&quot;</span>, zType);
<a name="l00802"></a>00802     <span class="keywordflow">return</span> 1;
<a name="l00803"></a>00803   }
<a name="l00804"></a>00804 <span class="preprocessor">#endif</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>  pEList = pSelect-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>;
<a name="l00806"></a>00806   assert( pEList!=0 );  <span class="comment">/* sqlite3SelectNew() guarantees this */</span>
<a name="l00807"></a>00807   <span class="keywordflow">for</span>(i=0, pItem=pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>; i&lt;pOrderBy-&gt;nExpr; i++, pItem++){
<a name="l00808"></a>00808     <span class="keywordflow">if</span>( pItem-&gt;iCol ){
<a name="l00809"></a>00809       <span class="keywordflow">if</span>( pItem-&gt;iCol&gt;pEList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a> ){
<a name="l00810"></a>00810         <a class="code" href="resolve_8c.html#abaf80a4194f11e3f8515a85ab94f670b">resolveOutOfRangeError</a>(pParse, zType, i+1, pEList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>);
<a name="l00811"></a>00811         <span class="keywordflow">return</span> 1;
<a name="l00812"></a>00812       }
<a name="l00813"></a>00813       <a class="code" href="resolve_8c.html#ad52379b88e14575e95e757bbdef9cac1">resolveAlias</a>(pParse, pEList, pItem-&gt;iCol-1, pItem-&gt;pExpr, zType);
<a name="l00814"></a>00814     }
<a name="l00815"></a>00815   }
<a name="l00816"></a>00816   <span class="keywordflow">return</span> 0;
<a name="l00817"></a>00817 }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 <span class="comment">/*</span>
<a name="l00820"></a>00820 <span class="comment">** pOrderBy is an ORDER BY or GROUP BY clause in SELECT statement pSelect.</span>
<a name="l00821"></a>00821 <span class="comment">** The Name context of the SELECT statement is pNC.  zType is either</span>
<a name="l00822"></a>00822 <span class="comment">** &quot;ORDER&quot; or &quot;GROUP&quot; depending on which type of clause pOrderBy is.</span>
<a name="l00823"></a>00823 <span class="comment">**</span>
<a name="l00824"></a>00824 <span class="comment">** This routine resolves each term of the clause into an expression.</span>
<a name="l00825"></a>00825 <span class="comment">** If the order-by term is an integer I between 1 and N (where N is the</span>
<a name="l00826"></a>00826 <span class="comment">** number of columns in the result set of the SELECT) then the expression</span>
<a name="l00827"></a>00827 <span class="comment">** in the resolution is a copy of the I-th result-set expression.  If</span>
<a name="l00828"></a>00828 <span class="comment">** the order-by term is an identify that corresponds to the AS-name of</span>
<a name="l00829"></a>00829 <span class="comment">** a result-set expression, then the term resolves to a copy of the</span>
<a name="l00830"></a>00830 <span class="comment">** result-set expression.  Otherwise, the expression is resolved in</span>
<a name="l00831"></a>00831 <span class="comment">** the usual way - using sqlite3ResolveExprNames().</span>
<a name="l00832"></a>00832 <span class="comment">**</span>
<a name="l00833"></a>00833 <span class="comment">** This routine returns the number of errors.  If errors occur, then</span>
<a name="l00834"></a>00834 <span class="comment">** an appropriate error message might be left in pParse.  (OOM errors</span>
<a name="l00835"></a>00835 <span class="comment">** excepted.)</span>
<a name="l00836"></a>00836 <span class="comment">*/</span>
<a name="l00837"></a><a class="code" href="resolve_8c.html#a4dc8ed6177a5de887eae1010992e3d00">00837</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="resolve_8c.html#a4dc8ed6177a5de887eae1010992e3d00">resolveOrderGroupBy</a>(
<a name="l00838"></a>00838   <a class="code" href="structNameContext.html">NameContext</a> *pNC,     <span class="comment">/* The name context of the SELECT statement */</span>
<a name="l00839"></a>00839   <a class="code" href="structSelect.html">Select</a> *pSelect,      <span class="comment">/* The SELECT statement holding pOrderBy */</span>
<a name="l00840"></a>00840   <a class="code" href="structExprList.html">ExprList</a> *pOrderBy,   <span class="comment">/* An ORDER BY or GROUP BY clause to resolve */</span>
<a name="l00841"></a>00841   <span class="keyword">const</span> <span class="keywordtype">char</span> *zType     <span class="comment">/* Either &quot;ORDER&quot; or &quot;GROUP&quot;, as appropriate */</span>
<a name="l00842"></a>00842 ){
<a name="l00843"></a>00843   <span class="keywordtype">int</span> i;                         <span class="comment">/* Loop counter */</span>
<a name="l00844"></a>00844   <span class="keywordtype">int</span> iCol;                      <span class="comment">/* Column number */</span>
<a name="l00845"></a>00845   <span class="keyword">struct </span>ExprList_item *pItem;   <span class="comment">/* A term of the ORDER BY clause */</span>
<a name="l00846"></a>00846   <a class="code" href="structParse.html">Parse</a> *pParse;                 <span class="comment">/* Parsing context */</span>
<a name="l00847"></a>00847   <span class="keywordtype">int</span> nResult;                   <span class="comment">/* Number of terms in the result set */</span>
<a name="l00848"></a>00848 
<a name="l00849"></a>00849   <span class="keywordflow">if</span>( pOrderBy==0 ) <span class="keywordflow">return</span> 0;
<a name="l00850"></a>00850   nResult = pSelect-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>;
<a name="l00851"></a>00851   pParse = pNC-&gt;<a class="code" href="structNameContext.html#a14635249bf75d5e18124089571dd2386">pParse</a>;
<a name="l00852"></a>00852   <span class="keywordflow">for</span>(i=0, pItem=pOrderBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>; i&lt;pOrderBy-&gt;nExpr; i++, pItem++){
<a name="l00853"></a>00853     <a class="code" href="structExpr.html">Expr</a> *pE = pItem-&gt;pExpr;
<a name="l00854"></a>00854     iCol = <a class="code" href="resolve_8c.html#abb95777576695ea71cdd95e0c17382f8">resolveAsName</a>(pParse, pSelect-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>, pE);
<a name="l00855"></a>00855     <span class="keywordflow">if</span>( iCol&lt;0 ){
<a name="l00856"></a>00856       <span class="keywordflow">return</span> 1;  <span class="comment">/* OOM error */</span>
<a name="l00857"></a>00857     }
<a name="l00858"></a>00858     <span class="keywordflow">if</span>( iCol&gt;0 ){
<a name="l00859"></a>00859       <span class="comment">/* If an AS-name match is found, mark this ORDER BY column as being</span>
<a name="l00860"></a>00860 <span class="comment">      ** a copy of the iCol-th result-set column.  The subsequent call to</span>
<a name="l00861"></a>00861 <span class="comment">      ** sqlite3ResolveOrderGroupBy() will convert the expression to a</span>
<a name="l00862"></a>00862 <span class="comment">      ** copy of the iCol-th result-set expression. */</span>
<a name="l00863"></a>00863       pItem-&gt;iCol = iCol;
<a name="l00864"></a>00864       <span class="keywordflow">continue</span>;
<a name="l00865"></a>00865     }
<a name="l00866"></a>00866     <span class="keywordflow">if</span>( <a class="code" href="expr_8c.html#ae6f241af6b7d1e232ef12fec49267832">sqlite3ExprIsInteger</a>(pE, &amp;iCol) ){
<a name="l00867"></a>00867       <span class="comment">/* The ORDER BY term is an integer constant.  Again, set the column</span>
<a name="l00868"></a>00868 <span class="comment">      ** number so that sqlite3ResolveOrderGroupBy() will convert the</span>
<a name="l00869"></a>00869 <span class="comment">      ** order-by term to a copy of the result-set expression */</span>
<a name="l00870"></a>00870       <span class="keywordflow">if</span>( iCol&lt;1 ){
<a name="l00871"></a>00871         <a class="code" href="resolve_8c.html#abaf80a4194f11e3f8515a85ab94f670b">resolveOutOfRangeError</a>(pParse, zType, i+1, nResult);
<a name="l00872"></a>00872         <span class="keywordflow">return</span> 1;
<a name="l00873"></a>00873       }
<a name="l00874"></a>00874       pItem-&gt;iCol = iCol;
<a name="l00875"></a>00875       <span class="keywordflow">continue</span>;
<a name="l00876"></a>00876     }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     <span class="comment">/* Otherwise, treat the ORDER BY term as an ordinary expression */</span>
<a name="l00879"></a>00879     pItem-&gt;iCol = 0;
<a name="l00880"></a>00880     <span class="keywordflow">if</span>( <a class="code" href="resolve_8c.html#afc8765990fa4299c3dc9bd295ae85291">sqlite3ResolveExprNames</a>(pNC, pE) ){
<a name="l00881"></a>00881       <span class="keywordflow">return</span> 1;
<a name="l00882"></a>00882     }
<a name="l00883"></a>00883   }
<a name="l00884"></a>00884   <span class="keywordflow">return</span> <a class="code" href="resolve_8c.html#a35c6c68fba6c9eed6a70a9a73f87422b">sqlite3ResolveOrderGroupBy</a>(pParse, pSelect, pOrderBy, zType);
<a name="l00885"></a>00885 }
<a name="l00886"></a>00886 
<a name="l00887"></a>00887 <span class="comment">/*</span>
<a name="l00888"></a>00888 <span class="comment">** Resolve names in the SELECT statement p and all of its descendents.</span>
<a name="l00889"></a>00889 <span class="comment">*/</span>
<a name="l00890"></a><a class="code" href="resolve_8c.html#a0b9015a9e505c63fd104dcbad672c814">00890</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="resolve_8c.html#a0b9015a9e505c63fd104dcbad672c814">resolveSelectStep</a>(<a class="code" href="structWalker.html">Walker</a> *pWalker, <a class="code" href="structSelect.html">Select</a> *p){
<a name="l00891"></a>00891   <a class="code" href="structNameContext.html">NameContext</a> *pOuterNC;  <span class="comment">/* Context that contains this SELECT */</span>
<a name="l00892"></a>00892   <a class="code" href="structNameContext.html">NameContext</a> sNC;        <span class="comment">/* Name context of this SELECT */</span>
<a name="l00893"></a>00893   <span class="keywordtype">int</span> isCompound;         <span class="comment">/* True if p is a compound select */</span>
<a name="l00894"></a>00894   <span class="keywordtype">int</span> nCompound;          <span class="comment">/* Number of compound terms processed so far */</span>
<a name="l00895"></a>00895   <a class="code" href="structParse.html">Parse</a> *pParse;          <span class="comment">/* Parsing context */</span>
<a name="l00896"></a>00896   <a class="code" href="structExprList.html">ExprList</a> *pEList;       <span class="comment">/* Result set expression list */</span>
<a name="l00897"></a>00897   <span class="keywordtype">int</span> i;                  <span class="comment">/* Loop counter */</span>
<a name="l00898"></a>00898   <a class="code" href="structExprList.html">ExprList</a> *pGroupBy;     <span class="comment">/* The GROUP BY clause */</span>
<a name="l00899"></a>00899   <a class="code" href="structSelect.html">Select</a> *pLeftmost;      <span class="comment">/* Left-most of SELECT of a compound */</span>
<a name="l00900"></a>00900   <a class="code" href="structsqlite3.html">sqlite3</a> *<a class="code" href="shell_8c.html#ad6e663497d2c934364b3bcf07496b30b">db</a>;            <span class="comment">/* Database connection */</span>
<a name="l00901"></a>00901   
<a name="l00902"></a>00902 
<a name="l00903"></a>00903   assert( p!=0 );
<a name="l00904"></a>00904   <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structSelect.html#a1c445561ea66d48573c8d8751108c743">selFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a2bc64027cc77d7a3281d833fd2a72907">SF_Resolved</a> ){
<a name="l00905"></a>00905     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a692431abc1f48e71c14b403d1e392adf">WRC_Prune</a>;
<a name="l00906"></a>00906   }
<a name="l00907"></a>00907   pOuterNC = pWalker-&gt;<a class="code" href="structWalker.html#a0479a19ba29888e2ab092e7f2b3cf13a">u</a>.<a class="code" href="structWalker.html#adbf5872a6c5a9311adbfe01c0e444388">pNC</a>;
<a name="l00908"></a>00908   pParse = pWalker-&gt;<a class="code" href="structWalker.html#ac6e8e756b5da8f187b9cf6b94560f352">pParse</a>;
<a name="l00909"></a>00909   db = pParse-&gt;<a class="code" href="structParse.html#a44364e5e1197927f89864ec345bc5491">db</a>;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911   <span class="comment">/* Normally sqlite3SelectExpand() will be called first and will have</span>
<a name="l00912"></a>00912 <span class="comment">  ** already expanded this SELECT.  However, if this is a subquery within</span>
<a name="l00913"></a>00913 <span class="comment">  ** an expression, sqlite3ResolveExprNames() will be called without a</span>
<a name="l00914"></a>00914 <span class="comment">  ** prior call to sqlite3SelectExpand().  When that happens, let</span>
<a name="l00915"></a>00915 <span class="comment">  ** sqlite3SelectPrep() do all of the processing for this SELECT.</span>
<a name="l00916"></a>00916 <span class="comment">  ** sqlite3SelectPrep() will invoke both sqlite3SelectExpand() and</span>
<a name="l00917"></a>00917 <span class="comment">  ** this routine in the correct order.</span>
<a name="l00918"></a>00918 <span class="comment">  */</span>
<a name="l00919"></a>00919   <span class="keywordflow">if</span>( (p-&gt;<a class="code" href="structSelect.html#a1c445561ea66d48573c8d8751108c743">selFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#aa6e382257e3dec5629879c591c8ed6f0">SF_Expanded</a>)==0 ){
<a name="l00920"></a>00920     <a class="code" href="select_8c.html#aa7da28414e53119bc44bfa41eeec3013">sqlite3SelectPrep</a>(pParse, p, pOuterNC);
<a name="l00921"></a>00921     <span class="keywordflow">return</span> (pParse-&gt;<a class="code" href="structParse.html#ac7206f0c7e580ab32b7dfb20950bb1c9">nErr</a> || db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a>) ? <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a> : <a class="code" href="sqliteInt_8h.html#a692431abc1f48e71c14b403d1e392adf">WRC_Prune</a>;
<a name="l00922"></a>00922   }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   isCompound = p-&gt;<a class="code" href="structSelect.html#a51d1a253b0aba5a54b11b3bf3896d056">pPrior</a>!=0;
<a name="l00925"></a>00925   nCompound = 0;
<a name="l00926"></a>00926   pLeftmost = p;
<a name="l00927"></a>00927   <span class="keywordflow">while</span>( p ){
<a name="l00928"></a>00928     assert( (p-&gt;<a class="code" href="structSelect.html#a1c445561ea66d48573c8d8751108c743">selFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#aa6e382257e3dec5629879c591c8ed6f0">SF_Expanded</a>)!=0 );
<a name="l00929"></a>00929     assert( (p-&gt;<a class="code" href="structSelect.html#a1c445561ea66d48573c8d8751108c743">selFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#a2bc64027cc77d7a3281d833fd2a72907">SF_Resolved</a>)==0 );
<a name="l00930"></a>00930     p-&gt;<a class="code" href="structSelect.html#a1c445561ea66d48573c8d8751108c743">selFlags</a> |= <a class="code" href="sqliteInt_8h.html#a2bc64027cc77d7a3281d833fd2a72907">SF_Resolved</a>;
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     <span class="comment">/* Resolve the expressions in the LIMIT and OFFSET clauses. These</span>
<a name="l00933"></a>00933 <span class="comment">    ** are not allowed to refer to any names, so pass an empty NameContext.</span>
<a name="l00934"></a>00934 <span class="comment">    */</span>
<a name="l00935"></a>00935     memset(&amp;sNC, 0, <span class="keyword">sizeof</span>(sNC));
<a name="l00936"></a>00936     sNC.<a class="code" href="structNameContext.html#a14635249bf75d5e18124089571dd2386">pParse</a> = pParse;
<a name="l00937"></a>00937     <span class="keywordflow">if</span>( <a class="code" href="resolve_8c.html#afc8765990fa4299c3dc9bd295ae85291">sqlite3ResolveExprNames</a>(&amp;sNC, p-&gt;<a class="code" href="structSelect.html#a11d3b48d04d58be818cdefb10aa061a0">pLimit</a>) ||
<a name="l00938"></a>00938         <a class="code" href="resolve_8c.html#afc8765990fa4299c3dc9bd295ae85291">sqlite3ResolveExprNames</a>(&amp;sNC, p-&gt;<a class="code" href="structSelect.html#aeaf016a10203b911000354122562fb46">pOffset</a>) ){
<a name="l00939"></a>00939       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941   
<a name="l00942"></a>00942     <span class="comment">/* Set up the local name-context to pass to sqlite3ResolveExprNames() to</span>
<a name="l00943"></a>00943 <span class="comment">    ** resolve the result-set expression list.</span>
<a name="l00944"></a>00944 <span class="comment">    */</span>
<a name="l00945"></a>00945     sNC.<a class="code" href="structNameContext.html#a78dc76c1493dd2f74f5f1ec661039665">allowAgg</a> = 1;
<a name="l00946"></a>00946     sNC.<a class="code" href="structNameContext.html#a6ede21da33e2e9bd3d0c5fe90a3ec72c">pSrcList</a> = p-&gt;<a class="code" href="structSelect.html#a4e3b9b176a8e1b4af988405ff1f090db">pSrc</a>;
<a name="l00947"></a>00947     sNC.<a class="code" href="structNameContext.html#a82ce0ec8a3cc3d792e1f38bb5e0ad5fc">pNext</a> = pOuterNC;
<a name="l00948"></a>00948   
<a name="l00949"></a>00949     <span class="comment">/* Resolve names in the result set. */</span>
<a name="l00950"></a>00950     pEList = p-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>;
<a name="l00951"></a>00951     assert( pEList!=0 );
<a name="l00952"></a>00952     <span class="keywordflow">for</span>(i=0; i&lt;pEList-&gt;<a class="code" href="structExprList.html#a88bdbd62cce306124eea63ae9f80ec33">nExpr</a>; i++){
<a name="l00953"></a>00953       <a class="code" href="structExpr.html">Expr</a> *pX = pEList-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>[i].<a class="code" href="structExprList_1_1ExprList__item.html#a75906cf3ff19e5bf16373fec7f3c79ad">pExpr</a>;
<a name="l00954"></a>00954       <span class="keywordflow">if</span>( <a class="code" href="resolve_8c.html#afc8765990fa4299c3dc9bd295ae85291">sqlite3ResolveExprNames</a>(&amp;sNC, pX) ){
<a name="l00955"></a>00955         <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l00956"></a>00956       }
<a name="l00957"></a>00957     }
<a name="l00958"></a>00958   
<a name="l00959"></a>00959     <span class="comment">/* Recursively resolve names in all subqueries</span>
<a name="l00960"></a>00960 <span class="comment">    */</span>
<a name="l00961"></a>00961     <span class="keywordflow">for</span>(i=0; i&lt;p-&gt;<a class="code" href="structSelect.html#a4e3b9b176a8e1b4af988405ff1f090db">pSrc</a>-&gt;<a class="code" href="structSrcList.html#a99c1d923c49fc0598d92f1cb54958ef4">nSrc</a>; i++){
<a name="l00962"></a>00962       <span class="keyword">struct </span>SrcList_item *pItem = &amp;p-&gt;<a class="code" href="structSelect.html#a4e3b9b176a8e1b4af988405ff1f090db">pSrc</a>-&gt;<a class="code" href="structSrcList.html#acd181938f7144b40022b28072247aa3d">a</a>[i];
<a name="l00963"></a>00963       <span class="keywordflow">if</span>( pItem-&gt;pSelect ){
<a name="l00964"></a>00964         <span class="keyword">const</span> <span class="keywordtype">char</span> *zSavedContext = pParse-&gt;<a class="code" href="structParse.html#a12c6e2fb69848bcc57169d44993c351f">zAuthContext</a>;
<a name="l00965"></a>00965         <span class="keywordflow">if</span>( pItem-&gt;zName ) pParse-&gt;<a class="code" href="structParse.html#a12c6e2fb69848bcc57169d44993c351f">zAuthContext</a> = pItem-&gt;zName;
<a name="l00966"></a>00966         <a class="code" href="resolve_8c.html#ac40b8bd36d5bb592f8d123c416f836cf">sqlite3ResolveSelectNames</a>(pParse, pItem-&gt;pSelect, &amp;sNC);
<a name="l00967"></a>00967         pParse-&gt;<a class="code" href="structParse.html#a12c6e2fb69848bcc57169d44993c351f">zAuthContext</a> = zSavedContext;
<a name="l00968"></a>00968         <span class="keywordflow">if</span>( pParse-&gt;<a class="code" href="structParse.html#ac7206f0c7e580ab32b7dfb20950bb1c9">nErr</a> || db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ) <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l00969"></a>00969       }
<a name="l00970"></a>00970     }
<a name="l00971"></a>00971   
<a name="l00972"></a>00972     <span class="comment">/* If there are no aggregate functions in the result-set, and no GROUP BY </span>
<a name="l00973"></a>00973 <span class="comment">    ** expression, do not allow aggregates in any of the other expressions.</span>
<a name="l00974"></a>00974 <span class="comment">    */</span>
<a name="l00975"></a>00975     assert( (p-&gt;<a class="code" href="structSelect.html#a1c445561ea66d48573c8d8751108c743">selFlags</a> &amp; <a class="code" href="sqliteInt_8h.html#ab5e09be5e165218403754a3d96778930">SF_Aggregate</a>)==0 );
<a name="l00976"></a>00976     pGroupBy = p-&gt;<a class="code" href="structSelect.html#a5b625c7495468ae56ca2f214a76231a0">pGroupBy</a>;
<a name="l00977"></a>00977     <span class="keywordflow">if</span>( pGroupBy || sNC.<a class="code" href="structNameContext.html#a6edabae39c69ad9a748f9ea519d9f56e">hasAgg</a> ){
<a name="l00978"></a>00978       p-&gt;<a class="code" href="structSelect.html#a1c445561ea66d48573c8d8751108c743">selFlags</a> |= <a class="code" href="sqliteInt_8h.html#ab5e09be5e165218403754a3d96778930">SF_Aggregate</a>;
<a name="l00979"></a>00979     }<span class="keywordflow">else</span>{
<a name="l00980"></a>00980       sNC.<a class="code" href="structNameContext.html#a78dc76c1493dd2f74f5f1ec661039665">allowAgg</a> = 0;
<a name="l00981"></a>00981     }
<a name="l00982"></a>00982   
<a name="l00983"></a>00983     <span class="comment">/* If a HAVING clause is present, then there must be a GROUP BY clause.</span>
<a name="l00984"></a>00984 <span class="comment">    */</span>
<a name="l00985"></a>00985     <span class="keywordflow">if</span>( p-&gt;<a class="code" href="structSelect.html#ad09e0b115e6e1599e3075b87dfa6e66e">pHaving</a> &amp;&amp; !pGroupBy ){
<a name="l00986"></a>00986       <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;a GROUP BY clause is required before HAVING&quot;</span>);
<a name="l00987"></a>00987       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l00988"></a>00988     }
<a name="l00989"></a>00989   
<a name="l00990"></a>00990     <span class="comment">/* Add the expression list to the name-context before parsing the</span>
<a name="l00991"></a>00991 <span class="comment">    ** other expressions in the SELECT statement. This is so that</span>
<a name="l00992"></a>00992 <span class="comment">    ** expressions in the WHERE clause (etc.) can refer to expressions by</span>
<a name="l00993"></a>00993 <span class="comment">    ** aliases in the result set.</span>
<a name="l00994"></a>00994 <span class="comment">    **</span>
<a name="l00995"></a>00995 <span class="comment">    ** Minor point: If this is the case, then the expression will be</span>
<a name="l00996"></a>00996 <span class="comment">    ** re-evaluated for each reference to it.</span>
<a name="l00997"></a>00997 <span class="comment">    */</span>
<a name="l00998"></a>00998     sNC.<a class="code" href="structNameContext.html#a8c752d7fb9b28179156c569cc57ba6f2">pEList</a> = p-&gt;<a class="code" href="structSelect.html#acf92c5d6b0e0e6a3263a77696baaadc8">pEList</a>;
<a name="l00999"></a>00999     <span class="keywordflow">if</span>( <a class="code" href="resolve_8c.html#afc8765990fa4299c3dc9bd295ae85291">sqlite3ResolveExprNames</a>(&amp;sNC, p-&gt;<a class="code" href="structSelect.html#a0562c1e19acde263a04af015611d8ce8">pWhere</a>) ||
<a name="l01000"></a>01000        <a class="code" href="resolve_8c.html#afc8765990fa4299c3dc9bd295ae85291">sqlite3ResolveExprNames</a>(&amp;sNC, p-&gt;<a class="code" href="structSelect.html#ad09e0b115e6e1599e3075b87dfa6e66e">pHaving</a>)
<a name="l01001"></a>01001     ){
<a name="l01002"></a>01002       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l01003"></a>01003     }
<a name="l01004"></a>01004 
<a name="l01005"></a>01005     <span class="comment">/* The ORDER BY and GROUP BY clauses may not refer to terms in</span>
<a name="l01006"></a>01006 <span class="comment">    ** outer queries </span>
<a name="l01007"></a>01007 <span class="comment">    */</span>
<a name="l01008"></a>01008     sNC.<a class="code" href="structNameContext.html#a82ce0ec8a3cc3d792e1f38bb5e0ad5fc">pNext</a> = 0;
<a name="l01009"></a>01009     sNC.<a class="code" href="structNameContext.html#a78dc76c1493dd2f74f5f1ec661039665">allowAgg</a> = 1;
<a name="l01010"></a>01010 
<a name="l01011"></a>01011     <span class="comment">/* Process the ORDER BY clause for singleton SELECT statements.</span>
<a name="l01012"></a>01012 <span class="comment">    ** The ORDER BY clause for compounds SELECT statements is handled</span>
<a name="l01013"></a>01013 <span class="comment">    ** below, after all of the result-sets for all of the elements of</span>
<a name="l01014"></a>01014 <span class="comment">    ** the compound have been resolved.</span>
<a name="l01015"></a>01015 <span class="comment">    */</span>
<a name="l01016"></a>01016     <span class="keywordflow">if</span>( !isCompound &amp;&amp; <a class="code" href="resolve_8c.html#a4dc8ed6177a5de887eae1010992e3d00">resolveOrderGroupBy</a>(&amp;sNC, p, p-&gt;<a class="code" href="structSelect.html#a73c474cd4a9a9b9aa4e3187d8bf2d886">pOrderBy</a>, <span class="stringliteral">&quot;ORDER&quot;</span>) ){
<a name="l01017"></a>01017       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l01018"></a>01018     }
<a name="l01019"></a>01019     <span class="keywordflow">if</span>( db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l01020"></a>01020       <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l01021"></a>01021     }
<a name="l01022"></a>01022   
<a name="l01023"></a>01023     <span class="comment">/* Resolve the GROUP BY clause.  At the same time, make sure </span>
<a name="l01024"></a>01024 <span class="comment">    ** the GROUP BY clause does not contain aggregate functions.</span>
<a name="l01025"></a>01025 <span class="comment">    */</span>
<a name="l01026"></a>01026     <span class="keywordflow">if</span>( pGroupBy ){
<a name="l01027"></a>01027       <span class="keyword">struct </span>ExprList_item *pItem;
<a name="l01028"></a>01028     
<a name="l01029"></a>01029       <span class="keywordflow">if</span>( <a class="code" href="resolve_8c.html#a4dc8ed6177a5de887eae1010992e3d00">resolveOrderGroupBy</a>(&amp;sNC, p, pGroupBy, <span class="stringliteral">&quot;GROUP&quot;</span>) || db-&gt;<a class="code" href="structsqlite3.html#a79beb0036337ba7fc2de5ccbb9225935">mallocFailed</a> ){
<a name="l01030"></a>01030         <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l01031"></a>01031       }
<a name="l01032"></a>01032       <span class="keywordflow">for</span>(i=0, pItem=pGroupBy-&gt;<a class="code" href="structExprList.html#a02a4222d2dc4da64dcec416188abc16c">a</a>; i&lt;pGroupBy-&gt;nExpr; i++, pItem++){
<a name="l01033"></a>01033         <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a70ceb3fd7e20d6b0565b359158c7f1d7">ExprHasProperty</a>(pItem-&gt;pExpr, <a class="code" href="sqliteInt_8h.html#a3e4e7c58ecba751cc608e357bc15f932">EP_Agg</a>) ){
<a name="l01034"></a>01034           <a class="code" href="sqliteInt_8h.html#af5069bb768199c3dab949999e7e6e19c">sqlite3ErrorMsg</a>(pParse, <span class="stringliteral">&quot;aggregate functions are not allowed in &quot;</span>
<a name="l01035"></a>01035               <span class="stringliteral">&quot;the GROUP BY clause&quot;</span>);
<a name="l01036"></a>01036           <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l01037"></a>01037         }
<a name="l01038"></a>01038       }
<a name="l01039"></a>01039     }
<a name="l01040"></a>01040 
<a name="l01041"></a>01041     <span class="comment">/* Advance to the next term of the compound</span>
<a name="l01042"></a>01042 <span class="comment">    */</span>
<a name="l01043"></a>01043     p = p-&gt;<a class="code" href="structSelect.html#a51d1a253b0aba5a54b11b3bf3896d056">pPrior</a>;
<a name="l01044"></a>01044     nCompound++;
<a name="l01045"></a>01045   }
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   <span class="comment">/* Resolve the ORDER BY on a compound SELECT after all terms of</span>
<a name="l01048"></a>01048 <span class="comment">  ** the compound have been resolved.</span>
<a name="l01049"></a>01049 <span class="comment">  */</span>
<a name="l01050"></a>01050   <span class="keywordflow">if</span>( isCompound &amp;&amp; <a class="code" href="resolve_8c.html#a462c5aa49cfd6aad6a92fa60ddefc569">resolveCompoundOrderBy</a>(pParse, pLeftmost) ){
<a name="l01051"></a>01051     <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#ae955af34df406989e8476e941af8c3d5">WRC_Abort</a>;
<a name="l01052"></a>01052   }
<a name="l01053"></a>01053 
<a name="l01054"></a>01054   <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a692431abc1f48e71c14b403d1e392adf">WRC_Prune</a>;
<a name="l01055"></a>01055 }
<a name="l01056"></a>01056 
<a name="l01057"></a>01057 <span class="comment">/*</span>
<a name="l01058"></a>01058 <span class="comment">** This routine walks an expression tree and resolves references to</span>
<a name="l01059"></a>01059 <span class="comment">** table columns and result-set columns.  At the same time, do error</span>
<a name="l01060"></a>01060 <span class="comment">** checking on function usage and set a flag if any aggregate functions</span>
<a name="l01061"></a>01061 <span class="comment">** are seen.</span>
<a name="l01062"></a>01062 <span class="comment">**</span>
<a name="l01063"></a>01063 <span class="comment">** To resolve table columns references we look for nodes (or subtrees) of the </span>
<a name="l01064"></a>01064 <span class="comment">** form X.Y.Z or Y.Z or just Z where</span>
<a name="l01065"></a>01065 <span class="comment">**</span>
<a name="l01066"></a>01066 <span class="comment">**      X:   The name of a database.  Ex:  &quot;main&quot; or &quot;temp&quot; or</span>
<a name="l01067"></a>01067 <span class="comment">**           the symbolic name assigned to an ATTACH-ed database.</span>
<a name="l01068"></a>01068 <span class="comment">**</span>
<a name="l01069"></a>01069 <span class="comment">**      Y:   The name of a table in a FROM clause.  Or in a trigger</span>
<a name="l01070"></a>01070 <span class="comment">**           one of the special names &quot;old&quot; or &quot;new&quot;.</span>
<a name="l01071"></a>01071 <span class="comment">**</span>
<a name="l01072"></a>01072 <span class="comment">**      Z:   The name of a column in table Y.</span>
<a name="l01073"></a>01073 <span class="comment">**</span>
<a name="l01074"></a>01074 <span class="comment">** The node at the root of the subtree is modified as follows:</span>
<a name="l01075"></a>01075 <span class="comment">**</span>
<a name="l01076"></a>01076 <span class="comment">**    Expr.op        Changed to TK_COLUMN</span>
<a name="l01077"></a>01077 <span class="comment">**    Expr.pTab      Points to the Table object for X.Y</span>
<a name="l01078"></a>01078 <span class="comment">**    Expr.iColumn   The column index in X.Y.  -1 for the rowid.</span>
<a name="l01079"></a>01079 <span class="comment">**    Expr.iTable    The VDBE cursor number for X.Y</span>
<a name="l01080"></a>01080 <span class="comment">**</span>
<a name="l01081"></a>01081 <span class="comment">**</span>
<a name="l01082"></a>01082 <span class="comment">** To resolve result-set references, look for expression nodes of the</span>
<a name="l01083"></a>01083 <span class="comment">** form Z (with no X and Y prefix) where the Z matches the right-hand</span>
<a name="l01084"></a>01084 <span class="comment">** size of an AS clause in the result-set of a SELECT.  The Z expression</span>
<a name="l01085"></a>01085 <span class="comment">** is replaced by a copy of the left-hand side of the result-set expression.</span>
<a name="l01086"></a>01086 <span class="comment">** Table-name and function resolution occurs on the substituted expression</span>
<a name="l01087"></a>01087 <span class="comment">** tree.  For example, in:</span>
<a name="l01088"></a>01088 <span class="comment">**</span>
<a name="l01089"></a>01089 <span class="comment">**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY x;</span>
<a name="l01090"></a>01090 <span class="comment">**</span>
<a name="l01091"></a>01091 <span class="comment">** The &quot;x&quot; term of the order by is replaced by &quot;a+b&quot; to render:</span>
<a name="l01092"></a>01092 <span class="comment">**</span>
<a name="l01093"></a>01093 <span class="comment">**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY a+b;</span>
<a name="l01094"></a>01094 <span class="comment">**</span>
<a name="l01095"></a>01095 <span class="comment">** Function calls are checked to make sure that the function is </span>
<a name="l01096"></a>01096 <span class="comment">** defined and that the correct number of arguments are specified.</span>
<a name="l01097"></a>01097 <span class="comment">** If the function is an aggregate function, then the pNC-&gt;hasAgg is</span>
<a name="l01098"></a>01098 <span class="comment">** set and the opcode is changed from TK_FUNCTION to TK_AGG_FUNCTION.</span>
<a name="l01099"></a>01099 <span class="comment">** If an expression contains aggregate functions then the EP_Agg</span>
<a name="l01100"></a>01100 <span class="comment">** property on the expression is set.</span>
<a name="l01101"></a>01101 <span class="comment">**</span>
<a name="l01102"></a>01102 <span class="comment">** An error message is left in pParse if anything is amiss.  The number</span>
<a name="l01103"></a>01103 <span class="comment">** if errors is returned.</span>
<a name="l01104"></a>01104 <span class="comment">*/</span>
<a name="l01105"></a><a class="code" href="sqliteInt_8h.html#a79027d9085b49742ce8586aa926a2916">01105</a> <span class="keywordtype">int</span> <a class="code" href="resolve_8c.html#afc8765990fa4299c3dc9bd295ae85291">sqlite3ResolveExprNames</a>( 
<a name="l01106"></a>01106   <a class="code" href="structNameContext.html">NameContext</a> *pNC,       <span class="comment">/* Namespace to resolve expressions in. */</span>
<a name="l01107"></a>01107   <a class="code" href="structExpr.html">Expr</a> *pExpr             <span class="comment">/* The expression to be analyzed. */</span>
<a name="l01108"></a>01108 ){
<a name="l01109"></a>01109   <span class="keywordtype">int</span> savedHasAgg;
<a name="l01110"></a>01110   <a class="code" href="structWalker.html">Walker</a> w;
<a name="l01111"></a>01111 
<a name="l01112"></a>01112   <span class="keywordflow">if</span>( pExpr==0 ) <span class="keywordflow">return</span> 0;
<a name="l01113"></a>01113 <span class="preprocessor">#if SQLITE_MAX_EXPR_DEPTH&gt;0</span>
<a name="l01114"></a>01114 <span class="preprocessor"></span>  {
<a name="l01115"></a>01115     <a class="code" href="structParse.html">Parse</a> *pParse = pNC-&gt;<a class="code" href="structNameContext.html#a14635249bf75d5e18124089571dd2386">pParse</a>;
<a name="l01116"></a>01116     <span class="keywordflow">if</span>( <a class="code" href="sqliteInt_8h.html#a847bbdc9550ebf38a449074a8500a5d0">sqlite3ExprCheckHeight</a>(pParse, pExpr-&gt;nHeight+pNC-&gt;<a class="code" href="structNameContext.html#a14635249bf75d5e18124089571dd2386">pParse</a>-&gt;<a class="code" href="structParse.html#af4ec053d44a2a3bc8ae82b69a7327c3c">nHeight</a>) ){
<a name="l01117"></a>01117       <span class="keywordflow">return</span> 1;
<a name="l01118"></a>01118     }
<a name="l01119"></a>01119     pParse-&gt;<a class="code" href="structParse.html#af4ec053d44a2a3bc8ae82b69a7327c3c">nHeight</a> += pExpr-&gt;nHeight;
<a name="l01120"></a>01120   }
<a name="l01121"></a>01121 <span class="preprocessor">#endif</span>
<a name="l01122"></a>01122 <span class="preprocessor"></span>  savedHasAgg = pNC-&gt;<a class="code" href="structNameContext.html#a6edabae39c69ad9a748f9ea519d9f56e">hasAgg</a>;
<a name="l01123"></a>01123   pNC-&gt;<a class="code" href="structNameContext.html#a6edabae39c69ad9a748f9ea519d9f56e">hasAgg</a> = 0;
<a name="l01124"></a>01124   w.<a class="code" href="structWalker.html#a6f4d546e4aea8e6ff1f9512e9190d411">xExprCallback</a> = <a class="code" href="resolve_8c.html#a0687a8650fd8a4ebbf5c2c5a75a8fb13">resolveExprStep</a>;
<a name="l01125"></a>01125   w.<a class="code" href="structWalker.html#a2850c95c634f9439bb403f0bb211c636">xSelectCallback</a> = <a class="code" href="resolve_8c.html#a0b9015a9e505c63fd104dcbad672c814">resolveSelectStep</a>;
<a name="l01126"></a>01126   w.<a class="code" href="structWalker.html#ac6e8e756b5da8f187b9cf6b94560f352">pParse</a> = pNC-&gt;<a class="code" href="structNameContext.html#a14635249bf75d5e18124089571dd2386">pParse</a>;
<a name="l01127"></a>01127   w.<a class="code" href="structWalker.html#a0479a19ba29888e2ab092e7f2b3cf13a">u</a>.<a class="code" href="structWalker.html#adbf5872a6c5a9311adbfe01c0e444388">pNC</a> = pNC;
<a name="l01128"></a>01128   <a class="code" href="sqliteInt_8h.html#a49c0da44c988d92a8f85c24ce1eca5c8">sqlite3WalkExpr</a>(&amp;w, pExpr);
<a name="l01129"></a>01129 <span class="preprocessor">#if SQLITE_MAX_EXPR_DEPTH&gt;0</span>
<a name="l01130"></a>01130 <span class="preprocessor"></span>  pNC-&gt;<a class="code" href="structNameContext.html#a14635249bf75d5e18124089571dd2386">pParse</a>-&gt;<a class="code" href="structParse.html#af4ec053d44a2a3bc8ae82b69a7327c3c">nHeight</a> -= pExpr-&gt;nHeight;
<a name="l01131"></a>01131 <span class="preprocessor">#endif</span>
<a name="l01132"></a>01132 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( pNC-&gt;<a class="code" href="structNameContext.html#aba0b89b42e945c4c96d57a8fe011329c">nErr</a>&gt;0 ){
<a name="l01133"></a>01133     <a class="code" href="sqliteInt_8h.html#aedc713d2783c34ef92b63ba28c495dfe">ExprSetProperty</a>(pExpr, <a class="code" href="sqliteInt_8h.html#a4edbf1903230bd143936826e72449494">EP_Error</a>);
<a name="l01134"></a>01134   }
<a name="l01135"></a>01135   <span class="keywordflow">if</span>( pNC-&gt;<a class="code" href="structNameContext.html#a6edabae39c69ad9a748f9ea519d9f56e">hasAgg</a> ){
<a name="l01136"></a>01136     <a class="code" href="sqliteInt_8h.html#aedc713d2783c34ef92b63ba28c495dfe">ExprSetProperty</a>(pExpr, <a class="code" href="sqliteInt_8h.html#a3e4e7c58ecba751cc608e357bc15f932">EP_Agg</a>);
<a name="l01137"></a>01137   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( savedHasAgg ){
<a name="l01138"></a>01138     pNC-&gt;<a class="code" href="structNameContext.html#a6edabae39c69ad9a748f9ea519d9f56e">hasAgg</a> = 1;
<a name="l01139"></a>01139   }
<a name="l01140"></a>01140   <span class="keywordflow">return</span> <a class="code" href="sqliteInt_8h.html#a70ceb3fd7e20d6b0565b359158c7f1d7">ExprHasProperty</a>(pExpr, <a class="code" href="sqliteInt_8h.html#a4edbf1903230bd143936826e72449494">EP_Error</a>);
<a name="l01141"></a>01141 }
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 
<a name="l01144"></a>01144 <span class="comment">/*</span>
<a name="l01145"></a>01145 <span class="comment">** Resolve all names in all expressions of a SELECT and in all</span>
<a name="l01146"></a>01146 <span class="comment">** decendents of the SELECT, including compounds off of p-&gt;pPrior,</span>
<a name="l01147"></a>01147 <span class="comment">** subqueries in expressions, and subqueries used as FROM clause</span>
<a name="l01148"></a>01148 <span class="comment">** terms.</span>
<a name="l01149"></a>01149 <span class="comment">**</span>
<a name="l01150"></a>01150 <span class="comment">** See sqlite3ResolveExprNames() for a description of the kinds of</span>
<a name="l01151"></a>01151 <span class="comment">** transformations that occur.</span>
<a name="l01152"></a>01152 <span class="comment">**</span>
<a name="l01153"></a>01153 <span class="comment">** All SELECT statements should have been expanded using</span>
<a name="l01154"></a>01154 <span class="comment">** sqlite3SelectExpand() prior to invoking this routine.</span>
<a name="l01155"></a>01155 <span class="comment">*/</span>
<a name="l01156"></a><a class="code" href="sqliteInt_8h.html#ac826fc0820c63eda3447458f792e6fac">01156</a> <span class="keywordtype">void</span> <a class="code" href="resolve_8c.html#ac40b8bd36d5bb592f8d123c416f836cf">sqlite3ResolveSelectNames</a>(
<a name="l01157"></a>01157   <a class="code" href="structParse.html">Parse</a> *pParse,         <span class="comment">/* The parser context */</span>
<a name="l01158"></a>01158   <a class="code" href="structSelect.html">Select</a> *p,             <span class="comment">/* The SELECT statement being coded. */</span>
<a name="l01159"></a>01159   <a class="code" href="structNameContext.html">NameContext</a> *pOuterNC  <span class="comment">/* Name context for parent SELECT statement */</span>
<a name="l01160"></a>01160 ){
<a name="l01161"></a>01161   <a class="code" href="structWalker.html">Walker</a> w;
<a name="l01162"></a>01162 
<a name="l01163"></a>01163   assert( p!=0 );
<a name="l01164"></a>01164   w.<a class="code" href="structWalker.html#a6f4d546e4aea8e6ff1f9512e9190d411">xExprCallback</a> = <a class="code" href="resolve_8c.html#a0687a8650fd8a4ebbf5c2c5a75a8fb13">resolveExprStep</a>;
<a name="l01165"></a>01165   w.<a class="code" href="structWalker.html#a2850c95c634f9439bb403f0bb211c636">xSelectCallback</a> = <a class="code" href="resolve_8c.html#a0b9015a9e505c63fd104dcbad672c814">resolveSelectStep</a>;
<a name="l01166"></a>01166   w.<a class="code" href="structWalker.html#ac6e8e756b5da8f187b9cf6b94560f352">pParse</a> = pParse;
<a name="l01167"></a>01167   w.<a class="code" href="structWalker.html#a0479a19ba29888e2ab092e7f2b3cf13a">u</a>.<a class="code" href="structWalker.html#adbf5872a6c5a9311adbfe01c0e444388">pNC</a> = pOuterNC;
<a name="l01168"></a>01168   <a class="code" href="sqliteInt_8h.html#a36f4ec0cb85c2ced6f5b860f4bcf7217">sqlite3WalkSelect</a>(&amp;w, p);
<a name="l01169"></a>01169 }
</pre></div></div>
<hr size="1">

<p style="text-align: right;">
  <a href="http://www.contextlogger.org/">ContextLogger2</a>&#8212;ContextLogger2 Logger Daemon Internals&#8212;<small>Generated on Mon May 2 13:49:56 2011 by&nbsp;<a href="http://www.doxygen.org/">Doxygen</a> 1.6.1</small>
</p>

</body>
</html>
